
graphicstest.ino.elf:     file format elf32-littlearm


Disassembly of section .text:

00002000 <__text_start__>:
    2000:	20008000 	.word	0x20008000
    2004:	000043b9 	.word	0x000043b9
    2008:	000043a1 	.word	0x000043a1
    200c:	000043a1 	.word	0x000043a1
	...
    202c:	000043a1 	.word	0x000043a1
	...
    2038:	000043a1 	.word	0x000043a1
    203c:	0000440d 	.word	0x0000440d
    2040:	000043a1 	.word	0x000043a1
    2044:	000043a1 	.word	0x000043a1
    2048:	000043a1 	.word	0x000043a1
    204c:	000043a1 	.word	0x000043a1
    2050:	000043a1 	.word	0x000043a1
    2054:	000043a1 	.word	0x000043a1
    2058:	000043a1 	.word	0x000043a1
    205c:	000043a5 	.word	0x000043a5
    2060:	000043a1 	.word	0x000043a1
    2064:	000042ed 	.word	0x000042ed
    2068:	000043a1 	.word	0x000043a1
    206c:	000043a1 	.word	0x000043a1
    2070:	000043a1 	.word	0x000043a1
    2074:	000043a1 	.word	0x000043a1
    2078:	000042fd 	.word	0x000042fd
    207c:	000043a1 	.word	0x000043a1
    2080:	000043a1 	.word	0x000043a1
    2084:	000043a1 	.word	0x000043a1
    2088:	000043a1 	.word	0x000043a1
    208c:	000043a1 	.word	0x000043a1
    2090:	00000000 	.word	0x00000000
    2094:	000043a1 	.word	0x000043a1
    2098:	000043a1 	.word	0x000043a1
    209c:	000043a1 	.word	0x000043a1
    20a0:	000043a1 	.word	0x000043a1
    20a4:	000043a1 	.word	0x000043a1
    20a8:	000043a1 	.word	0x000043a1
    20ac:	000043a1 	.word	0x000043a1
    20b0:	00000000 	.word	0x00000000

000020b4 <__do_global_dtors_aux>:
    20b4:	b510      	push	{r4, lr}
    20b6:	4c06      	ldr	r4, [pc, #24]	; (20d0 <__do_global_dtors_aux+0x1c>)
    20b8:	7823      	ldrb	r3, [r4, #0]
    20ba:	2b00      	cmp	r3, #0
    20bc:	d107      	bne.n	20ce <__do_global_dtors_aux+0x1a>
    20be:	4b05      	ldr	r3, [pc, #20]	; (20d4 <__do_global_dtors_aux+0x20>)
    20c0:	2b00      	cmp	r3, #0
    20c2:	d002      	beq.n	20ca <__do_global_dtors_aux+0x16>
    20c4:	4804      	ldr	r0, [pc, #16]	; (20d8 <__do_global_dtors_aux+0x24>)
    20c6:	e000      	b.n	20ca <__do_global_dtors_aux+0x16>
    20c8:	bf00      	nop
    20ca:	2301      	movs	r3, #1
    20cc:	7023      	strb	r3, [r4, #0]
    20ce:	bd10      	pop	{r4, pc}
    20d0:	20000110 	.word	0x20000110
    20d4:	00000000 	.word	0x00000000
    20d8:	00009274 	.word	0x00009274

000020dc <frame_dummy>:
    20dc:	b508      	push	{r3, lr}
    20de:	4b08      	ldr	r3, [pc, #32]	; (2100 <frame_dummy+0x24>)
    20e0:	2b00      	cmp	r3, #0
    20e2:	d003      	beq.n	20ec <frame_dummy+0x10>
    20e4:	4807      	ldr	r0, [pc, #28]	; (2104 <frame_dummy+0x28>)
    20e6:	4908      	ldr	r1, [pc, #32]	; (2108 <frame_dummy+0x2c>)
    20e8:	e000      	b.n	20ec <frame_dummy+0x10>
    20ea:	bf00      	nop
    20ec:	4807      	ldr	r0, [pc, #28]	; (210c <frame_dummy+0x30>)
    20ee:	6803      	ldr	r3, [r0, #0]
    20f0:	2b00      	cmp	r3, #0
    20f2:	d003      	beq.n	20fc <frame_dummy+0x20>
    20f4:	4b06      	ldr	r3, [pc, #24]	; (2110 <frame_dummy+0x34>)
    20f6:	2b00      	cmp	r3, #0
    20f8:	d000      	beq.n	20fc <frame_dummy+0x20>
    20fa:	4798      	blx	r3
    20fc:	bd08      	pop	{r3, pc}
    20fe:	46c0      	nop			; (mov r8, r8)
    2100:	00000000 	.word	0x00000000
    2104:	00009274 	.word	0x00009274
    2108:	20000114 	.word	0x20000114
    210c:	2000010c 	.word	0x2000010c
    2110:	00000000 	.word	0x00000000

00002114 <_Z12testdrawtextPct>:
  for (int16_t y=0; y < tft.height(); y+=6) {
    tft.drawLine(tft.width()-1, tft.height()-1, 0, y, color);
  }
}

void testdrawtext(char *text, uint16_t color) {
    2114:	b570      	push	{r4, r5, r6, lr}
  tft.setCursor(0, 0);
    2116:	4c0a      	ldr	r4, [pc, #40]	; (2140 <_Z12testdrawtextPct+0x2c>)
  for (int16_t y=0; y < tft.height(); y+=6) {
    tft.drawLine(tft.width()-1, tft.height()-1, 0, y, color);
  }
}

void testdrawtext(char *text, uint16_t color) {
    2118:	1c0e      	adds	r6, r1, #0
  tft.setCursor(0, 0);
    211a:	2100      	movs	r1, #0
    211c:	1c0a      	adds	r2, r1, #0
  for (int16_t y=0; y < tft.height(); y+=6) {
    tft.drawLine(tft.width()-1, tft.height()-1, 0, y, color);
  }
}

void testdrawtext(char *text, uint16_t color) {
    211e:	1c05      	adds	r5, r0, #0
  tft.setCursor(0, 0);
    2120:	1c20      	adds	r0, r4, #0
    2122:	f001 fc72 	bl	3a0a <_ZN12Adafruit_GFX9setCursorEss>
  tft.setTextColor(color);
    2126:	1c31      	adds	r1, r6, #0
    2128:	1c20      	adds	r0, r4, #0
    212a:	f001 fc76 	bl	3a1a <_ZN12Adafruit_GFX12setTextColorEt>
  tft.setTextWrap(true);
    212e:	1c20      	adds	r0, r4, #0
    2130:	2101      	movs	r1, #1
    2132:	f001 fc75 	bl	3a20 <_ZN12Adafruit_GFX11setTextWrapEb>
  tft.print(text);
    2136:	1c29      	adds	r1, r5, #0
    2138:	1c20      	adds	r0, r4, #0
    213a:	f002 fc07 	bl	494c <_ZN5Print5printEPKc>
}
    213e:	bd70      	pop	{r4, r5, r6, pc}
    2140:	2000012c 	.word	0x2000012c

00002144 <_Z15testfillcirclesht>:
    tft.fillRect(tft.width()/2 -x/2, tft.height()/2 -x/2 , x, x, color1);
    tft.drawRect(tft.width()/2 -x/2, tft.height()/2 -x/2 , x, x, color2);
  }
}

void testfillcircles(uint8_t radius, uint16_t color) {
    2144:	b5f0      	push	{r4, r5, r6, r7, lr}
    2146:	b087      	sub	sp, #28
    2148:	9105      	str	r1, [sp, #20]
  for (int16_t x=radius; x < tft.width(); x+=radius*2) {
    for (int16_t y=radius; y < tft.height(); y+=radius*2) {
    214a:	0041      	lsls	r1, r0, #1
    tft.fillRect(tft.width()/2 -x/2, tft.height()/2 -x/2 , x, x, color1);
    tft.drawRect(tft.width()/2 -x/2, tft.height()/2 -x/2 , x, x, color2);
  }
}

void testfillcircles(uint8_t radius, uint16_t color) {
    214c:	1c04      	adds	r4, r0, #0
  for (int16_t x=radius; x < tft.width(); x+=radius*2) {
    for (int16_t y=radius; y < tft.height(); y+=radius*2) {
    214e:	9103      	str	r1, [sp, #12]
    tft.drawRect(tft.width()/2 -x/2, tft.height()/2 -x/2 , x, x, color2);
  }
}

void testfillcircles(uint8_t radius, uint16_t color) {
  for (int16_t x=radius; x < tft.width(); x+=radius*2) {
    2150:	1c06      	adds	r6, r0, #0
    2152:	4810      	ldr	r0, [pc, #64]	; (2194 <_Z15testfillcirclesht+0x50>)
    2154:	f001 fc66 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    2158:	b233      	sxth	r3, r6
    215a:	9304      	str	r3, [sp, #16]
    215c:	4283      	cmp	r3, r0
    215e:	da16      	bge.n	218e <_Z15testfillcirclesht+0x4a>
    2160:	1c25      	adds	r5, r4, #0
    for (int16_t y=radius; y < tft.height(); y+=radius*2) {
    2162:	4f0c      	ldr	r7, [pc, #48]	; (2194 <_Z15testfillcirclesht+0x50>)
    2164:	1c38      	adds	r0, r7, #0
    2166:	f001 fc60 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    216a:	b22a      	sxth	r2, r5
    216c:	4282      	cmp	r2, r0
    216e:	da0a      	bge.n	2186 <_Z15testfillcirclesht+0x42>
      tft.fillCircle(x, y, radius, color);
    2170:	9905      	ldr	r1, [sp, #20]
    2172:	b223      	sxth	r3, r4
    2174:	9100      	str	r1, [sp, #0]
    2176:	1c38      	adds	r0, r7, #0
    2178:	9904      	ldr	r1, [sp, #16]
    217a:	f001 f844 	bl	3206 <_ZN12Adafruit_GFX10fillCircleEssst>
    217e:	9b03      	ldr	r3, [sp, #12]
    2180:	195d      	adds	r5, r3, r5
    2182:	b2ad      	uxth	r5, r5
    2184:	e7ed      	b.n	2162 <_Z15testfillcirclesht+0x1e>
    2186:	9903      	ldr	r1, [sp, #12]
    2188:	198e      	adds	r6, r1, r6
    218a:	b2b6      	uxth	r6, r6
    218c:	e7e1      	b.n	2152 <_Z15testfillcirclesht+0xe>
    }
  }
}
    218e:	b007      	add	sp, #28
    2190:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2192:	46c0      	nop			; (mov r8, r8)
    2194:	2000012c 	.word	0x2000012c

00002198 <_Z15testdrawcirclesht>:

void testdrawcircles(uint8_t radius, uint16_t color) {
    2198:	b5f0      	push	{r4, r5, r6, r7, lr}
    219a:	b087      	sub	sp, #28
    219c:	9105      	str	r1, [sp, #20]
  for (int16_t x=0; x < tft.width()+radius; x+=radius*2) {
    for (int16_t y=0; y < tft.height()+radius; y+=radius*2) {
    219e:	0041      	lsls	r1, r0, #1
      tft.fillCircle(x, y, radius, color);
    }
  }
}

void testdrawcircles(uint8_t radius, uint16_t color) {
    21a0:	1c04      	adds	r4, r0, #0
  for (int16_t x=0; x < tft.width()+radius; x+=radius*2) {
    for (int16_t y=0; y < tft.height()+radius; y+=radius*2) {
    21a2:	9103      	str	r1, [sp, #12]
    }
  }
}

void testdrawcircles(uint8_t radius, uint16_t color) {
  for (int16_t x=0; x < tft.width()+radius; x+=radius*2) {
    21a4:	2600      	movs	r6, #0
    21a6:	4811      	ldr	r0, [pc, #68]	; (21ec <_Z15testdrawcirclesht+0x54>)
    21a8:	f001 fc3c 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    21ac:	b233      	sxth	r3, r6
    21ae:	1900      	adds	r0, r0, r4
    21b0:	9304      	str	r3, [sp, #16]
    21b2:	4283      	cmp	r3, r0
    21b4:	da17      	bge.n	21e6 <_Z15testdrawcirclesht+0x4e>
    21b6:	2500      	movs	r5, #0
    for (int16_t y=0; y < tft.height()+radius; y+=radius*2) {
    21b8:	4f0c      	ldr	r7, [pc, #48]	; (21ec <_Z15testdrawcirclesht+0x54>)
    21ba:	1c38      	adds	r0, r7, #0
    21bc:	f001 fc35 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    21c0:	b22a      	sxth	r2, r5
    21c2:	1900      	adds	r0, r0, r4
    21c4:	4282      	cmp	r2, r0
    21c6:	da0a      	bge.n	21de <_Z15testdrawcirclesht+0x46>
      tft.drawCircle(x, y, radius, color);
    21c8:	9905      	ldr	r1, [sp, #20]
    21ca:	b223      	sxth	r3, r4
    21cc:	9100      	str	r1, [sp, #0]
    21ce:	1c38      	adds	r0, r7, #0
    21d0:	9904      	ldr	r1, [sp, #16]
    21d2:	f000 fde9 	bl	2da8 <_ZN12Adafruit_GFX10drawCircleEssst>
    21d6:	9b03      	ldr	r3, [sp, #12]
    21d8:	195d      	adds	r5, r3, r5
    21da:	b2ad      	uxth	r5, r5
    21dc:	e7ec      	b.n	21b8 <_Z15testdrawcirclesht+0x20>
    21de:	9903      	ldr	r1, [sp, #12]
    21e0:	198e      	adds	r6, r1, r6
    21e2:	b2b6      	uxth	r6, r6
    21e4:	e7df      	b.n	21a6 <_Z15testdrawcirclesht+0xe>
    }
  }
}
    21e6:	b007      	add	sp, #28
    21e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    21ea:	46c0      	nop			; (mov r8, r8)
    21ec:	2000012c 	.word	0x2000012c

000021f0 <_GLOBAL__sub_I_tft>:
  // pause color
  tft.fillRoundRect(39, 98, 20, 45, 5, ST7735_RED);
  tft.fillRoundRect(69, 98, 20, 45, 5, ST7735_RED);
  // play color
  tft.fillTriangle(42, 20, 42, 60, 90, 40, ST7735_GREEN);
}
    21f0:	b508      	push	{r3, lr}

// Option 1 (recommended): must use the hardware SPI pins
// (for UNO thats sclk = 13 and sid = 11) and pin 10 must be
// an output. This is much faster - also required if you want
// to use the microSD card (see the image drawing example)
Adafruit_ST7735 tft = Adafruit_ST7735(TFT_CS,  TFT_DC, TFT_RST);
    21f2:	4803      	ldr	r0, [pc, #12]	; (2200 <_GLOBAL__sub_I_tft+0x10>)
    21f4:	210a      	movs	r1, #10
    21f6:	2208      	movs	r2, #8
    21f8:	2309      	movs	r3, #9
    21fa:	f001 fc31 	bl	3a60 <_ZN15Adafruit_ST7735C1Eaaa>
  // pause color
  tft.fillRoundRect(39, 98, 20, 45, 5, ST7735_RED);
  tft.fillRoundRect(69, 98, 20, 45, 5, ST7735_RED);
  // play color
  tft.fillTriangle(42, 20, 42, 60, 90, 40, ST7735_GREEN);
}
    21fe:	bd08      	pop	{r3, pc}
    2200:	2000012c 	.word	0x2000012c

00002204 <_Z13testtrianglesv>:
      tft.drawCircle(x, y, radius, color);
    }
  }
}

void testtriangles() {
    2204:	b5f0      	push	{r4, r5, r6, r7, lr}
  tft.fillScreen(ST7735_BLACK);
    2206:	4c17      	ldr	r4, [pc, #92]	; (2264 <_Z13testtrianglesv+0x60>)
      tft.drawCircle(x, y, radius, color);
    }
  }
}

void testtriangles() {
    2208:	b085      	sub	sp, #20
  tft.fillScreen(ST7735_BLACK);
    220a:	2100      	movs	r1, #0
    220c:	1c20      	adds	r0, r4, #0
    220e:	f001 fc0f 	bl	3a30 <_ZN15Adafruit_ST773510fillScreenEt>
  int color = 0xF800;
  int t;
  int w = tft.width()/2;
    2212:	1c20      	adds	r0, r4, #0
    2214:	f001 fc06 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    2218:	0fc5      	lsrs	r5, r0, #31
    221a:	182d      	adds	r5, r5, r0
  int x = tft.height()-1;
    221c:	1c20      	adds	r0, r4, #0
    221e:	f001 fc04 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    2222:	1e46      	subs	r6, r0, #1
  int y = 0;
  int z = tft.width();
    2224:	1c20      	adds	r0, r4, #0
    2226:	f001 fbfd 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>

void testtriangles() {
  tft.fillScreen(ST7735_BLACK);
  int color = 0xF800;
  int t;
  int w = tft.width()/2;
    222a:	106d      	asrs	r5, r5, #1
    222c:	b2ad      	uxth	r5, r5
  int x = tft.height()-1;
  int y = 0;
  int z = tft.width();
    222e:	1c07      	adds	r7, r0, #0
    2230:	2400      	movs	r4, #0
    2232:	1b32      	subs	r2, r6, r4
  for(t = 0 ; t <= 15; t++) {
    tft.drawTriangle(w, y, y, x, z, x, color);
    2234:	b212      	sxth	r2, r2
    2236:	9200      	str	r2, [sp, #0]
    2238:	9202      	str	r2, [sp, #8]
    223a:	2219      	movs	r2, #25
    223c:	1b38      	subs	r0, r7, r4
    223e:	4362      	muls	r2, r4
    2240:	b200      	sxth	r0, r0
    2242:	9001      	str	r0, [sp, #4]
    2244:	4808      	ldr	r0, [pc, #32]	; (2268 <_Z13testtrianglesv+0x64>)
    2246:	b223      	sxth	r3, r4
    2248:	1812      	adds	r2, r2, r0
    224a:	b292      	uxth	r2, r2
    224c:	3404      	adds	r4, #4
    224e:	9203      	str	r2, [sp, #12]
    2250:	b229      	sxth	r1, r5
    2252:	4804      	ldr	r0, [pc, #16]	; (2264 <_Z13testtrianglesv+0x60>)
    2254:	1c1a      	adds	r2, r3, #0
    2256:	b2a4      	uxth	r4, r4
    2258:	f001 f8eb 	bl	3432 <_ZN12Adafruit_GFX12drawTriangleEsssssst>
  int t;
  int w = tft.width()/2;
  int x = tft.height()-1;
  int y = 0;
  int z = tft.width();
  for(t = 0 ; t <= 15; t++) {
    225c:	2c40      	cmp	r4, #64	; 0x40
    225e:	d1e8      	bne.n	2232 <_Z13testtrianglesv+0x2e>
    x-=4;
    y+=4;
    z-=4;
    color+=100;
  }
}
    2260:	b005      	add	sp, #20
    2262:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2264:	2000012c 	.word	0x2000012c
    2268:	fffff800 	.word	0xfffff800

0000226c <_Z14testroundrectsv>:

void testroundrects() {
    226c:	b5f0      	push	{r4, r5, r6, r7, lr}
  tft.fillScreen(ST7735_BLACK);
    226e:	4819      	ldr	r0, [pc, #100]	; (22d4 <_Z14testroundrectsv+0x68>)
    z-=4;
    color+=100;
  }
}

void testroundrects() {
    2270:	b087      	sub	sp, #28
  tft.fillScreen(ST7735_BLACK);
    2272:	2100      	movs	r1, #0
    2274:	f001 fbdc 	bl	3a30 <_ZN15Adafruit_ST773510fillScreenEt>
  int color = 100;
    2278:	2464      	movs	r4, #100	; 0x64
  int i;
  int t;
  for(t = 0 ; t <= 4; t+=1) {
    int x = 0;
    int y = 0;
    int w = tft.width()-2;
    227a:	4d16      	ldr	r5, [pc, #88]	; (22d4 <_Z14testroundrectsv+0x68>)
    227c:	1c28      	adds	r0, r5, #0
    227e:	f001 fbd1 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    2282:	1e87      	subs	r7, r0, #2
    int h = tft.height()-2;
    2284:	1c28      	adds	r0, r5, #0
    2286:	f001 fbd0 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    for(i = 0 ; i <= 16; i+=1) {
    228a:	2500      	movs	r5, #0
  int t;
  for(t = 0 ; t <= 4; t+=1) {
    int x = 0;
    int y = 0;
    int w = tft.width()-2;
    int h = tft.height()-2;
    228c:	1e86      	subs	r6, r0, #2
    228e:	9405      	str	r4, [sp, #20]
    2290:	b2ab      	uxth	r3, r5
    for(i = 0 ; i <= 16; i+=1) {
      tft.drawRoundRect(x, y, w, h, 5, color);
    2292:	b230      	sxth	r0, r6
    2294:	2203      	movs	r2, #3
    2296:	0059      	lsls	r1, r3, #1
    2298:	9000      	str	r0, [sp, #0]
    229a:	4353      	muls	r3, r2
    229c:	2005      	movs	r0, #5
    229e:	9001      	str	r0, [sp, #4]
    22a0:	9805      	ldr	r0, [sp, #20]
    22a2:	b21a      	sxth	r2, r3
    22a4:	b280      	uxth	r0, r0
    22a6:	b23b      	sxth	r3, r7
    22a8:	9002      	str	r0, [sp, #8]
    22aa:	b209      	sxth	r1, r1
    22ac:	4809      	ldr	r0, [pc, #36]	; (22d4 <_Z14testroundrectsv+0x68>)
    22ae:	f000 ffd6 	bl	325e <_ZN12Adafruit_GFX13drawRoundRectEssssst>
      x+=2;
      y+=3;
      w-=4;
      h-=6;
      color+=1100;
    22b2:	9a05      	ldr	r2, [sp, #20]
    22b4:	4b08      	ldr	r3, [pc, #32]	; (22d8 <_Z14testroundrectsv+0x6c>)
  for(t = 0 ; t <= 4; t+=1) {
    int x = 0;
    int y = 0;
    int w = tft.width()-2;
    int h = tft.height()-2;
    for(i = 0 ; i <= 16; i+=1) {
    22b6:	3501      	adds	r5, #1
      tft.drawRoundRect(x, y, w, h, 5, color);
      x+=2;
      y+=3;
      w-=4;
      h-=6;
      color+=1100;
    22b8:	18d2      	adds	r2, r2, r3
    int h = tft.height()-2;
    for(i = 0 ; i <= 16; i+=1) {
      tft.drawRoundRect(x, y, w, h, 5, color);
      x+=2;
      y+=3;
      w-=4;
    22ba:	3f04      	subs	r7, #4
      h-=6;
    22bc:	3e06      	subs	r6, #6
      color+=1100;
    22be:	9205      	str	r2, [sp, #20]
  for(t = 0 ; t <= 4; t+=1) {
    int x = 0;
    int y = 0;
    int w = tft.width()-2;
    int h = tft.height()-2;
    for(i = 0 ; i <= 16; i+=1) {
    22c0:	2d11      	cmp	r5, #17
    22c2:	d1e5      	bne.n	2290 <_Z14testroundrectsv+0x24>
    22c4:	4805      	ldr	r0, [pc, #20]	; (22dc <_Z14testroundrectsv+0x70>)
void testroundrects() {
  tft.fillScreen(ST7735_BLACK);
  int color = 100;
  int i;
  int t;
  for(t = 0 ; t <= 4; t+=1) {
    22c6:	4b06      	ldr	r3, [pc, #24]	; (22e0 <_Z14testroundrectsv+0x74>)
    22c8:	1824      	adds	r4, r4, r0
    22ca:	429c      	cmp	r4, r3
    22cc:	d1d5      	bne.n	227a <_Z14testroundrectsv+0xe>
      h-=6;
      color+=1100;
    }
    color+=100;
  }
}
    22ce:	b007      	add	sp, #28
    22d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    22d2:	46c0      	nop			; (mov r8, r8)
    22d4:	2000012c 	.word	0x2000012c
    22d8:	0000044c 	.word	0x0000044c
    22dc:	00004970 	.word	0x00004970
    22e0:	00016f94 	.word	0x00016f94
    22e4:	00000000 	.word	0x00000000

000022e8 <_Z12tftPrintTestv>:

void tftPrintTest() {
    22e8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  tft.setTextWrap(false);
    22ea:	4c57      	ldr	r4, [pc, #348]	; (2448 <_Z12tftPrintTestv+0x160>)
    22ec:	2100      	movs	r1, #0
    22ee:	1c20      	adds	r0, r4, #0
    22f0:	f001 fb96 	bl	3a20 <_ZN12Adafruit_GFX11setTextWrapEb>
  tft.fillScreen(ST7735_BLACK);
    22f4:	1c20      	adds	r0, r4, #0
    22f6:	2100      	movs	r1, #0
    22f8:	f001 fb9a 	bl	3a30 <_ZN15Adafruit_ST773510fillScreenEt>
  tft.setCursor(0, 30);
    22fc:	221e      	movs	r2, #30
    22fe:	1c20      	adds	r0, r4, #0
    2300:	2100      	movs	r1, #0
    2302:	f001 fb82 	bl	3a0a <_ZN12Adafruit_GFX9setCursorEss>
  tft.setTextColor(ST7735_RED);
    2306:	21f8      	movs	r1, #248	; 0xf8
    2308:	1c20      	adds	r0, r4, #0
    230a:	0209      	lsls	r1, r1, #8
    230c:	f001 fb85 	bl	3a1a <_ZN12Adafruit_GFX12setTextColorEt>
  tft.setTextSize(1);
    2310:	1c20      	adds	r0, r4, #0
    2312:	2101      	movs	r1, #1
    2314:	f001 fb7c 	bl	3a10 <_ZN12Adafruit_GFX11setTextSizeEh>
  tft.println("Hello World!");
    2318:	4e4c      	ldr	r6, [pc, #304]	; (244c <_Z12tftPrintTestv+0x164>)
    231a:	1c20      	adds	r0, r4, #0
    231c:	1c31      	adds	r1, r6, #0
    231e:	f002 fb27 	bl	4970 <_ZN5Print7printlnEPKc>
  tft.setTextColor(ST7735_YELLOW);
    2322:	1c20      	adds	r0, r4, #0
    2324:	494a      	ldr	r1, [pc, #296]	; (2450 <_Z12tftPrintTestv+0x168>)
    2326:	f001 fb78 	bl	3a1a <_ZN12Adafruit_GFX12setTextColorEt>
  tft.setTextSize(2);
  tft.println("Hello World!");
  tft.setTextColor(ST7735_GREEN);
    232a:	27fc      	movs	r7, #252	; 0xfc
  tft.setCursor(0, 30);
  tft.setTextColor(ST7735_RED);
  tft.setTextSize(1);
  tft.println("Hello World!");
  tft.setTextColor(ST7735_YELLOW);
  tft.setTextSize(2);
    232c:	1c20      	adds	r0, r4, #0
    232e:	2102      	movs	r1, #2
    2330:	f001 fb6e 	bl	3a10 <_ZN12Adafruit_GFX11setTextSizeEh>
  tft.println("Hello World!");
  tft.setTextColor(ST7735_GREEN);
    2334:	00ff      	lsls	r7, r7, #3
  tft.setTextColor(ST7735_RED);
  tft.setTextSize(1);
  tft.println("Hello World!");
  tft.setTextColor(ST7735_YELLOW);
  tft.setTextSize(2);
  tft.println("Hello World!");
    2336:	1c31      	adds	r1, r6, #0
    2338:	1c20      	adds	r0, r4, #0
    233a:	f002 fb19 	bl	4970 <_ZN5Print7printlnEPKc>
  tft.setTextColor(ST7735_GREEN);
    233e:	1c39      	adds	r1, r7, #0
    2340:	1c20      	adds	r0, r4, #0
    2342:	f001 fb6a 	bl	3a1a <_ZN12Adafruit_GFX12setTextColorEt>
  tft.setTextSize(3);
    2346:	1c20      	adds	r0, r4, #0
    2348:	2103      	movs	r1, #3
    234a:	f001 fb61 	bl	3a10 <_ZN12Adafruit_GFX11setTextSizeEh>
  tft.println("Hello World!");
    234e:	1c31      	adds	r1, r6, #0
    2350:	1c20      	adds	r0, r4, #0
    2352:	f002 fb0d 	bl	4970 <_ZN5Print7printlnEPKc>
  tft.setTextColor(ST7735_BLUE);
    2356:	1c20      	adds	r0, r4, #0
    2358:	211f      	movs	r1, #31
    235a:	f001 fb5e 	bl	3a1a <_ZN12Adafruit_GFX12setTextColorEt>
  tft.setTextSize(4);
    235e:	2104      	movs	r1, #4
    2360:	1c20      	adds	r0, r4, #0
    2362:	f001 fb55 	bl	3a10 <_ZN12Adafruit_GFX11setTextSizeEh>
  tft.print(1234.567);
    2366:	2302      	movs	r3, #2
    2368:	9300      	str	r3, [sp, #0]
    236a:	1c20      	adds	r0, r4, #0
    236c:	4b35      	ldr	r3, [pc, #212]	; (2444 <_Z12tftPrintTestv+0x15c>)
    236e:	4a34      	ldr	r2, [pc, #208]	; (2440 <_Z12tftPrintTestv+0x158>)
    2370:	f002 fc1e 	bl	4bb0 <_ZN5Print5printEdi>
  delay(1500);
    2374:	4837      	ldr	r0, [pc, #220]	; (2454 <_Z12tftPrintTestv+0x16c>)
    2376:	f002 f85d 	bl	4434 <delay>
  tft.setCursor(0, 0);
    237a:	2100      	movs	r1, #0
    237c:	1c0a      	adds	r2, r1, #0
  tft.fillScreen(ST7735_BLACK);
  tft.setTextColor(ST7735_WHITE);
    237e:	4d36      	ldr	r5, [pc, #216]	; (2458 <_Z12tftPrintTestv+0x170>)
  tft.println("Hello World!");
  tft.setTextColor(ST7735_BLUE);
  tft.setTextSize(4);
  tft.print(1234.567);
  delay(1500);
  tft.setCursor(0, 0);
    2380:	1c20      	adds	r0, r4, #0
    2382:	f001 fb42 	bl	3a0a <_ZN12Adafruit_GFX9setCursorEss>
  tft.fillScreen(ST7735_BLACK);
    2386:	1c20      	adds	r0, r4, #0
    2388:	2100      	movs	r1, #0
    238a:	f001 fb51 	bl	3a30 <_ZN15Adafruit_ST773510fillScreenEt>
  tft.setTextColor(ST7735_WHITE);
    238e:	1c29      	adds	r1, r5, #0
    2390:	1c20      	adds	r0, r4, #0
    2392:	f001 fb42 	bl	3a1a <_ZN12Adafruit_GFX12setTextColorEt>
  tft.setTextSize(0);
    2396:	1c20      	adds	r0, r4, #0
    2398:	2100      	movs	r1, #0
    239a:	f001 fb39 	bl	3a10 <_ZN12Adafruit_GFX11setTextSizeEh>
  tft.println("Hello World!");
    239e:	1c31      	adds	r1, r6, #0
    23a0:	1c20      	adds	r0, r4, #0
    23a2:	f002 fae5 	bl	4970 <_ZN5Print7printlnEPKc>
  tft.setTextSize(1);
    23a6:	1c20      	adds	r0, r4, #0
    23a8:	2101      	movs	r1, #1
    23aa:	f001 fb31 	bl	3a10 <_ZN12Adafruit_GFX11setTextSizeEh>
  tft.setTextColor(ST7735_GREEN);
    23ae:	1c39      	adds	r1, r7, #0
    23b0:	1c20      	adds	r0, r4, #0
    23b2:	f001 fb32 	bl	3a1a <_ZN12Adafruit_GFX12setTextColorEt>
  tft.print(p, 6);
    23b6:	4b29      	ldr	r3, [pc, #164]	; (245c <_Z12tftPrintTestv+0x174>)
    23b8:	6818      	ldr	r0, [r3, #0]
    23ba:	f005 ff1d 	bl	81f8 <__aeabi_f2d>
    23be:	1c0b      	adds	r3, r1, #0
    23c0:	2106      	movs	r1, #6
    23c2:	1c02      	adds	r2, r0, #0
    23c4:	9100      	str	r1, [sp, #0]
    23c6:	1c20      	adds	r0, r4, #0
    23c8:	f002 fbf2 	bl	4bb0 <_ZN5Print5printEdi>
  tft.println(" Want pi?");
    23cc:	4924      	ldr	r1, [pc, #144]	; (2460 <_Z12tftPrintTestv+0x178>)
    23ce:	1c20      	adds	r0, r4, #0
    23d0:	f002 face 	bl	4970 <_ZN5Print7printlnEPKc>
  tft.println(" ");
    23d4:	4e23      	ldr	r6, [pc, #140]	; (2464 <_Z12tftPrintTestv+0x17c>)
    23d6:	1c20      	adds	r0, r4, #0
    23d8:	1c31      	adds	r1, r6, #0
    23da:	f002 fac9 	bl	4970 <_ZN5Print7printlnEPKc>
  tft.print(8675309, HEX); // print 8,675,309 out in HEX!
    23de:	2210      	movs	r2, #16
    23e0:	4921      	ldr	r1, [pc, #132]	; (2468 <_Z12tftPrintTestv+0x180>)
    23e2:	1c20      	adds	r0, r4, #0
    23e4:	f002 fb13 	bl	4a0e <_ZN5Print5printEii>
  tft.println(" Print HEX!");
    23e8:	4920      	ldr	r1, [pc, #128]	; (246c <_Z12tftPrintTestv+0x184>)
    23ea:	1c20      	adds	r0, r4, #0
    23ec:	f002 fac0 	bl	4970 <_ZN5Print7printlnEPKc>
  tft.println(" ");
    23f0:	1c31      	adds	r1, r6, #0
    23f2:	1c20      	adds	r0, r4, #0
    23f4:	f002 fabc 	bl	4970 <_ZN5Print7printlnEPKc>
  tft.setTextColor(ST7735_WHITE);
    23f8:	1c29      	adds	r1, r5, #0
    23fa:	1c20      	adds	r0, r4, #0
    23fc:	f001 fb0d 	bl	3a1a <_ZN12Adafruit_GFX12setTextColorEt>
  tft.println("Sketch has been");
    2400:	491b      	ldr	r1, [pc, #108]	; (2470 <_Z12tftPrintTestv+0x188>)
    2402:	1c20      	adds	r0, r4, #0
    2404:	f002 fab4 	bl	4970 <_ZN5Print7printlnEPKc>
  tft.println("running for: ");
    2408:	491a      	ldr	r1, [pc, #104]	; (2474 <_Z12tftPrintTestv+0x18c>)
    240a:	1c20      	adds	r0, r4, #0
    240c:	f002 fab0 	bl	4970 <_ZN5Print7printlnEPKc>
  tft.setTextColor(ST7735_MAGENTA);
    2410:	4919      	ldr	r1, [pc, #100]	; (2478 <_Z12tftPrintTestv+0x190>)
    2412:	1c20      	adds	r0, r4, #0
    2414:	f001 fb01 	bl	3a1a <_ZN12Adafruit_GFX12setTextColorEt>
  tft.print(millis() / 1000);
    2418:	f002 f806 	bl	4428 <millis>
    241c:	21fa      	movs	r1, #250	; 0xfa
    241e:	0089      	lsls	r1, r1, #2
    2420:	f004 f832 	bl	6488 <__aeabi_uidiv>
    2424:	220a      	movs	r2, #10
    2426:	1c01      	adds	r1, r0, #0
    2428:	1c20      	adds	r0, r4, #0
    242a:	f002 fafe 	bl	4a2a <_ZN5Print5printEmi>
  tft.setTextColor(ST7735_WHITE);
    242e:	1c29      	adds	r1, r5, #0
    2430:	1c20      	adds	r0, r4, #0
    2432:	f001 faf2 	bl	3a1a <_ZN12Adafruit_GFX12setTextColorEt>
  tft.print(" seconds.");
    2436:	4911      	ldr	r1, [pc, #68]	; (247c <_Z12tftPrintTestv+0x194>)
    2438:	1c20      	adds	r0, r4, #0
    243a:	f002 fa87 	bl	494c <_ZN5Print5printEPKc>
}
    243e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    2440:	9ba5e354 	.word	0x9ba5e354
    2444:	40934a44 	.word	0x40934a44
    2448:	2000012c 	.word	0x2000012c
    244c:	00008484 	.word	0x00008484
    2450:	0000ffe0 	.word	0x0000ffe0
    2454:	000005dc 	.word	0x000005dc
    2458:	0000ffff 	.word	0x0000ffff
    245c:	20000000 	.word	0x20000000
    2460:	00008491 	.word	0x00008491
    2464:	0000865e 	.word	0x0000865e
    2468:	00845fed 	.word	0x00845fed
    246c:	0000849b 	.word	0x0000849b
    2470:	000084a7 	.word	0x000084a7
    2474:	000084b7 	.word	0x000084b7
    2478:	0000f81f 	.word	0x0000f81f
    247c:	000084c5 	.word	0x000084c5

00002480 <_Z12mediabuttonsv>:

void mediabuttons() {
    2480:	b5f0      	push	{r4, r5, r6, r7, lr}
  // play
  tft.fillScreen(ST7735_BLACK);
    2482:	4c3f      	ldr	r4, [pc, #252]	; (2580 <_Z12mediabuttonsv+0x100>)
  tft.print(millis() / 1000);
  tft.setTextColor(ST7735_WHITE);
  tft.print(" seconds.");
}

void mediabuttons() {
    2484:	b085      	sub	sp, #20
  // play
  tft.fillScreen(ST7735_BLACK);
    2486:	1c20      	adds	r0, r4, #0
  tft.fillRoundRect(25, 10, 78, 60, 8, ST7735_WHITE);
    2488:	4d3e      	ldr	r5, [pc, #248]	; (2584 <_Z12mediabuttonsv+0x104>)
  tft.print(" seconds.");
}

void mediabuttons() {
  // play
  tft.fillScreen(ST7735_BLACK);
    248a:	2100      	movs	r1, #0
    248c:	f001 fad0 	bl	3a30 <_ZN15Adafruit_ST773510fillScreenEt>
  tft.fillRoundRect(25, 10, 78, 60, 8, ST7735_WHITE);
    2490:	2608      	movs	r6, #8
    2492:	233c      	movs	r3, #60	; 0x3c
    2494:	9300      	str	r3, [sp, #0]
    2496:	9601      	str	r6, [sp, #4]
    2498:	9502      	str	r5, [sp, #8]
    249a:	1c20      	adds	r0, r4, #0
    249c:	2119      	movs	r1, #25
    249e:	220a      	movs	r2, #10
    24a0:	234e      	movs	r3, #78	; 0x4e
    24a2:	f000 ff6f 	bl	3384 <_ZN12Adafruit_GFX13fillRoundRectEssssst>
  tft.fillTriangle(42, 20, 42, 60, 90, 40, ST7735_RED);
    24a6:	233c      	movs	r3, #60	; 0x3c
    24a8:	9300      	str	r3, [sp, #0]
    24aa:	235a      	movs	r3, #90	; 0x5a
    24ac:	9301      	str	r3, [sp, #4]
    24ae:	2328      	movs	r3, #40	; 0x28
    24b0:	9302      	str	r3, [sp, #8]
    24b2:	23f8      	movs	r3, #248	; 0xf8
    24b4:	212a      	movs	r1, #42	; 0x2a
    24b6:	021b      	lsls	r3, r3, #8
    24b8:	9303      	str	r3, [sp, #12]
    24ba:	1c20      	adds	r0, r4, #0
    24bc:	1c0b      	adds	r3, r1, #0
    24be:	2214      	movs	r2, #20
    24c0:	f000 ffea 	bl	3498 <_ZN12Adafruit_GFX12fillTriangleEsssssst>
  delay(500);
    24c4:	20fa      	movs	r0, #250	; 0xfa
    24c6:	0040      	lsls	r0, r0, #1
    24c8:	f001 ffb4 	bl	4434 <delay>
  // pause
  tft.fillRoundRect(25, 90, 78, 60, 8, ST7735_WHITE);
    24cc:	233c      	movs	r3, #60	; 0x3c
    24ce:	9300      	str	r3, [sp, #0]
    24d0:	9601      	str	r6, [sp, #4]
    24d2:	9502      	str	r5, [sp, #8]
    24d4:	1c20      	adds	r0, r4, #0
    24d6:	2119      	movs	r1, #25
    24d8:	225a      	movs	r2, #90	; 0x5a
    24da:	234e      	movs	r3, #78	; 0x4e
    24dc:	f000 ff52 	bl	3384 <_ZN12Adafruit_GFX13fillRoundRectEssssst>
  tft.fillRoundRect(39, 98, 20, 45, 5, ST7735_GREEN);
    24e0:	23fc      	movs	r3, #252	; 0xfc
    24e2:	262d      	movs	r6, #45	; 0x2d
    24e4:	2505      	movs	r5, #5
    24e6:	00df      	lsls	r7, r3, #3
    24e8:	1c20      	adds	r0, r4, #0
    24ea:	9600      	str	r6, [sp, #0]
    24ec:	9501      	str	r5, [sp, #4]
    24ee:	9702      	str	r7, [sp, #8]
    24f0:	2127      	movs	r1, #39	; 0x27
    24f2:	2262      	movs	r2, #98	; 0x62
    24f4:	2314      	movs	r3, #20
    24f6:	f000 ff45 	bl	3384 <_ZN12Adafruit_GFX13fillRoundRectEssssst>
  tft.fillRoundRect(69, 98, 20, 45, 5, ST7735_GREEN);
    24fa:	1c20      	adds	r0, r4, #0
    24fc:	2145      	movs	r1, #69	; 0x45
    24fe:	2262      	movs	r2, #98	; 0x62
    2500:	2314      	movs	r3, #20
    2502:	9600      	str	r6, [sp, #0]
    2504:	9501      	str	r5, [sp, #4]
    2506:	9702      	str	r7, [sp, #8]
    2508:	f000 ff3c 	bl	3384 <_ZN12Adafruit_GFX13fillRoundRectEssssst>
  delay(500);
    250c:	20fa      	movs	r0, #250	; 0xfa
    250e:	0040      	lsls	r0, r0, #1
    2510:	f001 ff90 	bl	4434 <delay>
  // play color
  tft.fillTriangle(42, 20, 42, 60, 90, 40, ST7735_BLUE);
    2514:	233c      	movs	r3, #60	; 0x3c
    2516:	9300      	str	r3, [sp, #0]
    2518:	235a      	movs	r3, #90	; 0x5a
    251a:	9301      	str	r3, [sp, #4]
    251c:	2328      	movs	r3, #40	; 0x28
    251e:	212a      	movs	r1, #42	; 0x2a
    2520:	9302      	str	r3, [sp, #8]
    2522:	231f      	movs	r3, #31
    2524:	9303      	str	r3, [sp, #12]
    2526:	1c20      	adds	r0, r4, #0
    2528:	1c0b      	adds	r3, r1, #0
    252a:	2214      	movs	r2, #20
    252c:	f000 ffb4 	bl	3498 <_ZN12Adafruit_GFX12fillTriangleEsssssst>
  delay(50);
    2530:	2032      	movs	r0, #50	; 0x32
    2532:	f001 ff7f 	bl	4434 <delay>
  // pause color
  tft.fillRoundRect(39, 98, 20, 45, 5, ST7735_RED);
    2536:	23f8      	movs	r3, #248	; 0xf8
    2538:	021b      	lsls	r3, r3, #8
    253a:	9302      	str	r3, [sp, #8]
    253c:	1c20      	adds	r0, r4, #0
    253e:	9600      	str	r6, [sp, #0]
    2540:	9501      	str	r5, [sp, #4]
    2542:	2127      	movs	r1, #39	; 0x27
    2544:	2262      	movs	r2, #98	; 0x62
    2546:	2314      	movs	r3, #20
    2548:	f000 ff1c 	bl	3384 <_ZN12Adafruit_GFX13fillRoundRectEssssst>
  tft.fillRoundRect(69, 98, 20, 45, 5, ST7735_RED);
    254c:	23f8      	movs	r3, #248	; 0xf8
    254e:	021b      	lsls	r3, r3, #8
    2550:	9302      	str	r3, [sp, #8]
    2552:	1c20      	adds	r0, r4, #0
    2554:	9600      	str	r6, [sp, #0]
    2556:	9501      	str	r5, [sp, #4]
    2558:	2145      	movs	r1, #69	; 0x45
    255a:	2262      	movs	r2, #98	; 0x62
    255c:	2314      	movs	r3, #20
    255e:	f000 ff11 	bl	3384 <_ZN12Adafruit_GFX13fillRoundRectEssssst>
  // play color
  tft.fillTriangle(42, 20, 42, 60, 90, 40, ST7735_GREEN);
    2562:	233c      	movs	r3, #60	; 0x3c
    2564:	9300      	str	r3, [sp, #0]
    2566:	235a      	movs	r3, #90	; 0x5a
    2568:	9301      	str	r3, [sp, #4]
    256a:	212a      	movs	r1, #42	; 0x2a
    256c:	2328      	movs	r3, #40	; 0x28
    256e:	9302      	str	r3, [sp, #8]
    2570:	9703      	str	r7, [sp, #12]
    2572:	1c20      	adds	r0, r4, #0
    2574:	2214      	movs	r2, #20
    2576:	1c0b      	adds	r3, r1, #0
    2578:	f000 ff8e 	bl	3498 <_ZN12Adafruit_GFX12fillTriangleEsssssst>
}
    257c:	b005      	add	sp, #20
    257e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2580:	2000012c 	.word	0x2000012c
    2584:	0000ffff 	.word	0x0000ffff

00002588 <loop>:

  Serial.println("done");
  delay(1000);
}

void loop() {
    2588:	b538      	push	{r3, r4, r5, lr}
  tft.invertDisplay(true);
    258a:	4d09      	ldr	r5, [pc, #36]	; (25b0 <loop+0x28>)
  delay(500);
    258c:	24fa      	movs	r4, #250	; 0xfa
  Serial.println("done");
  delay(1000);
}

void loop() {
  tft.invertDisplay(true);
    258e:	1c28      	adds	r0, r5, #0
    2590:	2101      	movs	r1, #1
  delay(500);
    2592:	0064      	lsls	r4, r4, #1
  Serial.println("done");
  delay(1000);
}

void loop() {
  tft.invertDisplay(true);
    2594:	f001 fad8 	bl	3b48 <_ZN15Adafruit_ST773513invertDisplayEb>
  delay(500);
    2598:	1c20      	adds	r0, r4, #0
    259a:	f001 ff4b 	bl	4434 <delay>
  tft.invertDisplay(false);
    259e:	1c28      	adds	r0, r5, #0
    25a0:	2100      	movs	r1, #0
    25a2:	f001 fad1 	bl	3b48 <_ZN15Adafruit_ST773513invertDisplayEb>
  delay(500);
    25a6:	1c20      	adds	r0, r4, #0
    25a8:	f001 ff44 	bl	4434 <delay>
}
    25ac:	bd38      	pop	{r3, r4, r5, pc}
    25ae:	46c0      	nop			; (mov r8, r8)
    25b0:	2000012c 	.word	0x2000012c

000025b4 <_Z9testlinest>:

void testlines(uint16_t color) {
    25b4:	b5f0      	push	{r4, r5, r6, r7, lr}
  tft.fillScreen(ST7735_BLACK);
    25b6:	4c71      	ldr	r4, [pc, #452]	; (277c <_Z9testlinest+0x1c8>)
  delay(500);
  tft.invertDisplay(false);
  delay(500);
}

void testlines(uint16_t color) {
    25b8:	b085      	sub	sp, #20
    25ba:	1c05      	adds	r5, r0, #0
  tft.fillScreen(ST7735_BLACK);
    25bc:	2100      	movs	r1, #0
    25be:	1c20      	adds	r0, r4, #0
    25c0:	f001 fa36 	bl	3a30 <_ZN15Adafruit_ST773510fillScreenEt>
  for (int16_t x=0; x < tft.width(); x+=6) {
    25c4:	2600      	movs	r6, #0
    25c6:	1c20      	adds	r0, r4, #0
    25c8:	f001 fa2c 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    25cc:	b237      	sxth	r7, r6
    25ce:	4287      	cmp	r7, r0
    25d0:	da0f      	bge.n	25f2 <_Z9testlinest+0x3e>
    tft.drawLine(0, 0, x, tft.height()-1, color);
    25d2:	1c20      	adds	r0, r4, #0
    25d4:	f001 fa29 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    25d8:	3801      	subs	r0, #1
    25da:	b200      	sxth	r0, r0
    25dc:	2100      	movs	r1, #0
    25de:	9000      	str	r0, [sp, #0]
    25e0:	9501      	str	r5, [sp, #4]
    25e2:	1c20      	adds	r0, r4, #0
    25e4:	1c0a      	adds	r2, r1, #0
    25e6:	1c3b      	adds	r3, r7, #0
    25e8:	3606      	adds	r6, #6
    25ea:	f000 fb31 	bl	2c50 <_ZN12Adafruit_GFX8drawLineEsssst>
    25ee:	b2b6      	uxth	r6, r6
    25f0:	e7e9      	b.n	25c6 <_Z9testlinest+0x12>
  delay(500);
}

void testlines(uint16_t color) {
  tft.fillScreen(ST7735_BLACK);
  for (int16_t x=0; x < tft.width(); x+=6) {
    25f2:	2600      	movs	r6, #0
    tft.drawLine(0, 0, x, tft.height()-1, color);
  }
  for (int16_t y=0; y < tft.height(); y+=6) {
    25f4:	1c20      	adds	r0, r4, #0
    25f6:	f001 fa18 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    25fa:	b237      	sxth	r7, r6
    25fc:	4287      	cmp	r7, r0
    25fe:	da0e      	bge.n	261e <_Z9testlinest+0x6a>
    tft.drawLine(0, 0, tft.width()-1, y, color);
    2600:	1c20      	adds	r0, r4, #0
    2602:	f001 fa0f 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    2606:	2100      	movs	r1, #0
    2608:	1e43      	subs	r3, r0, #1
    260a:	b21b      	sxth	r3, r3
    260c:	9700      	str	r7, [sp, #0]
    260e:	9501      	str	r5, [sp, #4]
    2610:	1c20      	adds	r0, r4, #0
    2612:	1c0a      	adds	r2, r1, #0
    2614:	3606      	adds	r6, #6
    2616:	f000 fb1b 	bl	2c50 <_ZN12Adafruit_GFX8drawLineEsssst>
    261a:	b2b6      	uxth	r6, r6
    261c:	e7ea      	b.n	25f4 <_Z9testlinest+0x40>
  }

  tft.fillScreen(ST7735_BLACK);
    261e:	1c20      	adds	r0, r4, #0
    2620:	2100      	movs	r1, #0
    2622:	f001 fa05 	bl	3a30 <_ZN15Adafruit_ST773510fillScreenEt>
  for (int16_t x=0; x < tft.width(); x+=6) {
    2626:	2600      	movs	r6, #0
    2628:	1c20      	adds	r0, r4, #0
    262a:	f001 f9fb 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    262e:	b231      	sxth	r1, r6
    2630:	9103      	str	r1, [sp, #12]
    2632:	4281      	cmp	r1, r0
    2634:	da14      	bge.n	2660 <_Z9testlinest+0xac>
    tft.drawLine(tft.width()-1, 0, x, tft.height()-1, color);
    2636:	1c20      	adds	r0, r4, #0
    2638:	f001 f9f4 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    263c:	1c07      	adds	r7, r0, #0
    263e:	1c20      	adds	r0, r4, #0
    2640:	f001 f9f3 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    2644:	3801      	subs	r0, #1
    2646:	b200      	sxth	r0, r0
    2648:	3f01      	subs	r7, #1
    264a:	9000      	str	r0, [sp, #0]
    264c:	b239      	sxth	r1, r7
    264e:	9501      	str	r5, [sp, #4]
    2650:	1c20      	adds	r0, r4, #0
    2652:	2200      	movs	r2, #0
    2654:	9b03      	ldr	r3, [sp, #12]
    2656:	3606      	adds	r6, #6
    2658:	f000 fafa 	bl	2c50 <_ZN12Adafruit_GFX8drawLineEsssst>
    265c:	b2b6      	uxth	r6, r6
    265e:	e7e3      	b.n	2628 <_Z9testlinest+0x74>
  for (int16_t y=0; y < tft.height(); y+=6) {
    tft.drawLine(0, 0, tft.width()-1, y, color);
  }

  tft.fillScreen(ST7735_BLACK);
  for (int16_t x=0; x < tft.width(); x+=6) {
    2660:	2600      	movs	r6, #0
    tft.drawLine(tft.width()-1, 0, x, tft.height()-1, color);
  }
  for (int16_t y=0; y < tft.height(); y+=6) {
    2662:	1c20      	adds	r0, r4, #0
    2664:	f001 f9e1 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    2668:	b237      	sxth	r7, r6
    266a:	4287      	cmp	r7, r0
    266c:	da0e      	bge.n	268c <_Z9testlinest+0xd8>
    tft.drawLine(tft.width()-1, 0, 0, y, color);
    266e:	1c20      	adds	r0, r4, #0
    2670:	f001 f9d8 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    2674:	2200      	movs	r2, #0
    2676:	1e41      	subs	r1, r0, #1
    2678:	b209      	sxth	r1, r1
    267a:	9700      	str	r7, [sp, #0]
    267c:	9501      	str	r5, [sp, #4]
    267e:	1c20      	adds	r0, r4, #0
    2680:	1c13      	adds	r3, r2, #0
    2682:	3606      	adds	r6, #6
    2684:	f000 fae4 	bl	2c50 <_ZN12Adafruit_GFX8drawLineEsssst>
    2688:	b2b6      	uxth	r6, r6
    268a:	e7ea      	b.n	2662 <_Z9testlinest+0xae>
  }

  tft.fillScreen(ST7735_BLACK);
    268c:	1c20      	adds	r0, r4, #0
    268e:	2100      	movs	r1, #0
    2690:	f001 f9ce 	bl	3a30 <_ZN15Adafruit_ST773510fillScreenEt>
  for (int16_t x=0; x < tft.width(); x+=6) {
    2694:	2600      	movs	r6, #0
    2696:	1c20      	adds	r0, r4, #0
    2698:	f001 f9c4 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    269c:	b237      	sxth	r7, r6
    269e:	4287      	cmp	r7, r0
    26a0:	da0e      	bge.n	26c0 <_Z9testlinest+0x10c>
    tft.drawLine(0, tft.height()-1, x, 0, color);
    26a2:	1c20      	adds	r0, r4, #0
    26a4:	f001 f9c1 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    26a8:	2100      	movs	r1, #0
    26aa:	1e42      	subs	r2, r0, #1
    26ac:	b212      	sxth	r2, r2
    26ae:	9100      	str	r1, [sp, #0]
    26b0:	9501      	str	r5, [sp, #4]
    26b2:	1c20      	adds	r0, r4, #0
    26b4:	1c3b      	adds	r3, r7, #0
    26b6:	3606      	adds	r6, #6
    26b8:	f000 faca 	bl	2c50 <_ZN12Adafruit_GFX8drawLineEsssst>
    26bc:	b2b6      	uxth	r6, r6
    26be:	e7ea      	b.n	2696 <_Z9testlinest+0xe2>
  for (int16_t y=0; y < tft.height(); y+=6) {
    tft.drawLine(tft.width()-1, 0, 0, y, color);
  }

  tft.fillScreen(ST7735_BLACK);
  for (int16_t x=0; x < tft.width(); x+=6) {
    26c0:	2600      	movs	r6, #0
    tft.drawLine(0, tft.height()-1, x, 0, color);
  }
  for (int16_t y=0; y < tft.height(); y+=6) {
    26c2:	1c20      	adds	r0, r4, #0
    26c4:	f001 f9b1 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    26c8:	b233      	sxth	r3, r6
    26ca:	9303      	str	r3, [sp, #12]
    26cc:	4283      	cmp	r3, r0
    26ce:	da14      	bge.n	26fa <_Z9testlinest+0x146>
    tft.drawLine(0, tft.height()-1, tft.width()-1, y, color);
    26d0:	1c20      	adds	r0, r4, #0
    26d2:	f001 f9aa 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    26d6:	1c07      	adds	r7, r0, #0
    26d8:	1c20      	adds	r0, r4, #0
    26da:	f001 f9a3 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    26de:	9903      	ldr	r1, [sp, #12]
    26e0:	1e43      	subs	r3, r0, #1
    26e2:	3f01      	subs	r7, #1
    26e4:	9100      	str	r1, [sp, #0]
    26e6:	b23a      	sxth	r2, r7
    26e8:	b21b      	sxth	r3, r3
    26ea:	9501      	str	r5, [sp, #4]
    26ec:	1c20      	adds	r0, r4, #0
    26ee:	2100      	movs	r1, #0
    26f0:	3606      	adds	r6, #6
    26f2:	f000 faad 	bl	2c50 <_ZN12Adafruit_GFX8drawLineEsssst>
    26f6:	b2b6      	uxth	r6, r6
    26f8:	e7e3      	b.n	26c2 <_Z9testlinest+0x10e>
  }

  tft.fillScreen(ST7735_BLACK);
    26fa:	1c20      	adds	r0, r4, #0
    26fc:	2100      	movs	r1, #0
    26fe:	f001 f997 	bl	3a30 <_ZN15Adafruit_ST773510fillScreenEt>
  for (int16_t x=0; x < tft.width(); x+=6) {
    2702:	2600      	movs	r6, #0
    2704:	1c20      	adds	r0, r4, #0
    2706:	f001 f98d 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    270a:	b231      	sxth	r1, r6
    270c:	9103      	str	r1, [sp, #12]
    270e:	4281      	cmp	r1, r0
    2710:	da14      	bge.n	273c <_Z9testlinest+0x188>
    tft.drawLine(tft.width()-1, tft.height()-1, x, 0, color);
    2712:	1c20      	adds	r0, r4, #0
    2714:	f001 f986 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    2718:	1c07      	adds	r7, r0, #0
    271a:	1c20      	adds	r0, r4, #0
    271c:	f001 f985 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    2720:	3f01      	subs	r7, #1
    2722:	1e42      	subs	r2, r0, #1
    2724:	2300      	movs	r3, #0
    2726:	9300      	str	r3, [sp, #0]
    2728:	b239      	sxth	r1, r7
    272a:	b212      	sxth	r2, r2
    272c:	9501      	str	r5, [sp, #4]
    272e:	1c20      	adds	r0, r4, #0
    2730:	9b03      	ldr	r3, [sp, #12]
    2732:	3606      	adds	r6, #6
    2734:	f000 fa8c 	bl	2c50 <_ZN12Adafruit_GFX8drawLineEsssst>
    2738:	b2b6      	uxth	r6, r6
    273a:	e7e3      	b.n	2704 <_Z9testlinest+0x150>
  for (int16_t y=0; y < tft.height(); y+=6) {
    tft.drawLine(0, tft.height()-1, tft.width()-1, y, color);
  }

  tft.fillScreen(ST7735_BLACK);
  for (int16_t x=0; x < tft.width(); x+=6) {
    273c:	2600      	movs	r6, #0
    tft.drawLine(tft.width()-1, tft.height()-1, x, 0, color);
  }
  for (int16_t y=0; y < tft.height(); y+=6) {
    273e:	1c20      	adds	r0, r4, #0
    2740:	f001 f973 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    2744:	b231      	sxth	r1, r6
    2746:	9103      	str	r1, [sp, #12]
    2748:	4281      	cmp	r1, r0
    274a:	da14      	bge.n	2776 <_Z9testlinest+0x1c2>
    tft.drawLine(tft.width()-1, tft.height()-1, 0, y, color);
    274c:	1c20      	adds	r0, r4, #0
    274e:	f001 f969 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    2752:	1c07      	adds	r7, r0, #0
    2754:	1c20      	adds	r0, r4, #0
    2756:	f001 f968 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    275a:	9b03      	ldr	r3, [sp, #12]
    275c:	1e42      	subs	r2, r0, #1
    275e:	3f01      	subs	r7, #1
    2760:	9300      	str	r3, [sp, #0]
    2762:	b239      	sxth	r1, r7
    2764:	b212      	sxth	r2, r2
    2766:	9501      	str	r5, [sp, #4]
    2768:	1c20      	adds	r0, r4, #0
    276a:	2300      	movs	r3, #0
    276c:	3606      	adds	r6, #6
    276e:	f000 fa6f 	bl	2c50 <_ZN12Adafruit_GFX8drawLineEsssst>
    2772:	b2b6      	uxth	r6, r6
    2774:	e7e3      	b.n	273e <_Z9testlinest+0x18a>
  }
}
    2776:	b005      	add	sp, #20
    2778:	bdf0      	pop	{r4, r5, r6, r7, pc}
    277a:	46c0      	nop			; (mov r8, r8)
    277c:	2000012c 	.word	0x2000012c

00002780 <_Z13testfastlinestt>:
  tft.setTextColor(color);
  tft.setTextWrap(true);
  tft.print(text);
}

void testfastlines(uint16_t color1, uint16_t color2) {
    2780:	b5f0      	push	{r4, r5, r6, r7, lr}
  tft.fillScreen(ST7735_BLACK);
    2782:	4c19      	ldr	r4, [pc, #100]	; (27e8 <_Z13testfastlinestt+0x68>)
  tft.setTextColor(color);
  tft.setTextWrap(true);
  tft.print(text);
}

void testfastlines(uint16_t color1, uint16_t color2) {
    2784:	b085      	sub	sp, #20
    2786:	9103      	str	r1, [sp, #12]
    2788:	1c07      	adds	r7, r0, #0
  tft.fillScreen(ST7735_BLACK);
    278a:	2100      	movs	r1, #0
    278c:	1c20      	adds	r0, r4, #0
    278e:	f001 f94f 	bl	3a30 <_ZN15Adafruit_ST773510fillScreenEt>
  for (int16_t y=0; y < tft.height(); y+=5) {
    2792:	2500      	movs	r5, #0
    2794:	1c20      	adds	r0, r4, #0
    2796:	f001 f948 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    279a:	b22e      	sxth	r6, r5
    279c:	4286      	cmp	r6, r0
    279e:	da0c      	bge.n	27ba <_Z13testfastlinestt+0x3a>
    tft.drawFastHLine(0, y, tft.width(), color1);
    27a0:	1c20      	adds	r0, r4, #0
    27a2:	f001 f93f 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    27a6:	3505      	adds	r5, #5
    27a8:	1c03      	adds	r3, r0, #0
    27aa:	9700      	str	r7, [sp, #0]
    27ac:	1c20      	adds	r0, r4, #0
    27ae:	2100      	movs	r1, #0
    27b0:	1c32      	adds	r2, r6, #0
    27b2:	f001 fc33 	bl	401c <_ZN15Adafruit_ST773513drawFastHLineEssst>
    27b6:	b2ad      	uxth	r5, r5
    27b8:	e7ec      	b.n	2794 <_Z13testfastlinestt+0x14>
  tft.print(text);
}

void testfastlines(uint16_t color1, uint16_t color2) {
  tft.fillScreen(ST7735_BLACK);
  for (int16_t y=0; y < tft.height(); y+=5) {
    27ba:	2500      	movs	r5, #0
    tft.drawFastHLine(0, y, tft.width(), color1);
  }
  for (int16_t x=0; x < tft.width(); x+=5) {
    27bc:	1c20      	adds	r0, r4, #0
    27be:	f001 f931 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    27c2:	b22e      	sxth	r6, r5
    27c4:	4286      	cmp	r6, r0
    27c6:	da0d      	bge.n	27e4 <_Z13testfastlinestt+0x64>
    tft.drawFastVLine(x, 0, tft.height(), color2);
    27c8:	1c20      	adds	r0, r4, #0
    27ca:	f001 f92e 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    27ce:	9a03      	ldr	r2, [sp, #12]
    27d0:	1c03      	adds	r3, r0, #0
    27d2:	9200      	str	r2, [sp, #0]
    27d4:	1c20      	adds	r0, r4, #0
    27d6:	1c31      	adds	r1, r6, #0
    27d8:	2200      	movs	r2, #0
    27da:	3505      	adds	r5, #5
    27dc:	f001 fbcc 	bl	3f78 <_ZN15Adafruit_ST773513drawFastVLineEssst>
    27e0:	b2ad      	uxth	r5, r5
    27e2:	e7eb      	b.n	27bc <_Z13testfastlinestt+0x3c>
  }
}
    27e4:	b005      	add	sp, #20
    27e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    27e8:	2000012c 	.word	0x2000012c

000027ec <_Z13testdrawrectst>:

void testdrawrects(uint16_t color) {
    27ec:	b5f0      	push	{r4, r5, r6, r7, lr}
  tft.fillScreen(ST7735_BLACK);
    27ee:	4d19      	ldr	r5, [pc, #100]	; (2854 <_Z13testdrawrectst+0x68>)
  for (int16_t x=0; x < tft.width(); x+=5) {
    tft.drawFastVLine(x, 0, tft.height(), color2);
  }
}

void testdrawrects(uint16_t color) {
    27f0:	b085      	sub	sp, #20
    27f2:	9003      	str	r0, [sp, #12]
  tft.fillScreen(ST7735_BLACK);
    27f4:	2100      	movs	r1, #0
    27f6:	1c28      	adds	r0, r5, #0
    27f8:	f001 f91a 	bl	3a30 <_ZN15Adafruit_ST773510fillScreenEt>
  for (int16_t x=0; x < tft.width(); x+=6) {
    27fc:	2600      	movs	r6, #0
    27fe:	1c28      	adds	r0, r5, #0
    2800:	f001 f910 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    2804:	b234      	sxth	r4, r6
    2806:	4284      	cmp	r4, r0
    2808:	da21      	bge.n	284e <_Z13testdrawrectst+0x62>
    tft.drawRect(tft.width()/2 -x/2, tft.height()/2 -x/2 , x, x, color);
    280a:	1c28      	adds	r0, r5, #0
    280c:	f001 f90a 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    2810:	0fe3      	lsrs	r3, r4, #31
    2812:	191b      	adds	r3, r3, r4
    2814:	105b      	asrs	r3, r3, #1
    2816:	425b      	negs	r3, r3
    2818:	1c07      	adds	r7, r0, #0
    281a:	b29b      	uxth	r3, r3
    281c:	1c28      	adds	r0, r5, #0
    281e:	9302      	str	r3, [sp, #8]
    2820:	f001 f903 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    2824:	0ff9      	lsrs	r1, r7, #31
    2826:	0fc2      	lsrs	r2, r0, #31
    2828:	9b02      	ldr	r3, [sp, #8]
    282a:	1812      	adds	r2, r2, r0
    282c:	19c9      	adds	r1, r1, r7
    282e:	1049      	asrs	r1, r1, #1
    2830:	1052      	asrs	r2, r2, #1
    2832:	1859      	adds	r1, r3, r1
    2834:	189a      	adds	r2, r3, r2
    2836:	9b03      	ldr	r3, [sp, #12]
    2838:	b209      	sxth	r1, r1
    283a:	9301      	str	r3, [sp, #4]
    283c:	b212      	sxth	r2, r2
    283e:	9400      	str	r4, [sp, #0]
    2840:	1c28      	adds	r0, r5, #0
    2842:	1c23      	adds	r3, r4, #0
    2844:	3606      	adds	r6, #6
    2846:	f000 fa45 	bl	2cd4 <_ZN12Adafruit_GFX8drawRectEsssst>
    284a:	b2b6      	uxth	r6, r6
    284c:	e7d7      	b.n	27fe <_Z13testdrawrectst+0x12>
  }
}
    284e:	b005      	add	sp, #20
    2850:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2852:	46c0      	nop			; (mov r8, r8)
    2854:	2000012c 	.word	0x2000012c

00002858 <_Z13testfillrectstt>:

void testfillrects(uint16_t color1, uint16_t color2) {
    2858:	b5f0      	push	{r4, r5, r6, r7, lr}
  tft.fillScreen(ST7735_BLACK);
    285a:	4c27      	ldr	r4, [pc, #156]	; (28f8 <_Z13testfillrectstt+0xa0>)
  for (int16_t x=0; x < tft.width(); x+=6) {
    tft.drawRect(tft.width()/2 -x/2, tft.height()/2 -x/2 , x, x, color);
  }
}

void testfillrects(uint16_t color1, uint16_t color2) {
    285c:	b087      	sub	sp, #28
    285e:	9004      	str	r0, [sp, #16]
    2860:	9105      	str	r1, [sp, #20]
  tft.fillScreen(ST7735_BLACK);
    2862:	1c20      	adds	r0, r4, #0
    2864:	2100      	movs	r1, #0
    2866:	f001 f8e3 	bl	3a30 <_ZN15Adafruit_ST773510fillScreenEt>
  for (int16_t x=tft.width()-1; x > 6; x-=6) {
    286a:	1c20      	adds	r0, r4, #0
    286c:	f001 f8da 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    2870:	3801      	subs	r0, #1
    2872:	b280      	uxth	r0, r0
    2874:	9003      	str	r0, [sp, #12]
    2876:	9b03      	ldr	r3, [sp, #12]
    2878:	b21c      	sxth	r4, r3
    287a:	2c06      	cmp	r4, #6
    287c:	dd3a      	ble.n	28f4 <_Z13testfillrectstt+0x9c>
    tft.fillRect(tft.width()/2 -x/2, tft.height()/2 -x/2 , x, x, color1);
    287e:	4d1e      	ldr	r5, [pc, #120]	; (28f8 <_Z13testfillrectstt+0xa0>)
    2880:	0fe6      	lsrs	r6, r4, #31
    2882:	1c28      	adds	r0, r5, #0
    2884:	f001 f8ce 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    2888:	1c07      	adds	r7, r0, #0
    288a:	1c28      	adds	r0, r5, #0
    288c:	f001 f8cd 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    2890:	1936      	adds	r6, r6, r4
    2892:	0ff9      	lsrs	r1, r7, #31
    2894:	0fc2      	lsrs	r2, r0, #31
    2896:	1076      	asrs	r6, r6, #1
    2898:	19c9      	adds	r1, r1, r7
    289a:	1812      	adds	r2, r2, r0
    289c:	4276      	negs	r6, r6
    289e:	b2b6      	uxth	r6, r6
    28a0:	9b04      	ldr	r3, [sp, #16]
    28a2:	1049      	asrs	r1, r1, #1
    28a4:	1052      	asrs	r2, r2, #1
    28a6:	1871      	adds	r1, r6, r1
    28a8:	18b2      	adds	r2, r6, r2
    28aa:	b209      	sxth	r1, r1
    28ac:	b212      	sxth	r2, r2
    28ae:	9301      	str	r3, [sp, #4]
    28b0:	1c28      	adds	r0, r5, #0
    28b2:	1c23      	adds	r3, r4, #0
    28b4:	9400      	str	r4, [sp, #0]
    28b6:	f001 fc05 	bl	40c4 <_ZN15Adafruit_ST77358fillRectEsssst>
    tft.drawRect(tft.width()/2 -x/2, tft.height()/2 -x/2 , x, x, color2);
    28ba:	1c28      	adds	r0, r5, #0
    28bc:	f001 f8b2 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    28c0:	1c07      	adds	r7, r0, #0
    28c2:	1c28      	adds	r0, r5, #0
    28c4:	f001 f8b1 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    28c8:	0ff9      	lsrs	r1, r7, #31
    28ca:	0fc2      	lsrs	r2, r0, #31
    28cc:	1810      	adds	r0, r2, r0
    28ce:	19c9      	adds	r1, r1, r7
    28d0:	9b05      	ldr	r3, [sp, #20]
    28d2:	1040      	asrs	r0, r0, #1
    28d4:	1049      	asrs	r1, r1, #1
    28d6:	1871      	adds	r1, r6, r1
    28d8:	1836      	adds	r6, r6, r0
    28da:	9301      	str	r3, [sp, #4]
    28dc:	b209      	sxth	r1, r1
    28de:	1c23      	adds	r3, r4, #0
    28e0:	b232      	sxth	r2, r6
    28e2:	9400      	str	r4, [sp, #0]
    28e4:	1c28      	adds	r0, r5, #0
    28e6:	f000 f9f5 	bl	2cd4 <_ZN12Adafruit_GFX8drawRectEsssst>
    28ea:	9b03      	ldr	r3, [sp, #12]
    28ec:	3b06      	subs	r3, #6
    28ee:	b29b      	uxth	r3, r3
    28f0:	9303      	str	r3, [sp, #12]
    28f2:	e7c0      	b.n	2876 <_Z13testfillrectstt+0x1e>
  }
}
    28f4:	b007      	add	sp, #28
    28f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    28f8:	2000012c 	.word	0x2000012c

000028fc <setup>:
//Adafruit_ST7735 tft = Adafruit_ST7735(TFT_CS, TFT_DC, TFT_MOSI, TFT_SCLK, TFT_RST);


float p = 3.1415926;

void setup(void) {
    28fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  Serial.begin(9600);
    28fe:	4e4a      	ldr	r6, [pc, #296]	; (2a28 <setup+0x12c>)
    2900:	2196      	movs	r1, #150	; 0x96
    2902:	1c30      	adds	r0, r6, #0
    2904:	0189      	lsls	r1, r1, #6
    2906:	f002 fb1b 	bl	4f40 <_ZN4Uart5beginEm>
  Serial.print("Hello! ST7735 TFT Test");
    290a:	1c30      	adds	r0, r6, #0
    290c:	4947      	ldr	r1, [pc, #284]	; (2a2c <setup+0x130>)
    290e:	f002 f81d 	bl	494c <_ZN5Print5printEPKc>

  // Use this initializer if you're using a 1.8" TFT
  tft.initR(INITR_BLACKTAB);   // initialize a ST7735S chip, black tab
    2912:	4d47      	ldr	r5, [pc, #284]	; (2a30 <setup+0x134>)
    2914:	2102      	movs	r1, #2
    2916:	1c28      	adds	r0, r5, #0
    2918:	f001 fa4e 	bl	3db8 <_ZN15Adafruit_ST77355initREh>
  //tft.initR(INITR_144GREENTAB);   // initialize a ST7735S chip, black tab

  // Use this initializer (uncomment) if you're using a 0.96" 180x60 TFT
  //tft.initR(INITR_MINI160x80);   // initialize a ST7735S chip, mini display

  Serial.println("Initialized");
    291c:	1c30      	adds	r0, r6, #0
    291e:	4945      	ldr	r1, [pc, #276]	; (2a34 <setup+0x138>)
    2920:	f002 f826 	bl	4970 <_ZN5Print7printlnEPKc>

  uint16_t time = millis();
    2924:	f001 fd80 	bl	4428 <millis>
  tft.fillScreen(ST7735_BLACK);
    2928:	2100      	movs	r1, #0
  // Use this initializer (uncomment) if you're using a 0.96" 180x60 TFT
  //tft.initR(INITR_MINI160x80);   // initialize a ST7735S chip, mini display

  Serial.println("Initialized");

  uint16_t time = millis();
    292a:	b284      	uxth	r4, r0
  tft.fillScreen(ST7735_BLACK);
    292c:	1c28      	adds	r0, r5, #0
    292e:	f001 f87f 	bl	3a30 <_ZN15Adafruit_ST773510fillScreenEt>
  time = millis() - time;
    2932:	f001 fd79 	bl	4428 <millis>
    2936:	1b04      	subs	r4, r0, r4

  Serial.println(time, DEC);
    2938:	b2a1      	uxth	r1, r4
  delay(500);
    293a:	24fa      	movs	r4, #250	; 0xfa
    293c:	0064      	lsls	r4, r4, #1

  uint16_t time = millis();
  tft.fillScreen(ST7735_BLACK);
  time = millis() - time;

  Serial.println(time, DEC);
    293e:	220a      	movs	r2, #10
    2940:	1c30      	adds	r0, r6, #0
    2942:	f002 f868 	bl	4a16 <_ZN5Print7printlnEii>
  delay(500);
    2946:	1c20      	adds	r0, r4, #0
    2948:	f001 fd74 	bl	4434 <delay>

  // large block of text
  tft.fillScreen(ST7735_BLACK);
    294c:	1c28      	adds	r0, r5, #0
    294e:	2100      	movs	r1, #0
    2950:	f001 f86e 	bl	3a30 <_ZN15Adafruit_ST773510fillScreenEt>
  testdrawtext("Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur adipiscing ante sed nibh tincidunt feugiat. Maecenas enim massa, fringilla sed malesuada et, malesuada sit amet turpis. Sed porttitor neque ut ante pretium vitae malesuada nunc bibendum. Nullam aliquet ultrices massa eu hendrerit. Ut sed nisi lorem. In vestibulum purus a tortor imperdiet posuere. ", ST7735_WHITE);
    2954:	4938      	ldr	r1, [pc, #224]	; (2a38 <setup+0x13c>)
    2956:	4839      	ldr	r0, [pc, #228]	; (2a3c <setup+0x140>)
    2958:	f7ff fbdc 	bl	2114 <_Z12testdrawtextPct>
  delay(1000);
    295c:	20fa      	movs	r0, #250	; 0xfa
    295e:	0080      	lsls	r0, r0, #2
    2960:	f001 fd68 	bl	4434 <delay>

  // tft print function!
  tftPrintTest();
    2964:	f7ff fcc0 	bl	22e8 <_Z12tftPrintTestv>
  delay(4000);
    2968:	20fa      	movs	r0, #250	; 0xfa
    296a:	0100      	lsls	r0, r0, #4
    296c:	f001 fd62 	bl	4434 <delay>

  // a single pixel
  tft.drawPixel(tft.width()/2, tft.height()/2, ST7735_GREEN);
    2970:	1c28      	adds	r0, r5, #0
    2972:	f001 f857 	bl	3a24 <_ZNK12Adafruit_GFX5widthEv>
    2976:	1c07      	adds	r7, r0, #0
    2978:	1c28      	adds	r0, r5, #0
    297a:	f001 f856 	bl	3a2a <_ZNK12Adafruit_GFX6heightEv>
    297e:	0ff9      	lsrs	r1, r7, #31
    2980:	0fc2      	lsrs	r2, r0, #31
    2982:	19c9      	adds	r1, r1, r7
    2984:	1812      	adds	r2, r2, r0
    2986:	1049      	asrs	r1, r1, #1
    2988:	1052      	asrs	r2, r2, #1
    298a:	23fc      	movs	r3, #252	; 0xfc
    298c:	b212      	sxth	r2, r2
    298e:	00db      	lsls	r3, r3, #3
    2990:	b209      	sxth	r1, r1
    2992:	1c28      	adds	r0, r5, #0
  delay(500);

  // line draw test
  testlines(ST7735_YELLOW);
    2994:	4f2a      	ldr	r7, [pc, #168]	; (2a40 <setup+0x144>)
  // tft print function!
  tftPrintTest();
  delay(4000);

  // a single pixel
  tft.drawPixel(tft.width()/2, tft.height()/2, ST7735_GREEN);
    2996:	f001 faab 	bl	3ef0 <_ZN15Adafruit_ST77359drawPixelEsst>
  delay(500);
    299a:	1c20      	adds	r0, r4, #0
    299c:	f001 fd4a 	bl	4434 <delay>

  // line draw test
  testlines(ST7735_YELLOW);
    29a0:	1c38      	adds	r0, r7, #0
    29a2:	f7ff fe07 	bl	25b4 <_Z9testlinest>
  delay(500);
    29a6:	1c20      	adds	r0, r4, #0
    29a8:	f001 fd44 	bl	4434 <delay>

  // optimized lines
  testfastlines(ST7735_RED, ST7735_BLUE);
    29ac:	20f8      	movs	r0, #248	; 0xf8
    29ae:	211f      	movs	r1, #31
    29b0:	0200      	lsls	r0, r0, #8
    29b2:	f7ff fee5 	bl	2780 <_Z13testfastlinestt>
  delay(500);
    29b6:	1c20      	adds	r0, r4, #0
    29b8:	f001 fd3c 	bl	4434 <delay>

  testdrawrects(ST7735_GREEN);
    29bc:	20fc      	movs	r0, #252	; 0xfc
    29be:	00c0      	lsls	r0, r0, #3
    29c0:	f7ff ff14 	bl	27ec <_Z13testdrawrectst>
  delay(500);
    29c4:	1c20      	adds	r0, r4, #0
    29c6:	f001 fd35 	bl	4434 <delay>

  testfillrects(ST7735_YELLOW, ST7735_MAGENTA);
    29ca:	1c38      	adds	r0, r7, #0
    29cc:	491d      	ldr	r1, [pc, #116]	; (2a44 <setup+0x148>)
    29ce:	f7ff ff43 	bl	2858 <_Z13testfillrectstt>
  delay(500);
    29d2:	1c20      	adds	r0, r4, #0
    29d4:	f001 fd2e 	bl	4434 <delay>

  tft.fillScreen(ST7735_BLACK);
    29d8:	1c28      	adds	r0, r5, #0
    29da:	2100      	movs	r1, #0
    29dc:	f001 f828 	bl	3a30 <_ZN15Adafruit_ST773510fillScreenEt>
  testfillcircles(10, ST7735_BLUE);
    29e0:	200a      	movs	r0, #10
    29e2:	211f      	movs	r1, #31
    29e4:	f7ff fbae 	bl	2144 <_Z15testfillcirclesht>
  testdrawcircles(10, ST7735_WHITE);
    29e8:	4913      	ldr	r1, [pc, #76]	; (2a38 <setup+0x13c>)
    29ea:	200a      	movs	r0, #10
    29ec:	f7ff fbd4 	bl	2198 <_Z15testdrawcirclesht>
  delay(500);
    29f0:	1c20      	adds	r0, r4, #0
    29f2:	f001 fd1f 	bl	4434 <delay>

  testroundrects();
    29f6:	f7ff fc39 	bl	226c <_Z14testroundrectsv>
  delay(500);
    29fa:	1c20      	adds	r0, r4, #0
    29fc:	f001 fd1a 	bl	4434 <delay>

  testtriangles();
    2a00:	f7ff fc00 	bl	2204 <_Z13testtrianglesv>
  delay(500);
    2a04:	1c20      	adds	r0, r4, #0
    2a06:	f001 fd15 	bl	4434 <delay>

  mediabuttons();
    2a0a:	f7ff fd39 	bl	2480 <_Z12mediabuttonsv>
  delay(500);
    2a0e:	1c20      	adds	r0, r4, #0
    2a10:	f001 fd10 	bl	4434 <delay>

  Serial.println("done");
    2a14:	1c30      	adds	r0, r6, #0
    2a16:	490c      	ldr	r1, [pc, #48]	; (2a48 <setup+0x14c>)
    2a18:	f001 ffaa 	bl	4970 <_ZN5Print7printlnEPKc>
  delay(1000);
    2a1c:	20fa      	movs	r0, #250	; 0xfa
    2a1e:	0080      	lsls	r0, r0, #2
    2a20:	f001 fd08 	bl	4434 <delay>
}
    2a24:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2a26:	46c0      	nop			; (mov r8, r8)
    2a28:	20000178 	.word	0x20000178
    2a2c:	000084cf 	.word	0x000084cf
    2a30:	2000012c 	.word	0x2000012c
    2a34:	000084e6 	.word	0x000084e6
    2a38:	0000ffff 	.word	0x0000ffff
    2a3c:	000084f2 	.word	0x000084f2
    2a40:	0000ffe0 	.word	0x0000ffe0
    2a44:	0000f81f 	.word	0x0000f81f
    2a48:	00008660 	.word	0x00008660

00002a4c <_ZN5Print17availableForWriteEv>:
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
    2a4c:	2000      	movs	r0, #0
    2a4e:	4770      	bx	lr

00002a50 <_ZN5Print5flushEv>:
    size_t println(unsigned long, int = DEC);
    size_t println(double, int = 2);
    size_t println(const Printable&);
    size_t println(void);

    virtual void flush() { /* Empty implementation for backward compatibility */ }
    2a50:	4770      	bx	lr
	...

00002a54 <_ZN12Adafruit_GFX9writeLineEsssst>:
    gfxFont   = NULL;
}

// Bresenham's algorithm - thx wikpedia
void Adafruit_GFX::writeLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,
        uint16_t color) {
    2a54:	b5f0      	push	{r4, r5, r6, r7, lr}
    2a56:	b087      	sub	sp, #28
    2a58:	1c1e      	adds	r6, r3, #0
    2a5a:	ab0c      	add	r3, sp, #48	; 0x30
    2a5c:	1c07      	adds	r7, r0, #0
    2a5e:	1c15      	adds	r5, r2, #0
    2a60:	2000      	movs	r0, #0
    2a62:	5e1b      	ldrsh	r3, [r3, r0]
    2a64:	aa0d      	add	r2, sp, #52	; 0x34
    2a66:	8812      	ldrh	r2, [r2, #0]
    2a68:	1c0c      	adds	r4, r1, #0
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    2a6a:	1b59      	subs	r1, r3, r5
    gfxFont   = NULL;
}

// Bresenham's algorithm - thx wikpedia
void Adafruit_GFX::writeLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,
        uint16_t color) {
    2a6c:	9204      	str	r2, [sp, #16]
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    2a6e:	17ca      	asrs	r2, r1, #31
    2a70:	1889      	adds	r1, r1, r2
    2a72:	4051      	eors	r1, r2
    2a74:	1b32      	subs	r2, r6, r4
    2a76:	17d0      	asrs	r0, r2, #31
    2a78:	1812      	adds	r2, r2, r0
    2a7a:	4042      	eors	r2, r0
    2a7c:	4291      	cmp	r1, r2
    2a7e:	dd08      	ble.n	2a92 <_ZN12Adafruit_GFX9writeLineEsssst+0x3e>
    2a80:	1c32      	adds	r2, r6, #0
    2a82:	2101      	movs	r1, #1
    if (steep) {
        _swap_int16_t(x0, y0);
        _swap_int16_t(x1, y1);
    2a84:	1c1e      	adds	r6, r3, #0
    2a86:	1c13      	adds	r3, r2, #0
    2a88:	1c22      	adds	r2, r4, #0
    2a8a:	9101      	str	r1, [sp, #4]
// Bresenham's algorithm - thx wikpedia
void Adafruit_GFX::writeLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,
        uint16_t color) {
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    if (steep) {
        _swap_int16_t(x0, y0);
    2a8c:	1c2c      	adds	r4, r5, #0
    2a8e:	1c15      	adds	r5, r2, #0
    2a90:	e001      	b.n	2a96 <_ZN12Adafruit_GFX9writeLineEsssst+0x42>
    2a92:	2200      	movs	r2, #0
    2a94:	9201      	str	r2, [sp, #4]
        _swap_int16_t(x1, y1);
    }

    if (x0 > x1) {
    2a96:	42b4      	cmp	r4, r6
    2a98:	dd05      	ble.n	2aa6 <_ZN12Adafruit_GFX9writeLineEsssst+0x52>
    2a9a:	1c2a      	adds	r2, r5, #0
        _swap_int16_t(x0, x1);
        _swap_int16_t(y0, y1);
    2a9c:	1c1d      	adds	r5, r3, #0
    2a9e:	1c13      	adds	r3, r2, #0
    2aa0:	1c22      	adds	r2, r4, #0
    2aa2:	1c34      	adds	r4, r6, #0
    2aa4:	1c16      	adds	r6, r2, #0
    }

    int16_t dx, dy;
    dx = x1 - x0;
    2aa6:	1b32      	subs	r2, r6, r4
    2aa8:	b292      	uxth	r2, r2
    2aaa:	9202      	str	r2, [sp, #8]
    dy = abs(y1 - y0);
    2aac:	1b5a      	subs	r2, r3, r5
    2aae:	17d1      	asrs	r1, r2, #31
    2ab0:	1850      	adds	r0, r2, r1
    2ab2:	4048      	eors	r0, r1
    2ab4:	9005      	str	r0, [sp, #20]

    int16_t err = dx / 2;
    2ab6:	9802      	ldr	r0, [sp, #8]
    2ab8:	b202      	sxth	r2, r0
    2aba:	0fd1      	lsrs	r1, r2, #31
    2abc:	188a      	adds	r2, r1, r2
    2abe:	1052      	asrs	r2, r2, #1
    2ac0:	b292      	uxth	r2, r2
    2ac2:	9200      	str	r2, [sp, #0]
    int16_t ystep;

    if (y0 < y1) {
    2ac4:	429d      	cmp	r5, r3
    2ac6:	da02      	bge.n	2ace <_ZN12Adafruit_GFX9writeLineEsssst+0x7a>
        ystep = 1;
    2ac8:	2101      	movs	r1, #1
    2aca:	9103      	str	r1, [sp, #12]
    2acc:	e01f      	b.n	2b0e <_ZN12Adafruit_GFX9writeLineEsssst+0xba>
    } else {
        ystep = -1;
    2ace:	4a15      	ldr	r2, [pc, #84]	; (2b24 <_ZN12Adafruit_GFX9writeLineEsssst+0xd0>)
    2ad0:	9203      	str	r2, [sp, #12]
    2ad2:	e01c      	b.n	2b0e <_ZN12Adafruit_GFX9writeLineEsssst+0xba>
    }

    for (; x0<=x1; x0++) {
        if (steep) {
    2ad4:	9801      	ldr	r0, [sp, #4]
    2ad6:	683b      	ldr	r3, [r7, #0]
    2ad8:	2800      	cmp	r0, #0
    2ada:	d01b      	beq.n	2b14 <_ZN12Adafruit_GFX9writeLineEsssst+0xc0>
            writePixel(y0, x0, color);
    2adc:	6999      	ldr	r1, [r3, #24]
    2ade:	1c38      	adds	r0, r7, #0
    2ae0:	468c      	mov	ip, r1
    2ae2:	1c22      	adds	r2, r4, #0
    2ae4:	1c29      	adds	r1, r5, #0
        } else {
            writePixel(x0, y0, color);
    2ae6:	9b04      	ldr	r3, [sp, #16]
    2ae8:	47e0      	blx	ip
        }
        err -= dy;
    2aea:	9800      	ldr	r0, [sp, #0]
    2aec:	9905      	ldr	r1, [sp, #20]
    2aee:	1a43      	subs	r3, r0, r1
    2af0:	b29b      	uxth	r3, r3
    2af2:	b29a      	uxth	r2, r3
    2af4:	9200      	str	r2, [sp, #0]
        if (err < 0) {
    2af6:	b212      	sxth	r2, r2
    2af8:	2a00      	cmp	r2, #0
    2afa:	da06      	bge.n	2b0a <_ZN12Adafruit_GFX9writeLineEsssst+0xb6>
            y0 += ystep;
            err += dx;
    2afc:	9902      	ldr	r1, [sp, #8]
        } else {
            writePixel(x0, y0, color);
        }
        err -= dy;
        if (err < 0) {
            y0 += ystep;
    2afe:	9803      	ldr	r0, [sp, #12]
            err += dx;
    2b00:	185b      	adds	r3, r3, r1
        } else {
            writePixel(x0, y0, color);
        }
        err -= dy;
        if (err < 0) {
            y0 += ystep;
    2b02:	182d      	adds	r5, r5, r0
            err += dx;
    2b04:	b29b      	uxth	r3, r3
        } else {
            writePixel(x0, y0, color);
        }
        err -= dy;
        if (err < 0) {
            y0 += ystep;
    2b06:	b22d      	sxth	r5, r5
            err += dx;
    2b08:	9300      	str	r3, [sp, #0]
    2b0a:	3401      	adds	r4, #1
    2b0c:	b224      	sxth	r4, r4
        ystep = 1;
    } else {
        ystep = -1;
    }

    for (; x0<=x1; x0++) {
    2b0e:	42b4      	cmp	r4, r6
    2b10:	dde0      	ble.n	2ad4 <_ZN12Adafruit_GFX9writeLineEsssst+0x80>
    2b12:	e005      	b.n	2b20 <_ZN12Adafruit_GFX9writeLineEsssst+0xcc>
        if (steep) {
            writePixel(y0, x0, color);
        } else {
            writePixel(x0, y0, color);
    2b14:	699a      	ldr	r2, [r3, #24]
    2b16:	1c38      	adds	r0, r7, #0
    2b18:	4694      	mov	ip, r2
    2b1a:	1c21      	adds	r1, r4, #0
    2b1c:	1c2a      	adds	r2, r5, #0
    2b1e:	e7e2      	b.n	2ae6 <_ZN12Adafruit_GFX9writeLineEsssst+0x92>
        if (err < 0) {
            y0 += ystep;
            err += dx;
        }
    }
}
    2b20:	b007      	add	sp, #28
    2b22:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2b24:	0000ffff 	.word	0x0000ffff

00002b28 <_ZN12Adafruit_GFX10startWriteEv>:

void Adafruit_GFX::startWrite(){
    // Overwrite in subclasses if desired!
}
    2b28:	4770      	bx	lr

00002b2a <_ZN12Adafruit_GFX10writePixelEsst>:

void Adafruit_GFX::writePixel(int16_t x, int16_t y, uint16_t color){
    2b2a:	b510      	push	{r4, lr}
    // Overwrite in subclasses if startWrite is defined!
    drawPixel(x, y, color);
    2b2c:	6804      	ldr	r4, [r0, #0]
    2b2e:	6924      	ldr	r4, [r4, #16]
    2b30:	47a0      	blx	r4
}
    2b32:	bd10      	pop	{r4, pc}

00002b34 <_ZN12Adafruit_GFX14writeFastVLineEssst>:

// (x,y) is topmost point; if unsure, calling function
// should sort endpoints or call writeLine() instead
void Adafruit_GFX::writeFastVLine(int16_t x, int16_t y,
        int16_t h, uint16_t color) {
    2b34:	b537      	push	{r0, r1, r2, r4, r5, lr}
    2b36:	ac06      	add	r4, sp, #24
    2b38:	8825      	ldrh	r5, [r4, #0]
    // Overwrite in subclasses if startWrite is defined!
    // Can be just writeLine(x, y, x, y+h-1, color);
    // or writeFillRect(x, y, 1, h, color);
    drawFastVLine(x, y, h, color);
    2b3a:	6804      	ldr	r4, [r0, #0]
    2b3c:	9500      	str	r5, [sp, #0]
    2b3e:	6ba4      	ldr	r4, [r4, #56]	; 0x38
    2b40:	47a0      	blx	r4
}
    2b42:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

00002b44 <_ZN12Adafruit_GFX14writeFastHLineEssst>:

// (x,y) is leftmost point; if unsure, calling function
// should sort endpoints or call writeLine() instead
void Adafruit_GFX::writeFastHLine(int16_t x, int16_t y,
        int16_t w, uint16_t color) {
    2b44:	b537      	push	{r0, r1, r2, r4, r5, lr}
    2b46:	ac06      	add	r4, sp, #24
    2b48:	8825      	ldrh	r5, [r4, #0]
    // Overwrite in subclasses if startWrite is defined!
    // Example: writeLine(x, y, x+w-1, y, color);
    // or writeFillRect(x, y, w, 1, color);
    drawFastHLine(x, y, w, color);
    2b4a:	6804      	ldr	r4, [r0, #0]
    2b4c:	9500      	str	r5, [sp, #0]
    2b4e:	6be4      	ldr	r4, [r4, #60]	; 0x3c
    2b50:	47a0      	blx	r4
}
    2b52:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

00002b54 <_ZN12Adafruit_GFX13writeFillRectEsssst>:

void Adafruit_GFX::writeFillRect(int16_t x, int16_t y, int16_t w, int16_t h,
        uint16_t color) {
    2b54:	b573      	push	{r0, r1, r4, r5, r6, lr}
    2b56:	ac06      	add	r4, sp, #24
    2b58:	2500      	movs	r5, #0
    2b5a:	5f66      	ldrsh	r6, [r4, r5]
    2b5c:	ac07      	add	r4, sp, #28
    2b5e:	8825      	ldrh	r5, [r4, #0]
    // Overwrite in subclasses if desired!
    fillRect(x,y,w,h,color);
    2b60:	6804      	ldr	r4, [r0, #0]
    2b62:	9600      	str	r6, [sp, #0]
    2b64:	9501      	str	r5, [sp, #4]
    2b66:	6c24      	ldr	r4, [r4, #64]	; 0x40
    2b68:	47a0      	blx	r4
}
    2b6a:	bd73      	pop	{r0, r1, r4, r5, r6, pc}

00002b6c <_ZN12Adafruit_GFX8endWriteEv>:

void Adafruit_GFX::endWrite(){
    // Overwrite in subclasses if startWrite is defined!
}
    2b6c:	4770      	bx	lr

00002b6e <_ZN12Adafruit_GFX13drawFastVLineEssst>:

// (x,y) is topmost point; if unsure, calling function
// should sort endpoints or call drawLine() instead
void Adafruit_GFX::drawFastVLine(int16_t x, int16_t y,
        int16_t h, uint16_t color) {
    2b6e:	b5f0      	push	{r4, r5, r6, r7, lr}
    2b70:	b085      	sub	sp, #20
    2b72:	1c1f      	adds	r7, r3, #0
    2b74:	ab0a      	add	r3, sp, #40	; 0x28
    2b76:	881b      	ldrh	r3, [r3, #0]
    2b78:	1c16      	adds	r6, r2, #0
    2b7a:	9303      	str	r3, [sp, #12]
    // Update in subclasses if desired!
    startWrite();
    2b7c:	6803      	ldr	r3, [r0, #0]
    writeLine(x, y, x, y+h-1, color);
    2b7e:	3f01      	subs	r7, #1
// (x,y) is topmost point; if unsure, calling function
// should sort endpoints or call drawLine() instead
void Adafruit_GFX::drawFastVLine(int16_t x, int16_t y,
        int16_t h, uint16_t color) {
    // Update in subclasses if desired!
    startWrite();
    2b80:	695b      	ldr	r3, [r3, #20]
}

// (x,y) is topmost point; if unsure, calling function
// should sort endpoints or call drawLine() instead
void Adafruit_GFX::drawFastVLine(int16_t x, int16_t y,
        int16_t h, uint16_t color) {
    2b82:	1c04      	adds	r4, r0, #0
    2b84:	1c0d      	adds	r5, r1, #0
    // Update in subclasses if desired!
    startWrite();
    writeLine(x, y, x, y+h-1, color);
    2b86:	19bf      	adds	r7, r7, r6
// (x,y) is topmost point; if unsure, calling function
// should sort endpoints or call drawLine() instead
void Adafruit_GFX::drawFastVLine(int16_t x, int16_t y,
        int16_t h, uint16_t color) {
    // Update in subclasses if desired!
    startWrite();
    2b88:	4798      	blx	r3
    writeLine(x, y, x, y+h-1, color);
    2b8a:	9a03      	ldr	r2, [sp, #12]
    2b8c:	6823      	ldr	r3, [r4, #0]
    2b8e:	b23f      	sxth	r7, r7
    2b90:	9201      	str	r2, [sp, #4]
    2b92:	9700      	str	r7, [sp, #0]
    2b94:	6a9f      	ldr	r7, [r3, #40]	; 0x28
    2b96:	1c20      	adds	r0, r4, #0
    2b98:	1c29      	adds	r1, r5, #0
    2b9a:	1c32      	adds	r2, r6, #0
    2b9c:	1c2b      	adds	r3, r5, #0
    2b9e:	47b8      	blx	r7
    endWrite();
    2ba0:	6823      	ldr	r3, [r4, #0]
    2ba2:	1c20      	adds	r0, r4, #0
    2ba4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2ba6:	4798      	blx	r3
}
    2ba8:	b005      	add	sp, #20
    2baa:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002bac <_ZN12Adafruit_GFX13drawFastHLineEssst>:

// (x,y) is leftmost point; if unsure, calling function
// should sort endpoints or call drawLine() instead
void Adafruit_GFX::drawFastHLine(int16_t x, int16_t y,
        int16_t w, uint16_t color) {
    2bac:	b5f0      	push	{r4, r5, r6, r7, lr}
    2bae:	b085      	sub	sp, #20
    2bb0:	1c1f      	adds	r7, r3, #0
    2bb2:	ab0a      	add	r3, sp, #40	; 0x28
    2bb4:	881b      	ldrh	r3, [r3, #0]
    2bb6:	1c04      	adds	r4, r0, #0
    2bb8:	9303      	str	r3, [sp, #12]
    // Update in subclasses if desired!
    startWrite();
    2bba:	6803      	ldr	r3, [r0, #0]
}

// (x,y) is leftmost point; if unsure, calling function
// should sort endpoints or call drawLine() instead
void Adafruit_GFX::drawFastHLine(int16_t x, int16_t y,
        int16_t w, uint16_t color) {
    2bbc:	1c0e      	adds	r6, r1, #0
    // Update in subclasses if desired!
    startWrite();
    2bbe:	695b      	ldr	r3, [r3, #20]
}

// (x,y) is leftmost point; if unsure, calling function
// should sort endpoints or call drawLine() instead
void Adafruit_GFX::drawFastHLine(int16_t x, int16_t y,
        int16_t w, uint16_t color) {
    2bc0:	1c15      	adds	r5, r2, #0
    // Update in subclasses if desired!
    startWrite();
    2bc2:	4798      	blx	r3
    writeLine(x, y, x+w-1, y, color);
    2bc4:	9903      	ldr	r1, [sp, #12]
    2bc6:	6822      	ldr	r2, [r4, #0]
    2bc8:	1e7b      	subs	r3, r7, #1
    2bca:	9101      	str	r1, [sp, #4]
    2bcc:	9500      	str	r5, [sp, #0]
    2bce:	199b      	adds	r3, r3, r6
    2bd0:	6a97      	ldr	r7, [r2, #40]	; 0x28
    2bd2:	1c20      	adds	r0, r4, #0
    2bd4:	1c31      	adds	r1, r6, #0
    2bd6:	1c2a      	adds	r2, r5, #0
    2bd8:	b21b      	sxth	r3, r3
    2bda:	47b8      	blx	r7
    endWrite();
    2bdc:	6823      	ldr	r3, [r4, #0]
    2bde:	1c20      	adds	r0, r4, #0
    2be0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2be2:	4798      	blx	r3
}
    2be4:	b005      	add	sp, #20
    2be6:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002be8 <_ZN12Adafruit_GFX8fillRectEsssst>:

void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
        uint16_t color) {
    2be8:	b5f0      	push	{r4, r5, r6, r7, lr}
    2bea:	b087      	sub	sp, #28
    2bec:	9303      	str	r3, [sp, #12]
    2bee:	ab0c      	add	r3, sp, #48	; 0x30
    2bf0:	1c0e      	adds	r6, r1, #0
    2bf2:	1c17      	adds	r7, r2, #0
    2bf4:	2200      	movs	r2, #0
    2bf6:	5e99      	ldrsh	r1, [r3, r2]
    2bf8:	ab0d      	add	r3, sp, #52	; 0x34
    2bfa:	881b      	ldrh	r3, [r3, #0]
    2bfc:	9104      	str	r1, [sp, #16]
    2bfe:	9305      	str	r3, [sp, #20]
    // Update in subclasses if desired!
    startWrite();
    2c00:	6803      	ldr	r3, [r0, #0]
    writeLine(x, y, x+w-1, y, color);
    endWrite();
}

void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
        uint16_t color) {
    2c02:	1c04      	adds	r4, r0, #0
    // Update in subclasses if desired!
    startWrite();
    2c04:	695b      	ldr	r3, [r3, #20]
    2c06:	4798      	blx	r3
    for (int16_t i=x; i<x+w; i++) {
    2c08:	1c35      	adds	r5, r6, #0
    2c0a:	9b03      	ldr	r3, [sp, #12]
    2c0c:	18f2      	adds	r2, r6, r3
    2c0e:	6823      	ldr	r3, [r4, #0]
    2c10:	4295      	cmp	r5, r2
    2c12:	da0b      	bge.n	2c2c <_ZN12Adafruit_GFX8fillRectEsssst+0x44>
        writeFastVLine(i, y, h, color);
    2c14:	9905      	ldr	r1, [sp, #20]
    2c16:	1c20      	adds	r0, r4, #0
    2c18:	9100      	str	r1, [sp, #0]
    2c1a:	6a1a      	ldr	r2, [r3, #32]
    2c1c:	1c29      	adds	r1, r5, #0
    2c1e:	4694      	mov	ip, r2
    2c20:	9b04      	ldr	r3, [sp, #16]
    2c22:	1c3a      	adds	r2, r7, #0
    2c24:	3501      	adds	r5, #1
    2c26:	47e0      	blx	ip
    2c28:	b22d      	sxth	r5, r5
    2c2a:	e7ee      	b.n	2c0a <_ZN12Adafruit_GFX8fillRectEsssst+0x22>
    }
    endWrite();
    2c2c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2c2e:	1c20      	adds	r0, r4, #0
    2c30:	4798      	blx	r3
}
    2c32:	b007      	add	sp, #28
    2c34:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002c36 <_ZN12Adafruit_GFX10fillScreenEt>:

void Adafruit_GFX::fillScreen(uint16_t color) {
    2c36:	b537      	push	{r0, r1, r2, r4, r5, lr}
    // Update in subclasses if desired!
    fillRect(0, 0, _width, _height, color);
    2c38:	240c      	movs	r4, #12
    2c3a:	5f03      	ldrsh	r3, [r0, r4]
    2c3c:	250e      	movs	r5, #14
    2c3e:	5f44      	ldrsh	r4, [r0, r5]
    2c40:	6802      	ldr	r2, [r0, #0]
    2c42:	9101      	str	r1, [sp, #4]
    2c44:	9400      	str	r4, [sp, #0]
    2c46:	2100      	movs	r1, #0
    2c48:	6c14      	ldr	r4, [r2, #64]	; 0x40
    2c4a:	1c0a      	adds	r2, r1, #0
    2c4c:	47a0      	blx	r4
}
    2c4e:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

00002c50 <_ZN12Adafruit_GFX8drawLineEsssst>:

void Adafruit_GFX::drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,
        uint16_t color) {
    2c50:	b5f0      	push	{r4, r5, r6, r7, lr}
    2c52:	b085      	sub	sp, #20
    2c54:	9302      	str	r3, [sp, #8]
    2c56:	ab0a      	add	r3, sp, #40	; 0x28
    2c58:	1c0e      	adds	r6, r1, #0
    2c5a:	2100      	movs	r1, #0
    2c5c:	5e5f      	ldrsh	r7, [r3, r1]
    2c5e:	ab0b      	add	r3, sp, #44	; 0x2c
    2c60:	881b      	ldrh	r3, [r3, #0]
    2c62:	1c15      	adds	r5, r2, #0
    2c64:	9303      	str	r3, [sp, #12]
    // Update in subclasses if desired!
    if(x0 == x1){
    2c66:	9b02      	ldr	r3, [sp, #8]
    // Update in subclasses if desired!
    fillRect(0, 0, _width, _height, color);
}

void Adafruit_GFX::drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,
        uint16_t color) {
    2c68:	1c04      	adds	r4, r0, #0
    2c6a:	6802      	ldr	r2, [r0, #0]
    // Update in subclasses if desired!
    if(x0 == x1){
    2c6c:	429e      	cmp	r6, r3
    2c6e:	d10b      	bne.n	2c88 <_ZN12Adafruit_GFX8drawLineEsssst+0x38>
        if(y0 > y1) _swap_int16_t(y0, y1);
    2c70:	42bd      	cmp	r5, r7
    2c72:	dd02      	ble.n	2c7a <_ZN12Adafruit_GFX8drawLineEsssst+0x2a>
    2c74:	1c2b      	adds	r3, r5, #0
    2c76:	1c3d      	adds	r5, r7, #0
    2c78:	1c1f      	adds	r7, r3, #0
        drawFastVLine(x0, y0, y1 - y0 + 1, color);
    2c7a:	9903      	ldr	r1, [sp, #12]
    2c7c:	1c7b      	adds	r3, r7, #1
    2c7e:	1b5b      	subs	r3, r3, r5
    2c80:	9100      	str	r1, [sp, #0]
    2c82:	b21b      	sxth	r3, r3
    2c84:	6b97      	ldr	r7, [r2, #56]	; 0x38
    2c86:	e00e      	b.n	2ca6 <_ZN12Adafruit_GFX8drawLineEsssst+0x56>
    } else if(y0 == y1){
    2c88:	42bd      	cmp	r5, r7
    2c8a:	d111      	bne.n	2cb0 <_ZN12Adafruit_GFX8drawLineEsssst+0x60>
        if(x0 > x1) _swap_int16_t(x0, x1);
    2c8c:	9b02      	ldr	r3, [sp, #8]
    2c8e:	429e      	cmp	r6, r3
    2c90:	dd02      	ble.n	2c98 <_ZN12Adafruit_GFX8drawLineEsssst+0x48>
    2c92:	1c33      	adds	r3, r6, #0
    2c94:	9e02      	ldr	r6, [sp, #8]
    2c96:	9302      	str	r3, [sp, #8]
        drawFastHLine(x0, y0, x1 - x0 + 1, color);
    2c98:	9b02      	ldr	r3, [sp, #8]
    2c9a:	9903      	ldr	r1, [sp, #12]
    2c9c:	3301      	adds	r3, #1
    2c9e:	9100      	str	r1, [sp, #0]
    2ca0:	1b9b      	subs	r3, r3, r6
    2ca2:	6bd7      	ldr	r7, [r2, #60]	; 0x3c
    2ca4:	b21b      	sxth	r3, r3
    2ca6:	1c20      	adds	r0, r4, #0
    2ca8:	1c31      	adds	r1, r6, #0
    2caa:	1c2a      	adds	r2, r5, #0
    2cac:	47b8      	blx	r7
    2cae:	e00f      	b.n	2cd0 <_ZN12Adafruit_GFX8drawLineEsssst+0x80>
    } else {
        startWrite();
    2cb0:	6953      	ldr	r3, [r2, #20]
    2cb2:	4798      	blx	r3
        writeLine(x0, y0, x1, y1, color);
    2cb4:	9a03      	ldr	r2, [sp, #12]
    2cb6:	6823      	ldr	r3, [r4, #0]
    2cb8:	9201      	str	r2, [sp, #4]
    2cba:	9700      	str	r7, [sp, #0]
    2cbc:	6a9f      	ldr	r7, [r3, #40]	; 0x28
    2cbe:	1c20      	adds	r0, r4, #0
    2cc0:	9b02      	ldr	r3, [sp, #8]
    2cc2:	1c31      	adds	r1, r6, #0
    2cc4:	1c2a      	adds	r2, r5, #0
    2cc6:	47b8      	blx	r7
        endWrite();
    2cc8:	6823      	ldr	r3, [r4, #0]
    2cca:	1c20      	adds	r0, r4, #0
    2ccc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2cce:	4798      	blx	r3
    }
}
    2cd0:	b005      	add	sp, #20
    2cd2:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002cd4 <_ZN12Adafruit_GFX8drawRectEsssst>:
    }
}

// Draw a rectangle
void Adafruit_GFX::drawRect(int16_t x, int16_t y, int16_t w, int16_t h,
        uint16_t color) {
    2cd4:	b5f0      	push	{r4, r5, r6, r7, lr}
    2cd6:	b085      	sub	sp, #20
    2cd8:	1c1f      	adds	r7, r3, #0
    2cda:	ab0a      	add	r3, sp, #40	; 0x28
    2cdc:	1c15      	adds	r5, r2, #0
    2cde:	1c0e      	adds	r6, r1, #0
    2ce0:	2200      	movs	r2, #0
    2ce2:	5e99      	ldrsh	r1, [r3, r2]
    2ce4:	ab0b      	add	r3, sp, #44	; 0x2c
    2ce6:	881b      	ldrh	r3, [r3, #0]
    2ce8:	9103      	str	r1, [sp, #12]
    2cea:	9302      	str	r3, [sp, #8]
    startWrite();
    2cec:	6803      	ldr	r3, [r0, #0]
    }
}

// Draw a rectangle
void Adafruit_GFX::drawRect(int16_t x, int16_t y, int16_t w, int16_t h,
        uint16_t color) {
    2cee:	1c04      	adds	r4, r0, #0
    startWrite();
    2cf0:	695b      	ldr	r3, [r3, #20]
    2cf2:	4798      	blx	r3
    writeFastHLine(x, y, w, color);
    2cf4:	9902      	ldr	r1, [sp, #8]
    2cf6:	6823      	ldr	r3, [r4, #0]
    2cf8:	9100      	str	r1, [sp, #0]
    2cfa:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    2cfc:	1c20      	adds	r0, r4, #0
    2cfe:	4694      	mov	ip, r2
    2d00:	1c31      	adds	r1, r6, #0
    2d02:	1c2a      	adds	r2, r5, #0
    2d04:	1c3b      	adds	r3, r7, #0
    2d06:	47e0      	blx	ip
    writeFastHLine(x, y+h-1, w, color);
    2d08:	9902      	ldr	r1, [sp, #8]
    2d0a:	6823      	ldr	r3, [r4, #0]
    2d0c:	9a03      	ldr	r2, [sp, #12]
    2d0e:	9100      	str	r1, [sp, #0]
    2d10:	6a59      	ldr	r1, [r3, #36]	; 0x24
    2d12:	3a01      	subs	r2, #1
    2d14:	1952      	adds	r2, r2, r5
    2d16:	468c      	mov	ip, r1
    2d18:	1c20      	adds	r0, r4, #0
    2d1a:	1c31      	adds	r1, r6, #0
    2d1c:	1c3b      	adds	r3, r7, #0
    2d1e:	b212      	sxth	r2, r2
    2d20:	47e0      	blx	ip
    writeFastVLine(x, y, h, color);
    2d22:	9a02      	ldr	r2, [sp, #8]
    2d24:	6823      	ldr	r3, [r4, #0]
    2d26:	9200      	str	r2, [sp, #0]
    2d28:	6a19      	ldr	r1, [r3, #32]
    2d2a:	1c20      	adds	r0, r4, #0
    2d2c:	468c      	mov	ip, r1
    2d2e:	1c2a      	adds	r2, r5, #0
    2d30:	1c31      	adds	r1, r6, #0
    2d32:	9b03      	ldr	r3, [sp, #12]
    2d34:	47e0      	blx	ip
    writeFastVLine(x+w-1, y, h, color);
    2d36:	9a02      	ldr	r2, [sp, #8]
    2d38:	6823      	ldr	r3, [r4, #0]
    2d3a:	3f01      	subs	r7, #1
    2d3c:	9200      	str	r2, [sp, #0]
    2d3e:	19be      	adds	r6, r7, r6
    2d40:	b231      	sxth	r1, r6
    2d42:	6a1f      	ldr	r7, [r3, #32]
    2d44:	1c20      	adds	r0, r4, #0
    2d46:	1c2a      	adds	r2, r5, #0
    2d48:	9b03      	ldr	r3, [sp, #12]
    2d4a:	47b8      	blx	r7
    endWrite();
    2d4c:	6823      	ldr	r3, [r4, #0]
    2d4e:	1c20      	adds	r0, r4, #0
    2d50:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2d52:	4798      	blx	r3
}
    2d54:	b005      	add	sp, #20
    2d56:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002d58 <_ZN12Adafruit_GFX13invertDisplayEb>:
    return _height;
}

void Adafruit_GFX::invertDisplay(boolean i) {
    // Do nothing, must be subclassed if supported by hardware
}
    2d58:	4770      	bx	lr

00002d5a <_ZN12Adafruit_GFX11setRotationEh>:
uint8_t Adafruit_GFX::getRotation(void) const {
    return rotation;
}

void Adafruit_GFX::setRotation(uint8_t x) {
    rotation = (x & 3);
    2d5a:	2303      	movs	r3, #3
    2d5c:	4019      	ands	r1, r3
    2d5e:	7641      	strb	r1, [r0, #25]
    2d60:	8903      	ldrh	r3, [r0, #8]
    2d62:	8942      	ldrh	r2, [r0, #10]
    switch(rotation) {
    2d64:	2901      	cmp	r1, #1
    2d66:	d004      	beq.n	2d72 <_ZN12Adafruit_GFX11setRotationEh+0x18>
    2d68:	2903      	cmp	r1, #3
    2d6a:	d002      	beq.n	2d72 <_ZN12Adafruit_GFX11setRotationEh+0x18>
        case 0:
        case 2:
            _width  = WIDTH;
    2d6c:	8183      	strh	r3, [r0, #12]
            _height = HEIGHT;
    2d6e:	81c2      	strh	r2, [r0, #14]
    2d70:	e001      	b.n	2d76 <_ZN12Adafruit_GFX11setRotationEh+0x1c>
            break;
        case 1:
        case 3:
            _width  = HEIGHT;
    2d72:	8182      	strh	r2, [r0, #12]
            _height = WIDTH;
    2d74:	81c3      	strh	r3, [r0, #14]
            break;
    }
}
    2d76:	4770      	bx	lr

00002d78 <_ZN12Adafruit_GFXC1Ess>:

#ifndef _swap_int16_t
#define _swap_int16_t(a, b) { int16_t t = a; a = b; b = t; }
#endif

Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h):
    2d78:	b510      	push	{r4, lr}
WIDTH(w), HEIGHT(h)
    2d7a:	4c0a      	ldr	r4, [pc, #40]	; (2da4 <_ZN12Adafruit_GFXC1Ess+0x2c>)
    2d7c:	8142      	strh	r2, [r0, #10]
{
    _width    = WIDTH;
    _height   = HEIGHT;
    2d7e:	81c2      	strh	r2, [r0, #14]
    rotation  = 0;
    cursor_y  = cursor_x    = 0;
    textsize  = 1;
    2d80:	2201      	movs	r2, #1
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    2d82:	2300      	movs	r3, #0
#ifndef _swap_int16_t
#define _swap_int16_t(a, b) { int16_t t = a; a = b; b = t; }
#endif

Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h):
WIDTH(w), HEIGHT(h)
    2d84:	3408      	adds	r4, #8
    2d86:	8101      	strh	r1, [r0, #8]
{
    _width    = WIDTH;
    2d88:	8181      	strh	r1, [r0, #12]
    _height   = HEIGHT;
    rotation  = 0;
    cursor_y  = cursor_x    = 0;
    textsize  = 1;
    textcolor = textbgcolor = 0xFFFF;
    2d8a:	4251      	negs	r1, r2
    2d8c:	6043      	str	r3, [r0, #4]
#ifndef _swap_int16_t
#define _swap_int16_t(a, b) { int16_t t = a; a = b; b = t; }
#endif

Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h):
WIDTH(w), HEIGHT(h)
    2d8e:	6004      	str	r4, [r0, #0]
{
    _width    = WIDTH;
    _height   = HEIGHT;
    rotation  = 0;
    2d90:	7643      	strb	r3, [r0, #25]
    cursor_y  = cursor_x    = 0;
    2d92:	8203      	strh	r3, [r0, #16]
    2d94:	8243      	strh	r3, [r0, #18]
    textsize  = 1;
    2d96:	7602      	strb	r2, [r0, #24]
    textcolor = textbgcolor = 0xFFFF;
    2d98:	82c1      	strh	r1, [r0, #22]
    2d9a:	8281      	strh	r1, [r0, #20]
    wrap      = true;
    2d9c:	7682      	strb	r2, [r0, #26]
    _cp437    = false;
    2d9e:	76c3      	strb	r3, [r0, #27]
    gfxFont   = NULL;
    2da0:	61c3      	str	r3, [r0, #28]
}
    2da2:	bd10      	pop	{r4, pc}
    2da4:	00008668 	.word	0x00008668

00002da8 <_ZN12Adafruit_GFX10drawCircleEssst>:
    }
}

// Draw a circle outline
void Adafruit_GFX::drawCircle(int16_t x0, int16_t y0, int16_t r,
        uint16_t color) {
    2da8:	b5f0      	push	{r4, r5, r6, r7, lr}
    2daa:	b08b      	sub	sp, #44	; 0x2c
    2dac:	9306      	str	r3, [sp, #24]
    2dae:	ab10      	add	r3, sp, #64	; 0x40
    2db0:	1c0f      	adds	r7, r1, #0
    2db2:	881b      	ldrh	r3, [r3, #0]
    int16_t f = 1 - r;
    2db4:	9906      	ldr	r1, [sp, #24]
    }
}

// Draw a circle outline
void Adafruit_GFX::drawCircle(int16_t x0, int16_t y0, int16_t r,
        uint16_t color) {
    2db6:	9301      	str	r3, [sp, #4]
    int16_t f = 1 - r;
    2db8:	b28d      	uxth	r5, r1
    2dba:	2301      	movs	r3, #1
    2dbc:	1b5b      	subs	r3, r3, r5
    2dbe:	b29b      	uxth	r3, r3
    2dc0:	9304      	str	r3, [sp, #16]
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * r;
    2dc2:	006b      	lsls	r3, r5, #1
    2dc4:	425b      	negs	r3, r3
    2dc6:	b29b      	uxth	r3, r3
    2dc8:	9309      	str	r3, [sp, #36]	; 0x24
    int16_t x = 0;
    int16_t y = r;

    startWrite();
    2dca:	6803      	ldr	r3, [r0, #0]
    }
}

// Draw a circle outline
void Adafruit_GFX::drawCircle(int16_t x0, int16_t y0, int16_t r,
        uint16_t color) {
    2dcc:	1c04      	adds	r4, r0, #0
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * r;
    int16_t x = 0;
    int16_t y = r;

    startWrite();
    2dce:	695b      	ldr	r3, [r3, #20]
    }
}

// Draw a circle outline
void Adafruit_GFX::drawCircle(int16_t x0, int16_t y0, int16_t r,
        uint16_t color) {
    2dd0:	1c16      	adds	r6, r2, #0
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * r;
    int16_t x = 0;
    int16_t y = r;

    startWrite();
    2dd2:	4798      	blx	r3
    writePixel(x0  , y0+r, color);
    2dd4:	6823      	ldr	r3, [r4, #0]
    2dd6:	b2b2      	uxth	r2, r6
    2dd8:	6999      	ldr	r1, [r3, #24]
    2dda:	9202      	str	r2, [sp, #8]
    2ddc:	18aa      	adds	r2, r5, r2
    2dde:	468c      	mov	ip, r1
    2de0:	b212      	sxth	r2, r2
    2de2:	1c39      	adds	r1, r7, #0
    2de4:	1c20      	adds	r0, r4, #0
    2de6:	9b01      	ldr	r3, [sp, #4]
    2de8:	47e0      	blx	ip
    writePixel(x0  , y0-r, color);
    2dea:	6823      	ldr	r3, [r4, #0]
    2dec:	9902      	ldr	r1, [sp, #8]
    2dee:	1c20      	adds	r0, r4, #0
    2df0:	1b4a      	subs	r2, r1, r5
    2df2:	6999      	ldr	r1, [r3, #24]
    2df4:	b212      	sxth	r2, r2
    2df6:	468c      	mov	ip, r1
    2df8:	9b01      	ldr	r3, [sp, #4]
    2dfa:	1c39      	adds	r1, r7, #0
    2dfc:	47e0      	blx	ip
    writePixel(x0+r, y0  , color);
    2dfe:	b2bf      	uxth	r7, r7
    2e00:	6823      	ldr	r3, [r4, #0]
    2e02:	19e9      	adds	r1, r5, r7
    2e04:	9703      	str	r7, [sp, #12]
    2e06:	b209      	sxth	r1, r1
    2e08:	699f      	ldr	r7, [r3, #24]
    2e0a:	1c20      	adds	r0, r4, #0
    2e0c:	1c32      	adds	r2, r6, #0
    2e0e:	9b01      	ldr	r3, [sp, #4]
    2e10:	47b8      	blx	r7
    writePixel(x0-r, y0  , color);
    2e12:	9a03      	ldr	r2, [sp, #12]
    2e14:	6823      	ldr	r3, [r4, #0]
    2e16:	1b55      	subs	r5, r2, r5
    2e18:	699f      	ldr	r7, [r3, #24]
    2e1a:	b229      	sxth	r1, r5
    2e1c:	9b01      	ldr	r3, [sp, #4]
    2e1e:	1c20      	adds	r0, r4, #0
    2e20:	1c32      	adds	r2, r6, #0
    2e22:	47b8      	blx	r7

    while (x<y) {
    2e24:	2300      	movs	r3, #0
    2e26:	9308      	str	r3, [sp, #32]
    2e28:	9908      	ldr	r1, [sp, #32]
    2e2a:	9a06      	ldr	r2, [sp, #24]
    2e2c:	b20b      	sxth	r3, r1
    2e2e:	4293      	cmp	r3, r2
    2e30:	da7f      	bge.n	2f32 <_ZN12Adafruit_GFX10drawCircleEssst+0x18a>
        if (f >= 0) {
    2e32:	9904      	ldr	r1, [sp, #16]
    2e34:	b20b      	sxth	r3, r1
    2e36:	2b00      	cmp	r3, #0
    2e38:	db0c      	blt.n	2e54 <_ZN12Adafruit_GFX10drawCircleEssst+0xac>
            y--;
    2e3a:	9b06      	ldr	r3, [sp, #24]
    2e3c:	3b01      	subs	r3, #1
    2e3e:	b21a      	sxth	r2, r3
            ddF_y += 2;
    2e40:	9b09      	ldr	r3, [sp, #36]	; 0x24
    writePixel(x0+r, y0  , color);
    writePixel(x0-r, y0  , color);

    while (x<y) {
        if (f >= 0) {
            y--;
    2e42:	9206      	str	r2, [sp, #24]
            ddF_y += 2;
    2e44:	3302      	adds	r3, #2
            f += ddF_y;
    2e46:	9a04      	ldr	r2, [sp, #16]
    writePixel(x0-r, y0  , color);

    while (x<y) {
        if (f >= 0) {
            y--;
            ddF_y += 2;
    2e48:	b29b      	uxth	r3, r3
    2e4a:	b299      	uxth	r1, r3
            f += ddF_y;
    2e4c:	189b      	adds	r3, r3, r2
    2e4e:	b29b      	uxth	r3, r3
    writePixel(x0-r, y0  , color);

    while (x<y) {
        if (f >= 0) {
            y--;
            ddF_y += 2;
    2e50:	9109      	str	r1, [sp, #36]	; 0x24
            f += ddF_y;
    2e52:	9304      	str	r3, [sp, #16]
    2e54:	9b08      	ldr	r3, [sp, #32]
        }
        x++;
        ddF_x += 2;
        f += ddF_x;
    2e56:	9904      	ldr	r1, [sp, #16]
    2e58:	b29b      	uxth	r3, r3
    2e5a:	9305      	str	r3, [sp, #20]
    2e5c:	005b      	lsls	r3, r3, #1
    2e5e:	3303      	adds	r3, #3
    2e60:	18cb      	adds	r3, r1, r3
    2e62:	b29b      	uxth	r3, r3
    2e64:	9304      	str	r3, [sp, #16]
    2e66:	9f03      	ldr	r7, [sp, #12]

        writePixel(x0 + x, y0 + y, color);
    2e68:	9b06      	ldr	r3, [sp, #24]
    2e6a:	9a05      	ldr	r2, [sp, #20]
    2e6c:	9902      	ldr	r1, [sp, #8]
    2e6e:	b29b      	uxth	r3, r3
    2e70:	3701      	adds	r7, #1
    2e72:	185d      	adds	r5, r3, r1
    2e74:	19d7      	adds	r7, r2, r7
    2e76:	9307      	str	r3, [sp, #28]
    2e78:	6823      	ldr	r3, [r4, #0]
    2e7a:	b23f      	sxth	r7, r7
    2e7c:	b22d      	sxth	r5, r5
    2e7e:	699e      	ldr	r6, [r3, #24]
    2e80:	1c39      	adds	r1, r7, #0
    2e82:	1c2a      	adds	r2, r5, #0
    2e84:	1c20      	adds	r0, r4, #0
    2e86:	9b01      	ldr	r3, [sp, #4]
    2e88:	47b0      	blx	r6
    2e8a:	9e03      	ldr	r6, [sp, #12]
    2e8c:	9a05      	ldr	r2, [sp, #20]
        writePixel(x0 - x, y0 + y, color);
    2e8e:	6823      	ldr	r3, [r4, #0]
    2e90:	3e01      	subs	r6, #1
    2e92:	6999      	ldr	r1, [r3, #24]
    2e94:	1ab6      	subs	r6, r6, r2
    2e96:	b236      	sxth	r6, r6
    2e98:	468c      	mov	ip, r1
    2e9a:	1c2a      	adds	r2, r5, #0
    2e9c:	1c31      	adds	r1, r6, #0
    2e9e:	1c20      	adds	r0, r4, #0
    2ea0:	9b01      	ldr	r3, [sp, #4]
    2ea2:	47e0      	blx	ip
        writePixel(x0 + x, y0 - y, color);
    2ea4:	9a02      	ldr	r2, [sp, #8]
    2ea6:	9b07      	ldr	r3, [sp, #28]
    2ea8:	1c20      	adds	r0, r4, #0
    2eaa:	1ad5      	subs	r5, r2, r3
    2eac:	6823      	ldr	r3, [r4, #0]
    2eae:	b22d      	sxth	r5, r5
    2eb0:	6999      	ldr	r1, [r3, #24]
    2eb2:	1c2a      	adds	r2, r5, #0
    2eb4:	468c      	mov	ip, r1
    2eb6:	9b01      	ldr	r3, [sp, #4]
    2eb8:	1c39      	adds	r1, r7, #0
    2eba:	47e0      	blx	ip
        writePixel(x0 - x, y0 - y, color);
    2ebc:	6823      	ldr	r3, [r4, #0]
    2ebe:	1c31      	adds	r1, r6, #0
    2ec0:	699f      	ldr	r7, [r3, #24]
    2ec2:	1c2a      	adds	r2, r5, #0
    2ec4:	1c20      	adds	r0, r4, #0
    2ec6:	9b01      	ldr	r3, [sp, #4]
    2ec8:	47b8      	blx	r7
    2eca:	9d02      	ldr	r5, [sp, #8]
        writePixel(x0 + y, y0 + x, color);
    2ecc:	9a07      	ldr	r2, [sp, #28]
    2ece:	9b03      	ldr	r3, [sp, #12]
    2ed0:	9905      	ldr	r1, [sp, #20]
    2ed2:	3501      	adds	r5, #1
    2ed4:	18d7      	adds	r7, r2, r3
    2ed6:	194d      	adds	r5, r1, r5
    2ed8:	6823      	ldr	r3, [r4, #0]
    2eda:	b23f      	sxth	r7, r7
    2edc:	b22d      	sxth	r5, r5
    2ede:	699e      	ldr	r6, [r3, #24]
    2ee0:	1c39      	adds	r1, r7, #0
    2ee2:	1c2a      	adds	r2, r5, #0
    2ee4:	1c20      	adds	r0, r4, #0
    2ee6:	9b01      	ldr	r3, [sp, #4]
    2ee8:	47b0      	blx	r6
        writePixel(x0 - y, y0 + x, color);
    2eea:	9a03      	ldr	r2, [sp, #12]
    2eec:	9b07      	ldr	r3, [sp, #28]
    2eee:	1c20      	adds	r0, r4, #0
    2ef0:	1ad6      	subs	r6, r2, r3
    2ef2:	6823      	ldr	r3, [r4, #0]
    2ef4:	b236      	sxth	r6, r6
    2ef6:	6999      	ldr	r1, [r3, #24]
    2ef8:	1c2a      	adds	r2, r5, #0
    2efa:	468c      	mov	ip, r1
    2efc:	9b01      	ldr	r3, [sp, #4]
    2efe:	1c31      	adds	r1, r6, #0
    2f00:	47e0      	blx	ip
    2f02:	9d02      	ldr	r5, [sp, #8]
    2f04:	9a05      	ldr	r2, [sp, #20]
        writePixel(x0 + y, y0 - x, color);
    2f06:	6823      	ldr	r3, [r4, #0]
    2f08:	3d01      	subs	r5, #1
    2f0a:	6999      	ldr	r1, [r3, #24]
    2f0c:	1aad      	subs	r5, r5, r2
    2f0e:	b22d      	sxth	r5, r5
    2f10:	468c      	mov	ip, r1
    2f12:	1c20      	adds	r0, r4, #0
    2f14:	1c39      	adds	r1, r7, #0
    2f16:	1c2a      	adds	r2, r5, #0
    2f18:	9b01      	ldr	r3, [sp, #4]
    2f1a:	47e0      	blx	ip
        writePixel(x0 - y, y0 - x, color);
    2f1c:	6823      	ldr	r3, [r4, #0]
    2f1e:	1c2a      	adds	r2, r5, #0
    2f20:	699f      	ldr	r7, [r3, #24]
    2f22:	1c20      	adds	r0, r4, #0
    2f24:	1c31      	adds	r1, r6, #0
    2f26:	9b01      	ldr	r3, [sp, #4]
    2f28:	47b8      	blx	r7
    2f2a:	9a08      	ldr	r2, [sp, #32]
    2f2c:	3201      	adds	r2, #1
    2f2e:	9208      	str	r2, [sp, #32]
    2f30:	e77a      	b.n	2e28 <_ZN12Adafruit_GFX10drawCircleEssst+0x80>
    }
    endWrite();
    2f32:	6823      	ldr	r3, [r4, #0]
    2f34:	1c20      	adds	r0, r4, #0
    2f36:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2f38:	4798      	blx	r3
}
    2f3a:	b00b      	add	sp, #44	; 0x2c
    2f3c:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002f3e <_ZN12Adafruit_GFX16drawCircleHelperEsssht>:

void Adafruit_GFX::drawCircleHelper( int16_t x0, int16_t y0,
        int16_t r, uint8_t cornername, uint16_t color) {
    2f3e:	b5f0      	push	{r4, r5, r6, r7, lr}
    2f40:	b08b      	sub	sp, #44	; 0x2c
    2f42:	9302      	str	r3, [sp, #8]
    2f44:	ab10      	add	r3, sp, #64	; 0x40
    2f46:	781b      	ldrb	r3, [r3, #0]
    2f48:	1c04      	adds	r4, r0, #0
    2f4a:	9308      	str	r3, [sp, #32]
    2f4c:	ab11      	add	r3, sp, #68	; 0x44
    2f4e:	881b      	ldrh	r3, [r3, #0]
    int16_t f     = 1 - r;
    2f50:	9802      	ldr	r0, [sp, #8]
    }
    endWrite();
}

void Adafruit_GFX::drawCircleHelper( int16_t x0, int16_t y0,
        int16_t r, uint8_t cornername, uint16_t color) {
    2f52:	9207      	str	r2, [sp, #28]
    2f54:	9303      	str	r3, [sp, #12]
    int16_t f     = 1 - r;
    2f56:	2201      	movs	r2, #1
    2f58:	b283      	uxth	r3, r0
    2f5a:	1ad2      	subs	r2, r2, r3
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * r;
    2f5c:	005b      	lsls	r3, r3, #1
    endWrite();
}

void Adafruit_GFX::drawCircleHelper( int16_t x0, int16_t y0,
        int16_t r, uint8_t cornername, uint16_t color) {
    int16_t f     = 1 - r;
    2f5e:	b292      	uxth	r2, r2
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * r;
    2f60:	425b      	negs	r3, r3
    endWrite();
}

void Adafruit_GFX::drawCircleHelper( int16_t x0, int16_t y0,
        int16_t r, uint8_t cornername, uint16_t color) {
    int16_t f     = 1 - r;
    2f62:	9204      	str	r2, [sp, #16]
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * r;
    2f64:	b29b      	uxth	r3, r3
    int16_t x     = 0;
    int16_t y     = r;

    while (x<y) {
    2f66:	2200      	movs	r2, #0
    }
    endWrite();
}

void Adafruit_GFX::drawCircleHelper( int16_t x0, int16_t y0,
        int16_t r, uint8_t cornername, uint16_t color) {
    2f68:	9106      	str	r1, [sp, #24]
    int16_t f     = 1 - r;
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * r;
    2f6a:	9309      	str	r3, [sp, #36]	; 0x24
    int16_t x     = 0;
    int16_t y     = r;

    while (x<y) {
    2f6c:	9205      	str	r2, [sp, #20]
    2f6e:	9805      	ldr	r0, [sp, #20]
    2f70:	9a02      	ldr	r2, [sp, #8]
    2f72:	b203      	sxth	r3, r0
    2f74:	4293      	cmp	r3, r2
    2f76:	db00      	blt.n	2f7a <_ZN12Adafruit_GFX16drawCircleHelperEsssht+0x3c>
    2f78:	e09d      	b.n	30b6 <_ZN12Adafruit_GFX16drawCircleHelperEsssht+0x178>
        if (f >= 0) {
    2f7a:	9804      	ldr	r0, [sp, #16]
    2f7c:	b203      	sxth	r3, r0
    2f7e:	2b00      	cmp	r3, #0
    2f80:	db0c      	blt.n	2f9c <_ZN12Adafruit_GFX16drawCircleHelperEsssht+0x5e>
            y--;
    2f82:	9b02      	ldr	r3, [sp, #8]
    2f84:	3b01      	subs	r3, #1
    2f86:	b21a      	sxth	r2, r3
            ddF_y += 2;
    2f88:	9b09      	ldr	r3, [sp, #36]	; 0x24
    int16_t x     = 0;
    int16_t y     = r;

    while (x<y) {
        if (f >= 0) {
            y--;
    2f8a:	9202      	str	r2, [sp, #8]
            ddF_y += 2;
    2f8c:	3302      	adds	r3, #2
            f     += ddF_y;
    2f8e:	9a04      	ldr	r2, [sp, #16]
    int16_t y     = r;

    while (x<y) {
        if (f >= 0) {
            y--;
            ddF_y += 2;
    2f90:	b29b      	uxth	r3, r3
    2f92:	b298      	uxth	r0, r3
            f     += ddF_y;
    2f94:	189b      	adds	r3, r3, r2
    2f96:	b29b      	uxth	r3, r3
    int16_t y     = r;

    while (x<y) {
        if (f >= 0) {
            y--;
            ddF_y += 2;
    2f98:	9009      	str	r0, [sp, #36]	; 0x24
            f     += ddF_y;
    2f9a:	9304      	str	r3, [sp, #16]
    2f9c:	9b05      	ldr	r3, [sp, #20]
        }
        x++;
        ddF_x += 2;
        f     += ddF_x;
    2f9e:	9804      	ldr	r0, [sp, #16]
    2fa0:	b29b      	uxth	r3, r3
    2fa2:	9301      	str	r3, [sp, #4]
    2fa4:	005b      	lsls	r3, r3, #1
    2fa6:	3303      	adds	r3, #3
    2fa8:	18c3      	adds	r3, r0, r3
        if (cornername & 0x4) {
    2faa:	9a08      	ldr	r2, [sp, #32]
            ddF_y += 2;
            f     += ddF_y;
        }
        x++;
        ddF_x += 2;
        f     += ddF_x;
    2fac:	b29b      	uxth	r3, r3
    2fae:	9304      	str	r3, [sp, #16]
        if (cornername & 0x4) {
    2fb0:	0752      	lsls	r2, r2, #29
    2fb2:	d51c      	bpl.n	2fee <_ZN12Adafruit_GFX16drawCircleHelperEsssht+0xb0>
            writePixel(x0 + x, y0 + y, color);
    2fb4:	9b06      	ldr	r3, [sp, #24]
    2fb6:	9807      	ldr	r0, [sp, #28]
    2fb8:	b29e      	uxth	r6, r3
    2fba:	b285      	uxth	r5, r0
    2fbc:	9a02      	ldr	r2, [sp, #8]
    2fbe:	6823      	ldr	r3, [r4, #0]
    2fc0:	9801      	ldr	r0, [sp, #4]
    2fc2:	1c71      	adds	r1, r6, #1
    2fc4:	b297      	uxth	r7, r2
    2fc6:	1841      	adds	r1, r0, r1
    2fc8:	6998      	ldr	r0, [r3, #24]
    2fca:	197a      	adds	r2, r7, r5
    2fcc:	b209      	sxth	r1, r1
    2fce:	b212      	sxth	r2, r2
    2fd0:	4684      	mov	ip, r0
    2fd2:	9b03      	ldr	r3, [sp, #12]
    2fd4:	1c20      	adds	r0, r4, #0
    2fd6:	47e0      	blx	ip
    2fd8:	9801      	ldr	r0, [sp, #4]
            writePixel(x0 + y, y0 + x, color);
    2fda:	6823      	ldr	r3, [r4, #0]
    2fdc:	1c6a      	adds	r2, r5, #1
    2fde:	1882      	adds	r2, r0, r2
    2fe0:	19be      	adds	r6, r7, r6
    2fe2:	699d      	ldr	r5, [r3, #24]
    2fe4:	b231      	sxth	r1, r6
    2fe6:	b212      	sxth	r2, r2
    2fe8:	1c20      	adds	r0, r4, #0
    2fea:	9b03      	ldr	r3, [sp, #12]
    2fec:	47a8      	blx	r5
        }
        if (cornername & 0x2) {
    2fee:	9a08      	ldr	r2, [sp, #32]
    2ff0:	0792      	lsls	r2, r2, #30
    2ff2:	d51c      	bpl.n	302e <_ZN12Adafruit_GFX16drawCircleHelperEsssht+0xf0>
            writePixel(x0 + x, y0 - y, color);
    2ff4:	9b06      	ldr	r3, [sp, #24]
    2ff6:	9807      	ldr	r0, [sp, #28]
    2ff8:	b29e      	uxth	r6, r3
    2ffa:	b285      	uxth	r5, r0
    2ffc:	9a02      	ldr	r2, [sp, #8]
    2ffe:	6823      	ldr	r3, [r4, #0]
    3000:	9801      	ldr	r0, [sp, #4]
    3002:	1c71      	adds	r1, r6, #1
    3004:	b297      	uxth	r7, r2
    3006:	1841      	adds	r1, r0, r1
    3008:	6998      	ldr	r0, [r3, #24]
    300a:	1bea      	subs	r2, r5, r7
    300c:	b209      	sxth	r1, r1
    300e:	b212      	sxth	r2, r2
    3010:	4684      	mov	ip, r0
    3012:	9b03      	ldr	r3, [sp, #12]
    3014:	1c20      	adds	r0, r4, #0
    3016:	47e0      	blx	ip
    3018:	9801      	ldr	r0, [sp, #4]
            writePixel(x0 + y, y0 - x, color);
    301a:	6823      	ldr	r3, [r4, #0]
    301c:	1e6a      	subs	r2, r5, #1
    301e:	1a12      	subs	r2, r2, r0
    3020:	19be      	adds	r6, r7, r6
    3022:	699d      	ldr	r5, [r3, #24]
    3024:	b231      	sxth	r1, r6
    3026:	b212      	sxth	r2, r2
    3028:	1c20      	adds	r0, r4, #0
    302a:	9b03      	ldr	r3, [sp, #12]
    302c:	47a8      	blx	r5
        }
        if (cornername & 0x8) {
    302e:	9a08      	ldr	r2, [sp, #32]
    3030:	0712      	lsls	r2, r2, #28
    3032:	d51c      	bpl.n	306e <_ZN12Adafruit_GFX16drawCircleHelperEsssht+0x130>
            writePixel(x0 - y, y0 + x, color);
    3034:	9b06      	ldr	r3, [sp, #24]
    3036:	9802      	ldr	r0, [sp, #8]
    3038:	9a07      	ldr	r2, [sp, #28]
    303a:	b29f      	uxth	r7, r3
    303c:	b286      	uxth	r6, r0
    303e:	6823      	ldr	r3, [r4, #0]
    3040:	9801      	ldr	r0, [sp, #4]
    3042:	b295      	uxth	r5, r2
    3044:	1c6a      	adds	r2, r5, #1
    3046:	1882      	adds	r2, r0, r2
    3048:	6998      	ldr	r0, [r3, #24]
    304a:	1bb9      	subs	r1, r7, r6
    304c:	b209      	sxth	r1, r1
    304e:	b212      	sxth	r2, r2
    3050:	4684      	mov	ip, r0
    3052:	9b03      	ldr	r3, [sp, #12]
    3054:	1c20      	adds	r0, r4, #0
    3056:	47e0      	blx	ip
    3058:	9a01      	ldr	r2, [sp, #4]
            writePixel(x0 - x, y0 + y, color);
    305a:	6823      	ldr	r3, [r4, #0]
    305c:	1e79      	subs	r1, r7, #1
    305e:	1a89      	subs	r1, r1, r2
    3060:	1975      	adds	r5, r6, r5
    3062:	699f      	ldr	r7, [r3, #24]
    3064:	b209      	sxth	r1, r1
    3066:	b22a      	sxth	r2, r5
    3068:	1c20      	adds	r0, r4, #0
    306a:	9b03      	ldr	r3, [sp, #12]
    306c:	47b8      	blx	r7
        }
        if (cornername & 0x1) {
    306e:	9b08      	ldr	r3, [sp, #32]
    3070:	07db      	lsls	r3, r3, #31
    3072:	d51c      	bpl.n	30ae <_ZN12Adafruit_GFX16drawCircleHelperEsssht+0x170>
            writePixel(x0 - y, y0 - x, color);
    3074:	9806      	ldr	r0, [sp, #24]
    3076:	9b07      	ldr	r3, [sp, #28]
    3078:	9a02      	ldr	r2, [sp, #8]
    307a:	b287      	uxth	r7, r0
    307c:	b29e      	uxth	r6, r3
    307e:	9801      	ldr	r0, [sp, #4]
    3080:	6823      	ldr	r3, [r4, #0]
    3082:	b295      	uxth	r5, r2
    3084:	1e72      	subs	r2, r6, #1
    3086:	1a12      	subs	r2, r2, r0
    3088:	6998      	ldr	r0, [r3, #24]
    308a:	1b79      	subs	r1, r7, r5
    308c:	b209      	sxth	r1, r1
    308e:	b212      	sxth	r2, r2
    3090:	4684      	mov	ip, r0
    3092:	9b03      	ldr	r3, [sp, #12]
    3094:	1c20      	adds	r0, r4, #0
    3096:	47e0      	blx	ip
    3098:	9a01      	ldr	r2, [sp, #4]
            writePixel(x0 - x, y0 - y, color);
    309a:	6823      	ldr	r3, [r4, #0]
    309c:	1e79      	subs	r1, r7, #1
    309e:	1a89      	subs	r1, r1, r2
    30a0:	1b75      	subs	r5, r6, r5
    30a2:	699f      	ldr	r7, [r3, #24]
    30a4:	b209      	sxth	r1, r1
    30a6:	b22a      	sxth	r2, r5
    30a8:	1c20      	adds	r0, r4, #0
    30aa:	9b03      	ldr	r3, [sp, #12]
    30ac:	47b8      	blx	r7
    30ae:	9b05      	ldr	r3, [sp, #20]
    30b0:	3301      	adds	r3, #1
    30b2:	9305      	str	r3, [sp, #20]
    30b4:	e75b      	b.n	2f6e <_ZN12Adafruit_GFX16drawCircleHelperEsssht+0x30>
        }
    }
}
    30b6:	b00b      	add	sp, #44	; 0x2c
    30b8:	bdf0      	pop	{r4, r5, r6, r7, pc}

000030ba <_ZN12Adafruit_GFX16fillCircleHelperEssshst>:
    endWrite();
}

// Used to do circles and roundrects
void Adafruit_GFX::fillCircleHelper(int16_t x0, int16_t y0, int16_t r,
        uint8_t cornername, int16_t delta, uint16_t color) {
    30ba:	b5f0      	push	{r4, r5, r6, r7, lr}
    30bc:	b091      	sub	sp, #68	; 0x44
    30be:	9304      	str	r3, [sp, #16]
    30c0:	ab16      	add	r3, sp, #88	; 0x58
    30c2:	781b      	ldrb	r3, [r3, #0]
    30c4:	920d      	str	r2, [sp, #52]	; 0x34
    30c6:	930e      	str	r3, [sp, #56]	; 0x38
    30c8:	ab17      	add	r3, sp, #92	; 0x5c
    30ca:	2700      	movs	r7, #0
    30cc:	5fdd      	ldrsh	r5, [r3, r7]
    30ce:	ab18      	add	r3, sp, #96	; 0x60
    30d0:	881b      	ldrh	r3, [r3, #0]
    30d2:	950f      	str	r5, [sp, #60]	; 0x3c

    int16_t f     = 1 - r;
    30d4:	9d04      	ldr	r5, [sp, #16]
    endWrite();
}

// Used to do circles and roundrects
void Adafruit_GFX::fillCircleHelper(int16_t x0, int16_t y0, int16_t r,
        uint8_t cornername, int16_t delta, uint16_t color) {
    30d6:	9309      	str	r3, [sp, #36]	; 0x24

    int16_t f     = 1 - r;
    30d8:	2201      	movs	r2, #1
    30da:	b2ab      	uxth	r3, r5
    30dc:	1ad2      	subs	r2, r2, r3
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * r;
    30de:	005b      	lsls	r3, r3, #1
    30e0:	425b      	negs	r3, r3

// Used to do circles and roundrects
void Adafruit_GFX::fillCircleHelper(int16_t x0, int16_t y0, int16_t r,
        uint8_t cornername, int16_t delta, uint16_t color) {

    int16_t f     = 1 - r;
    30e2:	b292      	uxth	r2, r2
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * r;
    30e4:	b29b      	uxth	r3, r3
    endWrite();
}

// Used to do circles and roundrects
void Adafruit_GFX::fillCircleHelper(int16_t x0, int16_t y0, int16_t r,
        uint8_t cornername, int16_t delta, uint16_t color) {
    30e6:	1c04      	adds	r4, r0, #0
    30e8:	910c      	str	r1, [sp, #48]	; 0x30

    int16_t f     = 1 - r;
    30ea:	9205      	str	r2, [sp, #20]
    int16_t ddF_x = 1;
    int16_t ddF_y = -2 * r;
    30ec:	930b      	str	r3, [sp, #44]	; 0x2c
    int16_t x     = 0;
    int16_t y     = r;

    while (x<y) {
    30ee:	2700      	movs	r7, #0
    30f0:	9708      	str	r7, [sp, #32]
    30f2:	9d08      	ldr	r5, [sp, #32]
    30f4:	9f04      	ldr	r7, [sp, #16]
    30f6:	b22b      	sxth	r3, r5
    30f8:	42bb      	cmp	r3, r7
    30fa:	db00      	blt.n	30fe <_ZN12Adafruit_GFX16fillCircleHelperEssshst+0x44>
    30fc:	e081      	b.n	3202 <_ZN12Adafruit_GFX16fillCircleHelperEssshst+0x148>
        if (f >= 0) {
    30fe:	9d05      	ldr	r5, [sp, #20]
    3100:	b22b      	sxth	r3, r5
    3102:	2b00      	cmp	r3, #0
    3104:	db0c      	blt.n	3120 <_ZN12Adafruit_GFX16fillCircleHelperEssshst+0x66>
            y--;
    3106:	9b04      	ldr	r3, [sp, #16]
    3108:	3b01      	subs	r3, #1
    310a:	b21f      	sxth	r7, r3
            ddF_y += 2;
    310c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    int16_t x     = 0;
    int16_t y     = r;

    while (x<y) {
        if (f >= 0) {
            y--;
    310e:	9704      	str	r7, [sp, #16]
            ddF_y += 2;
    3110:	3302      	adds	r3, #2
            f     += ddF_y;
    3112:	9f05      	ldr	r7, [sp, #20]
    int16_t y     = r;

    while (x<y) {
        if (f >= 0) {
            y--;
            ddF_y += 2;
    3114:	b29b      	uxth	r3, r3
    3116:	b29d      	uxth	r5, r3
            f     += ddF_y;
    3118:	19db      	adds	r3, r3, r7
    311a:	b29b      	uxth	r3, r3
    int16_t y     = r;

    while (x<y) {
        if (f >= 0) {
            y--;
            ddF_y += 2;
    311c:	950b      	str	r5, [sp, #44]	; 0x2c
            f     += ddF_y;
    311e:	9305      	str	r3, [sp, #20]
    3120:	9d08      	ldr	r5, [sp, #32]
        }
        x++;
        ddF_x += 2;
        f     += ddF_x;
    3122:	9f05      	ldr	r7, [sp, #20]
    3124:	b2ad      	uxth	r5, r5
    3126:	006e      	lsls	r6, r5, #1
    3128:	b2b6      	uxth	r6, r6
    312a:	1c33      	adds	r3, r6, #0
    312c:	3303      	adds	r3, #3
    312e:	9506      	str	r5, [sp, #24]
    3130:	18fb      	adds	r3, r7, r3

        if (cornername & 0x1) {
    3132:	9d0e      	ldr	r5, [sp, #56]	; 0x38
            ddF_y += 2;
            f     += ddF_y;
        }
        x++;
        ddF_x += 2;
        f     += ddF_x;
    3134:	b29b      	uxth	r3, r3
    3136:	960a      	str	r6, [sp, #40]	; 0x28
    3138:	9305      	str	r3, [sp, #20]

        if (cornername & 0x1) {
    313a:	07ed      	lsls	r5, r5, #31
    313c:	d52d      	bpl.n	319a <_ZN12Adafruit_GFX16fillCircleHelperEssshst+0xe0>
            writeFastVLine(x0+x, y0-y, 2*y+1+delta, color);
    313e:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    3140:	990f      	ldr	r1, [sp, #60]	; 0x3c
    3142:	b2bb      	uxth	r3, r7
    3144:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    3146:	9804      	ldr	r0, [sp, #16]
    3148:	b28e      	uxth	r6, r1
    314a:	9a06      	ldr	r2, [sp, #24]
    314c:	1c19      	adds	r1, r3, #0
    314e:	b2af      	uxth	r7, r5
    3150:	3101      	adds	r1, #1
    3152:	b285      	uxth	r5, r0
    3154:	1851      	adds	r1, r2, r1
    3156:	9703      	str	r7, [sp, #12]
    3158:	1b7a      	subs	r2, r7, r5
    315a:	9f09      	ldr	r7, [sp, #36]	; 0x24
    315c:	1c70      	adds	r0, r6, #1
    315e:	9700      	str	r7, [sp, #0]
    3160:	6827      	ldr	r7, [r4, #0]
    3162:	9307      	str	r3, [sp, #28]
    3164:	006b      	lsls	r3, r5, #1
    3166:	18c3      	adds	r3, r0, r3
    3168:	6a38      	ldr	r0, [r7, #32]
    316a:	b209      	sxth	r1, r1
    316c:	b212      	sxth	r2, r2
    316e:	b21b      	sxth	r3, r3
    3170:	4684      	mov	ip, r0
    3172:	1c20      	adds	r0, r4, #0
    3174:	47e0      	blx	ip
            writeFastVLine(x0+y, y0-x, 2*x+1+delta, color);
    3176:	9f07      	ldr	r7, [sp, #28]
    3178:	9a03      	ldr	r2, [sp, #12]
    317a:	19ed      	adds	r5, r5, r7
    317c:	b229      	sxth	r1, r5
    317e:	9d06      	ldr	r5, [sp, #24]
    3180:	3a01      	subs	r2, #1
    3182:	1b52      	subs	r2, r2, r5
    3184:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    3186:	9d09      	ldr	r5, [sp, #36]	; 0x24
    3188:	6820      	ldr	r0, [r4, #0]
    318a:	1cf3      	adds	r3, r6, #3
    318c:	18fb      	adds	r3, r7, r3
    318e:	9500      	str	r5, [sp, #0]
    3190:	6a06      	ldr	r6, [r0, #32]
    3192:	b212      	sxth	r2, r2
    3194:	b21b      	sxth	r3, r3
    3196:	1c20      	adds	r0, r4, #0
    3198:	47b0      	blx	r6
        }
        if (cornername & 0x2) {
    319a:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    319c:	07bf      	lsls	r7, r7, #30
    319e:	d52d      	bpl.n	31fc <_ZN12Adafruit_GFX16fillCircleHelperEssshst+0x142>
            writeFastVLine(x0-x, y0-y, 2*y+1+delta, color);
    31a0:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    31a2:	990f      	ldr	r1, [sp, #60]	; 0x3c
    31a4:	b2ab      	uxth	r3, r5
    31a6:	9804      	ldr	r0, [sp, #16]
    31a8:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    31aa:	b28e      	uxth	r6, r1
    31ac:	9a06      	ldr	r2, [sp, #24]
    31ae:	1c19      	adds	r1, r3, #0
    31b0:	b2af      	uxth	r7, r5
    31b2:	3901      	subs	r1, #1
    31b4:	b285      	uxth	r5, r0
    31b6:	1a89      	subs	r1, r1, r2
    31b8:	9703      	str	r7, [sp, #12]
    31ba:	1b7a      	subs	r2, r7, r5
    31bc:	9f09      	ldr	r7, [sp, #36]	; 0x24
    31be:	1c70      	adds	r0, r6, #1
    31c0:	9700      	str	r7, [sp, #0]
    31c2:	6827      	ldr	r7, [r4, #0]
    31c4:	9307      	str	r3, [sp, #28]
    31c6:	006b      	lsls	r3, r5, #1
    31c8:	18c3      	adds	r3, r0, r3
    31ca:	6a38      	ldr	r0, [r7, #32]
    31cc:	b209      	sxth	r1, r1
    31ce:	b212      	sxth	r2, r2
    31d0:	b21b      	sxth	r3, r3
    31d2:	4684      	mov	ip, r0
    31d4:	1c20      	adds	r0, r4, #0
    31d6:	47e0      	blx	ip
            writeFastVLine(x0-y, y0-x, 2*x+1+delta, color);
    31d8:	9f07      	ldr	r7, [sp, #28]
    31da:	9a03      	ldr	r2, [sp, #12]
    31dc:	1b7d      	subs	r5, r7, r5
    31de:	b229      	sxth	r1, r5
    31e0:	9d06      	ldr	r5, [sp, #24]
    31e2:	3a01      	subs	r2, #1
    31e4:	1b52      	subs	r2, r2, r5
    31e6:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    31e8:	9d09      	ldr	r5, [sp, #36]	; 0x24
    31ea:	6820      	ldr	r0, [r4, #0]
    31ec:	1cf3      	adds	r3, r6, #3
    31ee:	18fb      	adds	r3, r7, r3
    31f0:	9500      	str	r5, [sp, #0]
    31f2:	6a06      	ldr	r6, [r0, #32]
    31f4:	b212      	sxth	r2, r2
    31f6:	b21b      	sxth	r3, r3
    31f8:	1c20      	adds	r0, r4, #0
    31fa:	47b0      	blx	r6
    31fc:	9f08      	ldr	r7, [sp, #32]
    31fe:	3701      	adds	r7, #1
    3200:	e776      	b.n	30f0 <_ZN12Adafruit_GFX16fillCircleHelperEssshst+0x36>
        }
    }
}
    3202:	b011      	add	sp, #68	; 0x44
    3204:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003206 <_ZN12Adafruit_GFX10fillCircleEssst>:
        }
    }
}

void Adafruit_GFX::fillCircle(int16_t x0, int16_t y0, int16_t r,
        uint16_t color) {
    3206:	b5f0      	push	{r4, r5, r6, r7, lr}
    3208:	b087      	sub	sp, #28
    320a:	1c1d      	adds	r5, r3, #0
    320c:	ab0c      	add	r3, sp, #48	; 0x30
    320e:	881b      	ldrh	r3, [r3, #0]
    3210:	1c04      	adds	r4, r0, #0
    3212:	9305      	str	r3, [sp, #20]
    startWrite();
    3214:	6803      	ldr	r3, [r0, #0]
        }
    }
}

void Adafruit_GFX::fillCircle(int16_t x0, int16_t y0, int16_t r,
        uint16_t color) {
    3216:	1c0f      	adds	r7, r1, #0
    startWrite();
    3218:	695b      	ldr	r3, [r3, #20]
        }
    }
}

void Adafruit_GFX::fillCircle(int16_t x0, int16_t y0, int16_t r,
        uint16_t color) {
    321a:	1c16      	adds	r6, r2, #0
    startWrite();
    321c:	4798      	blx	r3
    writeFastVLine(x0, y0-r, 2*r+1, color);
    321e:	9805      	ldr	r0, [sp, #20]
    3220:	6821      	ldr	r1, [r4, #0]
    3222:	b2ab      	uxth	r3, r5
    3224:	9000      	str	r0, [sp, #0]
    3226:	6a08      	ldr	r0, [r1, #32]
    3228:	1af2      	subs	r2, r6, r3
    322a:	005b      	lsls	r3, r3, #1
    322c:	3301      	adds	r3, #1
    322e:	4684      	mov	ip, r0
    3230:	1c39      	adds	r1, r7, #0
    3232:	1c20      	adds	r0, r4, #0
    3234:	b212      	sxth	r2, r2
    3236:	b21b      	sxth	r3, r3
    3238:	47e0      	blx	ip
    fillCircleHelper(x0, y0, r, 3, 0, color);
    323a:	2303      	movs	r3, #3
    323c:	9300      	str	r3, [sp, #0]
    323e:	2300      	movs	r3, #0
    3240:	9301      	str	r3, [sp, #4]
    3242:	9b05      	ldr	r3, [sp, #20]
    3244:	1c20      	adds	r0, r4, #0
    3246:	9302      	str	r3, [sp, #8]
    3248:	1c39      	adds	r1, r7, #0
    324a:	1c32      	adds	r2, r6, #0
    324c:	1c2b      	adds	r3, r5, #0
    324e:	f7ff ff34 	bl	30ba <_ZN12Adafruit_GFX16fillCircleHelperEssshst>
    endWrite();
    3252:	6823      	ldr	r3, [r4, #0]
    3254:	1c20      	adds	r0, r4, #0
    3256:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3258:	4798      	blx	r3
}
    325a:	b007      	add	sp, #28
    325c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000325e <_ZN12Adafruit_GFX13drawRoundRectEssssst>:
    endWrite();
}

// Draw a rounded rectangle
void Adafruit_GFX::drawRoundRect(int16_t x, int16_t y, int16_t w,
        int16_t h, int16_t r, uint16_t color) {
    325e:	b5f0      	push	{r4, r5, r6, r7, lr}
    3260:	b08d      	sub	sp, #52	; 0x34
    3262:	1c1e      	adds	r6, r3, #0
    3264:	ab12      	add	r3, sp, #72	; 0x48
    3266:	910b      	str	r1, [sp, #44]	; 0x2c
    3268:	2100      	movs	r1, #0
    326a:	5e5f      	ldrsh	r7, [r3, r1]
    326c:	ab13      	add	r3, sp, #76	; 0x4c
    326e:	1c15      	adds	r5, r2, #0
    3270:	2100      	movs	r1, #0
    3272:	5e5a      	ldrsh	r2, [r3, r1]
    3274:	ab14      	add	r3, sp, #80	; 0x50
    3276:	881b      	ldrh	r3, [r3, #0]
    3278:	9205      	str	r2, [sp, #20]
    327a:	9303      	str	r3, [sp, #12]
    // smarter version
    startWrite();
    327c:	6803      	ldr	r3, [r0, #0]
    endWrite();
}

// Draw a rounded rectangle
void Adafruit_GFX::drawRoundRect(int16_t x, int16_t y, int16_t w,
        int16_t h, int16_t r, uint16_t color) {
    327e:	1c04      	adds	r4, r0, #0
    // smarter version
    startWrite();
    3280:	695b      	ldr	r3, [r3, #20]
    3282:	4798      	blx	r3
    writeFastHLine(x+r  , y    , w-2*r, color); // Top
    3284:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    3286:	9b05      	ldr	r3, [sp, #20]
    3288:	b292      	uxth	r2, r2
    328a:	b29b      	uxth	r3, r3
    328c:	9207      	str	r2, [sp, #28]
    328e:	9304      	str	r3, [sp, #16]
    3290:	18d2      	adds	r2, r2, r3
    3292:	005b      	lsls	r3, r3, #1
    3294:	425b      	negs	r3, r3
    3296:	b29b      	uxth	r3, r3
    3298:	b211      	sxth	r1, r2
    329a:	b2b6      	uxth	r6, r6
    329c:	9a03      	ldr	r2, [sp, #12]
    329e:	9608      	str	r6, [sp, #32]
    32a0:	9309      	str	r3, [sp, #36]	; 0x24
    32a2:	199e      	adds	r6, r3, r6
    32a4:	6823      	ldr	r3, [r4, #0]
    32a6:	9200      	str	r2, [sp, #0]
    32a8:	9106      	str	r1, [sp, #24]
    32aa:	6a59      	ldr	r1, [r3, #36]	; 0x24
    32ac:	b236      	sxth	r6, r6
    32ae:	468c      	mov	ip, r1
    32b0:	1c20      	adds	r0, r4, #0
    32b2:	9906      	ldr	r1, [sp, #24]
    32b4:	1c2a      	adds	r2, r5, #0
    32b6:	1c33      	adds	r3, r6, #0
    writeFastHLine(x+r  , y+h-1, w-2*r, color); // Bottom
    32b8:	b2bf      	uxth	r7, r7
// Draw a rounded rectangle
void Adafruit_GFX::drawRoundRect(int16_t x, int16_t y, int16_t w,
        int16_t h, int16_t r, uint16_t color) {
    // smarter version
    startWrite();
    writeFastHLine(x+r  , y    , w-2*r, color); // Top
    32ba:	47e0      	blx	ip
    writeFastHLine(x+r  , y+h-1, w-2*r, color); // Bottom
    32bc:	b2ad      	uxth	r5, r5
    32be:	1e7b      	subs	r3, r7, #1
    32c0:	18eb      	adds	r3, r5, r3
    32c2:	b29b      	uxth	r3, r3
    32c4:	930a      	str	r3, [sp, #40]	; 0x28
    32c6:	990a      	ldr	r1, [sp, #40]	; 0x28
    32c8:	6823      	ldr	r3, [r4, #0]
    32ca:	b20a      	sxth	r2, r1
    32cc:	9903      	ldr	r1, [sp, #12]
    32ce:	1c20      	adds	r0, r4, #0
    32d0:	9100      	str	r1, [sp, #0]
    32d2:	6a59      	ldr	r1, [r3, #36]	; 0x24
    32d4:	1c33      	adds	r3, r6, #0
    32d6:	468c      	mov	ip, r1
    32d8:	9906      	ldr	r1, [sp, #24]
    32da:	47e0      	blx	ip
    writeFastVLine(x    , y+r  , h-2*r, color); // Left
    32dc:	9a04      	ldr	r2, [sp, #16]
    32de:	9b09      	ldr	r3, [sp, #36]	; 0x24
    32e0:	9903      	ldr	r1, [sp, #12]
    32e2:	1955      	adds	r5, r2, r5
    32e4:	19df      	adds	r7, r3, r7
    32e6:	6823      	ldr	r3, [r4, #0]
    32e8:	b22d      	sxth	r5, r5
    32ea:	9100      	str	r1, [sp, #0]
    32ec:	b23f      	sxth	r7, r7
    32ee:	6a1e      	ldr	r6, [r3, #32]
    32f0:	1c20      	adds	r0, r4, #0
    32f2:	990b      	ldr	r1, [sp, #44]	; 0x2c
    32f4:	1c2a      	adds	r2, r5, #0
    32f6:	1c3b      	adds	r3, r7, #0
    32f8:	47b0      	blx	r6
    writeFastVLine(x+w-1, y+r  , h-2*r, color); // Right
    32fa:	9a07      	ldr	r2, [sp, #28]
    32fc:	9b08      	ldr	r3, [sp, #32]
    32fe:	1c20      	adds	r0, r4, #0
    3300:	18d6      	adds	r6, r2, r3
    3302:	9a03      	ldr	r2, [sp, #12]
    3304:	6823      	ldr	r3, [r4, #0]
    3306:	9200      	str	r2, [sp, #0]
    3308:	6a1a      	ldr	r2, [r3, #32]
    330a:	b2b6      	uxth	r6, r6
    330c:	1e71      	subs	r1, r6, #1
    330e:	4694      	mov	ip, r2
    3310:	1c3b      	adds	r3, r7, #0
    3312:	1c2a      	adds	r2, r5, #0
    3314:	b209      	sxth	r1, r1
    3316:	47e0      	blx	ip
    // draw four corners
    drawCircleHelper(x+r    , y+r    , r, 1, color);
    3318:	2301      	movs	r3, #1
    331a:	9300      	str	r3, [sp, #0]
    331c:	9b03      	ldr	r3, [sp, #12]
    331e:	1c20      	adds	r0, r4, #0
    3320:	9301      	str	r3, [sp, #4]
    3322:	9906      	ldr	r1, [sp, #24]
    3324:	1c2a      	adds	r2, r5, #0
    3326:	9b05      	ldr	r3, [sp, #20]
    3328:	f7ff fe09 	bl	2f3e <_ZN12Adafruit_GFX16drawCircleHelperEsssht>
    drawCircleHelper(x+w-r-1, y+r    , r, 2, color);
    332c:	9904      	ldr	r1, [sp, #16]
    332e:	9a03      	ldr	r2, [sp, #12]
    3330:	43cb      	mvns	r3, r1
    3332:	18f6      	adds	r6, r6, r3
    3334:	b236      	sxth	r6, r6
    3336:	2302      	movs	r3, #2
    3338:	9300      	str	r3, [sp, #0]
    333a:	9201      	str	r2, [sp, #4]
    333c:	1c20      	adds	r0, r4, #0
    333e:	1c31      	adds	r1, r6, #0
    3340:	1c2a      	adds	r2, r5, #0
    3342:	9b05      	ldr	r3, [sp, #20]
    3344:	f7ff fdfb 	bl	2f3e <_ZN12Adafruit_GFX16drawCircleHelperEsssht>
    drawCircleHelper(x+w-r-1, y+h-r-1, r, 4, color);
    3348:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    334a:	9904      	ldr	r1, [sp, #16]
    334c:	9a03      	ldr	r2, [sp, #12]
    334e:	1a5d      	subs	r5, r3, r1
    3350:	b22d      	sxth	r5, r5
    3352:	2304      	movs	r3, #4
    3354:	9300      	str	r3, [sp, #0]
    3356:	9201      	str	r2, [sp, #4]
    3358:	1c20      	adds	r0, r4, #0
    335a:	1c31      	adds	r1, r6, #0
    335c:	1c2a      	adds	r2, r5, #0
    335e:	9b05      	ldr	r3, [sp, #20]
    3360:	f7ff fded 	bl	2f3e <_ZN12Adafruit_GFX16drawCircleHelperEsssht>
    drawCircleHelper(x+r    , y+h-r-1, r, 8, color);
    3364:	2308      	movs	r3, #8
    3366:	9300      	str	r3, [sp, #0]
    3368:	9b03      	ldr	r3, [sp, #12]
    336a:	1c20      	adds	r0, r4, #0
    336c:	9301      	str	r3, [sp, #4]
    336e:	9906      	ldr	r1, [sp, #24]
    3370:	1c2a      	adds	r2, r5, #0
    3372:	9b05      	ldr	r3, [sp, #20]
    3374:	f7ff fde3 	bl	2f3e <_ZN12Adafruit_GFX16drawCircleHelperEsssht>
    endWrite();
    3378:	6823      	ldr	r3, [r4, #0]
    337a:	1c20      	adds	r0, r4, #0
    337c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    337e:	4798      	blx	r3
}
    3380:	b00d      	add	sp, #52	; 0x34
    3382:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003384 <_ZN12Adafruit_GFX13fillRoundRectEssssst>:

// Fill a rounded rectangle
void Adafruit_GFX::fillRoundRect(int16_t x, int16_t y, int16_t w,
        int16_t h, int16_t r, uint16_t color) {
    3384:	b5f0      	push	{r4, r5, r6, r7, lr}
    3386:	b08b      	sub	sp, #44	; 0x2c
    3388:	1c1d      	adds	r5, r3, #0
    338a:	ab10      	add	r3, sp, #64	; 0x40
    338c:	1c17      	adds	r7, r2, #0
    338e:	1c0e      	adds	r6, r1, #0
    3390:	2200      	movs	r2, #0
    3392:	5e99      	ldrsh	r1, [r3, r2]
    3394:	ab11      	add	r3, sp, #68	; 0x44
    3396:	9109      	str	r1, [sp, #36]	; 0x24
    3398:	2200      	movs	r2, #0
    339a:	5e99      	ldrsh	r1, [r3, r2]
    339c:	ab12      	add	r3, sp, #72	; 0x48
    339e:	881b      	ldrh	r3, [r3, #0]
    33a0:	9105      	str	r1, [sp, #20]
    33a2:	9306      	str	r3, [sp, #24]
    // smarter version
    startWrite();
    33a4:	6803      	ldr	r3, [r0, #0]
    endWrite();
}

// Fill a rounded rectangle
void Adafruit_GFX::fillRoundRect(int16_t x, int16_t y, int16_t w,
        int16_t h, int16_t r, uint16_t color) {
    33a6:	1c04      	adds	r4, r0, #0
    // smarter version
    startWrite();
    33a8:	695b      	ldr	r3, [r3, #20]
    33aa:	4798      	blx	r3
    writeFillRect(x+r, y, w-2*r, h, color);
    33ac:	9b05      	ldr	r3, [sp, #20]
    33ae:	b2ad      	uxth	r5, r5
    33b0:	b29b      	uxth	r3, r3
    33b2:	9508      	str	r5, [sp, #32]
    33b4:	005d      	lsls	r5, r3, #1
    33b6:	9908      	ldr	r1, [sp, #32]
    33b8:	426d      	negs	r5, r5
    33ba:	b2ad      	uxth	r5, r5
    33bc:	b2b6      	uxth	r6, r6
    33be:	9607      	str	r6, [sp, #28]
    33c0:	9304      	str	r3, [sp, #16]
    33c2:	18f6      	adds	r6, r6, r3
    33c4:	186b      	adds	r3, r5, r1
    33c6:	9909      	ldr	r1, [sp, #36]	; 0x24
    33c8:	6822      	ldr	r2, [r4, #0]
    33ca:	9100      	str	r1, [sp, #0]
    33cc:	9906      	ldr	r1, [sp, #24]
    33ce:	b236      	sxth	r6, r6
    33d0:	9101      	str	r1, [sp, #4]
    33d2:	69d1      	ldr	r1, [r2, #28]
    33d4:	1c20      	adds	r0, r4, #0
    33d6:	468c      	mov	ip, r1
    33d8:	1c3a      	adds	r2, r7, #0
    33da:	1c31      	adds	r1, r6, #0
    33dc:	b21b      	sxth	r3, r3
    33de:	47e0      	blx	ip

    // draw four corners
    fillCircleHelper(x+w-r-1, y+r, r, 1, h-2*r-1, color);
    33e0:	9a04      	ldr	r2, [sp, #16]
    33e2:	9908      	ldr	r1, [sp, #32]
    33e4:	19d3      	adds	r3, r2, r7
    33e6:	9f09      	ldr	r7, [sp, #36]	; 0x24
    33e8:	9a07      	ldr	r2, [sp, #28]
    33ea:	3f01      	subs	r7, #1
    33ec:	3901      	subs	r1, #1
    33ee:	19ef      	adds	r7, r5, r7
    33f0:	1851      	adds	r1, r2, r1
    33f2:	b21d      	sxth	r5, r3
    33f4:	9a04      	ldr	r2, [sp, #16]
    33f6:	2301      	movs	r3, #1
    33f8:	9300      	str	r3, [sp, #0]
    33fa:	9b06      	ldr	r3, [sp, #24]
    33fc:	b23f      	sxth	r7, r7
    33fe:	1a89      	subs	r1, r1, r2
    3400:	9302      	str	r3, [sp, #8]
    3402:	1c20      	adds	r0, r4, #0
    3404:	1c2a      	adds	r2, r5, #0
    3406:	9b05      	ldr	r3, [sp, #20]
    3408:	b209      	sxth	r1, r1
    340a:	9701      	str	r7, [sp, #4]
    340c:	f7ff fe55 	bl	30ba <_ZN12Adafruit_GFX16fillCircleHelperEssshst>
    fillCircleHelper(x+r    , y+r, r, 2, h-2*r-1, color);
    3410:	9906      	ldr	r1, [sp, #24]
    3412:	2302      	movs	r3, #2
    3414:	9300      	str	r3, [sp, #0]
    3416:	9102      	str	r1, [sp, #8]
    3418:	1c20      	adds	r0, r4, #0
    341a:	1c31      	adds	r1, r6, #0
    341c:	1c2a      	adds	r2, r5, #0
    341e:	9b05      	ldr	r3, [sp, #20]
    3420:	9701      	str	r7, [sp, #4]
    3422:	f7ff fe4a 	bl	30ba <_ZN12Adafruit_GFX16fillCircleHelperEssshst>
    endWrite();
    3426:	6823      	ldr	r3, [r4, #0]
    3428:	1c20      	adds	r0, r4, #0
    342a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    342c:	4798      	blx	r3
}
    342e:	b00b      	add	sp, #44	; 0x2c
    3430:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003432 <_ZN12Adafruit_GFX12drawTriangleEsssssst>:

// Draw a triangle
void Adafruit_GFX::drawTriangle(int16_t x0, int16_t y0,
        int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color) {
    3432:	b5f0      	push	{r4, r5, r6, r7, lr}
    3434:	b087      	sub	sp, #28
    3436:	1c1f      	adds	r7, r3, #0
    3438:	ab0c      	add	r3, sp, #48	; 0x30
    343a:	9102      	str	r1, [sp, #8]
    343c:	2100      	movs	r1, #0
    343e:	5e5e      	ldrsh	r6, [r3, r1]
    3440:	ab0d      	add	r3, sp, #52	; 0x34
    3442:	9203      	str	r2, [sp, #12]
    3444:	2100      	movs	r1, #0
    3446:	5e5a      	ldrsh	r2, [r3, r1]
    3448:	ab0e      	add	r3, sp, #56	; 0x38
    344a:	9204      	str	r2, [sp, #16]
    344c:	2100      	movs	r1, #0
    344e:	5e5a      	ldrsh	r2, [r3, r1]
    3450:	ab0f      	add	r3, sp, #60	; 0x3c
    3452:	881d      	ldrh	r5, [r3, #0]
    drawLine(x0, y0, x1, y1, color);
    3454:	6803      	ldr	r3, [r0, #0]
    3456:	9501      	str	r5, [sp, #4]
    3458:	9600      	str	r6, [sp, #0]
    endWrite();
}

// Draw a triangle
void Adafruit_GFX::drawTriangle(int16_t x0, int16_t y0,
        int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color) {
    345a:	9205      	str	r2, [sp, #20]
    drawLine(x0, y0, x1, y1, color);
    345c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    345e:	9902      	ldr	r1, [sp, #8]
    3460:	4694      	mov	ip, r2
    3462:	1c3b      	adds	r3, r7, #0
    3464:	9a03      	ldr	r2, [sp, #12]
    endWrite();
}

// Draw a triangle
void Adafruit_GFX::drawTriangle(int16_t x0, int16_t y0,
        int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color) {
    3466:	1c04      	adds	r4, r0, #0
    drawLine(x0, y0, x1, y1, color);
    3468:	47e0      	blx	ip
    drawLine(x1, y1, x2, y2, color);
    346a:	9905      	ldr	r1, [sp, #20]
    346c:	6823      	ldr	r3, [r4, #0]
    346e:	9100      	str	r1, [sp, #0]
    3470:	9501      	str	r5, [sp, #4]
    3472:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    3474:	1c20      	adds	r0, r4, #0
    3476:	4694      	mov	ip, r2
    3478:	1c39      	adds	r1, r7, #0
    347a:	1c32      	adds	r2, r6, #0
    347c:	9b04      	ldr	r3, [sp, #16]
    347e:	47e0      	blx	ip
    drawLine(x2, y2, x0, y0, color);
    3480:	9903      	ldr	r1, [sp, #12]
    3482:	6823      	ldr	r3, [r4, #0]
    3484:	9100      	str	r1, [sp, #0]
    3486:	9501      	str	r5, [sp, #4]
    3488:	6c9d      	ldr	r5, [r3, #72]	; 0x48
    348a:	1c20      	adds	r0, r4, #0
    348c:	9904      	ldr	r1, [sp, #16]
    348e:	9a05      	ldr	r2, [sp, #20]
    3490:	9b02      	ldr	r3, [sp, #8]
    3492:	47a8      	blx	r5
}
    3494:	b007      	add	sp, #28
    3496:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003498 <_ZN12Adafruit_GFX12fillTriangleEsssssst>:

// Fill a triangle
void Adafruit_GFX::fillTriangle(int16_t x0, int16_t y0,
        int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color) {
    3498:	b5f0      	push	{r4, r5, r6, r7, lr}
    349a:	b093      	sub	sp, #76	; 0x4c
    349c:	1c1e      	adds	r6, r3, #0
    349e:	ab18      	add	r3, sp, #96	; 0x60
    34a0:	1c0d      	adds	r5, r1, #0
    34a2:	1c04      	adds	r4, r0, #0
    34a4:	2100      	movs	r1, #0
    34a6:	5e58      	ldrsh	r0, [r3, r1]
    34a8:	ab19      	add	r3, sp, #100	; 0x64
    34aa:	9204      	str	r2, [sp, #16]
    34ac:	2200      	movs	r2, #0
    34ae:	5e9f      	ldrsh	r7, [r3, r2]
    34b0:	ab1a      	add	r3, sp, #104	; 0x68
    34b2:	9003      	str	r0, [sp, #12]
    34b4:	2100      	movs	r1, #0
    34b6:	5e58      	ldrsh	r0, [r3, r1]
    34b8:	ab1b      	add	r3, sp, #108	; 0x6c
    34ba:	881b      	ldrh	r3, [r3, #0]

    int16_t a, b, y, last;

    // Sort coordinates by Y order (y2 >= y1 >= y0)
    if (y0 > y1) {
    34bc:	9a04      	ldr	r2, [sp, #16]
    drawLine(x2, y2, x0, y0, color);
}

// Fill a triangle
void Adafruit_GFX::fillTriangle(int16_t x0, int16_t y0,
        int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color) {
    34be:	9309      	str	r3, [sp, #36]	; 0x24

    int16_t a, b, y, last;

    // Sort coordinates by Y order (y2 >= y1 >= y0)
    if (y0 > y1) {
    34c0:	9b03      	ldr	r3, [sp, #12]
    drawLine(x2, y2, x0, y0, color);
}

// Fill a triangle
void Adafruit_GFX::fillTriangle(int16_t x0, int16_t y0,
        int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color) {
    34c2:	9005      	str	r0, [sp, #20]

    int16_t a, b, y, last;

    // Sort coordinates by Y order (y2 >= y1 >= y0)
    if (y0 > y1) {
    34c4:	429a      	cmp	r2, r3
    34c6:	dd05      	ble.n	34d4 <_ZN12Adafruit_GFX12fillTriangleEsssssst+0x3c>
    34c8:	9803      	ldr	r0, [sp, #12]
    34ca:	1c2b      	adds	r3, r5, #0
    34cc:	9004      	str	r0, [sp, #16]
        _swap_int16_t(y0, y1); _swap_int16_t(x0, x1);
    34ce:	1c35      	adds	r5, r6, #0
    34d0:	9203      	str	r2, [sp, #12]
    34d2:	1c1e      	adds	r6, r3, #0
    }
    if (y1 > y2) {
    34d4:	9903      	ldr	r1, [sp, #12]
    34d6:	9a05      	ldr	r2, [sp, #20]
    34d8:	4291      	cmp	r1, r2
    34da:	dd04      	ble.n	34e6 <_ZN12Adafruit_GFX12fillTriangleEsssssst+0x4e>
    34dc:	1c33      	adds	r3, r6, #0
    34de:	9203      	str	r2, [sp, #12]
        _swap_int16_t(y2, y1); _swap_int16_t(x2, x1);
    34e0:	1c3e      	adds	r6, r7, #0
    34e2:	9105      	str	r1, [sp, #20]
    34e4:	1c1f      	adds	r7, r3, #0
    }
    if (y0 > y1) {
    34e6:	9b04      	ldr	r3, [sp, #16]
    34e8:	9803      	ldr	r0, [sp, #12]
    34ea:	4283      	cmp	r3, r0
    34ec:	dd04      	ble.n	34f8 <_ZN12Adafruit_GFX12fillTriangleEsssssst+0x60>
    34ee:	9303      	str	r3, [sp, #12]
    34f0:	1c2b      	adds	r3, r5, #0
    34f2:	9004      	str	r0, [sp, #16]
        _swap_int16_t(y0, y1); _swap_int16_t(x0, x1);
    34f4:	1c35      	adds	r5, r6, #0
    34f6:	1c1e      	adds	r6, r3, #0
    }

    startWrite();
    34f8:	6823      	ldr	r3, [r4, #0]
    34fa:	1c20      	adds	r0, r4, #0
    34fc:	695b      	ldr	r3, [r3, #20]
    34fe:	4798      	blx	r3
    if(y0 == y2) { // Handle awkward all-on-same-line case as its own thing
    3500:	9904      	ldr	r1, [sp, #16]
    3502:	9a05      	ldr	r2, [sp, #20]
    3504:	4291      	cmp	r1, r2
    3506:	d118      	bne.n	353a <_ZN12Adafruit_GFX12fillTriangleEsssssst+0xa2>
        a = b = x0;
        if(x1 < a)      a = x1;
    3508:	42ae      	cmp	r6, r5
    350a:	db02      	blt.n	3512 <_ZN12Adafruit_GFX12fillTriangleEsssssst+0x7a>
    350c:	1c33      	adds	r3, r6, #0
    350e:	1c2e      	adds	r6, r5, #0
    3510:	1c1d      	adds	r5, r3, #0
        else if(x1 > b) b = x1;
        if(x2 < a)      a = x2;
    3512:	42b7      	cmp	r7, r6
    3514:	db05      	blt.n	3522 <_ZN12Adafruit_GFX12fillTriangleEsssssst+0x8a>
    3516:	1c2b      	adds	r3, r5, #0
    3518:	42bd      	cmp	r5, r7
    351a:	da00      	bge.n	351e <_ZN12Adafruit_GFX12fillTriangleEsssssst+0x86>
    351c:	1c3b      	adds	r3, r7, #0
    351e:	b21d      	sxth	r5, r3
    3520:	1c37      	adds	r7, r6, #0
        else if(x2 > b) b = x2;
        writeFastHLine(a, y0, b-a+1, color);
    3522:	9809      	ldr	r0, [sp, #36]	; 0x24
    3524:	6822      	ldr	r2, [r4, #0]
    3526:	1c6b      	adds	r3, r5, #1
    3528:	9000      	str	r0, [sp, #0]
    352a:	1bdb      	subs	r3, r3, r7
    352c:	6a56      	ldr	r6, [r2, #36]	; 0x24
    352e:	b21b      	sxth	r3, r3
    3530:	1c20      	adds	r0, r4, #0
    3532:	1c39      	adds	r1, r7, #0
    3534:	9a04      	ldr	r2, [sp, #16]
    3536:	47b0      	blx	r6
    3538:	e094      	b.n	3664 <_ZN12Adafruit_GFX12fillTriangleEsssssst+0x1cc>
        endWrite();
        return;
    }

    int16_t
    dx01 = x1 - x0,
    353a:	b2b6      	uxth	r6, r6
    353c:	b2ad      	uxth	r5, r5
    dy01 = y1 - y0,
    353e:	9903      	ldr	r1, [sp, #12]
    3540:	9a04      	ldr	r2, [sp, #16]
        endWrite();
        return;
    }

    int16_t
    dx01 = x1 - x0,
    3542:	1b73      	subs	r3, r6, r5
    3544:	b29b      	uxth	r3, r3
    3546:	930d      	str	r3, [sp, #52]	; 0x34
    dy01 = y1 - y0,
    3548:	b28b      	uxth	r3, r1
    354a:	b291      	uxth	r1, r2
    354c:	1a5a      	subs	r2, r3, r1
    354e:	b292      	uxth	r2, r2
    dx02 = x2 - x0,
    3550:	b2bf      	uxth	r7, r7
        return;
    }

    int16_t
    dx01 = x1 - x0,
    dy01 = y1 - y0,
    3552:	920e      	str	r2, [sp, #56]	; 0x38
    dx02 = x2 - x0,
    dy02 = y2 - y0,
    3554:	9805      	ldr	r0, [sp, #20]
    }

    int16_t
    dx01 = x1 - x0,
    dy01 = y1 - y0,
    dx02 = x2 - x0,
    3556:	1b7a      	subs	r2, r7, r5
    3558:	b292      	uxth	r2, r2
    355a:	920f      	str	r2, [sp, #60]	; 0x3c
    dy02 = y2 - y0,
    355c:	b282      	uxth	r2, r0
    355e:	1a51      	subs	r1, r2, r1
    3560:	b289      	uxth	r1, r1
    3562:	910c      	str	r1, [sp, #48]	; 0x30
    dx12 = x2 - x1,
    3564:	1bbf      	subs	r7, r7, r6
    dy12 = y2 - y1;
    3566:	1ad2      	subs	r2, r2, r3
    // 0-1 and 0-2.  If y1=y2 (flat-bottomed triangle), the scanline y1
    // is included here (and second loop will be skipped, avoiding a /0
    // error there), otherwise scanline y1 is skipped here and handled
    // in the second loop...which also avoids a /0 error here if y0=y1
    // (flat-topped triangle).
    if(y1 == y2) last = y1;   // Include y1 scanline
    3568:	9903      	ldr	r1, [sp, #12]
    int16_t
    dx01 = x1 - x0,
    dy01 = y1 - y0,
    dx02 = x2 - x0,
    dy02 = y2 - y0,
    dx12 = x2 - x1,
    356a:	b2bf      	uxth	r7, r7
    dy12 = y2 - y1;
    356c:	b292      	uxth	r2, r2
        endWrite();
        return;
    }

    int16_t
    dx01 = x1 - x0,
    356e:	9608      	str	r6, [sp, #32]
    3570:	9507      	str	r5, [sp, #28]
    dy01 = y1 - y0,
    dx02 = x2 - x0,
    dy02 = y2 - y0,
    dx12 = x2 - x1,
    3572:	9710      	str	r7, [sp, #64]	; 0x40
    dy12 = y2 - y1;
    3574:	9211      	str	r2, [sp, #68]	; 0x44
    // 0-1 and 0-2.  If y1=y2 (flat-bottomed triangle), the scanline y1
    // is included here (and second loop will be skipped, avoiding a /0
    // error there), otherwise scanline y1 is skipped here and handled
    // in the second loop...which also avoids a /0 error here if y0=y1
    // (flat-topped triangle).
    if(y1 == y2) last = y1;   // Include y1 scanline
    3576:	4281      	cmp	r1, r0
    3578:	d003      	beq.n	3582 <_ZN12Adafruit_GFX12fillTriangleEsssssst+0xea>
    else         last = y1-1; // Skip it
    357a:	3b01      	subs	r3, #1
    357c:	b21a      	sxth	r2, r3
    357e:	920b      	str	r2, [sp, #44]	; 0x2c
    3580:	e001      	b.n	3586 <_ZN12Adafruit_GFX12fillTriangleEsssssst+0xee>
    3582:	9b03      	ldr	r3, [sp, #12]
    3584:	930b      	str	r3, [sp, #44]	; 0x2c
    dy02 = y2 - y0,
    dx12 = x2 - x1,
    dy12 = y2 - y1;
    int32_t
    sa   = 0,
    sb   = 0;
    3586:	2700      	movs	r7, #0
    // in the second loop...which also avoids a /0 error here if y0=y1
    // (flat-topped triangle).
    if(y1 == y2) last = y1;   // Include y1 scanline
    else         last = y1-1; // Skip it

    for(y=y0; y<=last; y++) {
    3588:	9e04      	ldr	r6, [sp, #16]
    dx02 = x2 - x0,
    dy02 = y2 - y0,
    dx12 = x2 - x1,
    dy12 = y2 - y1;
    int32_t
    sa   = 0,
    358a:	9706      	str	r7, [sp, #24]
    358c:	990f      	ldr	r1, [sp, #60]	; 0x3c
    // in the second loop...which also avoids a /0 error here if y0=y1
    // (flat-topped triangle).
    if(y1 == y2) last = y1;   // Include y1 scanline
    else         last = y1-1; // Skip it

    for(y=y0; y<=last; y++) {
    358e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    3590:	b209      	sxth	r1, r1
    3592:	910a      	str	r1, [sp, #40]	; 0x28
    3594:	4296      	cmp	r6, r2
    3596:	dc2b      	bgt.n	35f0 <_ZN12Adafruit_GFX12fillTriangleEsssssst+0x158>
        a   = x0 + sa / dy01;
    3598:	980e      	ldr	r0, [sp, #56]	; 0x38
    359a:	b201      	sxth	r1, r0
    359c:	9806      	ldr	r0, [sp, #24]
    359e:	f002 ffc1 	bl	6524 <__aeabi_idiv>
        b   = x0 + sb / dy02;
    35a2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    // (flat-topped triangle).
    if(y1 == y2) last = y1;   // Include y1 scanline
    else         last = y1-1; // Skip it

    for(y=y0; y<=last; y++) {
        a   = x0 + sa / dy01;
    35a4:	9907      	ldr	r1, [sp, #28]
    35a6:	180d      	adds	r5, r1, r0
        b   = x0 + sb / dy02;
    35a8:	b211      	sxth	r1, r2
    35aa:	1c38      	adds	r0, r7, #0
    35ac:	f002 ffba 	bl	6524 <__aeabi_idiv>
    35b0:	9907      	ldr	r1, [sp, #28]
    // (flat-topped triangle).
    if(y1 == y2) last = y1;   // Include y1 scanline
    else         last = y1-1; // Skip it

    for(y=y0; y<=last; y++) {
        a   = x0 + sa / dy01;
    35b2:	b2ad      	uxth	r5, r5
        b   = x0 + sb / dy02;
    35b4:	180b      	adds	r3, r1, r0
        sa += dx01;
    35b6:	980d      	ldr	r0, [sp, #52]	; 0x34
    35b8:	9906      	ldr	r1, [sp, #24]
    35ba:	b202      	sxth	r2, r0
    35bc:	1889      	adds	r1, r1, r2
        sb += dx02;
    35be:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    if(y1 == y2) last = y1;   // Include y1 scanline
    else         last = y1-1; // Skip it

    for(y=y0; y<=last; y++) {
        a   = x0 + sa / dy01;
        b   = x0 + sb / dy02;
    35c0:	b29b      	uxth	r3, r3
        sa += dx01;
    35c2:	9106      	str	r1, [sp, #24]
        sb += dx02;
    35c4:	18bf      	adds	r7, r7, r2
        /* longhand:
        a = x0 + (x1 - x0) * (y - y0) / (y1 - y0);
        b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);
        */
        if(a > b) _swap_int16_t(a,b);
    35c6:	b229      	sxth	r1, r5
    35c8:	b21a      	sxth	r2, r3
    35ca:	4291      	cmp	r1, r2
    35cc:	dc02      	bgt.n	35d4 <_ZN12Adafruit_GFX12fillTriangleEsssssst+0x13c>
    35ce:	1c1a      	adds	r2, r3, #0
    35d0:	1c2b      	adds	r3, r5, #0
    35d2:	1c15      	adds	r5, r2, #0
        writeFastHLine(a, y, b-a+1, color);
    35d4:	9809      	ldr	r0, [sp, #36]	; 0x24
    35d6:	6822      	ldr	r2, [r4, #0]
    35d8:	3501      	adds	r5, #1
    35da:	9000      	str	r0, [sp, #0]
    35dc:	b219      	sxth	r1, r3
    35de:	1aeb      	subs	r3, r5, r3
    35e0:	b21b      	sxth	r3, r3
    35e2:	6a55      	ldr	r5, [r2, #36]	; 0x24
    35e4:	1c20      	adds	r0, r4, #0
    35e6:	1c32      	adds	r2, r6, #0
    35e8:	3601      	adds	r6, #1
    35ea:	47a8      	blx	r5
    35ec:	b236      	sxth	r6, r6
    35ee:	e7cd      	b.n	358c <_ZN12Adafruit_GFX12fillTriangleEsssssst+0xf4>
    }

    // For lower part of triangle, find scanline crossings for segments
    // 0-2 and 1-2.  This loop is skipped if y1=y2.
    sa = dx12 * (y - y1);
    35f0:	9b10      	ldr	r3, [sp, #64]	; 0x40
    35f2:	9803      	ldr	r0, [sp, #12]
    35f4:	b21b      	sxth	r3, r3
    35f6:	9306      	str	r3, [sp, #24]
    35f8:	9906      	ldr	r1, [sp, #24]
    35fa:	1a33      	subs	r3, r6, r0
    sb = dx02 * (y - y0);
    35fc:	9a04      	ldr	r2, [sp, #16]
        writeFastHLine(a, y, b-a+1, color);
    }

    // For lower part of triangle, find scanline crossings for segments
    // 0-2 and 1-2.  This loop is skipped if y1=y2.
    sa = dx12 * (y - y1);
    35fe:	4359      	muls	r1, r3
    sb = dx02 * (y - y0);
    3600:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    3602:	1ab7      	subs	r7, r6, r2
    3604:	435f      	muls	r7, r3
        writeFastHLine(a, y, b-a+1, color);
    }

    // For lower part of triangle, find scanline crossings for segments
    // 0-2 and 1-2.  This loop is skipped if y1=y2.
    sa = dx12 * (y - y1);
    3606:	9103      	str	r1, [sp, #12]
    sb = dx02 * (y - y0);
    for(; y<=y2; y++) {
    3608:	9905      	ldr	r1, [sp, #20]
    360a:	428e      	cmp	r6, r1
    360c:	dc2a      	bgt.n	3664 <_ZN12Adafruit_GFX12fillTriangleEsssssst+0x1cc>
        a   = x1 + sa / dy12;
    360e:	9811      	ldr	r0, [sp, #68]	; 0x44
    3610:	b201      	sxth	r1, r0
    3612:	9803      	ldr	r0, [sp, #12]
    3614:	f002 ff86 	bl	6524 <__aeabi_idiv>
        b   = x0 + sb / dy02;
    3618:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    // For lower part of triangle, find scanline crossings for segments
    // 0-2 and 1-2.  This loop is skipped if y1=y2.
    sa = dx12 * (y - y1);
    sb = dx02 * (y - y0);
    for(; y<=y2; y++) {
        a   = x1 + sa / dy12;
    361a:	9908      	ldr	r1, [sp, #32]
    361c:	180d      	adds	r5, r1, r0
        b   = x0 + sb / dy02;
    361e:	b211      	sxth	r1, r2
    3620:	1c38      	adds	r0, r7, #0
    3622:	f002 ff7f 	bl	6524 <__aeabi_idiv>
    3626:	9907      	ldr	r1, [sp, #28]
        sa += dx12;
    3628:	9a03      	ldr	r2, [sp, #12]
    // 0-2 and 1-2.  This loop is skipped if y1=y2.
    sa = dx12 * (y - y1);
    sb = dx02 * (y - y0);
    for(; y<=y2; y++) {
        a   = x1 + sa / dy12;
        b   = x0 + sb / dy02;
    362a:	180b      	adds	r3, r1, r0
        sa += dx12;
    362c:	9806      	ldr	r0, [sp, #24]
        sb += dx02;
    362e:	990a      	ldr	r1, [sp, #40]	; 0x28
    sa = dx12 * (y - y1);
    sb = dx02 * (y - y0);
    for(; y<=y2; y++) {
        a   = x1 + sa / dy12;
        b   = x0 + sb / dy02;
        sa += dx12;
    3630:	1812      	adds	r2, r2, r0
    // For lower part of triangle, find scanline crossings for segments
    // 0-2 and 1-2.  This loop is skipped if y1=y2.
    sa = dx12 * (y - y1);
    sb = dx02 * (y - y0);
    for(; y<=y2; y++) {
        a   = x1 + sa / dy12;
    3632:	b2ad      	uxth	r5, r5
        b   = x0 + sb / dy02;
    3634:	b29b      	uxth	r3, r3
        sa += dx12;
    3636:	9203      	str	r2, [sp, #12]
        sb += dx02;
    3638:	187f      	adds	r7, r7, r1
        /* longhand:
        a = x1 + (x2 - x1) * (y - y1) / (y2 - y1);
        b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);
        */
        if(a > b) _swap_int16_t(a,b);
    363a:	b21a      	sxth	r2, r3
    363c:	b229      	sxth	r1, r5
    363e:	4291      	cmp	r1, r2
    3640:	dc02      	bgt.n	3648 <_ZN12Adafruit_GFX12fillTriangleEsssssst+0x1b0>
    3642:	1c1a      	adds	r2, r3, #0
    3644:	1c2b      	adds	r3, r5, #0
    3646:	1c15      	adds	r5, r2, #0
        writeFastHLine(a, y, b-a+1, color);
    3648:	9809      	ldr	r0, [sp, #36]	; 0x24
    364a:	6822      	ldr	r2, [r4, #0]
    364c:	3501      	adds	r5, #1
    364e:	9000      	str	r0, [sp, #0]
    3650:	b219      	sxth	r1, r3
    3652:	1aeb      	subs	r3, r5, r3
    3654:	b21b      	sxth	r3, r3
    3656:	6a55      	ldr	r5, [r2, #36]	; 0x24
    3658:	1c20      	adds	r0, r4, #0
    365a:	1c32      	adds	r2, r6, #0
    365c:	3601      	adds	r6, #1
    365e:	47a8      	blx	r5
    3660:	b236      	sxth	r6, r6
    3662:	e7d1      	b.n	3608 <_ZN12Adafruit_GFX12fillTriangleEsssssst+0x170>
    }
    endWrite();
    3664:	6823      	ldr	r3, [r4, #0]
    3666:	1c20      	adds	r0, r4, #0
    3668:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    366a:	4798      	blx	r3
}
    366c:	b013      	add	sp, #76	; 0x4c
    366e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003670 <_ZN12Adafruit_GFX8drawCharEsshtth>:

// TEXT- AND CHARACTER-HANDLING FUNCTIONS ----------------------------------

// Draw a character
void Adafruit_GFX::drawChar(int16_t x, int16_t y, unsigned char c,
  uint16_t color, uint16_t bg, uint8_t size) {
    3670:	b5f0      	push	{r4, r5, r6, r7, lr}
    3672:	b095      	sub	sp, #84	; 0x54
    3674:	1c1e      	adds	r6, r3, #0
    3676:	ab1a      	add	r3, sp, #104	; 0x68
    3678:	881b      	ldrh	r3, [r3, #0]
    367a:	1c04      	adds	r4, r0, #0
    367c:	930a      	str	r3, [sp, #40]	; 0x28
    367e:	ab1b      	add	r3, sp, #108	; 0x6c
    3680:	881b      	ldrh	r3, [r3, #0]
    3682:	9106      	str	r1, [sp, #24]
    3684:	9304      	str	r3, [sp, #16]
    3686:	ab1c      	add	r3, sp, #112	; 0x70
    3688:	781d      	ldrb	r5, [r3, #0]

    if(!gfxFont) { // 'Classic' built-in font
    368a:	69c3      	ldr	r3, [r0, #28]

// TEXT- AND CHARACTER-HANDLING FUNCTIONS ----------------------------------

// Draw a character
void Adafruit_GFX::drawChar(int16_t x, int16_t y, unsigned char c,
  uint16_t color, uint16_t bg, uint8_t size) {
    368c:	9209      	str	r2, [sp, #36]	; 0x24

    if(!gfxFont) { // 'Classic' built-in font
    368e:	2b00      	cmp	r3, #0
    3690:	d000      	beq.n	3694 <_ZN12Adafruit_GFX8drawCharEsshtth+0x24>
    3692:	e0b1      	b.n	37f8 <_ZN12Adafruit_GFX8drawCharEsshtth+0x188>

        if((x >= _width)            || // Clip right
    3694:	200c      	movs	r0, #12
    3696:	5e23      	ldrsh	r3, [r4, r0]
    3698:	428b      	cmp	r3, r1
    369a:	dc00      	bgt.n	369e <_ZN12Adafruit_GFX8drawCharEsshtth+0x2e>
    369c:	e136      	b.n	390c <_ZN12Adafruit_GFX8drawCharEsshtth+0x29c>
    369e:	210e      	movs	r1, #14
    36a0:	5e63      	ldrsh	r3, [r4, r1]
    36a2:	4293      	cmp	r3, r2
    36a4:	dc00      	bgt.n	36a8 <_ZN12Adafruit_GFX8drawCharEsshtth+0x38>
    36a6:	e131      	b.n	390c <_ZN12Adafruit_GFX8drawCharEsshtth+0x29c>
           (y >= _height)           || // Clip bottom
           ((x + 6 * size - 1) < 0) || // Clip left
    36a8:	2306      	movs	r3, #6
    36aa:	436b      	muls	r3, r5
    36ac:	9a06      	ldr	r2, [sp, #24]
    36ae:	18d3      	adds	r3, r2, r3
  uint16_t color, uint16_t bg, uint8_t size) {

    if(!gfxFont) { // 'Classic' built-in font

        if((x >= _width)            || // Clip right
           (y >= _height)           || // Clip bottom
    36b0:	2b00      	cmp	r3, #0
    36b2:	dc00      	bgt.n	36b6 <_ZN12Adafruit_GFX8drawCharEsshtth+0x46>
    36b4:	e12a      	b.n	390c <_ZN12Adafruit_GFX8drawCharEsshtth+0x29c>
           ((x + 6 * size - 1) < 0) || // Clip left
           ((y + 8 * size - 1) < 0))   // Clip top
    36b6:	9809      	ldr	r0, [sp, #36]	; 0x24
    36b8:	00eb      	lsls	r3, r5, #3
    36ba:	18c3      	adds	r3, r0, r3

    if(!gfxFont) { // 'Classic' built-in font

        if((x >= _width)            || // Clip right
           (y >= _height)           || // Clip bottom
           ((x + 6 * size - 1) < 0) || // Clip left
    36bc:	2b00      	cmp	r3, #0
    36be:	dc00      	bgt.n	36c2 <_ZN12Adafruit_GFX8drawCharEsshtth+0x52>
    36c0:	e124      	b.n	390c <_ZN12Adafruit_GFX8drawCharEsshtth+0x29c>
           ((y + 8 * size - 1) < 0))   // Clip top
            return;

        if(!_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior
    36c2:	7ee3      	ldrb	r3, [r4, #27]
    36c4:	2b00      	cmp	r3, #0
    36c6:	d103      	bne.n	36d0 <_ZN12Adafruit_GFX8drawCharEsshtth+0x60>
    36c8:	2eaf      	cmp	r6, #175	; 0xaf
    36ca:	d901      	bls.n	36d0 <_ZN12Adafruit_GFX8drawCharEsshtth+0x60>
    36cc:	3601      	adds	r6, #1
    36ce:	b2f6      	uxtb	r6, r6

        startWrite();
    36d0:	6823      	ldr	r3, [r4, #0]
    36d2:	1c20      	adds	r0, r4, #0
    36d4:	695b      	ldr	r3, [r3, #20]
    36d6:	4798      	blx	r3
        for(int8_t i=0; i<5; i++ ) { // Char bitmap = 5 columns
            uint8_t line = pgm_read_byte(&font[c * 5 + i]);
    36d8:	2305      	movs	r3, #5
    36da:	435e      	muls	r6, r3
            return;

        if(!_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior

        startWrite();
        for(int8_t i=0; i<5; i++ ) { // Char bitmap = 5 columns
    36dc:	2100      	movs	r1, #0
            uint8_t line = pgm_read_byte(&font[c * 5 + i]);
    36de:	960f      	str	r6, [sp, #60]	; 0x3c
    36e0:	930d      	str	r3, [sp, #52]	; 0x34
            return;

        if(!_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior

        startWrite();
        for(int8_t i=0; i<5; i++ ) { // Char bitmap = 5 columns
    36e2:	9108      	str	r1, [sp, #32]
            uint8_t line = pgm_read_byte(&font[c * 5 + i]);
    36e4:	9a08      	ldr	r2, [sp, #32]
    36e6:	980f      	ldr	r0, [sp, #60]	; 0x3c
    36e8:	b253      	sxtb	r3, r2
    36ea:	4a89      	ldr	r2, [pc, #548]	; (3910 <_ZN12Adafruit_GFX8drawCharEsshtth+0x2a0>)
            for(int8_t j=0; j<8; j++, line >>= 1) {
                if(line & 1) {
                    if(size == 1)
                        writePixel(x+i, y+j, color);
                    else
                        writeFillRect(x+i*size, y+j*size, size, size, color);
    36ec:	9906      	ldr	r1, [sp, #24]

        if(!_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior

        startWrite();
        for(int8_t i=0; i<5; i++ ) { // Char bitmap = 5 columns
            uint8_t line = pgm_read_byte(&font[c * 5 + i]);
    36ee:	1812      	adds	r2, r2, r0
    36f0:	5cd2      	ldrb	r2, [r2, r3]
            for(int8_t j=0; j<8; j++, line >>= 1) {
                if(line & 1) {
                    if(size == 1)
                        writePixel(x+i, y+j, color);
                    else
                        writeFillRect(x+i*size, y+j*size, size, size, color);
    36f2:	b29b      	uxth	r3, r3
    36f4:	9307      	str	r3, [sp, #28]
    36f6:	436b      	muls	r3, r5
    36f8:	b289      	uxth	r1, r1

        if(!_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior

        startWrite();
        for(int8_t i=0; i<5; i++ ) { // Char bitmap = 5 columns
            uint8_t line = pgm_read_byte(&font[c * 5 + i]);
    36fa:	920b      	str	r2, [sp, #44]	; 0x2c
    36fc:	9a09      	ldr	r2, [sp, #36]	; 0x24
            for(int8_t j=0; j<8; j++, line >>= 1) {
                if(line & 1) {
                    if(size == 1)
                        writePixel(x+i, y+j, color);
                    else
                        writeFillRect(x+i*size, y+j*size, size, size, color);
    36fe:	18cb      	adds	r3, r1, r3
    3700:	b296      	uxth	r6, r2
    3702:	b29b      	uxth	r3, r3
    3704:	930e      	str	r3, [sp, #56]	; 0x38
    3706:	1c33      	adds	r3, r6, #0
    3708:	3308      	adds	r3, #8
    370a:	b29b      	uxth	r3, r3
    370c:	9105      	str	r1, [sp, #20]
    370e:	9310      	str	r3, [sp, #64]	; 0x40
                } else if(bg != color) {
                    if(size == 1)
                        writePixel(x+i, y+j, bg);
                    else
                        writeFillRect(x+i*size, y+j*size, size, size, bg);
    3710:	1c37      	adds	r7, r6, #0
    3712:	960c      	str	r6, [sp, #48]	; 0x30

        startWrite();
        for(int8_t i=0; i<5; i++ ) { // Char bitmap = 5 columns
            uint8_t line = pgm_read_byte(&font[c * 5 + i]);
            for(int8_t j=0; j<8; j++, line >>= 1) {
                if(line & 1) {
    3714:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3716:	07db      	lsls	r3, r3, #31
    3718:	d514      	bpl.n	3744 <_ZN12Adafruit_GFX8drawCharEsshtth+0xd4>
    371a:	6820      	ldr	r0, [r4, #0]
                    if(size == 1)
    371c:	2d01      	cmp	r5, #1
    371e:	d109      	bne.n	3734 <_ZN12Adafruit_GFX8drawCharEsshtth+0xc4>
                        writePixel(x+i, y+j, color);
    3720:	9a07      	ldr	r2, [sp, #28]
    3722:	9b05      	ldr	r3, [sp, #20]
    3724:	18d1      	adds	r1, r2, r3
    3726:	6983      	ldr	r3, [r0, #24]
    3728:	b209      	sxth	r1, r1
    372a:	469c      	mov	ip, r3
    372c:	b23a      	sxth	r2, r7
    372e:	1c20      	adds	r0, r4, #0
    3730:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    3732:	e017      	b.n	3764 <_ZN12Adafruit_GFX8drawCharEsshtth+0xf4>
                    else
                        writeFillRect(x+i*size, y+j*size, size, size, color);
    3734:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    3736:	b233      	sxth	r3, r6
    3738:	9311      	str	r3, [sp, #68]	; 0x44
    373a:	b22b      	sxth	r3, r5
    373c:	b211      	sxth	r1, r2
    373e:	9300      	str	r3, [sp, #0]
    3740:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    3742:	e019      	b.n	3778 <_ZN12Adafruit_GFX8drawCharEsshtth+0x108>
                } else if(bg != color) {
    3744:	9b04      	ldr	r3, [sp, #16]
    3746:	980a      	ldr	r0, [sp, #40]	; 0x28
    3748:	4283      	cmp	r3, r0
    374a:	d01b      	beq.n	3784 <_ZN12Adafruit_GFX8drawCharEsshtth+0x114>
    374c:	6820      	ldr	r0, [r4, #0]
                    if(size == 1)
    374e:	2d01      	cmp	r5, #1
    3750:	d10a      	bne.n	3768 <_ZN12Adafruit_GFX8drawCharEsshtth+0xf8>
                        writePixel(x+i, y+j, bg);
    3752:	9a07      	ldr	r2, [sp, #28]
    3754:	9b05      	ldr	r3, [sp, #20]
    3756:	18d1      	adds	r1, r2, r3
    3758:	6983      	ldr	r3, [r0, #24]
    375a:	b209      	sxth	r1, r1
    375c:	469c      	mov	ip, r3
    375e:	9b04      	ldr	r3, [sp, #16]
    3760:	b23a      	sxth	r2, r7
    3762:	1c20      	adds	r0, r4, #0
    3764:	47e0      	blx	ip
    3766:	e00d      	b.n	3784 <_ZN12Adafruit_GFX8drawCharEsshtth+0x114>
                    else
                        writeFillRect(x+i*size, y+j*size, size, size, bg);
    3768:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    376a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    376c:	b21b      	sxth	r3, r3
    376e:	b211      	sxth	r1, r2
    3770:	9311      	str	r3, [sp, #68]	; 0x44
    3772:	9a04      	ldr	r2, [sp, #16]
    3774:	b22b      	sxth	r3, r5
    3776:	9300      	str	r3, [sp, #0]
    3778:	9201      	str	r2, [sp, #4]
    377a:	69c2      	ldr	r2, [r0, #28]
    377c:	1c20      	adds	r0, r4, #0
    377e:	4694      	mov	ip, r2
    3780:	9a11      	ldr	r2, [sp, #68]	; 0x44
    3782:	47e0      	blx	ip
        if(!_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior

        startWrite();
        for(int8_t i=0; i<5; i++ ) { // Char bitmap = 5 columns
            uint8_t line = pgm_read_byte(&font[c * 5 + i]);
            for(int8_t j=0; j<8; j++, line >>= 1) {
    3784:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3786:	980c      	ldr	r0, [sp, #48]	; 0x30
    3788:	085b      	lsrs	r3, r3, #1
    378a:	930b      	str	r3, [sp, #44]	; 0x2c
    378c:	3701      	adds	r7, #1
    378e:	1943      	adds	r3, r0, r5
    3790:	9910      	ldr	r1, [sp, #64]	; 0x40
    3792:	1976      	adds	r6, r6, r5
    3794:	b29b      	uxth	r3, r3
    3796:	b2bf      	uxth	r7, r7
    3798:	b2b6      	uxth	r6, r6
    379a:	930c      	str	r3, [sp, #48]	; 0x30
    379c:	428f      	cmp	r7, r1
    379e:	d1b9      	bne.n	3714 <_ZN12Adafruit_GFX8drawCharEsshtth+0xa4>
            return;

        if(!_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior

        startWrite();
        for(int8_t i=0; i<5; i++ ) { // Char bitmap = 5 columns
    37a0:	9b08      	ldr	r3, [sp, #32]
    37a2:	3301      	adds	r3, #1
    37a4:	b2db      	uxtb	r3, r3
    37a6:	9308      	str	r3, [sp, #32]
    37a8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    37aa:	3b01      	subs	r3, #1
    37ac:	b2db      	uxtb	r3, r3
    37ae:	930d      	str	r3, [sp, #52]	; 0x34
    37b0:	2b00      	cmp	r3, #0
    37b2:	d197      	bne.n	36e4 <_ZN12Adafruit_GFX8drawCharEsshtth+0x74>
                    else
                        writeFillRect(x+i*size, y+j*size, size, size, bg);
                }
            }
        }
        if(bg != color) { // If opaque, draw vertical line for last column
    37b4:	9a04      	ldr	r2, [sp, #16]
    37b6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    37b8:	429a      	cmp	r2, r3
    37ba:	d100      	bne.n	37be <_ZN12Adafruit_GFX8drawCharEsshtth+0x14e>
    37bc:	e0a2      	b.n	3904 <_ZN12Adafruit_GFX8drawCharEsshtth+0x294>
    37be:	6822      	ldr	r2, [r4, #0]
            if(size == 1) writeFastVLine(x+5, y, 8, bg);
    37c0:	2d01      	cmp	r5, #1
    37c2:	d10a      	bne.n	37da <_ZN12Adafruit_GFX8drawCharEsshtth+0x16a>
    37c4:	9804      	ldr	r0, [sp, #16]
    37c6:	9905      	ldr	r1, [sp, #20]
    37c8:	9000      	str	r0, [sp, #0]
    37ca:	3105      	adds	r1, #5
    37cc:	6a15      	ldr	r5, [r2, #32]
    37ce:	b209      	sxth	r1, r1
    37d0:	1c20      	adds	r0, r4, #0
    37d2:	9a09      	ldr	r2, [sp, #36]	; 0x24
    37d4:	2308      	movs	r3, #8
    37d6:	47a8      	blx	r5
    37d8:	e094      	b.n	3904 <_ZN12Adafruit_GFX8drawCharEsshtth+0x294>
            else          writeFillRect(x+5*size, y, size, 8*size, bg);
    37da:	2105      	movs	r1, #5
    37dc:	4369      	muls	r1, r5
    37de:	9b05      	ldr	r3, [sp, #20]
    37e0:	9804      	ldr	r0, [sp, #16]
    37e2:	1859      	adds	r1, r3, r1
    37e4:	b22b      	sxth	r3, r5
    37e6:	00ed      	lsls	r5, r5, #3
    37e8:	9001      	str	r0, [sp, #4]
    37ea:	9500      	str	r5, [sp, #0]
    37ec:	69d5      	ldr	r5, [r2, #28]
    37ee:	b209      	sxth	r1, r1
    37f0:	1c20      	adds	r0, r4, #0
    37f2:	9a09      	ldr	r2, [sp, #36]	; 0x24
    37f4:	47a8      	blx	r5
    37f6:	e085      	b.n	3904 <_ZN12Adafruit_GFX8drawCharEsshtth+0x294>

        // Character is assumed previously filtered by write() to eliminate
        // newlines, returns, non-printable characters, etc.  Calling
        // drawChar() directly with 'bad' characters of font may cause mayhem!

        c -= (uint8_t)pgm_read_byte(&gfxFont->first);
    37f8:	7a1a      	ldrb	r2, [r3, #8]
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&gfxFont->glyph))[c]);
    37fa:	6859      	ldr	r1, [r3, #4]

        // Character is assumed previously filtered by write() to eliminate
        // newlines, returns, non-printable characters, etc.  Calling
        // drawChar() directly with 'bad' characters of font may cause mayhem!

        c -= (uint8_t)pgm_read_byte(&gfxFont->first);
    37fc:	1ab6      	subs	r6, r6, r2
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&gfxFont->glyph))[c]);
    37fe:	b2f6      	uxtb	r6, r6
        uint8_t  *bitmap = (uint8_t *)pgm_read_pointer(&gfxFont->bitmap);
    3800:	681b      	ldr	r3, [r3, #0]
        // Character is assumed previously filtered by write() to eliminate
        // newlines, returns, non-printable characters, etc.  Calling
        // drawChar() directly with 'bad' characters of font may cause mayhem!

        c -= (uint8_t)pgm_read_byte(&gfxFont->first);
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&gfxFont->glyph))[c]);
    3802:	00f6      	lsls	r6, r6, #3
    3804:	1876      	adds	r6, r6, r1
        uint8_t  *bitmap = (uint8_t *)pgm_read_pointer(&gfxFont->bitmap);

        uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
    3806:	8832      	ldrh	r2, [r6, #0]
        uint8_t  w  = pgm_read_byte(&glyph->width),
                 h  = pgm_read_byte(&glyph->height);
    3808:	78f0      	ldrb	r0, [r6, #3]
        int8_t   xo = pgm_read_byte(&glyph->xOffset),
    380a:	7971      	ldrb	r1, [r6, #5]
        // newlines, returns, non-printable characters, etc.  Calling
        // drawChar() directly with 'bad' characters of font may cause mayhem!

        c -= (uint8_t)pgm_read_byte(&gfxFont->first);
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&gfxFont->glyph))[c]);
        uint8_t  *bitmap = (uint8_t *)pgm_read_pointer(&gfxFont->bitmap);
    380c:	9311      	str	r3, [sp, #68]	; 0x44

        uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
        uint8_t  w  = pgm_read_byte(&glyph->width),
    380e:	78b3      	ldrb	r3, [r6, #2]
                 h  = pgm_read_byte(&glyph->height);
        int8_t   xo = pgm_read_byte(&glyph->xOffset),
                 yo = pgm_read_byte(&glyph->yOffset);
    3810:	79b6      	ldrb	r6, [r6, #6]

        c -= (uint8_t)pgm_read_byte(&gfxFont->first);
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&gfxFont->glyph))[c]);
        uint8_t  *bitmap = (uint8_t *)pgm_read_pointer(&gfxFont->bitmap);

        uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
    3812:	9205      	str	r2, [sp, #20]
        uint8_t  w  = pgm_read_byte(&glyph->width),
    3814:	930c      	str	r3, [sp, #48]	; 0x30
                 h  = pgm_read_byte(&glyph->height);
    3816:	9012      	str	r0, [sp, #72]	; 0x48
        int8_t   xo = pgm_read_byte(&glyph->xOffset),
    3818:	910d      	str	r1, [sp, #52]	; 0x34
                 yo = pgm_read_byte(&glyph->yOffset);
    381a:	960e      	str	r6, [sp, #56]	; 0x38
        uint8_t  xx, yy, bits = 0, bit = 0;
        int16_t  xo16 = 0, yo16 = 0;

        if(size > 1) {
    381c:	2d01      	cmp	r5, #1
    381e:	d906      	bls.n	382e <_ZN12Adafruit_GFX8drawCharEsshtth+0x1be>
            xo16 = xo;
            yo16 = yo;
    3820:	9a0e      	ldr	r2, [sp, #56]	; 0x38
                 yo = pgm_read_byte(&glyph->yOffset);
        uint8_t  xx, yy, bits = 0, bit = 0;
        int16_t  xo16 = 0, yo16 = 0;

        if(size > 1) {
            xo16 = xo;
    3822:	b24e      	sxtb	r6, r1
            yo16 = yo;
    3824:	b253      	sxtb	r3, r2
    3826:	b29b      	uxth	r3, r3
                 yo = pgm_read_byte(&glyph->yOffset);
        uint8_t  xx, yy, bits = 0, bit = 0;
        int16_t  xo16 = 0, yo16 = 0;

        if(size > 1) {
            xo16 = xo;
    3828:	b2b6      	uxth	r6, r6
            yo16 = yo;
    382a:	9307      	str	r3, [sp, #28]
    382c:	e002      	b.n	3834 <_ZN12Adafruit_GFX8drawCharEsshtth+0x1c4>
        uint8_t  w  = pgm_read_byte(&glyph->width),
                 h  = pgm_read_byte(&glyph->height);
        int8_t   xo = pgm_read_byte(&glyph->xOffset),
                 yo = pgm_read_byte(&glyph->yOffset);
        uint8_t  xx, yy, bits = 0, bit = 0;
        int16_t  xo16 = 0, yo16 = 0;
    382e:	2300      	movs	r3, #0
    3830:	9307      	str	r3, [sp, #28]
    3832:	1c1e      	adds	r6, r3, #0
        // only creates a new set of problems.  Have an idea to work around
        // this (a canvas object type for MCUs that can afford the RAM and
        // displays supporting setAddrWindow() and pushColors()), but haven't
        // implemented this yet.

        startWrite();
    3834:	6823      	ldr	r3, [r4, #0]
    3836:	1c20      	adds	r0, r4, #0
    3838:	695b      	ldr	r3, [r3, #20]
    383a:	436e      	muls	r6, r5
    383c:	4798      	blx	r3
    383e:	9806      	ldr	r0, [sp, #24]
    3840:	b280      	uxth	r0, r0
    3842:	1986      	adds	r6, r0, r6
    3844:	b2b6      	uxth	r6, r6
    3846:	9610      	str	r6, [sp, #64]	; 0x40
        for(yy=0; yy<h; yy++) {
    3848:	2600      	movs	r6, #0
    384a:	900b      	str	r0, [sp, #44]	; 0x2c
        uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
        uint8_t  w  = pgm_read_byte(&glyph->width),
                 h  = pgm_read_byte(&glyph->height);
        int8_t   xo = pgm_read_byte(&glyph->xOffset),
                 yo = pgm_read_byte(&glyph->yOffset);
        uint8_t  xx, yy, bits = 0, bit = 0;
    384c:	9606      	str	r6, [sp, #24]
    384e:	9604      	str	r6, [sp, #16]
        // this (a canvas object type for MCUs that can afford the RAM and
        // displays supporting setAddrWindow() and pushColors()), but haven't
        // implemented this yet.

        startWrite();
        for(yy=0; yy<h; yy++) {
    3850:	9a12      	ldr	r2, [sp, #72]	; 0x48
    3852:	b2f3      	uxtb	r3, r6
    3854:	4293      	cmp	r3, r2
    3856:	d255      	bcs.n	3904 <_ZN12Adafruit_GFX8drawCharEsshtth+0x294>
                if(bits & 0x80) {
                    if(size == 1) {
                        writePixel(x+xo+xx, y+yo+yy, color);
                    } else {
                        writeFillRect(x+(xo16+xx)*size, y+(yo16+yy)*size,
                          size, size, color);
    3858:	9b09      	ldr	r3, [sp, #36]	; 0x24
    385a:	9807      	ldr	r0, [sp, #28]
    385c:	b29b      	uxth	r3, r3
    385e:	930f      	str	r3, [sp, #60]	; 0x3c
    3860:	1833      	adds	r3, r6, r0
    3862:	436b      	muls	r3, r5
    3864:	990f      	ldr	r1, [sp, #60]	; 0x3c
    3866:	9a10      	ldr	r2, [sp, #64]	; 0x40
    3868:	18cb      	adds	r3, r1, r3
    386a:	b29b      	uxth	r3, r3
    386c:	9313      	str	r3, [sp, #76]	; 0x4c
    386e:	9208      	str	r2, [sp, #32]
    3870:	2700      	movs	r7, #0
    3872:	9806      	ldr	r0, [sp, #24]
    3874:	b2fb      	uxtb	r3, r7
        // displays supporting setAddrWindow() and pushColors()), but haven't
        // implemented this yet.

        startWrite();
        for(yy=0; yy<h; yy++) {
            for(xx=0; xx<w; xx++) {
    3876:	990c      	ldr	r1, [sp, #48]	; 0x30
    3878:	181a      	adds	r2, r3, r0
    387a:	b2d2      	uxtb	r2, r2
    387c:	428b      	cmp	r3, r1
    387e:	d23b      	bcs.n	38f8 <_ZN12Adafruit_GFX8drawCharEsshtth+0x288>
                if(!(bit++ & 7)) {
    3880:	0751      	lsls	r1, r2, #29
    3882:	d107      	bne.n	3894 <_ZN12Adafruit_GFX8drawCharEsshtth+0x224>
                    bits = pgm_read_byte(&bitmap[bo++]);
    3884:	9b05      	ldr	r3, [sp, #20]
    3886:	9805      	ldr	r0, [sp, #20]
    3888:	9a11      	ldr	r2, [sp, #68]	; 0x44
    388a:	3301      	adds	r3, #1
    388c:	5c12      	ldrb	r2, [r2, r0]
    388e:	b29b      	uxth	r3, r3
    3890:	9204      	str	r2, [sp, #16]
    3892:	9305      	str	r3, [sp, #20]
                }
                if(bits & 0x80) {
    3894:	9804      	ldr	r0, [sp, #16]
    3896:	b243      	sxtb	r3, r0
    3898:	2b00      	cmp	r3, #0
    389a:	da22      	bge.n	38e2 <_ZN12Adafruit_GFX8drawCharEsshtth+0x272>
    389c:	6820      	ldr	r0, [r4, #0]
                    if(size == 1) {
    389e:	2d01      	cmp	r5, #1
    38a0:	d111      	bne.n	38c6 <_ZN12Adafruit_GFX8drawCharEsshtth+0x256>
                        writePixel(x+xo+xx, y+yo+yy, color);
    38a2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    38a4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    38a6:	b251      	sxtb	r1, r2
    38a8:	1859      	adds	r1, r3, r1
    38aa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    38ac:	1879      	adds	r1, r7, r1
    38ae:	b25a      	sxtb	r2, r3
    38b0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    38b2:	b209      	sxth	r1, r1
    38b4:	189a      	adds	r2, r3, r2
    38b6:	6983      	ldr	r3, [r0, #24]
    38b8:	18b2      	adds	r2, r6, r2
    38ba:	469c      	mov	ip, r3
    38bc:	b212      	sxth	r2, r2
    38be:	1c20      	adds	r0, r4, #0
    38c0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    38c2:	47e0      	blx	ip
    38c4:	e00d      	b.n	38e2 <_ZN12Adafruit_GFX8drawCharEsshtth+0x272>
                    } else {
                        writeFillRect(x+(xo16+xx)*size, y+(yo16+yy)*size,
                          size, size, color);
    38c6:	9a08      	ldr	r2, [sp, #32]
    38c8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    38ca:	b211      	sxth	r1, r2
    38cc:	b21b      	sxth	r3, r3
    38ce:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    38d0:	9303      	str	r3, [sp, #12]
    38d2:	b22b      	sxth	r3, r5
    38d4:	9300      	str	r3, [sp, #0]
    38d6:	9201      	str	r2, [sp, #4]
    38d8:	69c2      	ldr	r2, [r0, #28]
    38da:	1c20      	adds	r0, r4, #0
    38dc:	4694      	mov	ip, r2
    38de:	9a03      	ldr	r2, [sp, #12]
    38e0:	47e0      	blx	ip
                    }
                }
                bits <<= 1;
    38e2:	9804      	ldr	r0, [sp, #16]
    38e4:	9908      	ldr	r1, [sp, #32]
    38e6:	0043      	lsls	r3, r0, #1
    38e8:	b2db      	uxtb	r3, r3
    38ea:	9304      	str	r3, [sp, #16]
    38ec:	194b      	adds	r3, r1, r5
    38ee:	b29b      	uxth	r3, r3
    38f0:	3701      	adds	r7, #1
    38f2:	9308      	str	r3, [sp, #32]
    38f4:	b2bf      	uxth	r7, r7
    38f6:	e7bc      	b.n	3872 <_ZN12Adafruit_GFX8drawCharEsshtth+0x202>
    38f8:	1843      	adds	r3, r0, r1
    38fa:	b2db      	uxtb	r3, r3
    38fc:	3601      	adds	r6, #1
    38fe:	9306      	str	r3, [sp, #24]
    3900:	b2b6      	uxth	r6, r6
    3902:	e7a5      	b.n	3850 <_ZN12Adafruit_GFX8drawCharEsshtth+0x1e0>
            }
        }
        endWrite();
    3904:	6823      	ldr	r3, [r4, #0]
    3906:	1c20      	adds	r0, r4, #0
    3908:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    390a:	4798      	blx	r3

    } // End classic vs custom font
}
    390c:	b015      	add	sp, #84	; 0x54
    390e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3910:	000086c0 	.word	0x000086c0

00003914 <_ZN12Adafruit_GFX5writeEh>:

#if ARDUINO >= 100
size_t Adafruit_GFX::write(uint8_t c) {
    3914:	b5f0      	push	{r4, r5, r6, r7, lr}
#else
void Adafruit_GFX::write(uint8_t c) {
#endif
    if(!gfxFont) { // 'Classic' built-in font
    3916:	69c2      	ldr	r2, [r0, #28]

    } // End classic vs custom font
}

#if ARDUINO >= 100
size_t Adafruit_GFX::write(uint8_t c) {
    3918:	b087      	sub	sp, #28
    391a:	1c04      	adds	r4, r0, #0
    391c:	1c0b      	adds	r3, r1, #0
#else
void Adafruit_GFX::write(uint8_t c) {
#endif
    if(!gfxFont) { // 'Classic' built-in font
    391e:	2a00      	cmp	r2, #0
    3920:	d128      	bne.n	3974 <_ZN12Adafruit_GFX5writeEh+0x60>

        if(c == '\n') {                        // Newline?
    3922:	290a      	cmp	r1, #10
    3924:	d103      	bne.n	392e <_ZN12Adafruit_GFX5writeEh+0x1a>
            cursor_x  = 0;                     // Reset x to zero,
            cursor_y += textsize * 8;          // advance y one line
    3926:	7e03      	ldrb	r3, [r0, #24]
void Adafruit_GFX::write(uint8_t c) {
#endif
    if(!gfxFont) { // 'Classic' built-in font

        if(c == '\n') {                        // Newline?
            cursor_x  = 0;                     // Reset x to zero,
    3928:	8202      	strh	r2, [r0, #16]
            cursor_y += textsize * 8;          // advance y one line
    392a:	00db      	lsls	r3, r3, #3
    392c:	e029      	b.n	3982 <_ZN12Adafruit_GFX5writeEh+0x6e>
        } else if(c != '\r') {                 // Ignore carriage returns
    392e:	290d      	cmp	r1, #13
    3930:	d068      	beq.n	3a04 <_ZN12Adafruit_GFX5writeEh+0xf0>
            if(wrap && ((cursor_x + textsize * 6) > _width)) { // Off right?
    3932:	7e81      	ldrb	r1, [r0, #26]
    3934:	7e00      	ldrb	r0, [r0, #24]
    3936:	2900      	cmp	r1, #0
    3938:	d00d      	beq.n	3956 <_ZN12Adafruit_GFX5writeEh+0x42>
    393a:	2510      	movs	r5, #16
    393c:	5f61      	ldrsh	r1, [r4, r5]
    393e:	2506      	movs	r5, #6
    3940:	4345      	muls	r5, r0
    3942:	194d      	adds	r5, r1, r5
    3944:	260c      	movs	r6, #12
    3946:	5fa1      	ldrsh	r1, [r4, r6]
    3948:	428d      	cmp	r5, r1
    394a:	dd04      	ble.n	3956 <_ZN12Adafruit_GFX5writeEh+0x42>
                cursor_x  = 0;                 // Reset x to zero,
                cursor_y += textsize * 8;      // advance y one line
    394c:	8a61      	ldrh	r1, [r4, #18]
        if(c == '\n') {                        // Newline?
            cursor_x  = 0;                     // Reset x to zero,
            cursor_y += textsize * 8;          // advance y one line
        } else if(c != '\r') {                 // Ignore carriage returns
            if(wrap && ((cursor_x + textsize * 6) > _width)) { // Off right?
                cursor_x  = 0;                 // Reset x to zero,
    394e:	8222      	strh	r2, [r4, #16]
                cursor_y += textsize * 8;      // advance y one line
    3950:	00c2      	lsls	r2, r0, #3
    3952:	1852      	adds	r2, r2, r1
    3954:	8262      	strh	r2, [r4, #18]
            }
            drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize);
    3956:	2512      	movs	r5, #18
    3958:	5f62      	ldrsh	r2, [r4, r5]
    395a:	8aa5      	ldrh	r5, [r4, #20]
    395c:	9002      	str	r0, [sp, #8]
    395e:	9500      	str	r5, [sp, #0]
    3960:	8ae5      	ldrh	r5, [r4, #22]
    3962:	2710      	movs	r7, #16
    3964:	5fe1      	ldrsh	r1, [r4, r7]
    3966:	9501      	str	r5, [sp, #4]
    3968:	1c20      	adds	r0, r4, #0
    396a:	f7ff fe81 	bl	3670 <_ZN12Adafruit_GFX8drawCharEsshtth>
            cursor_x += textsize * 6;          // Advance x one char
    396e:	7e22      	ldrb	r2, [r4, #24]
    3970:	2306      	movs	r3, #6
    3972:	e043      	b.n	39fc <_ZN12Adafruit_GFX5writeEh+0xe8>
        }

    } else { // Custom font

        if(c == '\n') {
    3974:	290a      	cmp	r1, #10
    3976:	d108      	bne.n	398a <_ZN12Adafruit_GFX5writeEh+0x76>
            cursor_x  = 0;
    3978:	2300      	movs	r3, #0
    397a:	8203      	strh	r3, [r0, #16]
            cursor_y += (int16_t)textsize *
                        (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
    397c:	7a92      	ldrb	r2, [r2, #10]
    397e:	7e03      	ldrb	r3, [r0, #24]
    3980:	4353      	muls	r3, r2
    3982:	8a62      	ldrh	r2, [r4, #18]
    3984:	189b      	adds	r3, r3, r2
    3986:	8263      	strh	r3, [r4, #18]
    3988:	e03c      	b.n	3a04 <_ZN12Adafruit_GFX5writeEh+0xf0>
        } else if(c != '\r') {
    398a:	290d      	cmp	r1, #13
    398c:	d03a      	beq.n	3a04 <_ZN12Adafruit_GFX5writeEh+0xf0>
            uint8_t first = pgm_read_byte(&gfxFont->first);
    398e:	7a15      	ldrb	r5, [r2, #8]
            if((c >= first) && (c <= (uint8_t)pgm_read_byte(&gfxFont->last))) {
    3990:	42a9      	cmp	r1, r5
    3992:	d337      	bcc.n	3a04 <_ZN12Adafruit_GFX5writeEh+0xf0>
    3994:	7a51      	ldrb	r1, [r2, #9]
    3996:	4299      	cmp	r1, r3
    3998:	d334      	bcc.n	3a04 <_ZN12Adafruit_GFX5writeEh+0xf0>
                GFXglyph *glyph = &(((GFXglyph *)pgm_read_pointer(
                  &gfxFont->glyph))[c - first]);
    399a:	1b5d      	subs	r5, r3, r5
    399c:	6856      	ldr	r6, [r2, #4]
    399e:	00ed      	lsls	r5, r5, #3
    39a0:	19ad      	adds	r5, r5, r6
                uint8_t   w     = pgm_read_byte(&glyph->width),
    39a2:	78a9      	ldrb	r1, [r5, #2]
                          h     = pgm_read_byte(&glyph->height);
    39a4:	78e8      	ldrb	r0, [r5, #3]
                if((w > 0) && (h > 0)) { // Is there an associated bitmap?
    39a6:	2900      	cmp	r1, #0
    39a8:	d026      	beq.n	39f8 <_ZN12Adafruit_GFX5writeEh+0xe4>
    39aa:	2800      	cmp	r0, #0
    39ac:	d024      	beq.n	39f8 <_ZN12Adafruit_GFX5writeEh+0xe4>
                    int16_t xo = (int8_t)pgm_read_byte(&glyph->xOffset); // sic
    39ae:	796f      	ldrb	r7, [r5, #5]
                    if(wrap && ((cursor_x + textsize * (xo + w)) > _width)) {
    39b0:	7ea6      	ldrb	r6, [r4, #26]
                GFXglyph *glyph = &(((GFXglyph *)pgm_read_pointer(
                  &gfxFont->glyph))[c - first]);
                uint8_t   w     = pgm_read_byte(&glyph->width),
                          h     = pgm_read_byte(&glyph->height);
                if((w > 0) && (h > 0)) { // Is there an associated bitmap?
                    int16_t xo = (int8_t)pgm_read_byte(&glyph->xOffset); // sic
    39b2:	9705      	str	r7, [sp, #20]
    39b4:	7e20      	ldrb	r0, [r4, #24]
                    if(wrap && ((cursor_x + textsize * (xo + w)) > _width)) {
    39b6:	2e00      	cmp	r6, #0
    39b8:	d012      	beq.n	39e0 <_ZN12Adafruit_GFX5writeEh+0xcc>
    39ba:	2710      	movs	r7, #16
    39bc:	5fe6      	ldrsh	r6, [r4, r7]
    39be:	46b4      	mov	ip, r6
    39c0:	9e05      	ldr	r6, [sp, #20]
    39c2:	b277      	sxtb	r7, r6
    39c4:	1879      	adds	r1, r7, r1
    39c6:	4341      	muls	r1, r0
    39c8:	270c      	movs	r7, #12
    39ca:	5fe6      	ldrsh	r6, [r4, r7]
    39cc:	4461      	add	r1, ip
    39ce:	42b1      	cmp	r1, r6
    39d0:	dd06      	ble.n	39e0 <_ZN12Adafruit_GFX5writeEh+0xcc>
                        cursor_x  = 0;
    39d2:	2100      	movs	r1, #0
    39d4:	8221      	strh	r1, [r4, #16]
                        cursor_y += (int16_t)textsize *
                          (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
    39d6:	7a92      	ldrb	r2, [r2, #10]
    39d8:	8a61      	ldrh	r1, [r4, #18]
    39da:	4342      	muls	r2, r0
    39dc:	1852      	adds	r2, r2, r1
    39de:	8262      	strh	r2, [r4, #18]
                    }
                    drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize);
    39e0:	2210      	movs	r2, #16
    39e2:	5ea1      	ldrsh	r1, [r4, r2]
    39e4:	2612      	movs	r6, #18
    39e6:	5fa2      	ldrsh	r2, [r4, r6]
    39e8:	8aa6      	ldrh	r6, [r4, #20]
    39ea:	9002      	str	r0, [sp, #8]
    39ec:	9600      	str	r6, [sp, #0]
    39ee:	8ae6      	ldrh	r6, [r4, #22]
    39f0:	1c20      	adds	r0, r4, #0
    39f2:	9601      	str	r6, [sp, #4]
    39f4:	f7ff fe3c 	bl	3670 <_ZN12Adafruit_GFX8drawCharEsshtth>
                }
                cursor_x += (uint8_t)pgm_read_byte(&glyph->xAdvance) * (int16_t)textsize;
    39f8:	792a      	ldrb	r2, [r5, #4]
    39fa:	7e23      	ldrb	r3, [r4, #24]
    39fc:	4353      	muls	r3, r2
    39fe:	8a22      	ldrh	r2, [r4, #16]
    3a00:	189b      	adds	r3, r3, r2
    3a02:	8223      	strh	r3, [r4, #16]

    }
#if ARDUINO >= 100
    return 1;
#endif
}
    3a04:	2001      	movs	r0, #1
    3a06:	b007      	add	sp, #28
    3a08:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003a0a <_ZN12Adafruit_GFX9setCursorEss>:

void Adafruit_GFX::setCursor(int16_t x, int16_t y) {
    cursor_x = x;
    3a0a:	8201      	strh	r1, [r0, #16]
    cursor_y = y;
    3a0c:	8242      	strh	r2, [r0, #18]
}
    3a0e:	4770      	bx	lr

00003a10 <_ZN12Adafruit_GFX11setTextSizeEh>:
int16_t Adafruit_GFX::getCursorY(void) const {
    return cursor_y;
}

void Adafruit_GFX::setTextSize(uint8_t s) {
    textsize = (s > 0) ? s : 1;
    3a10:	2900      	cmp	r1, #0
    3a12:	d100      	bne.n	3a16 <_ZN12Adafruit_GFX11setTextSizeEh+0x6>
    3a14:	2101      	movs	r1, #1
    3a16:	7601      	strb	r1, [r0, #24]
}
    3a18:	4770      	bx	lr

00003a1a <_ZN12Adafruit_GFX12setTextColorEt>:

void Adafruit_GFX::setTextColor(uint16_t c) {
    // For 'transparent' background, we'll set the bg
    // to the same as fg instead of using a flag
    textcolor = textbgcolor = c;
    3a1a:	82c1      	strh	r1, [r0, #22]
    3a1c:	8281      	strh	r1, [r0, #20]
}
    3a1e:	4770      	bx	lr

00003a20 <_ZN12Adafruit_GFX11setTextWrapEb>:
    textcolor   = c;
    textbgcolor = b;
}

void Adafruit_GFX::setTextWrap(boolean w) {
    wrap = w;
    3a20:	7681      	strb	r1, [r0, #26]
}
    3a22:	4770      	bx	lr

00003a24 <_ZNK12Adafruit_GFX5widthEv>:
    }
}

// Return the size of the display (per current rotation)
int16_t Adafruit_GFX::width(void) const {
    return _width;
    3a24:	230c      	movs	r3, #12
    3a26:	5ec0      	ldrsh	r0, [r0, r3]
}
    3a28:	4770      	bx	lr

00003a2a <_ZNK12Adafruit_GFX6heightEv>:

int16_t Adafruit_GFX::height(void) const {
    return _height;
    3a2a:	230e      	movs	r3, #14
    3a2c:	5ec0      	ldrsh	r0, [r0, r3]
}
    3a2e:	4770      	bx	lr

00003a30 <_ZN15Adafruit_ST773510fillScreenEt>:
#endif
}



void Adafruit_ST7735::fillScreen(uint16_t color) {
    3a30:	b537      	push	{r0, r1, r2, r4, r5, lr}
  fillRect(0, 0,  _width, _height, color);
    3a32:	240c      	movs	r4, #12
    3a34:	5f03      	ldrsh	r3, [r0, r4]
    3a36:	250e      	movs	r5, #14
    3a38:	5f44      	ldrsh	r4, [r0, r5]
    3a3a:	6802      	ldr	r2, [r0, #0]
    3a3c:	9101      	str	r1, [sp, #4]
    3a3e:	9400      	str	r4, [sp, #0]
    3a40:	2100      	movs	r1, #0
    3a42:	6c14      	ldr	r4, [r2, #64]	; 0x40
    3a44:	1c0a      	adds	r2, r1, #0
    3a46:	47a0      	blx	r4
}
    3a48:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

00003a4a <_ZN15Adafruit_ST77357CS_HIGHEv.isra.0>:


/******** low level bit twiddling **********/


inline void Adafruit_ST7735::CS_HIGH(void) {
    3a4a:	b508      	push	{r3, lr}
#if defined(USE_FAST_IO)
  *csport |= cspinmask;
#else
  digitalWrite(_cs, HIGH);
    3a4c:	2101      	movs	r1, #1
    3a4e:	f000 fec3 	bl	47d8 <digitalWrite>
#endif
}
    3a52:	bd08      	pop	{r3, pc}

00003a54 <_ZN15Adafruit_ST77356CS_LOWEv.isra.1>:

inline void Adafruit_ST7735::CS_LOW(void) {
    3a54:	b508      	push	{r3, lr}
#if defined(USE_FAST_IO)
  *csport &= ~cspinmask;
#else
  digitalWrite(_cs, LOW);
    3a56:	2100      	movs	r1, #0
    3a58:	f000 febe 	bl	47d8 <digitalWrite>
#endif
}
    3a5c:	bd08      	pop	{r3, pc}
	...

00003a60 <_ZN15Adafruit_ST7735C1Eaaa>:
  hwSPI = false;
}

// Constructor when using hardware SPI.  Faster, but must use SPI pins
// specific to each board type (e.g. 11,13 for Uno, 51,52 for Mega, etc.)
Adafruit_ST7735::Adafruit_ST7735(int8_t cs, int8_t dc, int8_t rst) 
    3a60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3a62:	1c0f      	adds	r7, r1, #0
    3a64:	1c16      	adds	r6, r2, #0
  : Adafruit_GFX(ST7735_TFTWIDTH_128, ST7735_TFTHEIGHT_160) {
    3a66:	2180      	movs	r1, #128	; 0x80
    3a68:	22a0      	movs	r2, #160	; 0xa0
  hwSPI = false;
}

// Constructor when using hardware SPI.  Faster, but must use SPI pins
// specific to each board type (e.g. 11,13 for Uno, 51,52 for Mega, etc.)
Adafruit_ST7735::Adafruit_ST7735(int8_t cs, int8_t dc, int8_t rst) 
    3a6a:	1c04      	adds	r4, r0, #0
    3a6c:	1c1d      	adds	r5, r3, #0
  : Adafruit_GFX(ST7735_TFTWIDTH_128, ST7735_TFTHEIGHT_160) {
    3a6e:	f7ff f983 	bl	2d78 <_ZN12Adafruit_GFXC1Ess>
    3a72:	4b09      	ldr	r3, [pc, #36]	; (3a98 <_ZN15Adafruit_ST7735C1Eaaa+0x38>)
  _cs   = cs;
  _dc   = dc;
  _rst  = rst;
  hwSPI = true;
    3a74:	2201      	movs	r2, #1
}

// Constructor when using hardware SPI.  Faster, but must use SPI pins
// specific to each board type (e.g. 11,13 for Uno, 51,52 for Mega, etc.)
Adafruit_ST7735::Adafruit_ST7735(int8_t cs, int8_t dc, int8_t rst) 
  : Adafruit_GFX(ST7735_TFTWIDTH_128, ST7735_TFTHEIGHT_160) {
    3a76:	3308      	adds	r3, #8
    3a78:	6023      	str	r3, [r4, #0]
  _cs   = cs;
    3a7a:	1ce3      	adds	r3, r4, #3
    3a7c:	77df      	strb	r7, [r3, #31]
  _dc   = dc;
    3a7e:	1d23      	adds	r3, r4, #4
    3a80:	77de      	strb	r6, [r3, #31]
  _rst  = rst;
    3a82:	1d63      	adds	r3, r4, #5
    3a84:	77dd      	strb	r5, [r3, #31]
  hwSPI = true;
    3a86:	1ca3      	adds	r3, r4, #2
    3a88:	77da      	strb	r2, [r3, #31]
  _sid  = _sclk = -1;
    3a8a:	1de2      	adds	r2, r4, #7
    3a8c:	23ff      	movs	r3, #255	; 0xff
    3a8e:	77d3      	strb	r3, [r2, #31]
    3a90:	1da2      	adds	r2, r4, #6
}
    3a92:	1c20      	adds	r0, r4, #0
  : Adafruit_GFX(ST7735_TFTWIDTH_128, ST7735_TFTHEIGHT_160) {
  _cs   = cs;
  _dc   = dc;
  _rst  = rst;
  hwSPI = true;
  _sid  = _sclk = -1;
    3a94:	77d3      	strb	r3, [r2, #31]
}
    3a96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3a98:	00008bd0 	.word	0x00008bd0

00003a9c <_ZN15Adafruit_ST77358spiwriteEh>:

inline void Adafruit_ST7735::spiwrite(uint8_t c) {
    3a9c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}

  //Serial.println(c, HEX);

  if (hwSPI) {
    3a9e:	1c83      	adds	r3, r0, #2
    3aa0:	7fdb      	ldrb	r3, [r3, #31]
  _rst  = rst;
  hwSPI = true;
  _sid  = _sclk = -1;
}

inline void Adafruit_ST7735::spiwrite(uint8_t c) {
    3aa2:	1c05      	adds	r5, r0, #0
    3aa4:	1c0f      	adds	r7, r1, #0

  //Serial.println(c, HEX);

  if (hwSPI) {
    3aa6:	2b00      	cmp	r3, #0
    3aa8:	d003      	beq.n	3ab2 <_ZN15Adafruit_ST77358spiwriteEh+0x16>
#if defined (SPI_HAS_TRANSACTION)
      SPI.transfer(c);
    3aaa:	4811      	ldr	r0, [pc, #68]	; (3af0 <_ZN15Adafruit_ST77358spiwriteEh+0x54>)
    3aac:	f000 fbfc 	bl	42a8 <_ZN8SPIClass8transferEh>
    3ab0:	e01c      	b.n	3aec <_ZN15Adafruit_ST77358spiwriteEh+0x50>

inline void Adafruit_ST7735::spiwrite(uint8_t c) {

  //Serial.println(c, HEX);

  if (hwSPI) {
    3ab2:	2608      	movs	r6, #8
    3ab4:	2480      	movs	r4, #128	; 0x80
      if(c & bit) *dataport |=  datapinmask;
      else        *dataport &= ~datapinmask;
      *clkport |=  clkpinmask;
      *clkport &= ~clkpinmask;
#else
      if(c & bit) digitalWrite(_sid, HIGH);
    3ab6:	1c39      	adds	r1, r7, #0
    3ab8:	1dab      	adds	r3, r5, #6
    3aba:	201f      	movs	r0, #31
    3abc:	4021      	ands	r1, r4
    3abe:	5618      	ldrsb	r0, [r3, r0]
    3ac0:	2900      	cmp	r1, #0
    3ac2:	d000      	beq.n	3ac6 <_ZN15Adafruit_ST77358spiwriteEh+0x2a>
    3ac4:	2101      	movs	r1, #1
      else        digitalWrite(_sid, LOW);
    3ac6:	f000 fe87 	bl	47d8 <digitalWrite>
      digitalWrite(_sclk, HIGH);
    3aca:	1deb      	adds	r3, r5, #7
    3acc:	9301      	str	r3, [sp, #4]
    3ace:	201f      	movs	r0, #31
    3ad0:	5618      	ldrsb	r0, [r3, r0]
    3ad2:	2101      	movs	r1, #1
    3ad4:	f000 fe80 	bl	47d8 <digitalWrite>
      digitalWrite(_sclk, LOW);
    3ad8:	9b01      	ldr	r3, [sp, #4]
    3ada:	201f      	movs	r0, #31
    3adc:	5618      	ldrsb	r0, [r3, r0]
    3ade:	2100      	movs	r1, #0
    3ae0:	3e01      	subs	r6, #1
    3ae2:	f000 fe79 	bl	47d8 <digitalWrite>
      SPI.transfer(c);
#endif
  } else {

    // Fast SPI bitbang swiped from LPD8806 library
    for(uint8_t bit = 0x80; bit; bit >>= 1) {
    3ae6:	0864      	lsrs	r4, r4, #1
    3ae8:	2e00      	cmp	r6, #0
    3aea:	d1e4      	bne.n	3ab6 <_ZN15Adafruit_ST77358spiwriteEh+0x1a>
      digitalWrite(_sclk, HIGH);
      digitalWrite(_sclk, LOW);
#endif
    }
  }
}
    3aec:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    3aee:	46c0      	nop			; (mov r8, r8)
    3af0:	20000168 	.word	0x20000168

00003af4 <_ZN15Adafruit_ST773512writecommandEh>:


void Adafruit_ST7735::writecommand(uint8_t c) {
    3af4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)    SPI.beginTransaction(mySPISettings);
    3af6:	1c85      	adds	r5, r0, #2
    3af8:	7feb      	ldrb	r3, [r5, #31]
    }
  }
}


void Adafruit_ST7735::writecommand(uint8_t c) {
    3afa:	1c04      	adds	r4, r0, #0
    3afc:	1c0f      	adds	r7, r1, #0
#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)    SPI.beginTransaction(mySPISettings);
    3afe:	2b00      	cmp	r3, #0
    3b00:	d004      	beq.n	3b0c <_ZN15Adafruit_ST773512writecommandEh+0x18>
    3b02:	4b0f      	ldr	r3, [pc, #60]	; (3b40 <_ZN15Adafruit_ST773512writecommandEh+0x4c>)
    3b04:	480f      	ldr	r0, [pc, #60]	; (3b44 <_ZN15Adafruit_ST773512writecommandEh+0x50>)
    3b06:	cb06      	ldmia	r3!, {r1, r2}
    3b08:	f000 fba0 	bl	424c <_ZN8SPIClass16beginTransactionE11SPISettings>
    }
  }
}


void Adafruit_ST7735::writecommand(uint8_t c) {
    3b0c:	1d23      	adds	r3, r4, #4

inline void Adafruit_ST7735::DC_LOW(void) {
#if defined(USE_FAST_IO)
  *dcport &= ~dcpinmask;
#else
  digitalWrite(_dc, LOW);
    3b0e:	201f      	movs	r0, #31
    3b10:	5618      	ldrsb	r0, [r3, r0]
    3b12:	2100      	movs	r1, #0
    3b14:	f000 fe60 	bl	47d8 <digitalWrite>
    }
  }
}


void Adafruit_ST7735::writecommand(uint8_t c) {
    3b18:	1ce6      	adds	r6, r4, #3
#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)    SPI.beginTransaction(mySPISettings);
#endif
  DC_LOW();
  CS_LOW();
    3b1a:	201f      	movs	r0, #31
    3b1c:	5630      	ldrsb	r0, [r6, r0]
    3b1e:	f7ff ff99 	bl	3a54 <_ZN15Adafruit_ST77356CS_LOWEv.isra.1>

  spiwrite(c);
    3b22:	1c20      	adds	r0, r4, #0
    3b24:	1c39      	adds	r1, r7, #0
    3b26:	f7ff ffb9 	bl	3a9c <_ZN15Adafruit_ST77358spiwriteEh>

  CS_HIGH();
    3b2a:	201f      	movs	r0, #31
    3b2c:	5630      	ldrsb	r0, [r6, r0]
    3b2e:	f7ff ff8c 	bl	3a4a <_ZN15Adafruit_ST77357CS_HIGHEv.isra.0>
#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)    SPI.endTransaction();
    3b32:	7feb      	ldrb	r3, [r5, #31]
    3b34:	2b00      	cmp	r3, #0
    3b36:	d002      	beq.n	3b3e <_ZN15Adafruit_ST773512writecommandEh+0x4a>
    3b38:	4802      	ldr	r0, [pc, #8]	; (3b44 <_ZN15Adafruit_ST773512writecommandEh+0x50>)
    3b3a:	f000 fba3 	bl	4284 <_ZN8SPIClass14endTransactionEv>
#endif
}
    3b3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3b40:	20000158 	.word	0x20000158
    3b44:	20000168 	.word	0x20000168

00003b48 <_ZN15Adafruit_ST773513invertDisplayEb>:
     break;
  }
}


void Adafruit_ST7735::invertDisplay(boolean i) {
    3b48:	b508      	push	{r3, lr}
  writecommand(i ? ST7735_INVON : ST7735_INVOFF);
    3b4a:	424b      	negs	r3, r1
    3b4c:	414b      	adcs	r3, r1
    3b4e:	2121      	movs	r1, #33	; 0x21
    3b50:	1ac9      	subs	r1, r1, r3
    3b52:	f7ff ffcf 	bl	3af4 <_ZN15Adafruit_ST773512writecommandEh>
}
    3b56:	bd08      	pop	{r3, pc}

00003b58 <_ZN15Adafruit_ST77359writedataEh>:
  if (hwSPI)    SPI.endTransaction();
#endif
}


void Adafruit_ST7735::writedata(uint8_t c) {
    3b58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)    SPI.beginTransaction(mySPISettings);
    3b5a:	1c85      	adds	r5, r0, #2
    3b5c:	7feb      	ldrb	r3, [r5, #31]
  if (hwSPI)    SPI.endTransaction();
#endif
}


void Adafruit_ST7735::writedata(uint8_t c) {
    3b5e:	1c04      	adds	r4, r0, #0
    3b60:	1c0f      	adds	r7, r1, #0
#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)    SPI.beginTransaction(mySPISettings);
    3b62:	2b00      	cmp	r3, #0
    3b64:	d004      	beq.n	3b70 <_ZN15Adafruit_ST77359writedataEh+0x18>
    3b66:	4b0f      	ldr	r3, [pc, #60]	; (3ba4 <_ZN15Adafruit_ST77359writedataEh+0x4c>)
    3b68:	480f      	ldr	r0, [pc, #60]	; (3ba8 <_ZN15Adafruit_ST77359writedataEh+0x50>)
    3b6a:	cb06      	ldmia	r3!, {r1, r2}
    3b6c:	f000 fb6e 	bl	424c <_ZN8SPIClass16beginTransactionE11SPISettings>
  if (hwSPI)    SPI.endTransaction();
#endif
}


void Adafruit_ST7735::writedata(uint8_t c) {
    3b70:	1d23      	adds	r3, r4, #4

inline void Adafruit_ST7735::DC_HIGH(void) {
#if defined(USE_FAST_IO)
  *dcport |= dcpinmask;
#else
  digitalWrite(_dc, HIGH);
    3b72:	201f      	movs	r0, #31
    3b74:	5618      	ldrsb	r0, [r3, r0]
    3b76:	2101      	movs	r1, #1
    3b78:	f000 fe2e 	bl	47d8 <digitalWrite>
  if (hwSPI)    SPI.endTransaction();
#endif
}


void Adafruit_ST7735::writedata(uint8_t c) {
    3b7c:	1ce6      	adds	r6, r4, #3
#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)    SPI.beginTransaction(mySPISettings);
#endif
  DC_HIGH();
  CS_LOW();
    3b7e:	201f      	movs	r0, #31
    3b80:	5630      	ldrsb	r0, [r6, r0]
    3b82:	f7ff ff67 	bl	3a54 <_ZN15Adafruit_ST77356CS_LOWEv.isra.1>
    
  spiwrite(c);
    3b86:	1c20      	adds	r0, r4, #0
    3b88:	1c39      	adds	r1, r7, #0
    3b8a:	f7ff ff87 	bl	3a9c <_ZN15Adafruit_ST77358spiwriteEh>

  CS_HIGH();
    3b8e:	201f      	movs	r0, #31
    3b90:	5630      	ldrsb	r0, [r6, r0]
    3b92:	f7ff ff5a 	bl	3a4a <_ZN15Adafruit_ST77357CS_HIGHEv.isra.0>
#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)    SPI.endTransaction();
    3b96:	7feb      	ldrb	r3, [r5, #31]
    3b98:	2b00      	cmp	r3, #0
    3b9a:	d002      	beq.n	3ba2 <_ZN15Adafruit_ST77359writedataEh+0x4a>
    3b9c:	4802      	ldr	r0, [pc, #8]	; (3ba8 <_ZN15Adafruit_ST77359writedataEh+0x50>)
    3b9e:	f000 fb71 	bl	4284 <_ZN8SPIClass14endTransactionEv>
#endif
}
    3ba2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3ba4:	20000158 	.word	0x20000158
    3ba8:	20000168 	.word	0x20000168

00003bac <_ZN15Adafruit_ST773511setRotationEh>:
#define MADCTL_ML  0x10
#define MADCTL_RGB 0x00
#define MADCTL_BGR 0x08
#define MADCTL_MH  0x04

void Adafruit_ST7735::setRotation(uint8_t m) {
    3bac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    3bae:	1c04      	adds	r4, r0, #0
    3bb0:	1c0d      	adds	r5, r1, #0

  writecommand(ST7735_MADCTL);
    3bb2:	2136      	movs	r1, #54	; 0x36
    3bb4:	f7ff ff9e 	bl	3af4 <_ZN15Adafruit_ST773512writecommandEh>
  rotation = m % 4; // can't be higher than 3
    3bb8:	2103      	movs	r1, #3
    3bba:	1c22      	adds	r2, r4, #0
    3bbc:	1c23      	adds	r3, r4, #0
    3bbe:	4029      	ands	r1, r5
    3bc0:	3328      	adds	r3, #40	; 0x28
    3bc2:	3229      	adds	r2, #41	; 0x29
    3bc4:	7661      	strb	r1, [r4, #25]
    3bc6:	1c65      	adds	r5, r4, #1
    3bc8:	1c27      	adds	r7, r4, #0
    3bca:	9200      	str	r2, [sp, #0]
    3bcc:	9301      	str	r3, [sp, #4]
    3bce:	1c26      	adds	r6, r4, #0
    3bd0:	3708      	adds	r7, #8
    3bd2:	362a      	adds	r6, #42	; 0x2a
     }
     ystart = colstart;
     xstart = rowstart;
     break;
  case 2:
     if ((tabcolor == INITR_BLACKTAB) || (tabcolor == INITR_MINI160x80)) {
    3bd4:	7feb      	ldrb	r3, [r5, #31]
       writedata(MADCTL_RGB);
    3bd6:	1c20      	adds	r0, r4, #0

void Adafruit_ST7735::setRotation(uint8_t m) {

  writecommand(ST7735_MADCTL);
  rotation = m % 4; // can't be higher than 3
  switch (rotation) {
    3bd8:	2902      	cmp	r1, #2
    3bda:	d011      	beq.n	3c00 <_ZN15Adafruit_ST773511setRotationEh+0x54>
    3bdc:	2903      	cmp	r1, #3
    3bde:	d02b      	beq.n	3c38 <_ZN15Adafruit_ST773511setRotationEh+0x8c>
    3be0:	2901      	cmp	r1, #1
    3be2:	d006      	beq.n	3bf2 <_ZN15Adafruit_ST773511setRotationEh+0x46>
   case 0:
     if ((tabcolor == INITR_BLACKTAB) || (tabcolor == INITR_MINI160x80)) {
    3be4:	2b02      	cmp	r3, #2
    3be6:	d002      	beq.n	3bee <_ZN15Adafruit_ST773511setRotationEh+0x42>
       writedata(MADCTL_MX | MADCTL_MY | MADCTL_RGB);
     } else {
       writedata(MADCTL_MX | MADCTL_MY | MADCTL_BGR);
    3be8:	21c8      	movs	r1, #200	; 0xc8

  writecommand(ST7735_MADCTL);
  rotation = m % 4; // can't be higher than 3
  switch (rotation) {
   case 0:
     if ((tabcolor == INITR_BLACKTAB) || (tabcolor == INITR_MINI160x80)) {
    3bea:	2b04      	cmp	r3, #4
    3bec:	d10e      	bne.n	3c0c <_ZN15Adafruit_ST773511setRotationEh+0x60>
       writedata(MADCTL_MX | MADCTL_MY | MADCTL_RGB);
    3bee:	21c0      	movs	r1, #192	; 0xc0
    3bf0:	e00c      	b.n	3c0c <_ZN15Adafruit_ST773511setRotationEh+0x60>
     }
     xstart = colstart;
     ystart = rowstart;
     break;
   case 1:
     if ((tabcolor == INITR_BLACKTAB) || (tabcolor == INITR_MINI160x80)) {
    3bf2:	2b02      	cmp	r3, #2
    3bf4:	d002      	beq.n	3bfc <_ZN15Adafruit_ST773511setRotationEh+0x50>
       writedata(MADCTL_MY | MADCTL_MV | MADCTL_RGB);
     } else {
       writedata(MADCTL_MY | MADCTL_MV | MADCTL_BGR);
    3bf6:	21a8      	movs	r1, #168	; 0xa8
     }
     xstart = colstart;
     ystart = rowstart;
     break;
   case 1:
     if ((tabcolor == INITR_BLACKTAB) || (tabcolor == INITR_MINI160x80)) {
    3bf8:	2b04      	cmp	r3, #4
    3bfa:	d123      	bne.n	3c44 <_ZN15Adafruit_ST773511setRotationEh+0x98>
       writedata(MADCTL_MY | MADCTL_MV | MADCTL_RGB);
    3bfc:	21a0      	movs	r1, #160	; 0xa0
    3bfe:	e021      	b.n	3c44 <_ZN15Adafruit_ST773511setRotationEh+0x98>
     }
     ystart = colstart;
     xstart = rowstart;
     break;
  case 2:
     if ((tabcolor == INITR_BLACKTAB) || (tabcolor == INITR_MINI160x80)) {
    3c00:	2b02      	cmp	r3, #2
    3c02:	d002      	beq.n	3c0a <_ZN15Adafruit_ST773511setRotationEh+0x5e>
       writedata(MADCTL_RGB);
     } else {
       writedata(MADCTL_BGR);
    3c04:	2108      	movs	r1, #8
     }
     ystart = colstart;
     xstart = rowstart;
     break;
  case 2:
     if ((tabcolor == INITR_BLACKTAB) || (tabcolor == INITR_MINI160x80)) {
    3c06:	2b04      	cmp	r3, #4
    3c08:	d100      	bne.n	3c0c <_ZN15Adafruit_ST773511setRotationEh+0x60>
       writedata(MADCTL_RGB);
    3c0a:	2100      	movs	r1, #0
     } else {
       writedata(MADCTL_BGR);
    3c0c:	f7ff ffa4 	bl	3b58 <_ZN15Adafruit_ST77359writedataEh>
     }

     if (tabcolor == INITR_144GREENTAB) {
    3c10:	7fea      	ldrb	r2, [r5, #31]
    3c12:	2a01      	cmp	r2, #1
    3c14:	d102      	bne.n	3c1c <_ZN15Adafruit_ST773511setRotationEh+0x70>
       _height = ST7735_TFTHEIGHT_128;
    3c16:	2380      	movs	r3, #128	; 0x80
    3c18:	81e3      	strh	r3, [r4, #14]
    3c1a:	e005      	b.n	3c28 <_ZN15Adafruit_ST773511setRotationEh+0x7c>
    3c1c:	23a0      	movs	r3, #160	; 0xa0
       _width  = ST7735_TFTWIDTH_128;
     } else if (tabcolor == INITR_MINI160x80)  {
       _height = ST7735_TFTHEIGHT_160;
    3c1e:	81e3      	strh	r3, [r4, #14]
       _width = ST7735_TFTWIDTH_80;
    3c20:	2350      	movs	r3, #80	; 0x50
     }

     if (tabcolor == INITR_144GREENTAB) {
       _height = ST7735_TFTHEIGHT_128;
       _width  = ST7735_TFTWIDTH_128;
     } else if (tabcolor == INITR_MINI160x80)  {
    3c22:	2a04      	cmp	r2, #4
    3c24:	d000      	beq.n	3c28 <_ZN15Adafruit_ST773511setRotationEh+0x7c>
       _height = ST7735_TFTHEIGHT_160;
       _width = ST7735_TFTWIDTH_80;
     } else {
       _height = ST7735_TFTHEIGHT_160;
       _width  = ST7735_TFTWIDTH_128;
    3c26:	2380      	movs	r3, #128	; 0x80
    3c28:	81a3      	strh	r3, [r4, #12]
     }
     xstart = colstart;
    3c2a:	7ffb      	ldrb	r3, [r7, #31]
    3c2c:	9a00      	ldr	r2, [sp, #0]
    3c2e:	7013      	strb	r3, [r2, #0]
     ystart = rowstart;
    3c30:	9a01      	ldr	r2, [sp, #4]
    3c32:	7813      	ldrb	r3, [r2, #0]
    3c34:	7033      	strb	r3, [r6, #0]
     break;
    3c36:	e01a      	b.n	3c6e <_ZN15Adafruit_ST773511setRotationEh+0xc2>
   case 3:
     if ((tabcolor == INITR_BLACKTAB) || (tabcolor == INITR_MINI160x80)) {
    3c38:	2b02      	cmp	r3, #2
    3c3a:	d002      	beq.n	3c42 <_ZN15Adafruit_ST773511setRotationEh+0x96>
       writedata(MADCTL_MX | MADCTL_MV | MADCTL_RGB);
     } else {
       writedata(MADCTL_MX | MADCTL_MV | MADCTL_BGR);
    3c3c:	2168      	movs	r1, #104	; 0x68
     }
     xstart = colstart;
     ystart = rowstart;
     break;
   case 3:
     if ((tabcolor == INITR_BLACKTAB) || (tabcolor == INITR_MINI160x80)) {
    3c3e:	2b04      	cmp	r3, #4
    3c40:	d100      	bne.n	3c44 <_ZN15Adafruit_ST773511setRotationEh+0x98>
       writedata(MADCTL_MX | MADCTL_MV | MADCTL_RGB);
    3c42:	2160      	movs	r1, #96	; 0x60
     } else {
       writedata(MADCTL_MX | MADCTL_MV | MADCTL_BGR);
    3c44:	f7ff ff88 	bl	3b58 <_ZN15Adafruit_ST77359writedataEh>
     }

     if (tabcolor == INITR_144GREENTAB)  {
    3c48:	7fea      	ldrb	r2, [r5, #31]
    3c4a:	2a01      	cmp	r2, #1
    3c4c:	d102      	bne.n	3c54 <_ZN15Adafruit_ST773511setRotationEh+0xa8>
       _width = ST7735_TFTHEIGHT_128;
    3c4e:	2380      	movs	r3, #128	; 0x80
    3c50:	81a3      	strh	r3, [r4, #12]
    3c52:	e005      	b.n	3c60 <_ZN15Adafruit_ST773511setRotationEh+0xb4>
    3c54:	23a0      	movs	r3, #160	; 0xa0
       _height = ST7735_TFTWIDTH_128;
     } else if (tabcolor == INITR_MINI160x80)  {
       _width = ST7735_TFTHEIGHT_160;
    3c56:	81a3      	strh	r3, [r4, #12]
       _height = ST7735_TFTWIDTH_80;
    3c58:	2350      	movs	r3, #80	; 0x50
     }

     if (tabcolor == INITR_144GREENTAB)  {
       _width = ST7735_TFTHEIGHT_128;
       _height = ST7735_TFTWIDTH_128;
     } else if (tabcolor == INITR_MINI160x80)  {
    3c5a:	2a04      	cmp	r2, #4
    3c5c:	d000      	beq.n	3c60 <_ZN15Adafruit_ST773511setRotationEh+0xb4>
       _width = ST7735_TFTHEIGHT_160;
       _height = ST7735_TFTWIDTH_80;
     } else {
       _width = ST7735_TFTHEIGHT_160;
       _height = ST7735_TFTWIDTH_128;
    3c5e:	2380      	movs	r3, #128	; 0x80
    3c60:	81e3      	strh	r3, [r4, #14]
     }
     ystart = colstart;
    3c62:	7ffb      	ldrb	r3, [r7, #31]
     xstart = rowstart;
    3c64:	9a01      	ldr	r2, [sp, #4]
       _height = ST7735_TFTWIDTH_80;
     } else {
       _width = ST7735_TFTHEIGHT_160;
       _height = ST7735_TFTWIDTH_128;
     }
     ystart = colstart;
    3c66:	7033      	strb	r3, [r6, #0]
     xstart = rowstart;
    3c68:	7813      	ldrb	r3, [r2, #0]
    3c6a:	9a00      	ldr	r2, [sp, #0]
    3c6c:	7013      	strb	r3, [r2, #0]
     break;
  }
}
    3c6e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

00003c70 <_ZN15Adafruit_ST773511commandListEPKh>:
      100 };                  //     100 ms delay


// Companion code to the above tables.  Reads and issues
// a series of LCD commands stored in PROGMEM byte array.
void Adafruit_ST7735::commandList(const uint8_t *addr) {
    3c70:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}

  uint8_t  numCommands, numArgs;
  uint16_t ms;

  numCommands = pgm_read_byte(addr++);   // Number of commands to follow
    3c72:	780d      	ldrb	r5, [r1, #0]
      100 };                  //     100 ms delay


// Companion code to the above tables.  Reads and issues
// a series of LCD commands stored in PROGMEM byte array.
void Adafruit_ST7735::commandList(const uint8_t *addr) {
    3c74:	1c06      	adds	r6, r0, #0

  uint8_t  numCommands, numArgs;
  uint16_t ms;

  numCommands = pgm_read_byte(addr++);   // Number of commands to follow
    3c76:	1c4c      	adds	r4, r1, #1
  while(numCommands--) {                 // For each command...
    3c78:	2d00      	cmp	r5, #0
    3c7a:	d027      	beq.n	3ccc <_ZN15Adafruit_ST773511commandListEPKh+0x5c>
    writecommand(pgm_read_byte(addr++)); //   Read, issue command
    3c7c:	7821      	ldrb	r1, [r4, #0]
    3c7e:	1c30      	adds	r0, r6, #0
    3c80:	f7ff ff38 	bl	3af4 <_ZN15Adafruit_ST773512writecommandEh>
    numArgs  = pgm_read_byte(addr++);    //   Number of args to follow
    3c84:	7862      	ldrb	r2, [r4, #1]
    ms       = numArgs & DELAY;          //   If hibit set, delay follows args
    3c86:	237f      	movs	r3, #127	; 0x7f
    3c88:	1c11      	adds	r1, r2, #0
  uint16_t ms;

  numCommands = pgm_read_byte(addr++);   // Number of commands to follow
  while(numCommands--) {                 // For each command...
    writecommand(pgm_read_byte(addr++)); //   Read, issue command
    numArgs  = pgm_read_byte(addr++);    //   Number of args to follow
    3c8a:	1ca7      	adds	r7, r4, #2
    ms       = numArgs & DELAY;          //   If hibit set, delay follows args
    3c8c:	4399      	bics	r1, r3
    numArgs &= ~DELAY;                   //   Mask out delay bit
    3c8e:	401a      	ands	r2, r3

  numCommands = pgm_read_byte(addr++);   // Number of commands to follow
  while(numCommands--) {                 // For each command...
    writecommand(pgm_read_byte(addr++)); //   Read, issue command
    numArgs  = pgm_read_byte(addr++);    //   Number of args to follow
    ms       = numArgs & DELAY;          //   If hibit set, delay follows args
    3c90:	9100      	str	r1, [sp, #0]
    numArgs &= ~DELAY;                   //   Mask out delay bit
    3c92:	9201      	str	r2, [sp, #4]
    while(numArgs--) {                   //   For each argument...
    3c94:	1c3c      	adds	r4, r7, #0
    3c96:	9a01      	ldr	r2, [sp, #4]
    3c98:	18bb      	adds	r3, r7, r2
    3c9a:	b2d9      	uxtb	r1, r3
    3c9c:	b2e2      	uxtb	r2, r4
    3c9e:	4291      	cmp	r1, r2
    3ca0:	d005      	beq.n	3cae <_ZN15Adafruit_ST773511commandListEPKh+0x3e>
      writedata(pgm_read_byte(addr++));  //     Read, issue argument
    3ca2:	7821      	ldrb	r1, [r4, #0]
    3ca4:	1c30      	adds	r0, r6, #0
    3ca6:	f7ff ff57 	bl	3b58 <_ZN15Adafruit_ST77359writedataEh>
    3caa:	3401      	adds	r4, #1
    3cac:	e7f3      	b.n	3c96 <_ZN15Adafruit_ST773511commandListEPKh+0x26>
    }

    if(ms) {
    3cae:	9900      	ldr	r1, [sp, #0]
    3cb0:	1c1c      	adds	r4, r3, #0
    3cb2:	2900      	cmp	r1, #0
    3cb4:	d007      	beq.n	3cc6 <_ZN15Adafruit_ST773511commandListEPKh+0x56>
      ms = pgm_read_byte(addr++); // Read post-command delay time (ms)
    3cb6:	7818      	ldrb	r0, [r3, #0]
    3cb8:	1c5c      	adds	r4, r3, #1
      if(ms == 255) ms = 500;     // If 255, delay for 500 ms
    3cba:	28ff      	cmp	r0, #255	; 0xff
    3cbc:	d101      	bne.n	3cc2 <_ZN15Adafruit_ST773511commandListEPKh+0x52>
    3cbe:	20fa      	movs	r0, #250	; 0xfa
    3cc0:	0040      	lsls	r0, r0, #1
      delay(ms);
    3cc2:	f000 fbb7 	bl	4434 <delay>
    3cc6:	3d01      	subs	r5, #1
    3cc8:	b2ed      	uxtb	r5, r5
    3cca:	e7d5      	b.n	3c78 <_ZN15Adafruit_ST773511commandListEPKh+0x8>
    }
  }
}
    3ccc:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
	...

00003cd0 <_ZN15Adafruit_ST773510commonInitEPKh>:


// Initialization code common to both 'B' and 'R' type displays
void Adafruit_ST7735::commonInit(const uint8_t *cmdList) {
    3cd0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  ystart = xstart = colstart  = rowstart = 0; // May be overridden in init func
    3cd2:	1c03      	adds	r3, r0, #0
    3cd4:	1c02      	adds	r2, r0, #0
    3cd6:	2700      	movs	r7, #0
    3cd8:	3228      	adds	r2, #40	; 0x28
    3cda:	3308      	adds	r3, #8
    3cdc:	7017      	strb	r7, [r2, #0]
    3cde:	77df      	strb	r7, [r3, #31]
    3ce0:	3321      	adds	r3, #33	; 0x21
  }
}


// Initialization code common to both 'B' and 'R' type displays
void Adafruit_ST7735::commonInit(const uint8_t *cmdList) {
    3ce2:	1c04      	adds	r4, r0, #0
  ystart = xstart = colstart  = rowstart = 0; // May be overridden in init func
    3ce4:	701f      	strb	r7, [r3, #0]
    3ce6:	705f      	strb	r7, [r3, #1]

  pinMode(_dc, OUTPUT);
    3ce8:	1d03      	adds	r3, r0, #4
    3cea:	201f      	movs	r0, #31
    3cec:	5618      	ldrsb	r0, [r3, r0]
  }
}


// Initialization code common to both 'B' and 'R' type displays
void Adafruit_ST7735::commonInit(const uint8_t *cmdList) {
    3cee:	1c0e      	adds	r6, r1, #0
  ystart = xstart = colstart  = rowstart = 0; // May be overridden in init func

  pinMode(_dc, OUTPUT);
    3cf0:	2101      	movs	r1, #1
    3cf2:	f000 fd17 	bl	4724 <pinMode>
  pinMode(_cs, OUTPUT);
    3cf6:	1ce3      	adds	r3, r4, #3
    3cf8:	9300      	str	r3, [sp, #0]
    3cfa:	201f      	movs	r0, #31
    3cfc:	5618      	ldrsb	r0, [r3, r0]
    3cfe:	2101      	movs	r1, #1
    3d00:	f000 fd10 	bl	4724 <pinMode>
  dcport    = portOutputRegister(digitalPinToPort(_dc));
  cspinmask = digitalPinToBitMask(_cs);
  dcpinmask = digitalPinToBitMask(_dc);
#endif

  if(hwSPI) { // Using hardware SPI
    3d04:	1ca3      	adds	r3, r4, #2
    3d06:	7fdd      	ldrb	r5, [r3, #31]
    3d08:	42bd      	cmp	r5, r7
    3d0a:	d008      	beq.n	3d1e <_ZN15Adafruit_ST773510commonInitEPKh+0x4e>
#if defined (SPI_HAS_TRANSACTION)
    SPI.begin();
    3d0c:	4827      	ldr	r0, [pc, #156]	; (3dac <_ZN15Adafruit_ST773510commonInitEPKh+0xdc>)
    3d0e:	f000 fa75 	bl	41fc <_ZN8SPIClass5beginEv>
    mySPISettings = SPISettings(8000000, MSBFIRST, SPI_MODE0);
    3d12:	4b27      	ldr	r3, [pc, #156]	; (3db0 <_ZN15Adafruit_ST773510commonInitEPKh+0xe0>)
    3d14:	4a27      	ldr	r2, [pc, #156]	; (3db4 <_ZN15Adafruit_ST773510commonInitEPKh+0xe4>)
    3d16:	711f      	strb	r7, [r3, #4]
    3d18:	601a      	str	r2, [r3, #0]
    3d1a:	715f      	strb	r7, [r3, #5]
    3d1c:	e017      	b.n	3d4e <_ZN15Adafruit_ST773510commonInitEPKh+0x7e>
    SPI.begin();
    SPI.setClockDivider(21); //4MHz
    SPI.setDataMode(SPI_MODE0);
#endif
  } else {
    pinMode(_sclk, OUTPUT);
    3d1e:	1de7      	adds	r7, r4, #7
    3d20:	201f      	movs	r0, #31
    3d22:	5638      	ldrsb	r0, [r7, r0]
    3d24:	2101      	movs	r1, #1
    3d26:	f000 fcfd 	bl	4724 <pinMode>
    pinMode(_sid , OUTPUT);
    3d2a:	1da3      	adds	r3, r4, #6
    3d2c:	9301      	str	r3, [sp, #4]
    3d2e:	201f      	movs	r0, #31
    3d30:	5618      	ldrsb	r0, [r3, r0]
    3d32:	2101      	movs	r1, #1
    3d34:	f000 fcf6 	bl	4724 <pinMode>
    digitalWrite(_sclk, LOW);
    3d38:	201f      	movs	r0, #31
    3d3a:	5638      	ldrsb	r0, [r7, r0]
    3d3c:	1c29      	adds	r1, r5, #0
    3d3e:	f000 fd4b 	bl	47d8 <digitalWrite>
    digitalWrite(_sid, LOW);
    3d42:	9b01      	ldr	r3, [sp, #4]
    3d44:	201f      	movs	r0, #31
    3d46:	5618      	ldrsb	r0, [r3, r0]
    3d48:	1c29      	adds	r1, r5, #0
    3d4a:	f000 fd45 	bl	47d8 <digitalWrite>
    datapinmask = digitalPinToBitMask(_sid);
#endif
  }

  // toggle RST low to reset; CS low so it'll listen to us
  CS_LOW();
    3d4e:	9b00      	ldr	r3, [sp, #0]
    3d50:	201f      	movs	r0, #31
    3d52:	5618      	ldrsb	r0, [r3, r0]
    3d54:	f7ff fe7e 	bl	3a54 <_ZN15Adafruit_ST77356CS_LOWEv.isra.1>
  if (_rst != -1) {
    3d58:	1d65      	adds	r5, r4, #5
    3d5a:	201f      	movs	r0, #31
    3d5c:	5628      	ldrsb	r0, [r5, r0]
    3d5e:	1c43      	adds	r3, r0, #1
    3d60:	d01d      	beq.n	3d9e <_ZN15Adafruit_ST773510commonInitEPKh+0xce>
    pinMode(_rst, OUTPUT);
    3d62:	2101      	movs	r1, #1
    3d64:	f000 fcde 	bl	4724 <pinMode>
    digitalWrite(_rst, HIGH);
    3d68:	201f      	movs	r0, #31
    3d6a:	2101      	movs	r1, #1
    3d6c:	5628      	ldrsb	r0, [r5, r0]
    3d6e:	f000 fd33 	bl	47d8 <digitalWrite>
    delay(500);
    3d72:	20fa      	movs	r0, #250	; 0xfa
    3d74:	0040      	lsls	r0, r0, #1
    3d76:	f000 fb5d 	bl	4434 <delay>
    digitalWrite(_rst, LOW);
    3d7a:	201f      	movs	r0, #31
    3d7c:	2100      	movs	r1, #0
    3d7e:	5628      	ldrsb	r0, [r5, r0]
    3d80:	f000 fd2a 	bl	47d8 <digitalWrite>
    delay(500);
    3d84:	20fa      	movs	r0, #250	; 0xfa
    3d86:	0040      	lsls	r0, r0, #1
    3d88:	f000 fb54 	bl	4434 <delay>
    digitalWrite(_rst, HIGH);
    3d8c:	201f      	movs	r0, #31
    3d8e:	5628      	ldrsb	r0, [r5, r0]
    3d90:	2101      	movs	r1, #1
    3d92:	f000 fd21 	bl	47d8 <digitalWrite>
    delay(500);
    3d96:	20fa      	movs	r0, #250	; 0xfa
    3d98:	0040      	lsls	r0, r0, #1
    3d9a:	f000 fb4b 	bl	4434 <delay>
  }

  if(cmdList) commandList(cmdList);
    3d9e:	2e00      	cmp	r6, #0
    3da0:	d003      	beq.n	3daa <_ZN15Adafruit_ST773510commonInitEPKh+0xda>
    3da2:	1c20      	adds	r0, r4, #0
    3da4:	1c31      	adds	r1, r6, #0
    3da6:	f7ff ff63 	bl	3c70 <_ZN15Adafruit_ST773511commandListEPKh>
}
    3daa:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    3dac:	20000168 	.word	0x20000168
    3db0:	20000158 	.word	0x20000158
    3db4:	007a1200 	.word	0x007a1200

00003db8 <_ZN15Adafruit_ST77355initREh>:
  setRotation(0);
}


// Initialization for ST7735R screens (green or red tabs)
void Adafruit_ST7735::initR(uint8_t options) {
    3db8:	b538      	push	{r3, r4, r5, lr}
    3dba:	1c0d      	adds	r5, r1, #0
  commonInit(Rcmd1);
    3dbc:	4926      	ldr	r1, [pc, #152]	; (3e58 <_ZN15Adafruit_ST77355initREh+0xa0>)
  setRotation(0);
}


// Initialization for ST7735R screens (green or red tabs)
void Adafruit_ST7735::initR(uint8_t options) {
    3dbe:	1c04      	adds	r4, r0, #0
  commonInit(Rcmd1);
    3dc0:	f7ff ff86 	bl	3cd0 <_ZN15Adafruit_ST773510commonInitEPKh>
  if(options == INITR_GREENTAB) {
    3dc4:	2d00      	cmp	r5, #0
    3dc6:	d109      	bne.n	3ddc <_ZN15Adafruit_ST77355initREh+0x24>
    commandList(Rcmd2green);
    3dc8:	1c20      	adds	r0, r4, #0
    3dca:	4924      	ldr	r1, [pc, #144]	; (3e5c <_ZN15Adafruit_ST77355initREh+0xa4>)
    3dcc:	f7ff ff50 	bl	3c70 <_ZN15Adafruit_ST773511commandListEPKh>
    colstart = 2;
    3dd0:	1c23      	adds	r3, r4, #0
    3dd2:	2202      	movs	r2, #2
    3dd4:	3308      	adds	r3, #8
    3dd6:	77da      	strb	r2, [r3, #31]
    rowstart = 1;
    3dd8:	2201      	movs	r2, #1
    3dda:	e00d      	b.n	3df8 <_ZN15Adafruit_ST77355initREh+0x40>
  } else if(options == INITR_144GREENTAB) {
    3ddc:	2d01      	cmp	r5, #1
    3dde:	d10e      	bne.n	3dfe <_ZN15Adafruit_ST77355initREh+0x46>
    _height = ST7735_TFTHEIGHT_128;
    3de0:	2380      	movs	r3, #128	; 0x80
    3de2:	81e3      	strh	r3, [r4, #14]
    _width = ST7735_TFTWIDTH_128;
    3de4:	81a3      	strh	r3, [r4, #12]
    commandList(Rcmd2green144);
    3de6:	1c20      	adds	r0, r4, #0
    3de8:	491d      	ldr	r1, [pc, #116]	; (3e60 <_ZN15Adafruit_ST77355initREh+0xa8>)
    3dea:	f7ff ff41 	bl	3c70 <_ZN15Adafruit_ST773511commandListEPKh>
    colstart = 2;
    3dee:	1c23      	adds	r3, r4, #0
    3df0:	2202      	movs	r2, #2
    3df2:	3308      	adds	r3, #8
    3df4:	77da      	strb	r2, [r3, #31]
    rowstart = 3;
    3df6:	2203      	movs	r2, #3
    3df8:	3320      	adds	r3, #32
    3dfa:	701a      	strb	r2, [r3, #0]
    3dfc:	e013      	b.n	3e26 <_ZN15Adafruit_ST77355initREh+0x6e>
  } else if(options == INITR_MINI160x80) {
    3dfe:	2d04      	cmp	r5, #4
    3e00:	d10d      	bne.n	3e1e <_ZN15Adafruit_ST77355initREh+0x66>
    _height = ST7735_TFTHEIGHT_160;
    3e02:	23a0      	movs	r3, #160	; 0xa0
    3e04:	81e3      	strh	r3, [r4, #14]
    _width = ST7735_TFTWIDTH_80;
    3e06:	2350      	movs	r3, #80	; 0x50
    3e08:	81a3      	strh	r3, [r4, #12]
    commandList(Rcmd2green160x80);
    3e0a:	1c20      	adds	r0, r4, #0
    3e0c:	4915      	ldr	r1, [pc, #84]	; (3e64 <_ZN15Adafruit_ST77355initREh+0xac>)
    3e0e:	f7ff ff2f 	bl	3c70 <_ZN15Adafruit_ST773511commandListEPKh>
    colstart = 24;
    3e12:	1c23      	adds	r3, r4, #0
    3e14:	2218      	movs	r2, #24
    3e16:	3308      	adds	r3, #8
    3e18:	77da      	strb	r2, [r3, #31]
    rowstart = 0;
    3e1a:	2200      	movs	r2, #0
    3e1c:	e7ec      	b.n	3df8 <_ZN15Adafruit_ST77355initREh+0x40>
  } else {
    // colstart, rowstart left at default '0' values
    commandList(Rcmd2red);
    3e1e:	1c20      	adds	r0, r4, #0
    3e20:	4911      	ldr	r1, [pc, #68]	; (3e68 <_ZN15Adafruit_ST77355initREh+0xb0>)
    3e22:	f7ff ff25 	bl	3c70 <_ZN15Adafruit_ST773511commandListEPKh>
  }
  commandList(Rcmd3);
    3e26:	1c20      	adds	r0, r4, #0
    3e28:	4910      	ldr	r1, [pc, #64]	; (3e6c <_ZN15Adafruit_ST77355initREh+0xb4>)
    3e2a:	f7ff ff21 	bl	3c70 <_ZN15Adafruit_ST773511commandListEPKh>

  // if black, change MADCTL color filter
  if ((options == INITR_BLACKTAB) || (options == INITR_MINI160x80)) {
    3e2e:	2d02      	cmp	r5, #2
    3e30:	d001      	beq.n	3e36 <_ZN15Adafruit_ST77355initREh+0x7e>
    3e32:	2d04      	cmp	r5, #4
    3e34:	d107      	bne.n	3e46 <_ZN15Adafruit_ST77355initREh+0x8e>
    writecommand(ST7735_MADCTL);
    3e36:	1c20      	adds	r0, r4, #0
    3e38:	2136      	movs	r1, #54	; 0x36
    3e3a:	f7ff fe5b 	bl	3af4 <_ZN15Adafruit_ST773512writecommandEh>
    writedata(0xC0);
    3e3e:	1c20      	adds	r0, r4, #0
    3e40:	21c0      	movs	r1, #192	; 0xc0
    3e42:	f7ff fe89 	bl	3b58 <_ZN15Adafruit_ST77359writedataEh>
  }

  tabcolor = options;
    3e46:	1c63      	adds	r3, r4, #1
    3e48:	77dd      	strb	r5, [r3, #31]

  setRotation(0);
    3e4a:	6823      	ldr	r3, [r4, #0]
    3e4c:	1c20      	adds	r0, r4, #0
    3e4e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    3e50:	2100      	movs	r1, #0
    3e52:	4798      	blx	r3
}
    3e54:	bd38      	pop	{r3, r4, r5, pc}
    3e56:	46c0      	nop			; (mov r8, r8)
    3e58:	00008c4f 	.word	0x00008c4f
    3e5c:	00008c42 	.word	0x00008c42
    3e60:	00008bc0 	.word	0x00008bc0
    3e64:	00008c28 	.word	0x00008c28
    3e68:	00008c35 	.word	0x00008c35
    3e6c:	00008c8a 	.word	0x00008c8a

00003e70 <_ZN15Adafruit_ST773513setAddrWindowEhhhh>:


void Adafruit_ST7735::setAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1,
 uint8_t y1) {
    3e70:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    3e72:	1c1e      	adds	r6, r3, #0
    3e74:	ab08      	add	r3, sp, #32
    3e76:	1c04      	adds	r4, r0, #0
    3e78:	781b      	ldrb	r3, [r3, #0]
    3e7a:	1c0f      	adds	r7, r1, #0

  writecommand(ST7735_CASET); // Column addr set
  writedata(0x00);
  writedata(x0+xstart);     // XSTART 
    3e7c:	1c25      	adds	r5, r4, #0


void Adafruit_ST7735::setAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1,
 uint8_t y1) {

  writecommand(ST7735_CASET); // Column addr set
    3e7e:	212a      	movs	r1, #42	; 0x2a
  setRotation(0);
}


void Adafruit_ST7735::setAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1,
 uint8_t y1) {
    3e80:	9200      	str	r2, [sp, #0]
    3e82:	9301      	str	r3, [sp, #4]

  writecommand(ST7735_CASET); // Column addr set
  writedata(0x00);
  writedata(x0+xstart);     // XSTART 
    3e84:	3529      	adds	r5, #41	; 0x29


void Adafruit_ST7735::setAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1,
 uint8_t y1) {

  writecommand(ST7735_CASET); // Column addr set
    3e86:	f7ff fe35 	bl	3af4 <_ZN15Adafruit_ST773512writecommandEh>
  writedata(0x00);
    3e8a:	1c20      	adds	r0, r4, #0
    3e8c:	2100      	movs	r1, #0
    3e8e:	f7ff fe63 	bl	3b58 <_ZN15Adafruit_ST77359writedataEh>
  writedata(x0+xstart);     // XSTART 
    3e92:	7829      	ldrb	r1, [r5, #0]
    3e94:	1c20      	adds	r0, r4, #0
    3e96:	187f      	adds	r7, r7, r1
    3e98:	b2f9      	uxtb	r1, r7
    3e9a:	f7ff fe5d 	bl	3b58 <_ZN15Adafruit_ST77359writedataEh>
  writedata(0x00);
    3e9e:	1c20      	adds	r0, r4, #0
    3ea0:	2100      	movs	r1, #0
    3ea2:	f7ff fe59 	bl	3b58 <_ZN15Adafruit_ST77359writedataEh>
  writedata(x1+xstart);     // XEND
    3ea6:	7829      	ldrb	r1, [r5, #0]
    3ea8:	1c20      	adds	r0, r4, #0
    3eaa:	1876      	adds	r6, r6, r1
    3eac:	b2f1      	uxtb	r1, r6
    3eae:	f7ff fe53 	bl	3b58 <_ZN15Adafruit_ST77359writedataEh>

  writecommand(ST7735_RASET); // Row addr set
    3eb2:	1c20      	adds	r0, r4, #0
    3eb4:	212b      	movs	r1, #43	; 0x2b
    3eb6:	f7ff fe1d 	bl	3af4 <_ZN15Adafruit_ST773512writecommandEh>
  writedata(0x00);
    3eba:	1c20      	adds	r0, r4, #0
    3ebc:	2100      	movs	r1, #0
    3ebe:	f7ff fe4b 	bl	3b58 <_ZN15Adafruit_ST77359writedataEh>
  writedata(y0+ystart);     // YSTART
    3ec2:	9b00      	ldr	r3, [sp, #0]
    3ec4:	7869      	ldrb	r1, [r5, #1]
    3ec6:	1c20      	adds	r0, r4, #0
    3ec8:	1859      	adds	r1, r3, r1
    3eca:	b2c9      	uxtb	r1, r1
    3ecc:	f7ff fe44 	bl	3b58 <_ZN15Adafruit_ST77359writedataEh>
  writedata(0x00);
    3ed0:	1c20      	adds	r0, r4, #0
    3ed2:	2100      	movs	r1, #0
    3ed4:	f7ff fe40 	bl	3b58 <_ZN15Adafruit_ST77359writedataEh>
  writedata(y1+ystart);     // YEND
    3ed8:	7869      	ldrb	r1, [r5, #1]
    3eda:	9b01      	ldr	r3, [sp, #4]
    3edc:	1c20      	adds	r0, r4, #0
    3ede:	1859      	adds	r1, r3, r1
    3ee0:	b2c9      	uxtb	r1, r1
    3ee2:	f7ff fe39 	bl	3b58 <_ZN15Adafruit_ST77359writedataEh>

  writecommand(ST7735_RAMWR); // write to RAM
    3ee6:	1c20      	adds	r0, r4, #0
    3ee8:	212c      	movs	r1, #44	; 0x2c
    3eea:	f7ff fe03 	bl	3af4 <_ZN15Adafruit_ST773512writecommandEh>
}
    3eee:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

00003ef0 <_ZN15Adafruit_ST77359drawPixelEsst>:
#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)    SPI.endTransaction();
#endif
}

void Adafruit_ST7735::drawPixel(int16_t x, int16_t y, uint16_t color) {
    3ef0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    3ef2:	1c04      	adds	r4, r0, #0
    3ef4:	1c1d      	adds	r5, r3, #0

  if((x < 0) ||(x >= _width) || (y < 0) || (y >= _height)) return;
    3ef6:	2900      	cmp	r1, #0
    3ef8:	db39      	blt.n	3f6e <_ZN15Adafruit_ST77359drawPixelEsst+0x7e>
    3efa:	200c      	movs	r0, #12
    3efc:	5e23      	ldrsh	r3, [r4, r0]
    3efe:	428b      	cmp	r3, r1
    3f00:	dd35      	ble.n	3f6e <_ZN15Adafruit_ST77359drawPixelEsst+0x7e>
    3f02:	2a00      	cmp	r2, #0
    3f04:	db33      	blt.n	3f6e <_ZN15Adafruit_ST77359drawPixelEsst+0x7e>
    3f06:	200e      	movs	r0, #14
    3f08:	5e23      	ldrsh	r3, [r4, r0]
    3f0a:	4293      	cmp	r3, r2
    3f0c:	dd2f      	ble.n	3f6e <_ZN15Adafruit_ST77359drawPixelEsst+0x7e>

  setAddrWindow(x,y,x+1,y+1);
    3f0e:	b2d2      	uxtb	r2, r2
    3f10:	b2c9      	uxtb	r1, r1
    3f12:	1c50      	adds	r0, r2, #1
    3f14:	1c4b      	adds	r3, r1, #1
    3f16:	b2c0      	uxtb	r0, r0
    3f18:	b2db      	uxtb	r3, r3
    3f1a:	9000      	str	r0, [sp, #0]

#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)     SPI.beginTransaction(mySPISettings);
    3f1c:	1ca6      	adds	r6, r4, #2

void Adafruit_ST7735::drawPixel(int16_t x, int16_t y, uint16_t color) {

  if((x < 0) ||(x >= _width) || (y < 0) || (y >= _height)) return;

  setAddrWindow(x,y,x+1,y+1);
    3f1e:	1c20      	adds	r0, r4, #0
    3f20:	f7ff ffa6 	bl	3e70 <_ZN15Adafruit_ST773513setAddrWindowEhhhh>

#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)     SPI.beginTransaction(mySPISettings);
    3f24:	7ff3      	ldrb	r3, [r6, #31]
    3f26:	2b00      	cmp	r3, #0
    3f28:	d004      	beq.n	3f34 <_ZN15Adafruit_ST77359drawPixelEsst+0x44>
    3f2a:	4b11      	ldr	r3, [pc, #68]	; (3f70 <_ZN15Adafruit_ST77359drawPixelEsst+0x80>)
    3f2c:	4811      	ldr	r0, [pc, #68]	; (3f74 <_ZN15Adafruit_ST77359drawPixelEsst+0x84>)
    3f2e:	cb06      	ldmia	r3!, {r1, r2}
    3f30:	f000 f98c 	bl	424c <_ZN8SPIClass16beginTransactionE11SPISettings>
#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)    SPI.endTransaction();
#endif
}

void Adafruit_ST7735::drawPixel(int16_t x, int16_t y, uint16_t color) {
    3f34:	1d23      	adds	r3, r4, #4

inline void Adafruit_ST7735::DC_HIGH(void) {
#if defined(USE_FAST_IO)
  *dcport |= dcpinmask;
#else
  digitalWrite(_dc, HIGH);
    3f36:	201f      	movs	r0, #31
    3f38:	5618      	ldrsb	r0, [r3, r0]
    3f3a:	2101      	movs	r1, #1
    3f3c:	f000 fc4c 	bl	47d8 <digitalWrite>
#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)    SPI.endTransaction();
#endif
}

void Adafruit_ST7735::drawPixel(int16_t x, int16_t y, uint16_t color) {
    3f40:	1ce7      	adds	r7, r4, #3
#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)     SPI.beginTransaction(mySPISettings);
#endif

  DC_HIGH();
  CS_LOW();
    3f42:	201f      	movs	r0, #31
    3f44:	5638      	ldrsb	r0, [r7, r0]
    3f46:	f7ff fd85 	bl	3a54 <_ZN15Adafruit_ST77356CS_LOWEv.isra.1>
  spiwrite(color >> 8);
    3f4a:	0a29      	lsrs	r1, r5, #8
    3f4c:	1c20      	adds	r0, r4, #0
    3f4e:	f7ff fda5 	bl	3a9c <_ZN15Adafruit_ST77358spiwriteEh>
  spiwrite(color);
    3f52:	b2e9      	uxtb	r1, r5
    3f54:	1c20      	adds	r0, r4, #0
    3f56:	f7ff fda1 	bl	3a9c <_ZN15Adafruit_ST77358spiwriteEh>
  CS_HIGH();
    3f5a:	201f      	movs	r0, #31
    3f5c:	5638      	ldrsb	r0, [r7, r0]
    3f5e:	f7ff fd74 	bl	3a4a <_ZN15Adafruit_ST77357CS_HIGHEv.isra.0>

#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)     SPI.endTransaction();
    3f62:	7ff3      	ldrb	r3, [r6, #31]
    3f64:	2b00      	cmp	r3, #0
    3f66:	d002      	beq.n	3f6e <_ZN15Adafruit_ST77359drawPixelEsst+0x7e>
    3f68:	4802      	ldr	r0, [pc, #8]	; (3f74 <_ZN15Adafruit_ST77359drawPixelEsst+0x84>)
    3f6a:	f000 f98b 	bl	4284 <_ZN8SPIClass14endTransactionEv>
#endif
}
    3f6e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    3f70:	20000158 	.word	0x20000158
    3f74:	20000168 	.word	0x20000168

00003f78 <_ZN15Adafruit_ST773513drawFastVLineEssst>:


void Adafruit_ST7735::drawFastVLine(int16_t x, int16_t y, int16_t h,
 uint16_t color) {
    3f78:	b5f0      	push	{r4, r5, r6, r7, lr}
    3f7a:	b085      	sub	sp, #20
    3f7c:	1c04      	adds	r4, r0, #0
    3f7e:	1c1d      	adds	r5, r3, #0
    3f80:	ab0a      	add	r3, sp, #40	; 0x28
    3f82:	881e      	ldrh	r6, [r3, #0]

  // Rudimentary clipping
  if((x >= _width) || (y >= _height)) return;
    3f84:	200c      	movs	r0, #12
    3f86:	5e23      	ldrsh	r3, [r4, r0]
    3f88:	428b      	cmp	r3, r1
    3f8a:	dd41      	ble.n	4010 <_ZN15Adafruit_ST773513drawFastVLineEssst+0x98>
    3f8c:	89e3      	ldrh	r3, [r4, #14]
    3f8e:	b218      	sxth	r0, r3
    3f90:	4282      	cmp	r2, r0
    3f92:	da3d      	bge.n	4010 <_ZN15Adafruit_ST773513drawFastVLineEssst+0x98>
  if((y+h-1) >= _height) h = _height-y;
    3f94:	1957      	adds	r7, r2, r5
    3f96:	4287      	cmp	r7, r0
    3f98:	dd01      	ble.n	3f9e <_ZN15Adafruit_ST773513drawFastVLineEssst+0x26>
    3f9a:	1a9d      	subs	r5, r3, r2
    3f9c:	b22d      	sxth	r5, r5
  setAddrWindow(x, y, x, y+h-1);
    3f9e:	b2d2      	uxtb	r2, r2
    3fa0:	b2cb      	uxtb	r3, r1
    3fa2:	1e51      	subs	r1, r2, #1
    3fa4:	1949      	adds	r1, r1, r5
    3fa6:	b2c9      	uxtb	r1, r1
    3fa8:	9100      	str	r1, [sp, #0]
    3faa:	1c20      	adds	r0, r4, #0
    3fac:	1c19      	adds	r1, r3, #0
    3fae:	f7ff ff5f 	bl	3e70 <_ZN15Adafruit_ST773513setAddrWindowEhhhh>

  uint8_t hi = color >> 8, lo = color;
    3fb2:	0a33      	lsrs	r3, r6, #8
    3fb4:	b2f6      	uxtb	r6, r6
    3fb6:	9603      	str	r6, [sp, #12]
    3fb8:	9302      	str	r3, [sp, #8]
    
#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)      SPI.beginTransaction(mySPISettings);
    3fba:	1ca6      	adds	r6, r4, #2
    3fbc:	7ff3      	ldrb	r3, [r6, #31]
    3fbe:	2b00      	cmp	r3, #0
    3fc0:	d004      	beq.n	3fcc <_ZN15Adafruit_ST773513drawFastVLineEssst+0x54>
    3fc2:	4b14      	ldr	r3, [pc, #80]	; (4014 <_ZN15Adafruit_ST773513drawFastVLineEssst+0x9c>)
    3fc4:	4814      	ldr	r0, [pc, #80]	; (4018 <_ZN15Adafruit_ST773513drawFastVLineEssst+0xa0>)
    3fc6:	cb06      	ldmia	r3!, {r1, r2}
    3fc8:	f000 f940 	bl	424c <_ZN8SPIClass16beginTransactionE11SPISettings>
#endif
}


void Adafruit_ST7735::drawFastVLine(int16_t x, int16_t y, int16_t h,
 uint16_t color) {
    3fcc:	1d23      	adds	r3, r4, #4

inline void Adafruit_ST7735::DC_HIGH(void) {
#if defined(USE_FAST_IO)
  *dcport |= dcpinmask;
#else
  digitalWrite(_dc, HIGH);
    3fce:	201f      	movs	r0, #31
    3fd0:	5618      	ldrsb	r0, [r3, r0]
    3fd2:	2101      	movs	r1, #1
    3fd4:	f000 fc00 	bl	47d8 <digitalWrite>
#endif
}


void Adafruit_ST7735::drawFastVLine(int16_t x, int16_t y, int16_t h,
 uint16_t color) {
    3fd8:	1ce7      	adds	r7, r4, #3
#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)      SPI.beginTransaction(mySPISettings);
#endif

  DC_HIGH();
  CS_LOW();
    3fda:	201f      	movs	r0, #31
    3fdc:	5638      	ldrsb	r0, [r7, r0]
    3fde:	f7ff fd39 	bl	3a54 <_ZN15Adafruit_ST77356CS_LOWEv.isra.1>
    3fe2:	b2ad      	uxth	r5, r5
  while (h--) {
    3fe4:	2d00      	cmp	r5, #0
    3fe6:	d009      	beq.n	3ffc <_ZN15Adafruit_ST773513drawFastVLineEssst+0x84>
    spiwrite(hi);
    3fe8:	1c20      	adds	r0, r4, #0
    3fea:	9902      	ldr	r1, [sp, #8]
    3fec:	f7ff fd56 	bl	3a9c <_ZN15Adafruit_ST77358spiwriteEh>
    spiwrite(lo);
    3ff0:	1c20      	adds	r0, r4, #0
    3ff2:	9903      	ldr	r1, [sp, #12]
    3ff4:	f7ff fd52 	bl	3a9c <_ZN15Adafruit_ST77358spiwriteEh>
    3ff8:	3d01      	subs	r5, #1
    3ffa:	e7f2      	b.n	3fe2 <_ZN15Adafruit_ST773513drawFastVLineEssst+0x6a>
  }
  CS_HIGH();
    3ffc:	201f      	movs	r0, #31
    3ffe:	5638      	ldrsb	r0, [r7, r0]
    4000:	f7ff fd23 	bl	3a4a <_ZN15Adafruit_ST77357CS_HIGHEv.isra.0>

#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)      SPI.endTransaction();
    4004:	7ff3      	ldrb	r3, [r6, #31]
    4006:	2b00      	cmp	r3, #0
    4008:	d002      	beq.n	4010 <_ZN15Adafruit_ST773513drawFastVLineEssst+0x98>
    400a:	4803      	ldr	r0, [pc, #12]	; (4018 <_ZN15Adafruit_ST773513drawFastVLineEssst+0xa0>)
    400c:	f000 f93a 	bl	4284 <_ZN8SPIClass14endTransactionEv>
#endif
}
    4010:	b005      	add	sp, #20
    4012:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4014:	20000158 	.word	0x20000158
    4018:	20000168 	.word	0x20000168

0000401c <_ZN15Adafruit_ST773513drawFastHLineEssst>:


void Adafruit_ST7735::drawFastHLine(int16_t x, int16_t y, int16_t w,
  uint16_t color) {
    401c:	b5f0      	push	{r4, r5, r6, r7, lr}
    401e:	b085      	sub	sp, #20
    4020:	1c1d      	adds	r5, r3, #0
    4022:	ab0a      	add	r3, sp, #40	; 0x28
    4024:	881e      	ldrh	r6, [r3, #0]

  // Rudimentary clipping
  if((x >= _width) || (y >= _height)) return;
    4026:	8983      	ldrh	r3, [r0, #12]
#endif
}


void Adafruit_ST7735::drawFastHLine(int16_t x, int16_t y, int16_t w,
  uint16_t color) {
    4028:	1c04      	adds	r4, r0, #0

  // Rudimentary clipping
  if((x >= _width) || (y >= _height)) return;
    402a:	b218      	sxth	r0, r3
    402c:	9302      	str	r3, [sp, #8]
    402e:	4281      	cmp	r1, r0
    4030:	da41      	bge.n	40b6 <_ZN15Adafruit_ST773513drawFastHLineEssst+0x9a>
    4032:	230e      	movs	r3, #14
    4034:	5ee7      	ldrsh	r7, [r4, r3]
    4036:	4297      	cmp	r7, r2
    4038:	dd3d      	ble.n	40b6 <_ZN15Adafruit_ST773513drawFastHLineEssst+0x9a>
  if((x+w-1) >= _width)  w = _width-x;
    403a:	194f      	adds	r7, r1, r5
    403c:	4287      	cmp	r7, r0
    403e:	dd02      	ble.n	4046 <_ZN15Adafruit_ST773513drawFastHLineEssst+0x2a>
    4040:	9f02      	ldr	r7, [sp, #8]
    4042:	1a7d      	subs	r5, r7, r1
    4044:	b22d      	sxth	r5, r5
  setAddrWindow(x, y, x+w-1, y);
    4046:	b2c9      	uxtb	r1, r1
    4048:	1e4b      	subs	r3, r1, #1
    404a:	b2d2      	uxtb	r2, r2
    404c:	195b      	adds	r3, r3, r5
    404e:	b2db      	uxtb	r3, r3

  uint8_t hi = color >> 8, lo = color;
    4050:	0a37      	lsrs	r7, r6, #8
  uint16_t color) {

  // Rudimentary clipping
  if((x >= _width) || (y >= _height)) return;
  if((x+w-1) >= _width)  w = _width-x;
  setAddrWindow(x, y, x+w-1, y);
    4052:	9200      	str	r2, [sp, #0]

  uint8_t hi = color >> 8, lo = color;
    4054:	b2f6      	uxtb	r6, r6
  uint16_t color) {

  // Rudimentary clipping
  if((x >= _width) || (y >= _height)) return;
  if((x+w-1) >= _width)  w = _width-x;
  setAddrWindow(x, y, x+w-1, y);
    4056:	1c20      	adds	r0, r4, #0
    4058:	f7ff ff0a 	bl	3e70 <_ZN15Adafruit_ST773513setAddrWindowEhhhh>

  uint8_t hi = color >> 8, lo = color;
    405c:	9603      	str	r6, [sp, #12]
    405e:	9702      	str	r7, [sp, #8]

#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)      SPI.beginTransaction(mySPISettings);
    4060:	1ca6      	adds	r6, r4, #2
    4062:	7ff3      	ldrb	r3, [r6, #31]
    4064:	2b00      	cmp	r3, #0
    4066:	d004      	beq.n	4072 <_ZN15Adafruit_ST773513drawFastHLineEssst+0x56>
    4068:	4b14      	ldr	r3, [pc, #80]	; (40bc <_ZN15Adafruit_ST773513drawFastHLineEssst+0xa0>)
    406a:	4815      	ldr	r0, [pc, #84]	; (40c0 <_ZN15Adafruit_ST773513drawFastHLineEssst+0xa4>)
    406c:	cb06      	ldmia	r3!, {r1, r2}
    406e:	f000 f8ed 	bl	424c <_ZN8SPIClass16beginTransactionE11SPISettings>
#endif
}


void Adafruit_ST7735::drawFastHLine(int16_t x, int16_t y, int16_t w,
  uint16_t color) {
    4072:	1d23      	adds	r3, r4, #4

inline void Adafruit_ST7735::DC_HIGH(void) {
#if defined(USE_FAST_IO)
  *dcport |= dcpinmask;
#else
  digitalWrite(_dc, HIGH);
    4074:	201f      	movs	r0, #31
    4076:	5618      	ldrsb	r0, [r3, r0]
    4078:	2101      	movs	r1, #1
    407a:	f000 fbad 	bl	47d8 <digitalWrite>
#endif
}


void Adafruit_ST7735::drawFastHLine(int16_t x, int16_t y, int16_t w,
  uint16_t color) {
    407e:	1ce7      	adds	r7, r4, #3
#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)      SPI.beginTransaction(mySPISettings);
#endif

  DC_HIGH();
  CS_LOW();
    4080:	201f      	movs	r0, #31
    4082:	5638      	ldrsb	r0, [r7, r0]
    4084:	f7ff fce6 	bl	3a54 <_ZN15Adafruit_ST77356CS_LOWEv.isra.1>
    4088:	b2ad      	uxth	r5, r5
  while (w--) {
    408a:	2d00      	cmp	r5, #0
    408c:	d009      	beq.n	40a2 <_ZN15Adafruit_ST773513drawFastHLineEssst+0x86>
    spiwrite(hi);
    408e:	1c20      	adds	r0, r4, #0
    4090:	9902      	ldr	r1, [sp, #8]
    4092:	f7ff fd03 	bl	3a9c <_ZN15Adafruit_ST77358spiwriteEh>
    spiwrite(lo);
    4096:	1c20      	adds	r0, r4, #0
    4098:	9903      	ldr	r1, [sp, #12]
    409a:	f7ff fcff 	bl	3a9c <_ZN15Adafruit_ST77358spiwriteEh>
    409e:	3d01      	subs	r5, #1
    40a0:	e7f2      	b.n	4088 <_ZN15Adafruit_ST773513drawFastHLineEssst+0x6c>
  }
  CS_HIGH();
    40a2:	201f      	movs	r0, #31
    40a4:	5638      	ldrsb	r0, [r7, r0]
    40a6:	f7ff fcd0 	bl	3a4a <_ZN15Adafruit_ST77357CS_HIGHEv.isra.0>

#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)      SPI.endTransaction();
    40aa:	7ff3      	ldrb	r3, [r6, #31]
    40ac:	2b00      	cmp	r3, #0
    40ae:	d002      	beq.n	40b6 <_ZN15Adafruit_ST773513drawFastHLineEssst+0x9a>
    40b0:	4803      	ldr	r0, [pc, #12]	; (40c0 <_ZN15Adafruit_ST773513drawFastHLineEssst+0xa4>)
    40b2:	f000 f8e7 	bl	4284 <_ZN8SPIClass14endTransactionEv>
#endif
}
    40b6:	b005      	add	sp, #20
    40b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    40ba:	46c0      	nop			; (mov r8, r8)
    40bc:	20000158 	.word	0x20000158
    40c0:	20000168 	.word	0x20000168

000040c4 <_ZN15Adafruit_ST77358fillRectEsssst>:



// fill a rectangle
void Adafruit_ST7735::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
  uint16_t color) {
    40c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    40c6:	b087      	sub	sp, #28
    40c8:	1c04      	adds	r4, r0, #0
    40ca:	9302      	str	r3, [sp, #8]
    40cc:	ab0c      	add	r3, sp, #48	; 0x30
    40ce:	2000      	movs	r0, #0
    40d0:	5e1e      	ldrsh	r6, [r3, r0]

  // rudimentary clipping (drawChar w/big text requires this)
  if((x >= _width) || (y >= _height)) return;
    40d2:	89a0      	ldrh	r0, [r4, #12]



// fill a rectangle
void Adafruit_ST7735::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
  uint16_t color) {
    40d4:	ab0d      	add	r3, sp, #52	; 0x34

  // rudimentary clipping (drawChar w/big text requires this)
  if((x >= _width) || (y >= _height)) return;
    40d6:	b205      	sxth	r5, r0



// fill a rectangle
void Adafruit_ST7735::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
  uint16_t color) {
    40d8:	881f      	ldrh	r7, [r3, #0]

  // rudimentary clipping (drawChar w/big text requires this)
  if((x >= _width) || (y >= _height)) return;
    40da:	42a9      	cmp	r1, r5
    40dc:	da57      	bge.n	418e <_ZN15Adafruit_ST77358fillRectEsssst+0xca>
    40de:	89e3      	ldrh	r3, [r4, #14]
    40e0:	469c      	mov	ip, r3
    40e2:	b21b      	sxth	r3, r3
    40e4:	9304      	str	r3, [sp, #16]
    40e6:	429a      	cmp	r2, r3
    40e8:	da51      	bge.n	418e <_ZN15Adafruit_ST77358fillRectEsssst+0xca>
  if((x + w - 1) >= _width)  w = _width  - x;
    40ea:	9b02      	ldr	r3, [sp, #8]
    40ec:	18cb      	adds	r3, r1, r3
    40ee:	42ab      	cmp	r3, r5
    40f0:	dd02      	ble.n	40f8 <_ZN15Adafruit_ST77358fillRectEsssst+0x34>
    40f2:	1a40      	subs	r0, r0, r1
    40f4:	b203      	sxth	r3, r0
    40f6:	9302      	str	r3, [sp, #8]
  if((y + h - 1) >= _height) h = _height - y;
    40f8:	9b04      	ldr	r3, [sp, #16]
    40fa:	1990      	adds	r0, r2, r6
    40fc:	4298      	cmp	r0, r3
    40fe:	dd02      	ble.n	4106 <_ZN15Adafruit_ST77358fillRectEsssst+0x42>
    4100:	4660      	mov	r0, ip
    4102:	1a86      	subs	r6, r0, r2
    4104:	b236      	sxth	r6, r6

  setAddrWindow(x, y, x+w-1, y+h-1);
    4106:	9802      	ldr	r0, [sp, #8]
    4108:	b2c9      	uxtb	r1, r1
    410a:	b2d2      	uxtb	r2, r2
    410c:	1e4b      	subs	r3, r1, #1
    410e:	181b      	adds	r3, r3, r0
    4110:	1e50      	subs	r0, r2, #1
    4112:	1980      	adds	r0, r0, r6
    4114:	b2c0      	uxtb	r0, r0
    4116:	b2db      	uxtb	r3, r3
    4118:	9000      	str	r0, [sp, #0]
    411a:	1c20      	adds	r0, r4, #0
    411c:	f7ff fea8 	bl	3e70 <_ZN15Adafruit_ST773513setAddrWindowEhhhh>

  uint8_t hi = color >> 8, lo = color;
    4120:	0a3a      	lsrs	r2, r7, #8
    
#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)      SPI.beginTransaction(mySPISettings);
    4122:	1ca3      	adds	r3, r4, #2
  if((x + w - 1) >= _width)  w = _width  - x;
  if((y + h - 1) >= _height) h = _height - y;

  setAddrWindow(x, y, x+w-1, y+h-1);

  uint8_t hi = color >> 8, lo = color;
    4124:	b2ff      	uxtb	r7, r7
    4126:	9204      	str	r2, [sp, #16]
    4128:	9705      	str	r7, [sp, #20]
    
#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)      SPI.beginTransaction(mySPISettings);
    412a:	9303      	str	r3, [sp, #12]
    412c:	7fdb      	ldrb	r3, [r3, #31]
    412e:	2b00      	cmp	r3, #0
    4130:	d004      	beq.n	413c <_ZN15Adafruit_ST77358fillRectEsssst+0x78>
    4132:	4b18      	ldr	r3, [pc, #96]	; (4194 <_ZN15Adafruit_ST77358fillRectEsssst+0xd0>)
    4134:	4818      	ldr	r0, [pc, #96]	; (4198 <_ZN15Adafruit_ST77358fillRectEsssst+0xd4>)
    4136:	cb06      	ldmia	r3!, {r1, r2}
    4138:	f000 f888 	bl	424c <_ZN8SPIClass16beginTransactionE11SPISettings>



// fill a rectangle
void Adafruit_ST7735::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
  uint16_t color) {
    413c:	1d23      	adds	r3, r4, #4

inline void Adafruit_ST7735::DC_HIGH(void) {
#if defined(USE_FAST_IO)
  *dcport |= dcpinmask;
#else
  digitalWrite(_dc, HIGH);
    413e:	201f      	movs	r0, #31
    4140:	5618      	ldrsb	r0, [r3, r0]
    4142:	2101      	movs	r1, #1
    4144:	f000 fb48 	bl	47d8 <digitalWrite>



// fill a rectangle
void Adafruit_ST7735::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
  uint16_t color) {
    4148:	1ce7      	adds	r7, r4, #3
#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)      SPI.beginTransaction(mySPISettings);
#endif

  DC_HIGH();
  CS_LOW();
    414a:	201f      	movs	r0, #31
    414c:	5638      	ldrsb	r0, [r7, r0]
    414e:	f7ff fc81 	bl	3a54 <_ZN15Adafruit_ST77356CS_LOWEv.isra.1>
  for(y=h; y>0; y--) {
    4152:	2e00      	cmp	r6, #0
    4154:	dd10      	ble.n	4178 <_ZN15Adafruit_ST77358fillRectEsssst+0xb4>
    4156:	9d02      	ldr	r5, [sp, #8]
    for(x=w; x>0; x--) {
    4158:	2d00      	cmp	r5, #0
    415a:	dd0a      	ble.n	4172 <_ZN15Adafruit_ST77358fillRectEsssst+0xae>
      spiwrite(hi);
    415c:	1c20      	adds	r0, r4, #0
    415e:	9904      	ldr	r1, [sp, #16]
    4160:	f7ff fc9c 	bl	3a9c <_ZN15Adafruit_ST77358spiwriteEh>
    4164:	3d01      	subs	r5, #1
      spiwrite(lo);
    4166:	1c20      	adds	r0, r4, #0
    4168:	9905      	ldr	r1, [sp, #20]
    416a:	f7ff fc97 	bl	3a9c <_ZN15Adafruit_ST77358spiwriteEh>
    416e:	b22d      	sxth	r5, r5
    4170:	e7f2      	b.n	4158 <_ZN15Adafruit_ST77358fillRectEsssst+0x94>
    4172:	3e01      	subs	r6, #1
    4174:	b236      	sxth	r6, r6
    4176:	e7ec      	b.n	4152 <_ZN15Adafruit_ST77358fillRectEsssst+0x8e>
    }
  }
  CS_HIGH();
    4178:	201f      	movs	r0, #31
    417a:	5638      	ldrsb	r0, [r7, r0]
    417c:	f7ff fc65 	bl	3a4a <_ZN15Adafruit_ST77357CS_HIGHEv.isra.0>

#if defined (SPI_HAS_TRANSACTION)
  if (hwSPI)      SPI.endTransaction();
    4180:	9803      	ldr	r0, [sp, #12]
    4182:	7fc3      	ldrb	r3, [r0, #31]
    4184:	2b00      	cmp	r3, #0
    4186:	d002      	beq.n	418e <_ZN15Adafruit_ST77358fillRectEsssst+0xca>
    4188:	4803      	ldr	r0, [pc, #12]	; (4198 <_ZN15Adafruit_ST77358fillRectEsssst+0xd4>)
    418a:	f000 f87b 	bl	4284 <_ZN8SPIClass14endTransactionEv>
#endif
}
    418e:	b007      	add	sp, #28
    4190:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4192:	46c0      	nop			; (mov r8, r8)
    4194:	20000158 	.word	0x20000158
    4198:	20000168 	.word	0x20000168

0000419c <_GLOBAL__sub_I__ZN15Adafruit_ST7735C2Eaaaaa>:
  void init_MightInline(uint32_t clock, BitOrder bitOrder, uint8_t dataMode) {
    init_AlwaysInline(clock, bitOrder, dataMode);
  }

  void init_AlwaysInline(uint32_t clock, BitOrder bitOrder, uint8_t dataMode) __attribute__((__always_inline__)) {
    this->clockFreq = (clock >= (F_CPU / SPI_MIN_CLOCK_DIVIDER) ? F_CPU / SPI_MIN_CLOCK_DIVIDER : clock);
    419c:	4b03      	ldr	r3, [pc, #12]	; (41ac <_GLOBAL__sub_I__ZN15Adafruit_ST7735C2Eaaaaa+0x10>)
    419e:	4a04      	ldr	r2, [pc, #16]	; (41b0 <_GLOBAL__sub_I__ZN15Adafruit_ST7735C2Eaaaaa+0x14>)
    41a0:	601a      	str	r2, [r3, #0]

    this->bitOrder = (bitOrder == MSBFIRST ? MSB_FIRST : LSB_FIRST);
    41a2:	2200      	movs	r2, #0
    41a4:	715a      	strb	r2, [r3, #5]

    switch (dataMode)
    {
      case SPI_MODE0:
        this->dataMode = SERCOM_SPI_MODE_0; break;
    41a6:	711a      	strb	r2, [r3, #4]
#if defined(USE_FAST_IO)
  *dcport &= ~dcpinmask;
#else
  digitalWrite(_dc, LOW);
#endif
}
    41a8:	4770      	bx	lr
    41aa:	46c0      	nop			; (mov r8, r8)
    41ac:	20000158 	.word	0x20000158
    41b0:	003d0900 	.word	0x003d0900

000041b4 <_ZN8SPIClass4initEv>:
  config(DEFAULT_SPI_SETTINGS);
}

void SPIClass::init()
{
  if (initialized)
    41b4:	7a43      	ldrb	r3, [r0, #9]
    41b6:	2b00      	cmp	r3, #0
    41b8:	d104      	bne.n	41c4 <_ZN8SPIClass4initEv+0x10>
    return;
  interruptMode = SPI_IMODE_NONE;
    41ba:	7283      	strb	r3, [r0, #10]
  interruptSave = 0;
    41bc:	72c3      	strb	r3, [r0, #11]
  interruptMask = 0;
    41be:	60c3      	str	r3, [r0, #12]
  initialized = true;
    41c0:	2301      	movs	r3, #1
    41c2:	7243      	strb	r3, [r0, #9]
}
    41c4:	4770      	bx	lr

000041c6 <_ZN8SPIClass6configE11SPISettings>:

void SPIClass::config(SPISettings settings)
{
    41c6:	b530      	push	{r4, r5, lr}
    41c8:	b085      	sub	sp, #20
    41ca:	1c04      	adds	r4, r0, #0
    41cc:	ad02      	add	r5, sp, #8
  _p_sercom->disableSPI();
    41ce:	6800      	ldr	r0, [r0, #0]
  interruptMask = 0;
  initialized = true;
}

void SPIClass::config(SPISettings settings)
{
    41d0:	9102      	str	r1, [sp, #8]
    41d2:	9203      	str	r2, [sp, #12]
  _p_sercom->disableSPI();
    41d4:	f000 fdec 	bl	4db0 <_ZN6SERCOM10disableSPIEv>

  _p_sercom->initSPI(_padTx, _padRx, SPI_CHAR_SIZE_8_BITS, settings.bitOrder);
    41d8:	796b      	ldrb	r3, [r5, #5]
    41da:	79e1      	ldrb	r1, [r4, #7]
    41dc:	7a22      	ldrb	r2, [r4, #8]
    41de:	9300      	str	r3, [sp, #0]
    41e0:	6820      	ldr	r0, [r4, #0]
    41e2:	2300      	movs	r3, #0
    41e4:	f000 fe86 	bl	4ef4 <_ZN6SERCOM7initSPIE14SercomSpiTXPad11SercomRXPad17SercomSpiCharSize15SercomDataOrder>
  _p_sercom->initSPIClock(settings.dataMode, settings.clockFreq);
    41e8:	7929      	ldrb	r1, [r5, #4]
    41ea:	6820      	ldr	r0, [r4, #0]
    41ec:	9a02      	ldr	r2, [sp, #8]
    41ee:	f000 fdaf 	bl	4d50 <_ZN6SERCOM12initSPIClockE18SercomSpiClockModem>

  _p_sercom->enableSPI();
    41f2:	6820      	ldr	r0, [r4, #0]
    41f4:	f000 fdd2 	bl	4d9c <_ZN6SERCOM9enableSPIEv>
}
    41f8:	b005      	add	sp, #20
    41fa:	bd30      	pop	{r4, r5, pc}

000041fc <_ZN8SPIClass5beginEv>:
  _padTx=PadTx;
  _padRx=PadRx;
}

void SPIClass::begin()
{
    41fc:	b570      	push	{r4, r5, r6, lr}
    41fe:	1c04      	adds	r4, r0, #0
  init();

  // PIO init
  pinPeripheral(_uc_pinMiso, g_APinDescription[_uc_pinMiso].ulPinType);
    4200:	2618      	movs	r6, #24
  _padRx=PadRx;
}

void SPIClass::begin()
{
  init();
    4202:	f7ff ffd7 	bl	41b4 <_ZN8SPIClass4initEv>

  // PIO init
  pinPeripheral(_uc_pinMiso, g_APinDescription[_uc_pinMiso].ulPinType);
    4206:	7920      	ldrb	r0, [r4, #4]
    4208:	1c33      	adds	r3, r6, #0
    420a:	4343      	muls	r3, r0
    420c:	4d0d      	ldr	r5, [pc, #52]	; (4244 <_ZN8SPIClass5beginEv+0x48>)
    420e:	2108      	movs	r1, #8
    4210:	18eb      	adds	r3, r5, r3
    4212:	5659      	ldrsb	r1, [r3, r1]
    4214:	f000 fb10 	bl	4838 <pinPeripheral>
  pinPeripheral(_uc_pinSCK, g_APinDescription[_uc_pinSCK].ulPinType);
    4218:	79a0      	ldrb	r0, [r4, #6]
    421a:	1c33      	adds	r3, r6, #0
    421c:	4343      	muls	r3, r0
    421e:	2108      	movs	r1, #8
    4220:	18eb      	adds	r3, r5, r3
    4222:	5659      	ldrsb	r1, [r3, r1]
    4224:	f000 fb08 	bl	4838 <pinPeripheral>
  pinPeripheral(_uc_pinMosi, g_APinDescription[_uc_pinMosi].ulPinType);
    4228:	7960      	ldrb	r0, [r4, #5]
    422a:	2108      	movs	r1, #8
    422c:	4346      	muls	r6, r0
    422e:	19ad      	adds	r5, r5, r6
    4230:	5669      	ldrsb	r1, [r5, r1]
    4232:	f000 fb01 	bl	4838 <pinPeripheral>

  config(DEFAULT_SPI_SETTINGS);
    4236:	4b04      	ldr	r3, [pc, #16]	; (4248 <_ZN8SPIClass5beginEv+0x4c>)
    4238:	1c20      	adds	r0, r4, #0
    423a:	cb06      	ldmia	r3!, {r1, r2}
    423c:	f7ff ffc3 	bl	41c6 <_ZN8SPIClass6configE11SPISettings>
}
    4240:	bd70      	pop	{r4, r5, r6, pc}
    4242:	46c0      	nop			; (mov r8, r8)
    4244:	00008cb8 	.word	0x00008cb8
    4248:	20000160 	.word	0x20000160

0000424c <_ZN8SPIClass16beginTransactionE11SPISettings>:
  if (irestore)
    interrupts();
}

void SPIClass::beginTransaction(SPISettings settings)
{
    424c:	b507      	push	{r0, r1, r2, lr}
  if (interruptMode != SPI_IMODE_NONE)
    424e:	7a83      	ldrb	r3, [r0, #10]
  if (irestore)
    interrupts();
}

void SPIClass::beginTransaction(SPISettings settings)
{
    4250:	9100      	str	r1, [sp, #0]
    4252:	9201      	str	r2, [sp, #4]
  if (interruptMode != SPI_IMODE_NONE)
    4254:	2b00      	cmp	r3, #0
    4256:	d00d      	beq.n	4274 <_ZN8SPIClass16beginTransactionE11SPISettings+0x28>
  {
    if (interruptMode & SPI_IMODE_GLOBAL)
    4258:	079a      	lsls	r2, r3, #30
    425a:	d506      	bpl.n	426a <_ZN8SPIClass16beginTransactionE11SPISettings+0x1e>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    425c:	f3ef 8310 	mrs	r3, PRIMASK
#define interruptsStatus() __interruptsStatus()
static inline unsigned char __interruptsStatus(void) __attribute__((always_inline, unused));
static inline unsigned char __interruptsStatus(void)
{
  // See http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0497a/CHDBIBGJ.html
  return (__get_PRIMASK() ? 0 : 1);
    4260:	425a      	negs	r2, r3
    4262:	4153      	adcs	r3, r2
{
  if (interruptMode != SPI_IMODE_NONE)
  {
    if (interruptMode & SPI_IMODE_GLOBAL)
    {
      interruptSave = interruptsStatus();
    4264:	72c3      	strb	r3, [r0, #11]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    4266:	b672      	cpsid	i
    4268:	e004      	b.n	4274 <_ZN8SPIClass16beginTransactionE11SPISettings+0x28>
      noInterrupts();
    }
    else if (interruptMode & SPI_IMODE_EXTINT)
    426a:	07da      	lsls	r2, r3, #31
    426c:	d502      	bpl.n	4274 <_ZN8SPIClass16beginTransactionE11SPISettings+0x28>
      EIC->INTENCLR.reg = EIC_INTENCLR_EXTINT(interruptMask);
    426e:	8982      	ldrh	r2, [r0, #12]
    4270:	4b03      	ldr	r3, [pc, #12]	; (4280 <_ZN8SPIClass16beginTransactionE11SPISettings+0x34>)
    4272:	609a      	str	r2, [r3, #8]
  }

  config(settings);
    4274:	9900      	ldr	r1, [sp, #0]
    4276:	9a01      	ldr	r2, [sp, #4]
    4278:	f7ff ffa5 	bl	41c6 <_ZN8SPIClass6configE11SPISettings>
}
    427c:	bd07      	pop	{r0, r1, r2, pc}
    427e:	46c0      	nop			; (mov r8, r8)
    4280:	40001800 	.word	0x40001800

00004284 <_ZN8SPIClass14endTransactionEv>:

void SPIClass::endTransaction(void)
{
  if (interruptMode != SPI_IMODE_NONE)
    4284:	7a83      	ldrb	r3, [r0, #10]
    4286:	2b00      	cmp	r3, #0
    4288:	d00b      	beq.n	42a2 <_ZN8SPIClass14endTransactionEv+0x1e>
  {
    if (interruptMode & SPI_IMODE_GLOBAL)
    428a:	079a      	lsls	r2, r3, #30
    428c:	d504      	bpl.n	4298 <_ZN8SPIClass14endTransactionEv+0x14>
    {
      if (interruptSave)
    428e:	7ac3      	ldrb	r3, [r0, #11]
    4290:	2b00      	cmp	r3, #0
    4292:	d006      	beq.n	42a2 <_ZN8SPIClass14endTransactionEv+0x1e>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    4294:	b662      	cpsie	i
    4296:	e004      	b.n	42a2 <_ZN8SPIClass14endTransactionEv+0x1e>
        interrupts();
    }
    else if (interruptMode & SPI_IMODE_EXTINT)
    4298:	07da      	lsls	r2, r3, #31
    429a:	d502      	bpl.n	42a2 <_ZN8SPIClass14endTransactionEv+0x1e>
      EIC->INTENSET.reg = EIC_INTENSET_EXTINT(interruptMask);
    429c:	8982      	ldrh	r2, [r0, #12]
    429e:	4b01      	ldr	r3, [pc, #4]	; (42a4 <_ZN8SPIClass14endTransactionEv+0x20>)
    42a0:	60da      	str	r2, [r3, #12]
  }
}
    42a2:	4770      	bx	lr
    42a4:	40001800 	.word	0x40001800

000042a8 <_ZN8SPIClass8transferEh>:
    _p_sercom->setBaudrateSPI(div);
  }
}

byte SPIClass::transfer(uint8_t data)
{
    42a8:	b508      	push	{r3, lr}
  return _p_sercom->transferDataSPI(data);
    42aa:	6800      	ldr	r0, [r0, #0]
    42ac:	f000 fd89 	bl	4dc2 <_ZN6SERCOM15transferDataSPIEh>
}
    42b0:	bd08      	pop	{r3, pc}
	...

000042b4 <_GLOBAL__sub_I__ZN8SPIClassC2EP6SERCOMhhh14SercomSpiTXPad11SercomRXPad>:
  void init_MightInline(uint32_t clock, BitOrder bitOrder, uint8_t dataMode) {
    init_AlwaysInline(clock, bitOrder, dataMode);
  }

  void init_AlwaysInline(uint32_t clock, BitOrder bitOrder, uint8_t dataMode) __attribute__((__always_inline__)) {
    this->clockFreq = (clock >= (F_CPU / SPI_MIN_CLOCK_DIVIDER) ? F_CPU / SPI_MIN_CLOCK_DIVIDER : clock);
    42b4:	4b09      	ldr	r3, [pc, #36]	; (42dc <_GLOBAL__sub_I__ZN8SPIClassC2EP6SERCOMhhh14SercomSpiTXPad11SercomRXPad+0x28>)
    42b6:	4a0a      	ldr	r2, [pc, #40]	; (42e0 <_GLOBAL__sub_I__ZN8SPIClassC2EP6SERCOMhhh14SercomSpiTXPad11SercomRXPad+0x2c>)

SPIClass::SPIClass(SERCOM *p_sercom, uint8_t uc_pinMISO, uint8_t uc_pinSCK, uint8_t uc_pinMOSI, SercomSpiTXPad PadTx, SercomRXPad PadRx)
{
  initialized = false;
  assert(p_sercom != NULL);
  _p_sercom = p_sercom;
    42b8:	490a      	ldr	r1, [pc, #40]	; (42e4 <_GLOBAL__sub_I__ZN8SPIClassC2EP6SERCOMhhh14SercomSpiTXPad11SercomRXPad+0x30>)
    42ba:	601a      	str	r2, [r3, #0]

    this->bitOrder = (bitOrder == MSBFIRST ? MSB_FIRST : LSB_FIRST);
    42bc:	2200      	movs	r2, #0
    42be:	715a      	strb	r2, [r3, #5]

    switch (dataMode)
    {
      case SPI_MODE0:
        this->dataMode = SERCOM_SPI_MODE_0; break;
    42c0:	711a      	strb	r2, [r3, #4]

const SPISettings DEFAULT_SPI_SETTINGS = SPISettings();

SPIClass::SPIClass(SERCOM *p_sercom, uint8_t uc_pinMISO, uint8_t uc_pinSCK, uint8_t uc_pinMOSI, SercomSpiTXPad PadTx, SercomRXPad PadRx)
{
  initialized = false;
    42c2:	4b09      	ldr	r3, [pc, #36]	; (42e8 <_GLOBAL__sub_I__ZN8SPIClassC2EP6SERCOMhhh14SercomSpiTXPad11SercomRXPad+0x34>)
  assert(p_sercom != NULL);
  _p_sercom = p_sercom;
    42c4:	6019      	str	r1, [r3, #0]

  // pins
  _uc_pinMiso = uc_pinMISO;
    42c6:	2116      	movs	r1, #22
    42c8:	7119      	strb	r1, [r3, #4]
  _uc_pinSCK = uc_pinSCK;
    42ca:	2118      	movs	r1, #24
    42cc:	7199      	strb	r1, [r3, #6]
  _uc_pinMosi = uc_pinMOSI;
    42ce:	2117      	movs	r1, #23
    42d0:	7159      	strb	r1, [r3, #5]

  // SERCOM pads
  _padTx=PadTx;
    42d2:	2101      	movs	r1, #1

const SPISettings DEFAULT_SPI_SETTINGS = SPISettings();

SPIClass::SPIClass(SERCOM *p_sercom, uint8_t uc_pinMISO, uint8_t uc_pinSCK, uint8_t uc_pinMOSI, SercomSpiTXPad PadTx, SercomRXPad PadRx)
{
  initialized = false;
    42d4:	725a      	strb	r2, [r3, #9]
  _uc_pinMiso = uc_pinMISO;
  _uc_pinSCK = uc_pinSCK;
  _uc_pinMosi = uc_pinMOSI;

  // SERCOM pads
  _padTx=PadTx;
    42d6:	71d9      	strb	r1, [r3, #7]
  _padRx=PadRx;
    42d8:	721a      	strb	r2, [r3, #8]
  #ifndef PERIPH_SPI
    #define PERIPH_SPI           sercom4
    #define PAD_SPI_TX           SPI_PAD_2_SCK_3
    #define PAD_SPI_RX           SERCOM_RX_PAD_0
  #endif // PERIPH_SPI
  SPIClass SPI (&PERIPH_SPI,  PIN_SPI_MISO,  PIN_SPI_SCK,  PIN_SPI_MOSI,  PAD_SPI_TX,  PAD_SPI_RX);
    42da:	4770      	bx	lr
    42dc:	20000160 	.word	0x20000160
    42e0:	003d0900 	.word	0x003d0900
    42e4:	200002d8 	.word	0x200002d8
    42e8:	20000168 	.word	0x20000168

000042ec <SERCOM0_Handler>:
SERCOM sercom5( SERCOM5 ) ;

Uart Serial1( &sercom0, PIN_SERIAL1_RX, PIN_SERIAL1_TX, PAD_SERIAL1_RX, PAD_SERIAL1_TX ) ;
Uart Serial( &sercom5, PIN_SERIAL_RX, PIN_SERIAL_TX, PAD_SERIAL_RX, PAD_SERIAL_TX ) ;
void SERCOM0_Handler()
{
    42ec:	b508      	push	{r3, lr}
  Serial1.IrqHandler();
    42ee:	4802      	ldr	r0, [pc, #8]	; (42f8 <SERCOM0_Handler+0xc>)
    42f0:	f000 fea6 	bl	5040 <_ZN4Uart10IrqHandlerEv>
}
    42f4:	bd08      	pop	{r3, pc}
    42f6:	46c0      	nop			; (mov r8, r8)
    42f8:	20000220 	.word	0x20000220

000042fc <SERCOM5_Handler>:

void SERCOM5_Handler()
{
    42fc:	b508      	push	{r3, lr}
  Serial.IrqHandler();
    42fe:	4802      	ldr	r0, [pc, #8]	; (4308 <SERCOM5_Handler+0xc>)
    4300:	f000 fe9e 	bl	5040 <_ZN4Uart10IrqHandlerEv>
}
    4304:	bd08      	pop	{r3, pc}
    4306:	46c0      	nop			; (mov r8, r8)
    4308:	20000178 	.word	0x20000178

0000430c <_GLOBAL__sub_I_g_APinDescription>:
    430c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
} ;

const void* g_apTCInstances[TCC_INST_NUM+TC_INST_NUM]={ TCC0, TCC1, TCC2, TC3, TC4, TC5 } ;

// Multi-serial objects instantiation
SERCOM sercom0( SERCOM0 ) ;
    430e:	4f16      	ldr	r7, [pc, #88]	; (4368 <_GLOBAL__sub_I_g_APinDescription+0x5c>)
    4310:	4916      	ldr	r1, [pc, #88]	; (436c <_GLOBAL__sub_I_g_APinDescription+0x60>)
    4312:	1c38      	adds	r0, r7, #0
    4314:	f000 fc9c 	bl	4c50 <_ZN6SERCOMC1EP6Sercom>
SERCOM sercom1( SERCOM1 ) ;
    4318:	4915      	ldr	r1, [pc, #84]	; (4370 <_GLOBAL__sub_I_g_APinDescription+0x64>)
    431a:	4816      	ldr	r0, [pc, #88]	; (4374 <_GLOBAL__sub_I_g_APinDescription+0x68>)
    431c:	f000 fc98 	bl	4c50 <_ZN6SERCOMC1EP6Sercom>
SERCOM sercom2( SERCOM2 ) ;
    4320:	4915      	ldr	r1, [pc, #84]	; (4378 <_GLOBAL__sub_I_g_APinDescription+0x6c>)
    4322:	4816      	ldr	r0, [pc, #88]	; (437c <_GLOBAL__sub_I_g_APinDescription+0x70>)
    4324:	f000 fc94 	bl	4c50 <_ZN6SERCOMC1EP6Sercom>
SERCOM sercom3( SERCOM3 ) ;
    4328:	4915      	ldr	r1, [pc, #84]	; (4380 <_GLOBAL__sub_I_g_APinDescription+0x74>)
    432a:	4816      	ldr	r0, [pc, #88]	; (4384 <_GLOBAL__sub_I_g_APinDescription+0x78>)
    432c:	f000 fc90 	bl	4c50 <_ZN6SERCOMC1EP6Sercom>
SERCOM sercom4( SERCOM4 ) ;
    4330:	4915      	ldr	r1, [pc, #84]	; (4388 <_GLOBAL__sub_I_g_APinDescription+0x7c>)
    4332:	4816      	ldr	r0, [pc, #88]	; (438c <_GLOBAL__sub_I_g_APinDescription+0x80>)
    4334:	f000 fc8c 	bl	4c50 <_ZN6SERCOMC1EP6Sercom>
SERCOM sercom5( SERCOM5 ) ;
    4338:	4d15      	ldr	r5, [pc, #84]	; (4390 <_GLOBAL__sub_I_g_APinDescription+0x84>)

Uart Serial1( &sercom0, PIN_SERIAL1_RX, PIN_SERIAL1_TX, PAD_SERIAL1_RX, PAD_SERIAL1_TX ) ;
    433a:	2603      	movs	r6, #3
    433c:	2401      	movs	r4, #1
SERCOM sercom0( SERCOM0 ) ;
SERCOM sercom1( SERCOM1 ) ;
SERCOM sercom2( SERCOM2 ) ;
SERCOM sercom3( SERCOM3 ) ;
SERCOM sercom4( SERCOM4 ) ;
SERCOM sercom5( SERCOM5 ) ;
    433e:	1c28      	adds	r0, r5, #0
    4340:	4914      	ldr	r1, [pc, #80]	; (4394 <_GLOBAL__sub_I_g_APinDescription+0x88>)
    4342:	f000 fc85 	bl	4c50 <_ZN6SERCOMC1EP6Sercom>

Uart Serial1( &sercom0, PIN_SERIAL1_RX, PIN_SERIAL1_TX, PAD_SERIAL1_RX, PAD_SERIAL1_TX ) ;
    4346:	1c39      	adds	r1, r7, #0
    4348:	9600      	str	r6, [sp, #0]
    434a:	1c23      	adds	r3, r4, #0
    434c:	9401      	str	r4, [sp, #4]
    434e:	2200      	movs	r2, #0
    4350:	4811      	ldr	r0, [pc, #68]	; (4398 <_GLOBAL__sub_I_g_APinDescription+0x8c>)
    4352:	f000 fe4d 	bl	4ff0 <_ZN4UartC1EP6SERCOMhh11SercomRXPad15SercomUartTXPad>
Uart Serial( &sercom5, PIN_SERIAL_RX, PIN_SERIAL_TX, PAD_SERIAL_RX, PAD_SERIAL_TX ) ;
    4356:	9600      	str	r6, [sp, #0]
    4358:	1c29      	adds	r1, r5, #0
    435a:	9401      	str	r4, [sp, #4]
    435c:	221f      	movs	r2, #31
    435e:	231e      	movs	r3, #30
    4360:	480e      	ldr	r0, [pc, #56]	; (439c <_GLOBAL__sub_I_g_APinDescription+0x90>)
    4362:	f000 fe45 	bl	4ff0 <_ZN4UartC1EP6SERCOMhh11SercomRXPad15SercomUartTXPad>
}

void SERCOM5_Handler()
{
  Serial.IrqHandler();
}
    4366:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    4368:	200002cc 	.word	0x200002cc
    436c:	42000800 	.word	0x42000800
    4370:	42000c00 	.word	0x42000c00
    4374:	200002d0 	.word	0x200002d0
    4378:	42001000 	.word	0x42001000
    437c:	200002d4 	.word	0x200002d4
    4380:	42001400 	.word	0x42001400
    4384:	200002c8 	.word	0x200002c8
    4388:	42001800 	.word	0x42001800
    438c:	200002d8 	.word	0x200002d8
    4390:	200002dc 	.word	0x200002dc
    4394:	42001c00 	.word	0x42001c00
    4398:	20000220 	.word	0x20000220
    439c:	20000178 	.word	0x20000178

000043a0 <Dummy_Handler>:
extern void pendSVHook(void);
extern int sysTickHook(void);

/* Default empty handler */
void Dummy_Handler(void)
{
    43a0:	e7fe      	b.n	43a0 <Dummy_Handler>
	...

000043a4 <USB_Handler>:
}

static void (*usb_isr)(void) = NULL;

void USB_Handler(void)
{
    43a4:	b508      	push	{r3, lr}
  if (usb_isr)
    43a6:	4b03      	ldr	r3, [pc, #12]	; (43b4 <USB_Handler+0x10>)
    43a8:	681b      	ldr	r3, [r3, #0]
    43aa:	2b00      	cmp	r3, #0
    43ac:	d000      	beq.n	43b0 <USB_Handler+0xc>
    usb_isr();
    43ae:	4798      	blx	r3
}
    43b0:	bd08      	pop	{r3, pc}
    43b2:	46c0      	nop			; (mov r8, r8)
    43b4:	200002e0 	.word	0x200002e0

000043b8 <Reset_Handler>:

extern int main(void);

/* This is called on processor reset to initialize the device and call main() */
void Reset_Handler(void)
{
    43b8:	b538      	push	{r3, r4, r5, lr}
    43ba:	490f      	ldr	r1, [pc, #60]	; (43f8 <Reset_Handler+0x40>)
    43bc:	4c0f      	ldr	r4, [pc, #60]	; (43fc <Reset_Handler+0x44>)

  /* Initialize the initialized data section */
  pSrc = &__etext;
  pDest = &__data_start__;

  if ((&__data_start__ != &__data_end__) && (pSrc != pDest)) {
    43be:	42a1      	cmp	r1, r4
    43c0:	d104      	bne.n	43cc <Reset_Handler+0x14>
  if ((&__data_start__ != &__data_end__) && (pSrc != pDest)) {
    for (pDest = &__bss_start__; pDest < &__bss_end__; pDest++)
      *pDest = 0;
  }

  SystemInit();
    43c2:	f000 f855 	bl	4470 <SystemInit>

  main();
    43c6:	f000 fedd 	bl	5184 <main>
    43ca:	e00b      	b.n	43e4 <Reset_Handler+0x2c>

  /* Initialize the initialized data section */
  pSrc = &__etext;
  pDest = &__data_start__;

  if ((&__data_start__ != &__data_end__) && (pSrc != pDest)) {
    43cc:	4d0c      	ldr	r5, [pc, #48]	; (4400 <Reset_Handler+0x48>)
    43ce:	428d      	cmp	r5, r1
    43d0:	d0f7      	beq.n	43c2 <Reset_Handler+0xa>
    43d2:	2300      	movs	r3, #0
    43d4:	18ca      	adds	r2, r1, r3
    43d6:	18e8      	adds	r0, r5, r3
    for (; pDest < &__data_end__; pDest++, pSrc++)
    43d8:	42a2      	cmp	r2, r4
    43da:	d204      	bcs.n	43e6 <Reset_Handler+0x2e>
      *pDest = *pSrc;
    43dc:	6800      	ldr	r0, [r0, #0]
    43de:	3304      	adds	r3, #4
    43e0:	6010      	str	r0, [r2, #0]
    43e2:	e7f7      	b.n	43d4 <Reset_Handler+0x1c>
    43e4:	e7fe      	b.n	43e4 <Reset_Handler+0x2c>
  }

  /* Clear the zero section */
  if ((&__data_start__ != &__data_end__) && (pSrc != pDest)) {
    43e6:	4290      	cmp	r0, r2
    43e8:	d0eb      	beq.n	43c2 <Reset_Handler+0xa>
    43ea:	4b06      	ldr	r3, [pc, #24]	; (4404 <Reset_Handler+0x4c>)
    for (pDest = &__bss_start__; pDest < &__bss_end__; pDest++)
    43ec:	4a06      	ldr	r2, [pc, #24]	; (4408 <Reset_Handler+0x50>)
    43ee:	4293      	cmp	r3, r2
    43f0:	d2e7      	bcs.n	43c2 <Reset_Handler+0xa>
      *pDest = 0;
    43f2:	2200      	movs	r2, #0
    43f4:	c304      	stmia	r3!, {r2}
    43f6:	e7f9      	b.n	43ec <Reset_Handler+0x34>
    43f8:	20000000 	.word	0x20000000
    43fc:	20000110 	.word	0x20000110
    4400:	00009278 	.word	0x00009278
    4404:	20000110 	.word	0x20000110
    4408:	200008e0 	.word	0x200008e0

0000440c <SysTick_Handler>:

/* Default Arduino systick handler */
extern void SysTick_DefaultHandler(void);

void SysTick_Handler(void)
{
    440c:	b508      	push	{r3, lr}
  if (sysTickHook())
    440e:	f000 f82c 	bl	446a <sysTickHook>
    4412:	2800      	cmp	r0, #0
    4414:	d101      	bne.n	441a <SysTick_Handler+0xe>
    return;
  SysTick_DefaultHandler();
    4416:	f000 f81d 	bl	4454 <SysTick_DefaultHandler>
}
    441a:	bd08      	pop	{r3, pc}

0000441c <USB_SetHandler>:
    usb_isr();
}

void USB_SetHandler(void (*new_usb_isr)(void))
{
  usb_isr = new_usb_isr;
    441c:	4b01      	ldr	r3, [pc, #4]	; (4424 <USB_SetHandler+0x8>)
    441e:	6018      	str	r0, [r3, #0]
}
    4420:	4770      	bx	lr
    4422:	46c0      	nop			; (mov r8, r8)
    4424:	200002e0 	.word	0x200002e0

00004428 <millis>:
static volatile uint32_t _ulTickCount=0 ;

unsigned long millis( void )
{
// todo: ensure no interrupts
  return _ulTickCount ;
    4428:	4b01      	ldr	r3, [pc, #4]	; (4430 <millis+0x8>)
    442a:	6818      	ldr	r0, [r3, #0]
}
    442c:	4770      	bx	lr
    442e:	46c0      	nop			; (mov r8, r8)
    4430:	200002e4 	.word	0x200002e4

00004434 <delay>:
  // this is an optimization to turn a runtime division into two compile-time divisions and
  // a runtime multiplication and shift, saving a few cycles
}

void delay( unsigned long ms )
{
    4434:	b570      	push	{r4, r5, r6, lr}
    4436:	1e04      	subs	r4, r0, #0
  if ( ms == 0 )
    4438:	d008      	beq.n	444c <delay+0x18>
  {
    return ;
  }

  uint32_t start = _ulTickCount ;
    443a:	4b05      	ldr	r3, [pc, #20]	; (4450 <delay+0x1c>)
    443c:	681d      	ldr	r5, [r3, #0]
    443e:	1c1e      	adds	r6, r3, #0

  do
  {
    yield() ;
    4440:	f000 f812 	bl	4468 <yield>
  } while ( _ulTickCount - start < ms ) ;
    4444:	6833      	ldr	r3, [r6, #0]
    4446:	1b5b      	subs	r3, r3, r5
    4448:	42a3      	cmp	r3, r4
    444a:	d3f9      	bcc.n	4440 <delay+0xc>
}
    444c:	bd70      	pop	{r4, r5, r6, pc}
    444e:	46c0      	nop			; (mov r8, r8)
    4450:	200002e4 	.word	0x200002e4

00004454 <SysTick_DefaultHandler>:

#include "Reset.h" // for tickReset()

void SysTick_DefaultHandler(void)
{
    4454:	b508      	push	{r3, lr}
  // Increment tick count each ms
  _ulTickCount++;
    4456:	4b03      	ldr	r3, [pc, #12]	; (4464 <SysTick_DefaultHandler+0x10>)
    4458:	681a      	ldr	r2, [r3, #0]
    445a:	3201      	adds	r2, #1
    445c:	601a      	str	r2, [r3, #0]
  tickReset();
    445e:	f000 fbbd 	bl	4bdc <tickReset>
}
    4462:	bd08      	pop	{r3, pc}
    4464:	200002e4 	.word	0x200002e4

00004468 <yield>:
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
	// Empty
}
    4468:	4770      	bx	lr

0000446a <sysTickHook>:
 * handler provided by Arduino.
 */
static int __false() {
	// Return false
	return 0;
}
    446a:	2000      	movs	r0, #0
    446c:	4770      	bx	lr
	...

00004470 <SystemInit>:
#define GENERIC_CLOCK_GENERATOR_OSC8M     (3u)
// Constants for Clock multiplexers
#define GENERIC_CLOCK_MULTIPLEXER_DFLL48M (0u)

void SystemInit( void )
{
    4470:	b570      	push	{r4, r5, r6, lr}
  /* Set 1 Flash Wait State for 48MHz, cf tables 20.9 and 35.27 in SAMD21 Datasheet */
  NVMCTRL->CTRLB.bit.RWS = NVMCTRL_CTRLB_RWS_HALF_Val ;
    4472:	4a49      	ldr	r2, [pc, #292]	; (4598 <SystemInit+0x128>)
    4474:	211e      	movs	r1, #30
    4476:	6853      	ldr	r3, [r2, #4]
    4478:	2002      	movs	r0, #2
    447a:	438b      	bics	r3, r1
    447c:	4303      	orrs	r3, r0

  /* Turn on the digital interface clock */
  PM->APBAMASK.reg |= PM_APBAMASK_GCLK ;
    447e:	4947      	ldr	r1, [pc, #284]	; (459c <SystemInit+0x12c>)
#define GENERIC_CLOCK_MULTIPLEXER_DFLL48M (0u)

void SystemInit( void )
{
  /* Set 1 Flash Wait State for 48MHz, cf tables 20.9 and 35.27 in SAMD21 Datasheet */
  NVMCTRL->CTRLB.bit.RWS = NVMCTRL_CTRLB_RWS_HALF_Val ;
    4480:	6053      	str	r3, [r2, #4]

  /* Turn on the digital interface clock */
  PM->APBAMASK.reg |= PM_APBAMASK_GCLK ;
    4482:	698b      	ldr	r3, [r1, #24]
    4484:	2408      	movs	r4, #8
    4486:	4323      	orrs	r3, r4
    4488:	618b      	str	r3, [r1, #24]
#else // has crystal

  /* ----------------------------------------------------------------------------------------------
   * 1) Enable XOSC32K clock (External on-board 32.768Hz oscillator)
   */
  SYSCTRL->XOSC32K.reg = SYSCTRL_XOSC32K_STARTUP( 0x6u ) | /* cf table 15.10 of product datasheet in chapter 15.8.6 */
    448a:	4c45      	ldr	r4, [pc, #276]	; (45a0 <SystemInit+0x130>)
    448c:	4b45      	ldr	r3, [pc, #276]	; (45a4 <SystemInit+0x134>)
    448e:	829c      	strh	r4, [r3, #20]
                         SYSCTRL_XOSC32K_XTALEN | SYSCTRL_XOSC32K_EN32K ;
  SYSCTRL->XOSC32K.bit.ENABLE = 1 ; /* separate call, as described in chapter 15.6.3 */
    4490:	8a9c      	ldrh	r4, [r3, #20]
    4492:	4320      	orrs	r0, r4
    4494:	8298      	strh	r0, [r3, #20]
    4496:	1c10      	adds	r0, r2, #0

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_XOSC32KRDY) == 0 )
    4498:	68da      	ldr	r2, [r3, #12]
    449a:	0794      	lsls	r4, r2, #30
    449c:	d5fc      	bpl.n	4498 <SystemInit+0x28>

  /* Software reset the module to ensure it is re-initialized correctly */
  /* Note: Due to synchronization, there is a delay from writing CTRL.SWRST until the reset is complete.
   * CTRL.SWRST and STATUS.SYNCBUSY will both be cleared when the reset is complete, as described in chapter 13.8.1
   */
  GCLK->CTRL.reg = GCLK_CTRL_SWRST ;
    449e:	4a42      	ldr	r2, [pc, #264]	; (45a8 <SystemInit+0x138>)
    44a0:	2401      	movs	r4, #1
    44a2:	7014      	strb	r4, [r2, #0]

  while ( (GCLK->CTRL.reg & GCLK_CTRL_SWRST) && (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY) )
    44a4:	7814      	ldrb	r4, [r2, #0]
    44a6:	07e5      	lsls	r5, r4, #31
    44a8:	d504      	bpl.n	44b4 <SystemInit+0x44>
    44aa:	4c3f      	ldr	r4, [pc, #252]	; (45a8 <SystemInit+0x138>)
    44ac:	7864      	ldrb	r4, [r4, #1]
    44ae:	b264      	sxtb	r4, r4
    44b0:	2c00      	cmp	r4, #0
    44b2:	dbf7      	blt.n	44a4 <SystemInit+0x34>
  }

  /* ----------------------------------------------------------------------------------------------
   * 2) Put XOSC32K as source of Generic Clock Generator 1
   */
  GCLK->GENDIV.reg = GCLK_GENDIV_ID( GENERIC_CLOCK_GENERATOR_XOSC32K ) ; // Generic Clock Generator 1
    44b4:	2401      	movs	r4, #1
    44b6:	6094      	str	r4, [r2, #8]

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
    44b8:	7854      	ldrb	r4, [r2, #1]
    44ba:	b264      	sxtb	r4, r4
    44bc:	2c00      	cmp	r4, #0
    44be:	dbfb      	blt.n	44b8 <SystemInit+0x48>
  {
    /* Wait for synchronization */
  }

  /* Write Generic Clock Generator 1 configuration */
  GCLK->GENCTRL.reg = GCLK_GENCTRL_ID( GENERIC_CLOCK_GENERATOR_OSC32K ) | // Generic Clock Generator 1
    44c0:	4d3a      	ldr	r5, [pc, #232]	; (45ac <SystemInit+0x13c>)
    44c2:	4c39      	ldr	r4, [pc, #228]	; (45a8 <SystemInit+0x138>)
    44c4:	6065      	str	r5, [r4, #4]
                      GCLK_GENCTRL_SRC_XOSC32K | // Selected source is External 32KHz Oscillator
#endif
//                      GCLK_GENCTRL_OE | // Output clock to a pin for tests
                      GCLK_GENCTRL_GENEN ;

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
    44c6:	7854      	ldrb	r4, [r2, #1]
    44c8:	b264      	sxtb	r4, r4
    44ca:	2c00      	cmp	r4, #0
    44cc:	dbfb      	blt.n	44c6 <SystemInit+0x56>
  }

  /* ----------------------------------------------------------------------------------------------
   * 3) Put Generic Clock Generator 1 as source for Generic Clock Multiplexer 0 (DFLL48M reference)
   */
  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID( GENERIC_CLOCK_MULTIPLEXER_DFLL48M ) | // Generic Clock Multiplexer 0
    44ce:	2582      	movs	r5, #130	; 0x82
    44d0:	4c35      	ldr	r4, [pc, #212]	; (45a8 <SystemInit+0x138>)
    44d2:	01ed      	lsls	r5, r5, #7
    44d4:	8065      	strh	r5, [r4, #2]
                      GCLK_CLKCTRL_GEN_GCLK1 | // Generic Clock Generator 1 is source
                      GCLK_CLKCTRL_CLKEN ;

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
    44d6:	7854      	ldrb	r4, [r2, #1]
    44d8:	b264      	sxtb	r4, r4
    44da:	2c00      	cmp	r4, #0
    44dc:	dbfb      	blt.n	44d6 <SystemInit+0x66>
   */

  /* DFLL Configuration in Closed Loop mode, cf product datasheet chapter 15.6.7.1 - Closed-Loop Operation */

  /* Remove the OnDemand mode, Bug http://avr32.icgroup.norway.atmel.com/bugzilla/show_bug.cgi?id=9905 */
  SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
    44de:	2402      	movs	r4, #2
    44e0:	849c      	strh	r4, [r3, #36]	; 0x24

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) == 0 )
    44e2:	68dc      	ldr	r4, [r3, #12]
    44e4:	06e6      	lsls	r6, r4, #27
    44e6:	d5fc      	bpl.n	44e2 <SystemInit+0x72>
  {
    /* Wait for synchronization */
  }

  SYSCTRL->DFLLMUL.reg = SYSCTRL_DFLLMUL_CSTEP( 31 ) | // Coarse step is 31, half of the max value
    44e8:	4d31      	ldr	r5, [pc, #196]	; (45b0 <SystemInit+0x140>)
    44ea:	4c2e      	ldr	r4, [pc, #184]	; (45a4 <SystemInit+0x134>)
    44ec:	62e5      	str	r5, [r4, #44]	; 0x2c
                         SYSCTRL_DFLLMUL_FSTEP( 511 ) | // Fine step is 511, half of the max value
                         SYSCTRL_DFLLMUL_MUL( (VARIANT_MCK/VARIANT_MAINOSC) ) ; // External 32KHz is the reference

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) == 0 )
    44ee:	68dd      	ldr	r5, [r3, #12]
    44f0:	4c2c      	ldr	r4, [pc, #176]	; (45a4 <SystemInit+0x134>)
    44f2:	06ee      	lsls	r6, r5, #27
    44f4:	d5fb      	bpl.n	44ee <SystemInit+0x7e>
  SYSCTRL->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_ENABLE ;

#else   // has crystal

  /* Write full configuration to DFLL control register */
  SYSCTRL->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_MODE | /* Enable the closed loop mode */
    44f6:	8ca5      	ldrh	r5, [r4, #36]	; 0x24
    44f8:	4e2e      	ldr	r6, [pc, #184]	; (45b4 <SystemInit+0x144>)
    44fa:	4335      	orrs	r5, r6
    44fc:	84a5      	strh	r5, [r4, #36]	; 0x24
                           SYSCTRL_DFLLCTRL_WAITLOCK |
                           SYSCTRL_DFLLCTRL_QLDIS ; /* Disable Quick lock */

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) == 0 )
    44fe:	68dd      	ldr	r5, [r3, #12]
    4500:	4c28      	ldr	r4, [pc, #160]	; (45a4 <SystemInit+0x134>)
    4502:	06ee      	lsls	r6, r5, #27
    4504:	d5fb      	bpl.n	44fe <SystemInit+0x8e>
  {
    /* Wait for synchronization */
  }

  /* Enable the DFLL */
  SYSCTRL->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_ENABLE ;
    4506:	8ca5      	ldrh	r5, [r4, #36]	; 0x24
    4508:	2602      	movs	r6, #2
    450a:	4335      	orrs	r5, r6
    450c:	84a5      	strh	r5, [r4, #36]	; 0x24

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLLCKC) == 0 ||
    450e:	68dc      	ldr	r4, [r3, #12]
    4510:	0625      	lsls	r5, r4, #24
    4512:	d5fc      	bpl.n	450e <SystemInit+0x9e>
          (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLLCKF) == 0 )
    4514:	4c23      	ldr	r4, [pc, #140]	; (45a4 <SystemInit+0x134>)
    4516:	68e4      	ldr	r4, [r4, #12]
  }

  /* Enable the DFLL */
  SYSCTRL->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_ENABLE ;

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLLCKC) == 0 ||
    4518:	0666      	lsls	r6, r4, #25
    451a:	d5f8      	bpl.n	450e <SystemInit+0x9e>
    /* Wait for locks flags */
  }

#endif

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) == 0 )
    451c:	68dc      	ldr	r4, [r3, #12]
    451e:	06e5      	lsls	r5, r4, #27
    4520:	d5fc      	bpl.n	451c <SystemInit+0xac>
  }

  /* ----------------------------------------------------------------------------------------------
   * 5) Switch Generic Clock Generator 0 to DFLL48M. CPU will run at 48MHz.
   */
  GCLK->GENDIV.reg = GCLK_GENDIV_ID( GENERIC_CLOCK_GENERATOR_MAIN ) ; // Generic Clock Generator 0
    4522:	2400      	movs	r4, #0
    4524:	6094      	str	r4, [r2, #8]

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
    4526:	7854      	ldrb	r4, [r2, #1]
    4528:	b264      	sxtb	r4, r4
    452a:	2c00      	cmp	r4, #0
    452c:	dbfb      	blt.n	4526 <SystemInit+0xb6>
  {
    /* Wait for synchronization */
  }

  /* Write Generic Clock Generator 0 configuration */
  GCLK->GENCTRL.reg = GCLK_GENCTRL_ID( GENERIC_CLOCK_GENERATOR_MAIN ) | // Generic Clock Generator 0
    452e:	4d22      	ldr	r5, [pc, #136]	; (45b8 <SystemInit+0x148>)
    4530:	4c1d      	ldr	r4, [pc, #116]	; (45a8 <SystemInit+0x138>)
    4532:	6065      	str	r5, [r4, #4]
                      GCLK_GENCTRL_SRC_DFLL48M | // Selected source is DFLL 48MHz
//                      GCLK_GENCTRL_OE | // Output clock to a pin for tests
                      GCLK_GENCTRL_IDC | // Set 50/50 duty cycle
                      GCLK_GENCTRL_GENEN ;

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
    4534:	7855      	ldrb	r5, [r2, #1]
    4536:	4c1c      	ldr	r4, [pc, #112]	; (45a8 <SystemInit+0x138>)
    4538:	b26d      	sxtb	r5, r5
    453a:	2d00      	cmp	r5, #0
    453c:	dbfa      	blt.n	4534 <SystemInit+0xc4>
  }

  /* ----------------------------------------------------------------------------------------------
   * 6) Modify PRESCaler value of OSC8M to have 8MHz
   */
  SYSCTRL->OSC8M.bit.PRESC = SYSCTRL_OSC8M_PRESC_0_Val ;  //CMSIS 4.5 changed the prescaler defines
    453e:	6a1e      	ldr	r6, [r3, #32]
    4540:	4d1e      	ldr	r5, [pc, #120]	; (45bc <SystemInit+0x14c>)
    4542:	4035      	ands	r5, r6
    4544:	621d      	str	r5, [r3, #32]
  SYSCTRL->OSC8M.bit.ONDEMAND = 0 ;
    4546:	6a1d      	ldr	r5, [r3, #32]
    4548:	2680      	movs	r6, #128	; 0x80
    454a:	43b5      	bics	r5, r6
    454c:	621d      	str	r5, [r3, #32]

  /* ----------------------------------------------------------------------------------------------
   * 7) Put OSC8M as source for Generic Clock Generator 3
   */
  GCLK->GENDIV.reg = GCLK_GENDIV_ID( GENERIC_CLOCK_GENERATOR_OSC8M ) ; // Generic Clock Generator 3
    454e:	2303      	movs	r3, #3
    4550:	60a3      	str	r3, [r4, #8]

  /* Write Generic Clock Generator 3 configuration */
  GCLK->GENCTRL.reg = GCLK_GENCTRL_ID( GENERIC_CLOCK_GENERATOR_OSC8M ) | // Generic Clock Generator 3
    4552:	4b1b      	ldr	r3, [pc, #108]	; (45c0 <SystemInit+0x150>)
    4554:	6063      	str	r3, [r4, #4]
                      GCLK_GENCTRL_SRC_OSC8M | // Selected source is RC OSC 8MHz (already enabled at reset)
//                      GCLK_GENCTRL_OE | // Output clock to a pin for tests
                      GCLK_GENCTRL_GENEN ;

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
    4556:	7853      	ldrb	r3, [r2, #1]
    4558:	b25b      	sxtb	r3, r3
    455a:	2b00      	cmp	r3, #0
    455c:	dbfb      	blt.n	4556 <SystemInit+0xe6>

  /*
   * Now that all system clocks are configured, we can set CPU and APBx BUS clocks.
   * There values are normally the one present after Reset.
   */
  PM->CPUSEL.reg  = PM_CPUSEL_CPUDIV_DIV1 ;
    455e:	2300      	movs	r3, #0
    4560:	720b      	strb	r3, [r1, #8]
  PM->APBASEL.reg = PM_APBASEL_APBADIV_DIV1_Val ;
  PM->APBBSEL.reg = PM_APBBSEL_APBBDIV_DIV1_Val ;
  PM->APBCSEL.reg = PM_APBCSEL_APBCDIV_DIV1_Val ;

  SystemCoreClock=VARIANT_MCK ;
    4562:	4a18      	ldr	r2, [pc, #96]	; (45c4 <SystemInit+0x154>)
  /*
   * Now that all system clocks are configured, we can set CPU and APBx BUS clocks.
   * There values are normally the one present after Reset.
   */
  PM->CPUSEL.reg  = PM_CPUSEL_CPUDIV_DIV1 ;
  PM->APBASEL.reg = PM_APBASEL_APBADIV_DIV1_Val ;
    4564:	724b      	strb	r3, [r1, #9]
  PM->APBBSEL.reg = PM_APBBSEL_APBBDIV_DIV1_Val ;
    4566:	728b      	strb	r3, [r1, #10]
  PM->APBCSEL.reg = PM_APBCSEL_APBCDIV_DIV1_Val ;
    4568:	72cb      	strb	r3, [r1, #11]

  SystemCoreClock=VARIANT_MCK ;
    456a:	4b17      	ldr	r3, [pc, #92]	; (45c8 <SystemInit+0x158>)

  // ADC Linearity bits 4:0
  uint32_t linearity = (*((uint32_t *) ADC_FUSES_LINEARITY_0_ADDR) & ADC_FUSES_LINEARITY_0_Msk) >> ADC_FUSES_LINEARITY_0_Pos;

  // ADC Linearity bits 7:5
  linearity |= ((*((uint32_t *) ADC_FUSES_LINEARITY_1_ADDR) & ADC_FUSES_LINEARITY_1_Msk) >> ADC_FUSES_LINEARITY_1_Pos) << 5;
    456c:	21ff      	movs	r1, #255	; 0xff
  PM->CPUSEL.reg  = PM_CPUSEL_CPUDIV_DIV1 ;
  PM->APBASEL.reg = PM_APBASEL_APBADIV_DIV1_Val ;
  PM->APBBSEL.reg = PM_APBBSEL_APBBDIV_DIV1_Val ;
  PM->APBCSEL.reg = PM_APBCSEL_APBCDIV_DIV1_Val ;

  SystemCoreClock=VARIANT_MCK ;
    456e:	601a      	str	r2, [r3, #0]
  /* ----------------------------------------------------------------------------------------------
   * 8) Load ADC factory calibration values
   */

  // ADC Bias Calibration
  uint32_t bias = (*((uint32_t *) ADC_FUSES_BIASCAL_ADDR) & ADC_FUSES_BIASCAL_Msk) >> ADC_FUSES_BIASCAL_Pos;
    4570:	4b16      	ldr	r3, [pc, #88]	; (45cc <SystemInit+0x15c>)

  // ADC Linearity bits 4:0
  uint32_t linearity = (*((uint32_t *) ADC_FUSES_LINEARITY_0_ADDR) & ADC_FUSES_LINEARITY_0_Msk) >> ADC_FUSES_LINEARITY_0_Pos;
    4572:	4a17      	ldr	r2, [pc, #92]	; (45d0 <SystemInit+0x160>)
  /* ----------------------------------------------------------------------------------------------
   * 8) Load ADC factory calibration values
   */

  // ADC Bias Calibration
  uint32_t bias = (*((uint32_t *) ADC_FUSES_BIASCAL_ADDR) & ADC_FUSES_BIASCAL_Msk) >> ADC_FUSES_BIASCAL_Pos;
    4574:	681b      	ldr	r3, [r3, #0]

  // ADC Linearity bits 4:0
  uint32_t linearity = (*((uint32_t *) ADC_FUSES_LINEARITY_0_ADDR) & ADC_FUSES_LINEARITY_0_Msk) >> ADC_FUSES_LINEARITY_0_Pos;
    4576:	6812      	ldr	r2, [r2, #0]

  // ADC Linearity bits 7:5
  linearity |= ((*((uint32_t *) ADC_FUSES_LINEARITY_1_ADDR) & ADC_FUSES_LINEARITY_1_Msk) >> ADC_FUSES_LINEARITY_1_Pos) << 5;
    4578:	015c      	lsls	r4, r3, #5

  // ADC Bias Calibration
  uint32_t bias = (*((uint32_t *) ADC_FUSES_BIASCAL_ADDR) & ADC_FUSES_BIASCAL_Msk) >> ADC_FUSES_BIASCAL_Pos;

  // ADC Linearity bits 4:0
  uint32_t linearity = (*((uint32_t *) ADC_FUSES_LINEARITY_0_ADDR) & ADC_FUSES_LINEARITY_0_Msk) >> ADC_FUSES_LINEARITY_0_Pos;
    457a:	0ed2      	lsrs	r2, r2, #27

  // ADC Linearity bits 7:5
  linearity |= ((*((uint32_t *) ADC_FUSES_LINEARITY_1_ADDR) & ADC_FUSES_LINEARITY_1_Msk) >> ADC_FUSES_LINEARITY_1_Pos) << 5;
    457c:	4021      	ands	r1, r4
    457e:	4311      	orrs	r1, r2
  /* ----------------------------------------------------------------------------------------------
   * 8) Load ADC factory calibration values
   */

  // ADC Bias Calibration
  uint32_t bias = (*((uint32_t *) ADC_FUSES_BIASCAL_ADDR) & ADC_FUSES_BIASCAL_Msk) >> ADC_FUSES_BIASCAL_Pos;
    4580:	069a      	lsls	r2, r3, #26
    4582:	0f52      	lsrs	r2, r2, #29
  uint32_t linearity = (*((uint32_t *) ADC_FUSES_LINEARITY_0_ADDR) & ADC_FUSES_LINEARITY_0_Msk) >> ADC_FUSES_LINEARITY_0_Pos;

  // ADC Linearity bits 7:5
  linearity |= ((*((uint32_t *) ADC_FUSES_LINEARITY_1_ADDR) & ADC_FUSES_LINEARITY_1_Msk) >> ADC_FUSES_LINEARITY_1_Pos) << 5;

  ADC->CALIB.reg = ADC_CALIB_BIAS_CAL(bias) | ADC_CALIB_LINEARITY_CAL(linearity);
    4584:	0212      	lsls	r2, r2, #8
    4586:	1c0b      	adds	r3, r1, #0
    4588:	4313      	orrs	r3, r2
    458a:	4a12      	ldr	r2, [pc, #72]	; (45d4 <SystemInit+0x164>)
    458c:	8513      	strh	r3, [r2, #40]	; 0x28

  /*
   * 9) Disable automatic NVM write operations
   */
  NVMCTRL->CTRLB.bit.MANW = 1;
    458e:	6843      	ldr	r3, [r0, #4]
    4590:	2280      	movs	r2, #128	; 0x80
    4592:	4313      	orrs	r3, r2
    4594:	6043      	str	r3, [r0, #4]
}
    4596:	bd70      	pop	{r4, r5, r6, pc}
    4598:	41004000 	.word	0x41004000
    459c:	40000400 	.word	0x40000400
    45a0:	0000060c 	.word	0x0000060c
    45a4:	40000800 	.word	0x40000800
    45a8:	40000c00 	.word	0x40000c00
    45ac:	00010501 	.word	0x00010501
    45b0:	7dff05b8 	.word	0x7dff05b8
    45b4:	00000a04 	.word	0x00000a04
    45b8:	00030700 	.word	0x00030700
    45bc:	fffffcff 	.word	0xfffffcff
    45c0:	00010603 	.word	0x00010603
    45c4:	02dc6c00 	.word	0x02dc6c00
    45c8:	20000004 	.word	0x20000004
    45cc:	00806024 	.word	0x00806024
    45d0:	00806020 	.word	0x00806020
    45d4:	42004000 	.word	0x42004000

000045d8 <init>:
 *   - During reset, all PORT lines are configured as inputs with input buffers, output buffers and pull disabled.
 */
void init( void )
{
  // Set Systick to 1ms interval, common to all Cortex-M variants
  if ( SysTick_Config( SystemCoreClock / 1000 ) )
    45d8:	4b31      	ldr	r3, [pc, #196]	; (46a0 <init+0xc8>)
    45da:	21fa      	movs	r1, #250	; 0xfa
    45dc:	6818      	ldr	r0, [r3, #0]
 *   - At reset, ResetHandler did the system clock configuration. Core is running at 48MHz.
 *   - Watchdog is disabled by default, unless someone plays with NVM User page
 *   - During reset, all PORT lines are configured as inputs with input buffers, output buffers and pull disabled.
 */
void init( void )
{
    45de:	b510      	push	{r4, lr}
  // Set Systick to 1ms interval, common to all Cortex-M variants
  if ( SysTick_Config( SystemCoreClock / 1000 ) )
    45e0:	0089      	lsls	r1, r1, #2
    45e2:	f001 ff51 	bl	6488 <__aeabi_uidiv>
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
    45e6:	4b2f      	ldr	r3, [pc, #188]	; (46a4 <init+0xcc>)
    45e8:	3801      	subs	r0, #1
    45ea:	4298      	cmp	r0, r3
    45ec:	d824      	bhi.n	4638 <init+0x60>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    45ee:	4a2e      	ldr	r2, [pc, #184]	; (46a8 <init+0xd0>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    45f0:	4b2e      	ldr	r3, [pc, #184]	; (46ac <init+0xd4>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    45f2:	6050      	str	r0, [r2, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    45f4:	6a18      	ldr	r0, [r3, #32]
    45f6:	21c0      	movs	r1, #192	; 0xc0
    45f8:	0200      	lsls	r0, r0, #8
    45fa:	0a00      	lsrs	r0, r0, #8
    45fc:	0609      	lsls	r1, r1, #24
    45fe:	4301      	orrs	r1, r0
    4600:	6219      	str	r1, [r3, #32]
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
    4602:	2400      	movs	r4, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    4604:	2107      	movs	r1, #7
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
    4606:	6094      	str	r4, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    4608:	6011      	str	r1, [r2, #0]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    460a:	6a19      	ldr	r1, [r3, #32]
    460c:	2280      	movs	r2, #128	; 0x80
    460e:	0209      	lsls	r1, r1, #8
    4610:	0a09      	lsrs	r1, r1, #8
    4612:	0612      	lsls	r2, r2, #24
    4614:	430a      	orrs	r2, r1
    4616:	621a      	str	r2, [r3, #32]
//
//  // Clock EIC for I/O interrupts
//  PM->APBAMASK.reg |= PM_APBAMASK_EIC ;

  // Clock SERCOM for Serial
  PM->APBCMASK.reg |= PM_APBCMASK_SERCOM0 | PM_APBCMASK_SERCOM1 | PM_APBCMASK_SERCOM2 | PM_APBCMASK_SERCOM3 | PM_APBCMASK_SERCOM4 | PM_APBCMASK_SERCOM5 ;
    4618:	4b25      	ldr	r3, [pc, #148]	; (46b0 <init+0xd8>)
    461a:	21fc      	movs	r1, #252	; 0xfc
    461c:	6a1a      	ldr	r2, [r3, #32]
    461e:	430a      	orrs	r2, r1
    4620:	621a      	str	r2, [r3, #32]

  // Clock TC/TCC for Pulse and Analog
  PM->APBCMASK.reg |= PM_APBCMASK_TCC0 | PM_APBCMASK_TCC1 | PM_APBCMASK_TCC2 | PM_APBCMASK_TC3 | PM_APBCMASK_TC4 | PM_APBCMASK_TC5 ;
    4622:	6a19      	ldr	r1, [r3, #32]
    4624:	22fc      	movs	r2, #252	; 0xfc
    4626:	0192      	lsls	r2, r2, #6
    4628:	430a      	orrs	r2, r1
    462a:	621a      	str	r2, [r3, #32]

  // Clock ADC/DAC for Analog
  PM->APBCMASK.reg |= PM_APBCMASK_ADC | PM_APBCMASK_DAC ;
    462c:	6a19      	ldr	r1, [r3, #32]
    462e:	22a0      	movs	r2, #160	; 0xa0
    4630:	02d2      	lsls	r2, r2, #11
    4632:	430a      	orrs	r2, r1
    4634:	621a      	str	r2, [r3, #32]
    4636:	e000      	b.n	463a <init+0x62>
    4638:	e7fe      	b.n	4638 <init+0x60>

  // Setup all pins (digital and analog) in INPUT mode (default is nothing)
  for (uint32_t ul = 0 ; ul < NUM_DIGITAL_PINS ; ul++ )
  {
    pinMode( ul, INPUT ) ;
    463a:	1c20      	adds	r0, r4, #0
    463c:	2100      	movs	r1, #0

  // Clock ADC/DAC for Analog
  PM->APBCMASK.reg |= PM_APBCMASK_ADC | PM_APBCMASK_DAC ;

  // Setup all pins (digital and analog) in INPUT mode (default is nothing)
  for (uint32_t ul = 0 ; ul < NUM_DIGITAL_PINS ; ul++ )
    463e:	3401      	adds	r4, #1
  {
    pinMode( ul, INPUT ) ;
    4640:	f000 f870 	bl	4724 <pinMode>

  // Clock ADC/DAC for Analog
  PM->APBCMASK.reg |= PM_APBCMASK_ADC | PM_APBCMASK_DAC ;

  // Setup all pins (digital and analog) in INPUT mode (default is nothing)
  for (uint32_t ul = 0 ; ul < NUM_DIGITAL_PINS ; ul++ )
    4644:	2c14      	cmp	r4, #20
    4646:	d1f8      	bne.n	463a <init+0x62>
    pinMode( ul, INPUT ) ;
  }

  // Initialize Analog Controller
  // Setting clock
  while(GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY);
    4648:	4c1a      	ldr	r4, [pc, #104]	; (46b4 <init+0xdc>)
    464a:	7863      	ldrb	r3, [r4, #1]
    464c:	b25b      	sxtb	r3, r3
    464e:	2b00      	cmp	r3, #0
    4650:	dbfa      	blt.n	4648 <init+0x70>

  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID( GCM_ADC ) | // Generic Clock ADC
    4652:	4b19      	ldr	r3, [pc, #100]	; (46b8 <init+0xe0>)
    4654:	8063      	strh	r3, [r4, #2]
                      GCLK_CLKCTRL_GEN_GCLK0     | // Generic Clock Generator 0 is source
                      GCLK_CLKCTRL_CLKEN ;

  while( ADC->STATUS.bit.SYNCBUSY == 1 );          // Wait for synchronization of registers between the clock domains
    4656:	4b19      	ldr	r3, [pc, #100]	; (46bc <init+0xe4>)
    4658:	7e5a      	ldrb	r2, [r3, #25]
    465a:	09d2      	lsrs	r2, r2, #7
    465c:	2a01      	cmp	r2, #1
    465e:	d0fa      	beq.n	4656 <init+0x7e>

  ADC->CTRLB.reg = ADC_CTRLB_PRESCALER_DIV512 |    // Divide Clock by 512.
    4660:	22e4      	movs	r2, #228	; 0xe4
    4662:	00d2      	lsls	r2, r2, #3
    4664:	809a      	strh	r2, [r3, #4]
                   ADC_CTRLB_RESSEL_10BIT;         // 10 bits resolution as default

  ADC->SAMPCTRL.reg = 0x3f;                        // Set max Sampling Time Length
    4666:	223f      	movs	r2, #63	; 0x3f
    4668:	70da      	strb	r2, [r3, #3]

  while( ADC->STATUS.bit.SYNCBUSY == 1 );          // Wait for synchronization of registers between the clock domains
    466a:	7e59      	ldrb	r1, [r3, #25]
    466c:	4a13      	ldr	r2, [pc, #76]	; (46bc <init+0xe4>)
    466e:	09c9      	lsrs	r1, r1, #7
    4670:	2901      	cmp	r1, #1
    4672:	d0fa      	beq.n	466a <init+0x92>

  ADC->INPUTCTRL.reg = ADC_INPUTCTRL_MUXNEG_GND;   // No Negative input (Internal Ground)
    4674:	23c0      	movs	r3, #192	; 0xc0
    4676:	015b      	lsls	r3, r3, #5

  // Averaging (see datasheet table in AVGCTRL register description)
  ADC->AVGCTRL.reg = ADC_AVGCTRL_SAMPLENUM_1 |    // 1 sample only (no oversampling nor averaging)
    4678:	2000      	movs	r0, #0

  ADC->SAMPCTRL.reg = 0x3f;                        // Set max Sampling Time Length

  while( ADC->STATUS.bit.SYNCBUSY == 1 );          // Wait for synchronization of registers between the clock domains

  ADC->INPUTCTRL.reg = ADC_INPUTCTRL_MUXNEG_GND;   // No Negative input (Internal Ground)
    467a:	6113      	str	r3, [r2, #16]

  // Averaging (see datasheet table in AVGCTRL register description)
  ADC->AVGCTRL.reg = ADC_AVGCTRL_SAMPLENUM_1 |    // 1 sample only (no oversampling nor averaging)
    467c:	7090      	strb	r0, [r2, #2]
                     ADC_AVGCTRL_ADJRES(0x0ul);   // Adjusting result by 0

  analogReference( AR_DEFAULT ) ; // Analog Reference is AREF pin (3.3v)
    467e:	f000 f823 	bl	46c8 <analogReference>

  // Initialize DAC
  // Setting clock
  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY );
    4682:	7863      	ldrb	r3, [r4, #1]
    4684:	b25b      	sxtb	r3, r3
    4686:	2b00      	cmp	r3, #0
    4688:	dbfb      	blt.n	4682 <init+0xaa>
  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID( GCM_DAC ) | // Generic Clock ADC
    468a:	4a0d      	ldr	r2, [pc, #52]	; (46c0 <init+0xe8>)
    468c:	4b09      	ldr	r3, [pc, #36]	; (46b4 <init+0xdc>)
    468e:	805a      	strh	r2, [r3, #2]
                      GCLK_CLKCTRL_GEN_GCLK0     | // Generic Clock Generator 0 is source
                      GCLK_CLKCTRL_CLKEN ;

  while ( DAC->STATUS.bit.SYNCBUSY == 1 ); // Wait for synchronization of registers between the clock domains
    4690:	4b0c      	ldr	r3, [pc, #48]	; (46c4 <init+0xec>)
    4692:	79da      	ldrb	r2, [r3, #7]
    4694:	09d2      	lsrs	r2, r2, #7
    4696:	2a01      	cmp	r2, #1
    4698:	d0fa      	beq.n	4690 <init+0xb8>
  DAC->CTRLB.reg = DAC_CTRLB_REFSEL_AVCC | // Using the 3.3V reference
    469a:	2241      	movs	r2, #65	; 0x41
    469c:	705a      	strb	r2, [r3, #1]
                   DAC_CTRLB_EOEN ;        // External Output Enable (Vout)
}
    469e:	bd10      	pop	{r4, pc}
    46a0:	20000004 	.word	0x20000004
    46a4:	00ffffff 	.word	0x00ffffff
    46a8:	e000e010 	.word	0xe000e010
    46ac:	e000ed00 	.word	0xe000ed00
    46b0:	40000400 	.word	0x40000400
    46b4:	40000c00 	.word	0x40000c00
    46b8:	0000401e 	.word	0x0000401e
    46bc:	42004000 	.word	0x42004000
    46c0:	00004021 	.word	0x00004021
    46c4:	42004800 	.word	0x42004800

000046c8 <analogReference>:
 * External Reference should be between 1v and VDDANA-0.6v=2.7v
 *
 * Warning : On Arduino Zero board the input/output voltage for SAMD21G18 is 3.3 volts maximum
 */
void analogReference(eAnalogReference mode)
{
    46c8:	b500      	push	{lr}
static int _writeResolution = 8;

// Wait for synchronization of registers between the clock domains
static __inline__ void syncADC() __attribute__((always_inline, unused));
static void syncADC() {
  while (ADC->STATUS.bit.SYNCBUSY == 1)
    46ca:	4a14      	ldr	r2, [pc, #80]	; (471c <analogReference+0x54>)
    46cc:	7e51      	ldrb	r1, [r2, #25]
    46ce:	1c13      	adds	r3, r2, #0
    46d0:	09c9      	lsrs	r1, r1, #7
    46d2:	2901      	cmp	r1, #1
    46d4:	d0f9      	beq.n	46ca <analogReference+0x2>
 * Warning : On Arduino Zero board the input/output voltage for SAMD21G18 is 3.3 volts maximum
 */
void analogReference(eAnalogReference mode)
{
  syncADC();
  switch (mode)
    46d6:	3801      	subs	r0, #1
    46d8:	2804      	cmp	r0, #4
    46da:	d813      	bhi.n	4704 <analogReference+0x3c>
      ADC->INPUTCTRL.bit.GAIN = ADC_INPUTCTRL_GAIN_1X_Val;      // Gain Factor Selection
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INT1V_Val;   // 1.0V voltage reference
      break;

    case AR_INTERNAL1V65:
      ADC->INPUTCTRL.bit.GAIN = ADC_INPUTCTRL_GAIN_1X_Val;      // Gain Factor Selection
    46dc:	6919      	ldr	r1, [r3, #16]
    46de:	4a10      	ldr	r2, [pc, #64]	; (4720 <analogReference+0x58>)
    46e0:	400a      	ands	r2, r1
    46e2:	611a      	str	r2, [r3, #16]
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INTVCC1_Val; // 1/2 VDDANA = 0.5* 3V3 = 1.65V
    46e4:	785a      	ldrb	r2, [r3, #1]
    46e6:	210f      	movs	r1, #15
    46e8:	438a      	bics	r2, r1
 * Warning : On Arduino Zero board the input/output voltage for SAMD21G18 is 3.3 volts maximum
 */
void analogReference(eAnalogReference mode)
{
  syncADC();
  switch (mode)
    46ea:	f001 fec3 	bl	6474 <__gnu_thumb1_case_uqi>
    46ee:	0503      	.short	0x0503
    46f0:	0709      	.short	0x0709
    46f2:	03          	.byte	0x03
    46f3:	00          	.byte	0x00
  {
    case AR_INTERNAL:
    case AR_INTERNAL2V23:
      ADC->INPUTCTRL.bit.GAIN = ADC_INPUTCTRL_GAIN_1X_Val;      // Gain Factor Selection
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INTVCC0_Val; // 1/1.48 VDDANA = 1/1.48* 3V3 = 2.2297
    46f4:	2101      	movs	r1, #1
    46f6:	e002      	b.n	46fe <analogReference+0x36>
      break;

    case AR_EXTERNAL:
      ADC->INPUTCTRL.bit.GAIN = ADC_INPUTCTRL_GAIN_1X_Val;      // Gain Factor Selection
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_AREFA_Val;
    46f8:	2103      	movs	r1, #3
    46fa:	e000      	b.n	46fe <analogReference+0x36>
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INT1V_Val;   // 1.0V voltage reference
      break;

    case AR_INTERNAL1V65:
      ADC->INPUTCTRL.bit.GAIN = ADC_INPUTCTRL_GAIN_1X_Val;      // Gain Factor Selection
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INTVCC1_Val; // 1/2 VDDANA = 0.5* 3V3 = 1.65V
    46fc:	2102      	movs	r1, #2
    46fe:	430a      	orrs	r2, r1
    4700:	705a      	strb	r2, [r3, #1]
      break;
    4702:	e00a      	b.n	471a <analogReference+0x52>

    case AR_DEFAULT:
    default:
      ADC->INPUTCTRL.bit.GAIN = ADC_INPUTCTRL_GAIN_DIV2_Val;
    4704:	6911      	ldr	r1, [r2, #16]
    4706:	23f0      	movs	r3, #240	; 0xf0
    4708:	051b      	lsls	r3, r3, #20
    470a:	430b      	orrs	r3, r1
    470c:	6113      	str	r3, [r2, #16]
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INTVCC1_Val; // 1/2 VDDANA = 0.5* 3V3 = 1.65V
    470e:	7853      	ldrb	r3, [r2, #1]
    4710:	210f      	movs	r1, #15
    4712:	438b      	bics	r3, r1
    4714:	2102      	movs	r1, #2
    4716:	430b      	orrs	r3, r1
    4718:	7053      	strb	r3, [r2, #1]
      break;
  }
}
    471a:	bd00      	pop	{pc}
    471c:	42004000 	.word	0x42004000
    4720:	f0ffffff 	.word	0xf0ffffff

00004724 <pinMode>:
#ifdef __cplusplus
 extern "C" {
#endif

void pinMode( uint32_t ulPin, uint32_t ulMode )
{
    4724:	b510      	push	{r4, lr}
  // Handle the case the pin isn't usable as PIO
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    4726:	2418      	movs	r4, #24
#ifdef __cplusplus
 extern "C" {
#endif

void pinMode( uint32_t ulPin, uint32_t ulMode )
{
    4728:	1c02      	adds	r2, r0, #0
  // Handle the case the pin isn't usable as PIO
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    472a:	1c20      	adds	r0, r4, #0
    472c:	4350      	muls	r0, r2
    472e:	4b27      	ldr	r3, [pc, #156]	; (47cc <pinMode+0xa8>)
    4730:	1818      	adds	r0, r3, r0
    4732:	7a00      	ldrb	r0, [r0, #8]
    4734:	b240      	sxtb	r0, r0
    4736:	3001      	adds	r0, #1
    4738:	d046      	beq.n	47c8 <pinMode+0xa4>
  {
    return ;
  }

  // Set pin mode according to chapter '22.6.3 I/O Pin Configuration'
  switch ( ulMode )
    473a:	2903      	cmp	r1, #3
    473c:	d844      	bhi.n	47c8 <pinMode+0xa4>
    473e:	1c08      	adds	r0, r1, #0
    4740:	1c21      	adds	r1, r4, #0
    4742:	f001 fe97 	bl	6474 <__gnu_thumb1_case_uqi>
    4746:	3302      	.short	0x3302
    4748:	2111      	.short	0x2111
  {
    case INPUT:
      // Set pin to input mode
      PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg=(uint8_t)(PORT_PINCFG_INEN) ;
    474a:	4362      	muls	r2, r4
    474c:	5698      	ldrsb	r0, [r3, r2]
    474e:	189a      	adds	r2, r3, r2
    4750:	01c3      	lsls	r3, r0, #7
    4752:	481f      	ldr	r0, [pc, #124]	; (47d0 <pinMode+0xac>)
    4754:	6852      	ldr	r2, [r2, #4]
    4756:	181b      	adds	r3, r3, r0
    4758:	1899      	adds	r1, r3, r2
    475a:	3140      	adds	r1, #64	; 0x40
    475c:	2002      	movs	r0, #2
    475e:	7008      	strb	r0, [r1, #0]
      PORT->Group[g_APinDescription[ulPin].ulPort].DIRCLR.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
    4760:	2101      	movs	r1, #1
    4762:	4091      	lsls	r1, r2
    4764:	6059      	str	r1, [r3, #4]
    break ;
    4766:	e02f      	b.n	47c8 <pinMode+0xa4>

    case INPUT_PULLUP:
      // Set pin to input mode with pull-up resistor enabled
      PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg=(uint8_t)(PORT_PINCFG_INEN|PORT_PINCFG_PULLEN) ;
    4768:	4362      	muls	r2, r4
    476a:	5698      	ldrsb	r0, [r3, r2]
    476c:	4918      	ldr	r1, [pc, #96]	; (47d0 <pinMode+0xac>)
    476e:	189a      	adds	r2, r3, r2
    4770:	6852      	ldr	r2, [r2, #4]
    4772:	01c3      	lsls	r3, r0, #7
    4774:	185b      	adds	r3, r3, r1
    4776:	1899      	adds	r1, r3, r2
    4778:	3140      	adds	r1, #64	; 0x40
    477a:	2006      	movs	r0, #6
    477c:	7008      	strb	r0, [r1, #0]
      PORT->Group[g_APinDescription[ulPin].ulPort].DIRCLR.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
    477e:	2101      	movs	r1, #1
    4780:	4091      	lsls	r1, r2
    4782:	6059      	str	r1, [r3, #4]

      // Enable pull level (cf '22.6.3.2 Input Configuration' and '22.8.7 Data Output Value Set')
      PORT->Group[g_APinDescription[ulPin].ulPort].OUTSET.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
    4784:	6199      	str	r1, [r3, #24]
    break ;
    4786:	e01f      	b.n	47c8 <pinMode+0xa4>

    case INPUT_PULLDOWN:
      // Set pin to input mode with pull-down resistor enabled
      PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg=(uint8_t)(PORT_PINCFG_INEN|PORT_PINCFG_PULLEN) ;
    4788:	4351      	muls	r1, r2
    478a:	565a      	ldrsb	r2, [r3, r1]
    478c:	4810      	ldr	r0, [pc, #64]	; (47d0 <pinMode+0xac>)
    478e:	1859      	adds	r1, r3, r1
    4790:	684b      	ldr	r3, [r1, #4]
    4792:	01d2      	lsls	r2, r2, #7
    4794:	1811      	adds	r1, r2, r0
    4796:	18c8      	adds	r0, r1, r3
    4798:	3040      	adds	r0, #64	; 0x40
    479a:	2406      	movs	r4, #6
    479c:	7004      	strb	r4, [r0, #0]
      PORT->Group[g_APinDescription[ulPin].ulPort].DIRCLR.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
    479e:	2001      	movs	r0, #1
    47a0:	4098      	lsls	r0, r3
    47a2:	6048      	str	r0, [r1, #4]

      // Enable pull level (cf '22.6.3.2 Input Configuration' and '22.8.6 Data Output Value Clear')
      PORT->Group[g_APinDescription[ulPin].ulPort].OUTCLR.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
    47a4:	490b      	ldr	r1, [pc, #44]	; (47d4 <pinMode+0xb0>)
    47a6:	1852      	adds	r2, r2, r1
    47a8:	6050      	str	r0, [r2, #4]
    break ;
    47aa:	e00d      	b.n	47c8 <pinMode+0xa4>

    case OUTPUT:
      // enable input, to support reading back values, with pullups disabled
      PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg=(uint8_t)(PORT_PINCFG_INEN) ;
    47ac:	4362      	muls	r2, r4
    47ae:	5698      	ldrsb	r0, [r3, r2]
    47b0:	189a      	adds	r2, r3, r2
    47b2:	01c3      	lsls	r3, r0, #7
    47b4:	4806      	ldr	r0, [pc, #24]	; (47d0 <pinMode+0xac>)
    47b6:	6852      	ldr	r2, [r2, #4]
    47b8:	181b      	adds	r3, r3, r0
    47ba:	1899      	adds	r1, r3, r2
    47bc:	3140      	adds	r1, #64	; 0x40
    47be:	2002      	movs	r0, #2
    47c0:	7008      	strb	r0, [r1, #0]

      // Set pin to output mode
      PORT->Group[g_APinDescription[ulPin].ulPort].DIRSET.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
    47c2:	2101      	movs	r1, #1
    47c4:	4091      	lsls	r1, r2
    47c6:	6099      	str	r1, [r3, #8]

    default:
      // do nothing
    break ;
  }
}
    47c8:	bd10      	pop	{r4, pc}
    47ca:	46c0      	nop			; (mov r8, r8)
    47cc:	00008cb8 	.word	0x00008cb8
    47d0:	41004400 	.word	0x41004400
    47d4:	41004410 	.word	0x41004410

000047d8 <digitalWrite>:

void digitalWrite( uint32_t ulPin, uint32_t ulVal )
{
  // Handle the case the pin isn't usable as PIO
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    47d8:	2318      	movs	r3, #24
    47da:	4358      	muls	r0, r3
    47dc:	4a13      	ldr	r2, [pc, #76]	; (482c <digitalWrite+0x54>)
    break ;
  }
}

void digitalWrite( uint32_t ulPin, uint32_t ulVal )
{
    47de:	b5f0      	push	{r4, r5, r6, r7, lr}
  // Handle the case the pin isn't usable as PIO
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    47e0:	1813      	adds	r3, r2, r0
    47e2:	2408      	movs	r4, #8
    47e4:	571c      	ldrsb	r4, [r3, r4]
    47e6:	3401      	adds	r4, #1
    47e8:	d01f      	beq.n	482a <digitalWrite+0x52>

  EPortType port = g_APinDescription[ulPin].ulPort;
  uint32_t pin = g_APinDescription[ulPin].ulPin;
  uint32_t pinMask = (1ul << pin);

  if ( (PORT->Group[port].DIRSET.reg & pinMask) == 0 ) {
    47ea:	5682      	ldrsb	r2, [r0, r2]
    47ec:	4e10      	ldr	r6, [pc, #64]	; (4830 <digitalWrite+0x58>)
    47ee:	01d2      	lsls	r2, r2, #7
  {
    return ;
  }

  EPortType port = g_APinDescription[ulPin].ulPort;
  uint32_t pin = g_APinDescription[ulPin].ulPin;
    47f0:	685d      	ldr	r5, [r3, #4]
  uint32_t pinMask = (1ul << pin);
    47f2:	2401      	movs	r4, #1

  if ( (PORT->Group[port].DIRSET.reg & pinMask) == 0 ) {
    47f4:	1990      	adds	r0, r2, r6
    return ;
  }

  EPortType port = g_APinDescription[ulPin].ulPort;
  uint32_t pin = g_APinDescription[ulPin].ulPin;
  uint32_t pinMask = (1ul << pin);
    47f6:	1c23      	adds	r3, r4, #0

  if ( (PORT->Group[port].DIRSET.reg & pinMask) == 0 ) {
    47f8:	6886      	ldr	r6, [r0, #8]
    return ;
  }

  EPortType port = g_APinDescription[ulPin].ulPort;
  uint32_t pin = g_APinDescription[ulPin].ulPin;
  uint32_t pinMask = (1ul << pin);
    47fa:	40ab      	lsls	r3, r5

  if ( (PORT->Group[port].DIRSET.reg & pinMask) == 0 ) {
    47fc:	421e      	tst	r6, r3
    47fe:	d10b      	bne.n	4818 <digitalWrite+0x40>
    // the pin is not an output, disable pull-up if val is LOW, otherwise enable pull-up
    PORT->Group[port].PINCFG[pin].bit.PULLEN = ((ulVal == LOW) ? 0 : 1) ;
    4800:	1c0e      	adds	r6, r1, #0
    4802:	1e77      	subs	r7, r6, #1
    4804:	41be      	sbcs	r6, r7
    4806:	1940      	adds	r0, r0, r5
    4808:	4034      	ands	r4, r6
    480a:	3040      	adds	r0, #64	; 0x40
    480c:	00a5      	lsls	r5, r4, #2
    480e:	7804      	ldrb	r4, [r0, #0]
    4810:	2604      	movs	r6, #4
    4812:	43b4      	bics	r4, r6
    4814:	432c      	orrs	r4, r5
    4816:	7004      	strb	r4, [r0, #0]
  }

  switch ( ulVal )
    4818:	2900      	cmp	r1, #0
    481a:	d103      	bne.n	4824 <digitalWrite+0x4c>
  {
    case LOW:
      PORT->Group[port].OUTCLR.reg = pinMask;
    481c:	4905      	ldr	r1, [pc, #20]	; (4834 <digitalWrite+0x5c>)
    481e:	1852      	adds	r2, r2, r1
    4820:	6053      	str	r3, [r2, #4]
    break ;
    4822:	e002      	b.n	482a <digitalWrite+0x52>

    default:
      PORT->Group[port].OUTSET.reg = pinMask;
    4824:	4e02      	ldr	r6, [pc, #8]	; (4830 <digitalWrite+0x58>)
    4826:	1992      	adds	r2, r2, r6
    4828:	6193      	str	r3, [r2, #24]
    break ;
  }

  return ;
}
    482a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    482c:	00008cb8 	.word	0x00008cb8
    4830:	41004400 	.word	0x41004400
    4834:	41004410 	.word	0x41004410

00004838 <pinPeripheral>:
#include "wiring_private.h"

int pinPeripheral( uint32_t ulPin, EPioType ulPeripheral )
{
  // Handle the case the pin isn't usable as PIO
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    4838:	2218      	movs	r2, #24
    483a:	4342      	muls	r2, r0

#include "Arduino.h"
#include "wiring_private.h"

int pinPeripheral( uint32_t ulPin, EPioType ulPeripheral )
{
    483c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // Handle the case the pin isn't usable as PIO
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    483e:	4d2d      	ldr	r5, [pc, #180]	; (48f4 <pinPeripheral+0xbc>)
    4840:	2408      	movs	r4, #8
    4842:	18aa      	adds	r2, r5, r2
    4844:	5714      	ldrsb	r4, [r2, r4]

#include "Arduino.h"
#include "wiring_private.h"

int pinPeripheral( uint32_t ulPin, EPioType ulPeripheral )
{
    4846:	1c03      	adds	r3, r0, #0
  // Handle the case the pin isn't usable as PIO
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    4848:	1c62      	adds	r2, r4, #1
    484a:	d050      	beq.n	48ee <pinPeripheral+0xb6>
  {
    return -1 ;
  }

  switch ( ulPeripheral )
    484c:	1c48      	adds	r0, r1, #1
    case PIO_NOT_A_PIN:
      return -1l ;
    break ;
  }

  return 0l ;
    484e:	2400      	movs	r4, #0
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
  {
    return -1 ;
  }

  switch ( ulPeripheral )
    4850:	280c      	cmp	r0, #12
    4852:	d84c      	bhi.n	48ee <pinPeripheral+0xb6>
    4854:	f001 fe0e 	bl	6474 <__gnu_thumb1_case_uqi>
    4858:	1e1e1e07 	.word	0x1e1e1e07
    485c:	1e1e1e1e 	.word	0x1e1e1e1e
    4860:	0a0a0a1e 	.word	0x0a0a0a1e
    4864:	0a          	.byte	0x0a
    4865:	00          	.byte	0x00
      }
#endif
    break ;

    case PIO_NOT_A_PIN:
      return -1l ;
    4866:	2401      	movs	r4, #1
    4868:	4264      	negs	r4, r4
    486a:	e040      	b.n	48ee <pinPeripheral+0xb6>
    case PIO_OUTPUT:
      // Disable peripheral muxing, done in pinMode
//			PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].bit.PMUXEN = 0 ;

      // Configure pin mode, if requested
      if ( ulPeripheral == PIO_INPUT )
    486c:	2909      	cmp	r1, #9
    486e:	d102      	bne.n	4876 <pinPeripheral+0x3e>
      {
        pinMode( ulPin, INPUT ) ;
    4870:	1c18      	adds	r0, r3, #0
    4872:	2100      	movs	r1, #0
    4874:	e003      	b.n	487e <pinPeripheral+0x46>
      }
      else
      {
        if ( ulPeripheral == PIO_INPUT_PULLUP )
    4876:	290a      	cmp	r1, #10
    4878:	d104      	bne.n	4884 <pinPeripheral+0x4c>
        {
          pinMode( ulPin, INPUT_PULLUP ) ;
    487a:	1c18      	adds	r0, r3, #0
    487c:	2102      	movs	r1, #2
    487e:	f7ff ff51 	bl	4724 <pinMode>
    4882:	e023      	b.n	48cc <pinPeripheral+0x94>
    case PIO_NOT_A_PIN:
      return -1l ;
    break ;
  }

  return 0l ;
    4884:	2400      	movs	r4, #0
        {
          pinMode( ulPin, INPUT_PULLUP ) ;
        }
        else
        {
          if ( ulPeripheral == PIO_OUTPUT )
    4886:	290b      	cmp	r1, #11
    4888:	d131      	bne.n	48ee <pinPeripheral+0xb6>
          {
            pinMode( ulPin, OUTPUT ) ;
    488a:	1c18      	adds	r0, r3, #0
    488c:	2101      	movs	r1, #1
    488e:	f7ff ff49 	bl	4724 <pinMode>
    4892:	e02c      	b.n	48ee <pinPeripheral+0xb6>
                                                                    PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_PMUXEN | PORT_WRCONFIG_PMUX( ulPeripheral ) |
                                                                    PORT_WRCONFIG_WRPINCFG |
                                                                    PORT_WRCONFIG_PINMASK( g_APinDescription[ulPin].ulPin - 16 ) ;
      }
#else
      if ( g_APinDescription[ulPin].ulPin & 1 ) // is pin odd?
    4894:	2218      	movs	r2, #24
    4896:	4353      	muls	r3, r2
    4898:	18ea      	adds	r2, r5, r3
    489a:	6852      	ldr	r2, [r2, #4]
    489c:	56eb      	ldrsb	r3, [r5, r3]
    489e:	2001      	movs	r0, #1
    48a0:	1c14      	adds	r4, r2, #0
    48a2:	4004      	ands	r4, r0
    48a4:	0855      	lsrs	r5, r2, #1
      {
        uint32_t temp ;

        // Get whole current setup for both odd and even pins and remove odd one
        temp = (PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg) & PORT_PMUX_PMUXE( 0xF ) ;
    48a6:	01db      	lsls	r3, r3, #7
                                                                    PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_PMUXEN | PORT_WRCONFIG_PMUX( ulPeripheral ) |
                                                                    PORT_WRCONFIG_WRPINCFG |
                                                                    PORT_WRCONFIG_PINMASK( g_APinDescription[ulPin].ulPin - 16 ) ;
      }
#else
      if ( g_APinDescription[ulPin].ulPin & 1 ) // is pin odd?
    48a8:	2c00      	cmp	r4, #0
    48aa:	d011      	beq.n	48d0 <pinPeripheral+0x98>
      {
        uint32_t temp ;

        // Get whole current setup for both odd and even pins and remove odd one
        temp = (PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg) & PORT_PMUX_PMUXE( 0xF ) ;
    48ac:	4c12      	ldr	r4, [pc, #72]	; (48f8 <pinPeripheral+0xc0>)
    48ae:	191b      	adds	r3, r3, r4
    48b0:	195d      	adds	r5, r3, r5
    48b2:	3530      	adds	r5, #48	; 0x30
    48b4:	782e      	ldrb	r6, [r5, #0]
        // Set new muxing
        PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg = temp|PORT_PMUX_PMUXO( ulPeripheral ) ;
    48b6:	010c      	lsls	r4, r1, #4
      if ( g_APinDescription[ulPin].ulPin & 1 ) // is pin odd?
      {
        uint32_t temp ;

        // Get whole current setup for both odd and even pins and remove odd one
        temp = (PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg) & PORT_PMUX_PMUXE( 0xF ) ;
    48b8:	210f      	movs	r1, #15
    48ba:	4031      	ands	r1, r6
        // Set new muxing
        PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg = temp|PORT_PMUX_PMUXO( ulPeripheral ) ;
    48bc:	4321      	orrs	r1, r4
        // Enable port mux
        PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg |= PORT_PINCFG_PMUXEN ;
    48be:	189a      	adds	r2, r3, r2
        uint32_t temp ;

        // Get whole current setup for both odd and even pins and remove odd one
        temp = (PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg) & PORT_PMUX_PMUXE( 0xF ) ;
        // Set new muxing
        PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg = temp|PORT_PMUX_PMUXO( ulPeripheral ) ;
    48c0:	b2c9      	uxtb	r1, r1
    48c2:	7029      	strb	r1, [r5, #0]
        // Enable port mux
        PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg |= PORT_PINCFG_PMUXEN ;
    48c4:	3240      	adds	r2, #64	; 0x40
    48c6:	7813      	ldrb	r3, [r2, #0]
    48c8:	4318      	orrs	r0, r3
    48ca:	7010      	strb	r0, [r2, #0]
    case PIO_NOT_A_PIN:
      return -1l ;
    break ;
  }

  return 0l ;
    48cc:	2400      	movs	r4, #0
    48ce:	e00e      	b.n	48ee <pinPeripheral+0xb6>
      }
      else // even pin
      {
        uint32_t temp ;

        temp = (PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg) & PORT_PMUX_PMUXO( 0xF ) ;
    48d0:	4e09      	ldr	r6, [pc, #36]	; (48f8 <pinPeripheral+0xc0>)
    48d2:	270f      	movs	r7, #15
    48d4:	199b      	adds	r3, r3, r6
    48d6:	195d      	adds	r5, r3, r5
    48d8:	3530      	adds	r5, #48	; 0x30
    48da:	782e      	ldrb	r6, [r5, #0]
        PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg = temp|PORT_PMUX_PMUXE( ulPeripheral ) ;
        PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg |= PORT_PINCFG_PMUXEN ; // Enable port mux
    48dc:	189a      	adds	r2, r3, r2
      }
      else // even pin
      {
        uint32_t temp ;

        temp = (PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg) & PORT_PMUX_PMUXO( 0xF ) ;
    48de:	43be      	bics	r6, r7
        PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg = temp|PORT_PMUX_PMUXE( ulPeripheral ) ;
    48e0:	4331      	orrs	r1, r6
    48e2:	b2c9      	uxtb	r1, r1
    48e4:	7029      	strb	r1, [r5, #0]
        PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg |= PORT_PINCFG_PMUXEN ; // Enable port mux
    48e6:	3240      	adds	r2, #64	; 0x40
    48e8:	7813      	ldrb	r3, [r2, #0]
    48ea:	4318      	orrs	r0, r3
    48ec:	7010      	strb	r0, [r2, #0]
      return -1l ;
    break ;
  }

  return 0l ;
}
    48ee:	1c20      	adds	r0, r4, #0
    48f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    48f2:	46c0      	nop			; (mov r8, r8)
    48f4:	00008cb8 	.word	0x00008cb8
    48f8:	41004400 	.word	0x41004400

000048fc <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
    48fc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    48fe:	188a      	adds	r2, r1, r2
    4900:	1c06      	adds	r6, r0, #0
    4902:	1c0d      	adds	r5, r1, #0
    4904:	9201      	str	r2, [sp, #4]
  size_t n = 0;
  while (size--) {
    4906:	1c0c      	adds	r4, r1, #0
    4908:	9b01      	ldr	r3, [sp, #4]
    490a:	1b67      	subs	r7, r4, r5
    490c:	429c      	cmp	r4, r3
    490e:	d007      	beq.n	4920 <_ZN5Print5writeEPKhj+0x24>
    if (write(*buffer++)) n++;
    4910:	6833      	ldr	r3, [r6, #0]
    4912:	7821      	ldrb	r1, [r4, #0]
    4914:	681b      	ldr	r3, [r3, #0]
    4916:	1c30      	adds	r0, r6, #0
    4918:	4798      	blx	r3
    491a:	3401      	adds	r4, #1
    491c:	2800      	cmp	r0, #0
    491e:	d1f3      	bne.n	4908 <_ZN5Print5writeEPKhj+0xc>
    else break;
  }
  return n;
}
    4920:	1c38      	adds	r0, r7, #0
    4922:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

00004924 <_ZN5Print5printEmi.part.3>:
  } else {
    return printNumber(n, base);
  }
}

size_t Print::print(unsigned long n, int base)
    4924:	b508      	push	{r3, lr}
{
  if (base == 0) return write(n);
    4926:	6803      	ldr	r3, [r0, #0]
    4928:	b2c9      	uxtb	r1, r1
    492a:	681b      	ldr	r3, [r3, #0]
    492c:	4798      	blx	r3
  else return printNumber(n, base);
}
    492e:	bd08      	pop	{r3, pc}

00004930 <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
    4930:	b538      	push	{r3, r4, r5, lr}
    4932:	1c05      	adds	r5, r0, #0
    4934:	1c0c      	adds	r4, r1, #0
      if (str == NULL) return 0;
    4936:	1e08      	subs	r0, r1, #0
    4938:	d007      	beq.n	494a <_ZN5Print5writeEPKc+0x1a>
      return write((const uint8_t *)str, strlen(str));
    493a:	f003 fd75 	bl	8428 <strlen>
    493e:	682b      	ldr	r3, [r5, #0]
    4940:	1c02      	adds	r2, r0, #0
    4942:	685b      	ldr	r3, [r3, #4]
    4944:	1c28      	adds	r0, r5, #0
    4946:	1c21      	adds	r1, r4, #0
    4948:	4798      	blx	r3
    }
    494a:	bd38      	pop	{r3, r4, r5, pc}

0000494c <_ZN5Print5printEPKc>:
{
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
    494c:	b508      	push	{r3, lr}
  return write(str);
    494e:	f7ff ffef 	bl	4930 <_ZN5Print5writeEPKc>
}
    4952:	bd08      	pop	{r3, pc}

00004954 <_ZN5Print5printEc>:

size_t Print::print(char c)
{
    4954:	b508      	push	{r3, lr}
  return write(c);
    4956:	6803      	ldr	r3, [r0, #0]
    4958:	681b      	ldr	r3, [r3, #0]
    495a:	4798      	blx	r3
}
    495c:	bd08      	pop	{r3, pc}
	...

00004960 <_ZN5Print7printlnEv>:
{
  return x.printTo(*this);
}

size_t Print::println(void)
{
    4960:	b508      	push	{r3, lr}
  return write("\r\n");
    4962:	4902      	ldr	r1, [pc, #8]	; (496c <_ZN5Print7printlnEv+0xc>)
    4964:	f7ff ffe4 	bl	4930 <_ZN5Print5writeEPKc>
}
    4968:	bd08      	pop	{r3, pc}
    496a:	46c0      	nop			; (mov r8, r8)
    496c:	000090d8 	.word	0x000090d8

00004970 <_ZN5Print7printlnEPKc>:
  n += println();
  return n;
}

size_t Print::println(const char c[])
{
    4970:	b538      	push	{r3, r4, r5, lr}
    4972:	1c04      	adds	r4, r0, #0
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
    4974:	f7ff ffdc 	bl	4930 <_ZN5Print5writeEPKc>
    4978:	1c05      	adds	r5, r0, #0
}

size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
    497a:	1c20      	adds	r0, r4, #0
    497c:	f7ff fff0 	bl	4960 <_ZN5Print7printlnEv>
    4980:	1828      	adds	r0, r5, r0
  return n;
}
    4982:	bd38      	pop	{r3, r4, r5, pc}

00004984 <_ZN5Print11printNumberEmh>:
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
{
    4984:	b5f0      	push	{r4, r5, r6, r7, lr}
    4986:	b08d      	sub	sp, #52	; 0x34
    4988:	1c16      	adds	r6, r2, #0
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
    498a:	ab0b      	add	r3, sp, #44	; 0x2c
    498c:	2200      	movs	r2, #0
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
{
    498e:	9001      	str	r0, [sp, #4]
    4990:	1c0c      	adds	r4, r1, #0
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
    4992:	701a      	strb	r2, [r3, #0]

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
    4994:	2e01      	cmp	r6, #1
    4996:	d800      	bhi.n	499a <_ZN5Print11printNumberEmh+0x16>
    4998:	260a      	movs	r6, #10
    499a:	466d      	mov	r5, sp
    499c:	352b      	adds	r5, #43	; 0x2b

  do {
    char c = n % base;
    499e:	1c20      	adds	r0, r4, #0
    49a0:	1c31      	adds	r1, r6, #0
    49a2:	f001 fdb5 	bl	6510 <__aeabi_uidivmod>
    n /= base;
    49a6:	1c20      	adds	r0, r4, #0

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    char c = n % base;
    49a8:	b2cf      	uxtb	r7, r1
    n /= base;
    49aa:	1c31      	adds	r1, r6, #0
    49ac:	f001 fd6c 	bl	6488 <__aeabi_uidiv>

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    49b0:	1c29      	adds	r1, r5, #0
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    char c = n % base;
    n /= base;
    49b2:	1c04      	adds	r4, r0, #0

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    49b4:	2f09      	cmp	r7, #9
    49b6:	d801      	bhi.n	49bc <_ZN5Print11printNumberEmh+0x38>
    49b8:	3730      	adds	r7, #48	; 0x30
    49ba:	e000      	b.n	49be <_ZN5Print11printNumberEmh+0x3a>
    49bc:	3737      	adds	r7, #55	; 0x37
    49be:	b2ff      	uxtb	r7, r7
    49c0:	702f      	strb	r7, [r5, #0]
    49c2:	3d01      	subs	r5, #1
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    49c4:	2c00      	cmp	r4, #0
    49c6:	d1ea      	bne.n	499e <_ZN5Print11printNumberEmh+0x1a>
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
    49c8:	9801      	ldr	r0, [sp, #4]
    49ca:	f7ff ffb1 	bl	4930 <_ZN5Print5writeEPKc>
}
    49ce:	b00d      	add	sp, #52	; 0x34
    49d0:	bdf0      	pop	{r4, r5, r6, r7, pc}

000049d2 <_ZN5Print5printEli>:
{
  return print((unsigned long) n, base);
}

size_t Print::print(long n, int base)
{
    49d2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    49d4:	1c04      	adds	r4, r0, #0
    49d6:	1c0d      	adds	r5, r1, #0
    49d8:	1e16      	subs	r6, r2, #0
  if (base == 0) {
    49da:	d104      	bne.n	49e6 <_ZN5Print5printEli+0x14>
    return write(n);
    49dc:	6803      	ldr	r3, [r0, #0]
    49de:	b2c9      	uxtb	r1, r1
    49e0:	681b      	ldr	r3, [r3, #0]
    49e2:	4798      	blx	r3
    49e4:	e012      	b.n	4a0c <_ZN5Print5printEli+0x3a>
  } else if (base == 10) {
    49e6:	2a0a      	cmp	r2, #10
    49e8:	d10d      	bne.n	4a06 <_ZN5Print5printEli+0x34>
    if (n < 0) {
    49ea:	2900      	cmp	r1, #0
    49ec:	da0a      	bge.n	4a04 <_ZN5Print5printEli+0x32>
      int t = print('-');
    49ee:	212d      	movs	r1, #45	; 0x2d
    49f0:	f7ff ffb0 	bl	4954 <_ZN5Print5printEc>
      n = -n;
    49f4:	4269      	negs	r1, r5
{
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
      int t = print('-');
    49f6:	1c07      	adds	r7, r0, #0
      n = -n;
      return printNumber(n, 10) + t;
    49f8:	1c32      	adds	r2, r6, #0
    49fa:	1c20      	adds	r0, r4, #0
    49fc:	f7ff ffc2 	bl	4984 <_ZN5Print11printNumberEmh>
    4a00:	19c0      	adds	r0, r0, r7
    4a02:	e003      	b.n	4a0c <_ZN5Print5printEli+0x3a>
    4a04:	e000      	b.n	4a08 <_ZN5Print5printEli+0x36>
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
    4a06:	b2d2      	uxtb	r2, r2
    4a08:	f7ff ffbc 	bl	4984 <_ZN5Print11printNumberEmh>
  }
}
    4a0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00004a0e <_ZN5Print5printEii>:
{
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
    4a0e:	b508      	push	{r3, lr}
  return print((long) n, base);
    4a10:	f7ff ffdf 	bl	49d2 <_ZN5Print5printEli>
}
    4a14:	bd08      	pop	{r3, pc}

00004a16 <_ZN5Print7printlnEii>:
  n += println();
  return n;
}

size_t Print::println(int num, int base)
{
    4a16:	b538      	push	{r3, r4, r5, lr}
    4a18:	1c04      	adds	r4, r0, #0
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
  return print((long) n, base);
    4a1a:	f7ff ffda 	bl	49d2 <_ZN5Print5printEli>
    4a1e:	1c05      	adds	r5, r0, #0
}

size_t Print::println(int num, int base)
{
  size_t n = print(num, base);
  n += println();
    4a20:	1c20      	adds	r0, r4, #0
    4a22:	f7ff ff9d 	bl	4960 <_ZN5Print7printlnEv>
    4a26:	1828      	adds	r0, r5, r0
  return n;
}
    4a28:	bd38      	pop	{r3, r4, r5, pc}

00004a2a <_ZN5Print5printEmi>:
    return printNumber(n, base);
  }
}

size_t Print::print(unsigned long n, int base)
{
    4a2a:	b508      	push	{r3, lr}
  if (base == 0) return write(n);
    4a2c:	2a00      	cmp	r2, #0
    4a2e:	d102      	bne.n	4a36 <_ZN5Print5printEmi+0xc>
    4a30:	f7ff ff78 	bl	4924 <_ZN5Print5printEmi.part.3>
    4a34:	e002      	b.n	4a3c <_ZN5Print5printEmi+0x12>
  else return printNumber(n, base);
    4a36:	b2d2      	uxtb	r2, r2
    4a38:	f7ff ffa4 	bl	4984 <_ZN5Print11printNumberEmh>
}
    4a3c:	bd08      	pop	{r3, pc}
	...

00004a40 <_ZN5Print10printFloatEdh>:

  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits)
{
    4a40:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    4a42:	1c1c      	adds	r4, r3, #0
    4a44:	ab08      	add	r3, sp, #32
    4a46:	781b      	ldrb	r3, [r3, #0]
    4a48:	1c07      	adds	r7, r0, #0
  size_t n = 0;

  if (isnan(number)) return print("nan");
    4a4a:	1c21      	adds	r1, r4, #0
    4a4c:	1c10      	adds	r0, r2, #0

  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits)
{
    4a4e:	1c15      	adds	r5, r2, #0
    4a50:	9300      	str	r3, [sp, #0]
  size_t n = 0;

  if (isnan(number)) return print("nan");
    4a52:	f001 fcdf 	bl	6414 <__fpclassifyd>
    4a56:	2800      	cmp	r0, #0
    4a58:	d102      	bne.n	4a60 <_ZN5Print10printFloatEdh+0x20>
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
    4a5a:	1c38      	adds	r0, r7, #0
    4a5c:	4950      	ldr	r1, [pc, #320]	; (4ba0 <_ZN5Print10printFloatEdh+0x160>)
    4a5e:	e007      	b.n	4a70 <_ZN5Print10printFloatEdh+0x30>
size_t Print::printFloat(double number, uint8_t digits)
{
  size_t n = 0;

  if (isnan(number)) return print("nan");
  if (isinf(number)) return print("inf");
    4a60:	1c28      	adds	r0, r5, #0
    4a62:	1c21      	adds	r1, r4, #0
    4a64:	f001 fcd6 	bl	6414 <__fpclassifyd>
    4a68:	2801      	cmp	r0, #1
    4a6a:	d104      	bne.n	4a76 <_ZN5Print10printFloatEdh+0x36>
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
    4a6c:	494d      	ldr	r1, [pc, #308]	; (4ba4 <_ZN5Print10printFloatEdh+0x164>)
    4a6e:	1c38      	adds	r0, r7, #0
    4a70:	f7ff ff5e 	bl	4930 <_ZN5Print5writeEPKc>
size_t Print::printFloat(double number, uint8_t digits)
{
  size_t n = 0;

  if (isnan(number)) return print("nan");
  if (isinf(number)) return print("inf");
    4a74:	e07c      	b.n	4b70 <_ZN5Print10printFloatEdh+0x130>
  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
    4a76:	1c28      	adds	r0, r5, #0
    4a78:	1c21      	adds	r1, r4, #0
    4a7a:	4b40      	ldr	r3, [pc, #256]	; (4b7c <_ZN5Print10printFloatEdh+0x13c>)
    4a7c:	4a3e      	ldr	r2, [pc, #248]	; (4b78 <_ZN5Print10printFloatEdh+0x138>)
    4a7e:	f001 fddd 	bl	663c <__aeabi_dcmpgt>
    4a82:	2800      	cmp	r0, #0
    4a84:	d002      	beq.n	4a8c <_ZN5Print10printFloatEdh+0x4c>
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
    4a86:	1c38      	adds	r0, r7, #0
    4a88:	4947      	ldr	r1, [pc, #284]	; (4ba8 <_ZN5Print10printFloatEdh+0x168>)
    4a8a:	e7f1      	b.n	4a70 <_ZN5Print10printFloatEdh+0x30>
  size_t n = 0;

  if (isnan(number)) return print("nan");
  if (isinf(number)) return print("inf");
  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
  if (number <-4294967040.0) return print ("ovf");  // constant determined empirically
    4a8c:	1c28      	adds	r0, r5, #0
    4a8e:	1c21      	adds	r1, r4, #0
    4a90:	4a3b      	ldr	r2, [pc, #236]	; (4b80 <_ZN5Print10printFloatEdh+0x140>)
    4a92:	4b3c      	ldr	r3, [pc, #240]	; (4b84 <_ZN5Print10printFloatEdh+0x144>)
    4a94:	f001 fdbe 	bl	6614 <__aeabi_dcmplt>
    4a98:	2800      	cmp	r0, #0
    4a9a:	d1f4      	bne.n	4a86 <_ZN5Print10printFloatEdh+0x46>

  // Handle negative numbers
  if (number < 0.0)
    4a9c:	1c28      	adds	r0, r5, #0
    4a9e:	1c21      	adds	r1, r4, #0
    4aa0:	4a39      	ldr	r2, [pc, #228]	; (4b88 <_ZN5Print10printFloatEdh+0x148>)
    4aa2:	4b3a      	ldr	r3, [pc, #232]	; (4b8c <_ZN5Print10printFloatEdh+0x14c>)
    4aa4:	f001 fdb6 	bl	6614 <__aeabi_dcmplt>
    4aa8:	2800      	cmp	r0, #0
    4aaa:	d008      	beq.n	4abe <_ZN5Print10printFloatEdh+0x7e>
  {
     n += print('-');
    4aac:	212d      	movs	r1, #45	; 0x2d
    4aae:	1c38      	adds	r0, r7, #0
    4ab0:	f7ff ff50 	bl	4954 <_ZN5Print5printEc>
     number = -number;
    4ab4:	2180      	movs	r1, #128	; 0x80
    4ab6:	0609      	lsls	r1, r1, #24
  if (number <-4294967040.0) return print ("ovf");  // constant determined empirically

  // Handle negative numbers
  if (number < 0.0)
  {
     n += print('-');
    4ab8:	9001      	str	r0, [sp, #4]
     number = -number;
    4aba:	1864      	adds	r4, r4, r1
    4abc:	e000      	b.n	4ac0 <_ZN5Print10printFloatEdh+0x80>
  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits)
{
  size_t n = 0;
    4abe:	9001      	str	r0, [sp, #4]
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
  for (uint8_t i=0; i<digits; ++i)
    4ac0:	2600      	movs	r6, #0
     n += print('-');
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
    4ac2:	4a33      	ldr	r2, [pc, #204]	; (4b90 <_ZN5Print10printFloatEdh+0x150>)
    4ac4:	4b33      	ldr	r3, [pc, #204]	; (4b94 <_ZN5Print10printFloatEdh+0x154>)
  for (uint8_t i=0; i<digits; ++i)
    4ac6:	9900      	ldr	r1, [sp, #0]
    4ac8:	428e      	cmp	r6, r1
    4aca:	d00a      	beq.n	4ae2 <_ZN5Print10printFloatEdh+0xa2>
    rounding /= 10.0;
    4acc:	1c10      	adds	r0, r2, #0
    4ace:	1c19      	adds	r1, r3, #0
    4ad0:	4a31      	ldr	r2, [pc, #196]	; (4b98 <_ZN5Print10printFloatEdh+0x158>)
    4ad2:	4b32      	ldr	r3, [pc, #200]	; (4b9c <_ZN5Print10printFloatEdh+0x15c>)
    4ad4:	f002 f904 	bl	6ce0 <__aeabi_ddiv>
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
  for (uint8_t i=0; i<digits; ++i)
    4ad8:	3601      	adds	r6, #1
    rounding /= 10.0;
    4ada:	1c02      	adds	r2, r0, #0
    4adc:	1c0b      	adds	r3, r1, #0
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
  for (uint8_t i=0; i<digits; ++i)
    4ade:	b2f6      	uxtb	r6, r6
    4ae0:	e7f1      	b.n	4ac6 <_ZN5Print10printFloatEdh+0x86>
    rounding /= 10.0;

  number += rounding;
    4ae2:	1c28      	adds	r0, r5, #0
    4ae4:	1c21      	adds	r1, r4, #0
    4ae6:	f001 fddf 	bl	66a8 <__aeabi_dadd>
    4aea:	1c0d      	adds	r5, r1, #0
    4aec:	1c04      	adds	r4, r0, #0

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
    4aee:	f001 fdbb 	bl	6668 <__aeabi_d2uiz>
    4af2:	1c06      	adds	r6, r0, #0
  double remainder = number - (double)int_part;
    4af4:	f003 fb4c 	bl	8190 <__aeabi_ui2d>
    4af8:	1c0b      	adds	r3, r1, #0
    4afa:	1c02      	adds	r2, r0, #0
    4afc:	1c29      	adds	r1, r5, #0
    4afe:	1c20      	adds	r0, r4, #0
    4b00:	f002 ffe8 	bl	7ad4 <__aeabi_dsub>
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
    4b04:	220a      	movs	r2, #10

  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
    4b06:	1c04      	adds	r4, r0, #0
    4b08:	1c0d      	adds	r5, r1, #0
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
    4b0a:	1c38      	adds	r0, r7, #0
    4b0c:	1c31      	adds	r1, r6, #0
    4b0e:	f7ff ff39 	bl	4984 <_ZN5Print11printNumberEmh>
  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
  n += print(int_part);
    4b12:	9b01      	ldr	r3, [sp, #4]

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0) {
    4b14:	9900      	ldr	r1, [sp, #0]
  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
  n += print(int_part);
    4b16:	18c6      	adds	r6, r0, r3

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0) {
    4b18:	2900      	cmp	r1, #0
    4b1a:	d004      	beq.n	4b26 <_ZN5Print10printFloatEdh+0xe6>
    n += print('.');
    4b1c:	1c38      	adds	r0, r7, #0
    4b1e:	212e      	movs	r1, #46	; 0x2e
    4b20:	f7ff ff18 	bl	4954 <_ZN5Print5printEc>
    4b24:	1836      	adds	r6, r6, r0
  }

  // Extract digits from the remainder one at a time
  while (digits-- > 0)
    4b26:	9b00      	ldr	r3, [sp, #0]
    4b28:	2b00      	cmp	r3, #0
    4b2a:	d020      	beq.n	4b6e <_ZN5Print10printFloatEdh+0x12e>
  {
    remainder *= 10.0;
    4b2c:	4a1a      	ldr	r2, [pc, #104]	; (4b98 <_ZN5Print10printFloatEdh+0x158>)
    4b2e:	4b1b      	ldr	r3, [pc, #108]	; (4b9c <_ZN5Print10printFloatEdh+0x15c>)
    4b30:	1c20      	adds	r0, r4, #0
    4b32:	1c29      	adds	r1, r5, #0
    4b34:	f002 fd3e 	bl	75b4 <__aeabi_dmul>
    4b38:	1c0d      	adds	r5, r1, #0
    4b3a:	1c04      	adds	r4, r0, #0
    unsigned int toPrint = (unsigned int)(remainder);
    4b3c:	f001 fd94 	bl	6668 <__aeabi_d2uiz>
    4b40:	9001      	str	r0, [sp, #4]
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
    4b42:	220a      	movs	r2, #10
    4b44:	9901      	ldr	r1, [sp, #4]
    4b46:	1c38      	adds	r0, r7, #0
    4b48:	f7ff ff1c 	bl	4984 <_ZN5Print11printNumberEmh>
  // Extract digits from the remainder one at a time
  while (digits-- > 0)
  {
    remainder *= 10.0;
    unsigned int toPrint = (unsigned int)(remainder);
    n += print(toPrint);
    4b4c:	1836      	adds	r6, r6, r0
    remainder -= toPrint;
    4b4e:	9801      	ldr	r0, [sp, #4]
    4b50:	f003 fb1e 	bl	8190 <__aeabi_ui2d>
    4b54:	1c0b      	adds	r3, r1, #0
    4b56:	1c02      	adds	r2, r0, #0
    4b58:	1c29      	adds	r1, r5, #0
    4b5a:	1c20      	adds	r0, r4, #0
    4b5c:	f002 ffba 	bl	7ad4 <__aeabi_dsub>
    4b60:	9b00      	ldr	r3, [sp, #0]
    4b62:	1c04      	adds	r4, r0, #0
    4b64:	3b01      	subs	r3, #1
    4b66:	b2db      	uxtb	r3, r3
    4b68:	1c0d      	adds	r5, r1, #0
    4b6a:	9300      	str	r3, [sp, #0]
    4b6c:	e7db      	b.n	4b26 <_ZN5Print10printFloatEdh+0xe6>
    4b6e:	1c30      	adds	r0, r6, #0
  }

  return n;
}
    4b70:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    4b72:	46c0      	nop			; (mov r8, r8)
    4b74:	46c0      	nop			; (mov r8, r8)
    4b76:	46c0      	nop			; (mov r8, r8)
    4b78:	e0000000 	.word	0xe0000000
    4b7c:	41efffff 	.word	0x41efffff
    4b80:	e0000000 	.word	0xe0000000
    4b84:	c1efffff 	.word	0xc1efffff
	...
    4b94:	3fe00000 	.word	0x3fe00000
    4b98:	00000000 	.word	0x00000000
    4b9c:	40240000 	.word	0x40240000
    4ba0:	000090db 	.word	0x000090db
    4ba4:	000090df 	.word	0x000090df
    4ba8:	000090e3 	.word	0x000090e3
    4bac:	46c0      	nop			; (mov r8, r8)
    4bae:	46c0      	nop			; (mov r8, r8)

00004bb0 <_ZN5Print5printEdi>:
  if (base == 0) return write(n);
  else return printNumber(n, base);
}

size_t Print::print(double n, int digits)
{
    4bb0:	b513      	push	{r0, r1, r4, lr}
  return printFloat(n, digits);
    4bb2:	9c04      	ldr	r4, [sp, #16]
    4bb4:	b2e1      	uxtb	r1, r4
    4bb6:	9100      	str	r1, [sp, #0]
    4bb8:	f7ff ff42 	bl	4a40 <_ZN5Print10printFloatEdh>
}
    4bbc:	bd16      	pop	{r1, r2, r4, pc}
	...

00004bc0 <initiateReset>:
}

static int ticks = -1;

void initiateReset(int _ticks) {
	ticks = _ticks;
    4bc0:	4b01      	ldr	r3, [pc, #4]	; (4bc8 <initiateReset+0x8>)
    4bc2:	6018      	str	r0, [r3, #0]
}
    4bc4:	4770      	bx	lr
    4bc6:	46c0      	nop			; (mov r8, r8)
    4bc8:	20000008 	.word	0x20000008

00004bcc <cancelReset>:

void cancelReset() {
	ticks = -1;
    4bcc:	4b02      	ldr	r3, [pc, #8]	; (4bd8 <cancelReset+0xc>)
    4bce:	2201      	movs	r2, #1
    4bd0:	4252      	negs	r2, r2
    4bd2:	601a      	str	r2, [r3, #0]
}
    4bd4:	4770      	bx	lr
    4bd6:	46c0      	nop			; (mov r8, r8)
    4bd8:	20000008 	.word	0x20000008

00004bdc <tickReset>:

void tickReset() {
	if (ticks == -1)
    4bdc:	4a15      	ldr	r2, [pc, #84]	; (4c34 <tickReset+0x58>)
    4bde:	6813      	ldr	r3, [r2, #0]
    4be0:	1c58      	adds	r0, r3, #1
    4be2:	d025      	beq.n	4c30 <tickReset+0x54>
		return;
	ticks--;
    4be4:	3b01      	subs	r3, #1
    4be6:	6013      	str	r3, [r2, #0]
	if (ticks == 0)
    4be8:	2b00      	cmp	r3, #0
    4bea:	d121      	bne.n	4c30 <tickReset+0x54>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    4bec:	b672      	cpsid	i
	__disable_irq();

	// Avoid erasing the application if APP_START is < than the minimum bootloader size
	// This could happen if without_bootloader linker script was chosen
	// Minimum bootloader size in SAMD21 family is 512bytes (RM section 22.6.5)
	if (APP_START < (0x200 + 4)) {
    4bee:	4a12      	ldr	r2, [pc, #72]	; (4c38 <tickReset+0x5c>)
    4bf0:	4b12      	ldr	r3, [pc, #72]	; (4c3c <tickReset+0x60>)
    4bf2:	3204      	adds	r2, #4
    4bf4:	429a      	cmp	r2, r3
    4bf6:	d807      	bhi.n	4c08 <tickReset+0x2c>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    4bf8:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                 SCB_AIRCR_SYSRESETREQ_Msk);
    4bfc:	4a10      	ldr	r2, [pc, #64]	; (4c40 <tickReset+0x64>)
    4bfe:	4b11      	ldr	r3, [pc, #68]	; (4c44 <tickReset+0x68>)
    4c00:	60da      	str	r2, [r3, #12]
    4c02:	f3bf 8f4f 	dsb	sy
    4c06:	e011      	b.n	4c2c <tickReset+0x50>
#else
#define APP_START 0x00002004
#endif

static inline bool nvmReady(void) {
        return NVMCTRL->INTFLAG.reg & NVMCTRL_INTFLAG_READY;
    4c08:	4b0f      	ldr	r3, [pc, #60]	; (4c48 <tickReset+0x6c>)
    4c0a:	7d19      	ldrb	r1, [r3, #20]
	if (APP_START < (0x200 + 4)) {
		goto reset;
	}

	// Erase application
	while (!nvmReady())
    4c0c:	07c8      	lsls	r0, r1, #31
    4c0e:	d5fb      	bpl.n	4c08 <tickReset+0x2c>
		;
	NVMCTRL->STATUS.reg |= NVMCTRL_STATUS_MASK;
    4c10:	8b18      	ldrh	r0, [r3, #24]
    4c12:	2120      	movs	r1, #32
    4c14:	31ff      	adds	r1, #255	; 0xff
	NVMCTRL->ADDR.reg  = (uintptr_t)&NVM_MEMORY[APP_START / 4];
    4c16:	0892      	lsrs	r2, r2, #2
    4c18:	0052      	lsls	r2, r2, #1
	}

	// Erase application
	while (!nvmReady())
		;
	NVMCTRL->STATUS.reg |= NVMCTRL_STATUS_MASK;
    4c1a:	4301      	orrs	r1, r0
    4c1c:	8319      	strh	r1, [r3, #24]
	NVMCTRL->ADDR.reg  = (uintptr_t)&NVM_MEMORY[APP_START / 4];
    4c1e:	61da      	str	r2, [r3, #28]
	NVMCTRL->CTRLA.reg = NVMCTRL_CTRLA_CMD_ER | NVMCTRL_CTRLA_CMDEX_KEY;
    4c20:	4a0a      	ldr	r2, [pc, #40]	; (4c4c <tickReset+0x70>)
    4c22:	801a      	strh	r2, [r3, #0]
#else
#define APP_START 0x00002004
#endif

static inline bool nvmReady(void) {
        return NVMCTRL->INTFLAG.reg & NVMCTRL_INTFLAG_READY;
    4c24:	7d1a      	ldrb	r2, [r3, #20]
	while (!nvmReady())
		;
	NVMCTRL->STATUS.reg |= NVMCTRL_STATUS_MASK;
	NVMCTRL->ADDR.reg  = (uintptr_t)&NVM_MEMORY[APP_START / 4];
	NVMCTRL->CTRLA.reg = NVMCTRL_CTRLA_CMD_ER | NVMCTRL_CTRLA_CMDEX_KEY;
	while (!nvmReady())
    4c26:	07d1      	lsls	r1, r2, #31
    4c28:	d5fc      	bpl.n	4c24 <tickReset+0x48>
    4c2a:	e7e5      	b.n	4bf8 <tickReset+0x1c>
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
    4c2c:	46c0      	nop			; (mov r8, r8)
    4c2e:	e7fd      	b.n	4c2c <tickReset+0x50>
	if (ticks == -1)
		return;
	ticks--;
	if (ticks == 0)
		banzai();
}
    4c30:	4770      	bx	lr
    4c32:	46c0      	nop			; (mov r8, r8)
    4c34:	20000008 	.word	0x20000008
    4c38:	00002000 	.word	0x00002000
    4c3c:	00000203 	.word	0x00000203
    4c40:	05fa0004 	.word	0x05fa0004
    4c44:	e000ed00 	.word	0xe000ed00
    4c48:	41004000 	.word	0x41004000
    4c4c:	ffffa502 	.word	0xffffa502

00004c50 <_ZN6SERCOMC1EP6Sercom>:
#include "SERCOM.h"
#include "variant.h"

SERCOM::SERCOM(Sercom* s)
{
  sercom = s;
    4c50:	6001      	str	r1, [r0, #0]
}
    4c52:	4770      	bx	lr

00004c54 <_ZN6SERCOM9initFrameE18SercomUartCharSize15SercomDataOrder16SercomParityMode19SercomNumberStopBit>:
    sercom->USART.BAUD.FRAC.FP   = (baudTimes8 % 8);
    sercom->USART.BAUD.FRAC.BAUD = (baudTimes8 / 8);
  }
}
void SERCOM::initFrame(SercomUartCharSize charSize, SercomDataOrder dataOrder, SercomParityMode parityMode, SercomNumberStopBit nbStopBits)
{
    4c54:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    4c56:	ac08      	add	r4, sp, #32
    4c58:	7826      	ldrb	r6, [r4, #0]
  //Setting the CTRLA register
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_FORM( (parityMode == SERCOM_NO_PARITY ? 0 : 1) ) |
                dataOrder << SERCOM_USART_CTRLA_DORD_Pos;
    4c5a:	6804      	ldr	r4, [r0, #0]
  }
}
void SERCOM::initFrame(SercomUartCharSize charSize, SercomDataOrder dataOrder, SercomParityMode parityMode, SercomNumberStopBit nbStopBits)
{
  //Setting the CTRLA register
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_FORM( (parityMode == SERCOM_NO_PARITY ? 0 : 1) ) |
    4c5c:	1e9d      	subs	r5, r3, #2
                dataOrder << SERCOM_USART_CTRLA_DORD_Pos;
    4c5e:	6827      	ldr	r7, [r4, #0]
  }
}
void SERCOM::initFrame(SercomUartCharSize charSize, SercomDataOrder dataOrder, SercomParityMode parityMode, SercomNumberStopBit nbStopBits)
{
  //Setting the CTRLA register
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_FORM( (parityMode == SERCOM_NO_PARITY ? 0 : 1) ) |
    4c60:	1e6c      	subs	r4, r5, #1
    4c62:	41a5      	sbcs	r5, r4
    4c64:	b2ec      	uxtb	r4, r5
                dataOrder << SERCOM_USART_CTRLA_DORD_Pos;
    4c66:	0792      	lsls	r2, r2, #30
    4c68:	6805      	ldr	r5, [r0, #0]
  }
}
void SERCOM::initFrame(SercomUartCharSize charSize, SercomDataOrder dataOrder, SercomParityMode parityMode, SercomNumberStopBit nbStopBits)
{
  //Setting the CTRLA register
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_FORM( (parityMode == SERCOM_NO_PARITY ? 0 : 1) ) |
    4c6a:	433a      	orrs	r2, r7
    4c6c:	0627      	lsls	r7, r4, #24
                dataOrder << SERCOM_USART_CTRLA_DORD_Pos;
    4c6e:	433a      	orrs	r2, r7
    4c70:	602a      	str	r2, [r5, #0]

  //Setting the CTRLB register
  sercom->USART.CTRLB.reg |=	SERCOM_USART_CTRLB_CHSIZE(charSize) |
                nbStopBits << SERCOM_USART_CTRLB_SBMODE_Pos |
                (parityMode == SERCOM_NO_PARITY ? 0 : parityMode) << SERCOM_USART_CTRLB_PMODE_Pos; //If no parity use default value
    4c72:	6802      	ldr	r2, [r0, #0]
  //Setting the CTRLA register
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_FORM( (parityMode == SERCOM_NO_PARITY ? 0 : 1) ) |
                dataOrder << SERCOM_USART_CTRLA_DORD_Pos;

  //Setting the CTRLB register
  sercom->USART.CTRLB.reg |=	SERCOM_USART_CTRLB_CHSIZE(charSize) |
    4c74:	2507      	movs	r5, #7
    4c76:	4029      	ands	r1, r5
                nbStopBits << SERCOM_USART_CTRLB_SBMODE_Pos |
                (parityMode == SERCOM_NO_PARITY ? 0 : parityMode) << SERCOM_USART_CTRLB_PMODE_Pos; //If no parity use default value
    4c78:	6850      	ldr	r0, [r2, #4]
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_FORM( (parityMode == SERCOM_NO_PARITY ? 0 : 1) ) |
                dataOrder << SERCOM_USART_CTRLA_DORD_Pos;

  //Setting the CTRLB register
  sercom->USART.CTRLB.reg |=	SERCOM_USART_CTRLB_CHSIZE(charSize) |
                nbStopBits << SERCOM_USART_CTRLB_SBMODE_Pos |
    4c7a:	01b5      	lsls	r5, r6, #6
    4c7c:	2c00      	cmp	r4, #0
    4c7e:	d000      	beq.n	4c82 <_ZN6SERCOM9initFrameE18SercomUartCharSize15SercomDataOrder16SercomParityMode19SercomNumberStopBit+0x2e>
    4c80:	035c      	lsls	r4, r3, #13
  //Setting the CTRLA register
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_FORM( (parityMode == SERCOM_NO_PARITY ? 0 : 1) ) |
                dataOrder << SERCOM_USART_CTRLA_DORD_Pos;

  //Setting the CTRLB register
  sercom->USART.CTRLB.reg |=	SERCOM_USART_CTRLB_CHSIZE(charSize) |
    4c82:	4329      	orrs	r1, r5
                nbStopBits << SERCOM_USART_CTRLB_SBMODE_Pos |
    4c84:	4301      	orrs	r1, r0
                (parityMode == SERCOM_NO_PARITY ? 0 : parityMode) << SERCOM_USART_CTRLB_PMODE_Pos; //If no parity use default value
    4c86:	430c      	orrs	r4, r1
    4c88:	6054      	str	r4, [r2, #4]
}
    4c8a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

00004c8c <_ZN6SERCOM8initPadsE15SercomUartTXPad11SercomRXPad>:

void SERCOM::initPads(SercomUartTXPad txPad, SercomRXPad rxPad)
{
    4c8c:	b530      	push	{r4, r5, lr}
  //Setting the CTRLA register
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_TXPO(txPad) |
                SERCOM_USART_CTRLA_RXPO(rxPad);
    4c8e:	6803      	ldr	r3, [r0, #0]
    4c90:	25c0      	movs	r5, #192	; 0xc0
    4c92:	681c      	ldr	r4, [r3, #0]
    4c94:	03ad      	lsls	r5, r5, #14
    4c96:	0512      	lsls	r2, r2, #20
    4c98:	402a      	ands	r2, r5
}

void SERCOM::initPads(SercomUartTXPad txPad, SercomRXPad rxPad)
{
  //Setting the CTRLA register
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_TXPO(txPad) |
    4c9a:	4322      	orrs	r2, r4
    4c9c:	24c0      	movs	r4, #192	; 0xc0
    4c9e:	02a4      	lsls	r4, r4, #10
    4ca0:	0409      	lsls	r1, r1, #16
    4ca2:	4021      	ands	r1, r4
                SERCOM_USART_CTRLA_RXPO(rxPad);
    4ca4:	4311      	orrs	r1, r2
    4ca6:	6019      	str	r1, [r3, #0]

  // Enable Transceiver and Receiver
  sercom->USART.CTRLB.reg |= SERCOM_USART_CTRLB_TXEN | SERCOM_USART_CTRLB_RXEN ;
    4ca8:	6803      	ldr	r3, [r0, #0]
    4caa:	685a      	ldr	r2, [r3, #4]
    4cac:	4314      	orrs	r4, r2
    4cae:	605c      	str	r4, [r3, #4]
}
    4cb0:	bd30      	pop	{r4, r5, pc}

00004cb2 <_ZN6SERCOM9resetUARTEv>:

void SERCOM::resetUART()
{
  // Start the Software Reset
  sercom->USART.CTRLA.bit.SWRST = 1 ;
    4cb2:	6803      	ldr	r3, [r0, #0]
    4cb4:	2101      	movs	r1, #1
    4cb6:	681a      	ldr	r2, [r3, #0]
    4cb8:	430a      	orrs	r2, r1
    4cba:	601a      	str	r2, [r3, #0]

  while ( sercom->USART.CTRLA.bit.SWRST || sercom->USART.SYNCBUSY.bit.SWRST )
    4cbc:	6802      	ldr	r2, [r0, #0]
    4cbe:	6811      	ldr	r1, [r2, #0]
    4cc0:	2301      	movs	r3, #1
    4cc2:	4219      	tst	r1, r3
    4cc4:	d1fb      	bne.n	4cbe <_ZN6SERCOM9resetUARTEv+0xc>
    4cc6:	69d1      	ldr	r1, [r2, #28]
    4cc8:	4219      	tst	r1, r3
    4cca:	d1f8      	bne.n	4cbe <_ZN6SERCOM9resetUARTEv+0xc>
  {
    // Wait for both bits Software Reset from CTRLA and SYNCBUSY coming back to 0
  }
}
    4ccc:	4770      	bx	lr

00004cce <_ZN6SERCOM10enableUARTEv>:

void SERCOM::enableUART()
{
  //Setting  the enable bit to 1
  sercom->USART.CTRLA.bit.ENABLE = 0x1u;
    4cce:	6803      	ldr	r3, [r0, #0]
    4cd0:	2102      	movs	r1, #2
    4cd2:	681a      	ldr	r2, [r3, #0]
    4cd4:	430a      	orrs	r2, r1
    4cd6:	601a      	str	r2, [r3, #0]

  //Wait for then enable bit from SYNCBUSY is equal to 0;
  while(sercom->USART.SYNCBUSY.bit.ENABLE);
    4cd8:	6802      	ldr	r2, [r0, #0]
    4cda:	69d3      	ldr	r3, [r2, #28]
    4cdc:	0799      	lsls	r1, r3, #30
    4cde:	d4fc      	bmi.n	4cda <_ZN6SERCOM10enableUARTEv+0xc>
}
    4ce0:	4770      	bx	lr

00004ce2 <_ZN6SERCOM9flushUARTEv>:
}

bool SERCOM::isDataRegisterEmptyUART()
{
  //DRE : Data Register Empty
  return sercom->USART.INTFLAG.bit.DRE;
    4ce2:	6803      	ldr	r3, [r0, #0]
    4ce4:	7e1a      	ldrb	r2, [r3, #24]
}

void SERCOM::flushUART()
{
  // Skip checking transmission completion if data register is empty
  if(isDataRegisterEmptyUART())
    4ce6:	07d1      	lsls	r1, r2, #31
    4ce8:	d402      	bmi.n	4cf0 <_ZN6SERCOM9flushUARTEv+0xe>
    return;

  // Wait for transmission to complete
  while(!sercom->USART.INTFLAG.bit.TXC);
    4cea:	7e1a      	ldrb	r2, [r3, #24]
    4cec:	0791      	lsls	r1, r2, #30
    4cee:	d5fc      	bpl.n	4cea <_ZN6SERCOM9flushUARTEv+0x8>
}
    4cf0:	4770      	bx	lr

00004cf2 <_ZN6SERCOM15clearStatusUARTEv>:

void SERCOM::clearStatusUART()
{
  //Reset (with 0) the STATUS register
  sercom->USART.STATUS.reg = SERCOM_USART_STATUS_RESETVALUE;
    4cf2:	6803      	ldr	r3, [r0, #0]
    4cf4:	2200      	movs	r2, #0
    4cf6:	835a      	strh	r2, [r3, #26]
}
    4cf8:	4770      	bx	lr

00004cfa <_ZN6SERCOM17availableDataUARTEv>:

bool SERCOM::availableDataUART()
{
  //RXC : Receive Complete
  return sercom->USART.INTFLAG.bit.RXC;
    4cfa:	6803      	ldr	r3, [r0, #0]
    4cfc:	7e18      	ldrb	r0, [r3, #24]
    4cfe:	0740      	lsls	r0, r0, #29
    4d00:	0fc0      	lsrs	r0, r0, #31
}
    4d02:	4770      	bx	lr

00004d04 <_ZN6SERCOM11isUARTErrorEv>:

bool SERCOM::isUARTError()
{
  return sercom->USART.INTFLAG.bit.ERROR;
    4d04:	6803      	ldr	r3, [r0, #0]
    4d06:	7e18      	ldrb	r0, [r3, #24]
    4d08:	09c0      	lsrs	r0, r0, #7
}
    4d0a:	4770      	bx	lr

00004d0c <_ZN6SERCOM20acknowledgeUARTErrorEv>:

void SERCOM::acknowledgeUARTError()
{
  sercom->USART.INTFLAG.bit.ERROR = 1;
    4d0c:	6803      	ldr	r3, [r0, #0]
    4d0e:	2280      	movs	r2, #128	; 0x80
    4d10:	7e19      	ldrb	r1, [r3, #24]
    4d12:	4252      	negs	r2, r2
    4d14:	430a      	orrs	r2, r1
    4d16:	761a      	strb	r2, [r3, #24]
}
    4d18:	4770      	bx	lr

00004d1a <_ZN6SERCOM23isDataRegisterEmptyUARTEv>:
}

bool SERCOM::isDataRegisterEmptyUART()
{
  //DRE : Data Register Empty
  return sercom->USART.INTFLAG.bit.DRE;
    4d1a:	6803      	ldr	r3, [r0, #0]
    4d1c:	7e18      	ldrb	r0, [r3, #24]
    4d1e:	2301      	movs	r3, #1
    4d20:	4018      	ands	r0, r3
}
    4d22:	4770      	bx	lr

00004d24 <_ZN6SERCOM12readDataUARTEv>:

uint8_t SERCOM::readDataUART()
{
  return sercom->USART.DATA.bit.DATA;
    4d24:	6803      	ldr	r3, [r0, #0]
    4d26:	8d18      	ldrh	r0, [r3, #40]	; 0x28
    4d28:	b2c0      	uxtb	r0, r0
}
    4d2a:	4770      	bx	lr

00004d2c <_ZN6SERCOM13writeDataUARTEh>:
}

bool SERCOM::isDataRegisterEmptyUART()
{
  //DRE : Data Register Empty
  return sercom->USART.INTFLAG.bit.DRE;
    4d2c:	6803      	ldr	r3, [r0, #0]
    4d2e:	7e1a      	ldrb	r2, [r3, #24]
    4d30:	2001      	movs	r0, #1
}

int SERCOM::writeDataUART(uint8_t data)
{
  // Wait for data register to be empty
  while(!isDataRegisterEmptyUART());
    4d32:	4202      	tst	r2, r0
    4d34:	d0fb      	beq.n	4d2e <_ZN6SERCOM13writeDataUARTEh+0x2>

  //Put data into DATA register
  sercom->USART.DATA.reg = (uint16_t)data;
    4d36:	8519      	strh	r1, [r3, #40]	; 0x28
  return 1;
}
    4d38:	4770      	bx	lr

00004d3a <_ZN6SERCOM36enableDataRegisterEmptyInterruptUARTEv>:

void SERCOM::enableDataRegisterEmptyInterruptUART()
{
  sercom->USART.INTENSET.reg |= SERCOM_USART_INTENSET_DRE;
    4d3a:	6803      	ldr	r3, [r0, #0]
    4d3c:	2101      	movs	r1, #1
    4d3e:	7d9a      	ldrb	r2, [r3, #22]
    4d40:	430a      	orrs	r2, r1
    4d42:	759a      	strb	r2, [r3, #22]
}
    4d44:	4770      	bx	lr

00004d46 <_ZN6SERCOM37disableDataRegisterEmptyInterruptUARTEv>:

void SERCOM::disableDataRegisterEmptyInterruptUART()
{
  sercom->USART.INTENCLR.reg = SERCOM_USART_INTENCLR_DRE;
    4d46:	6803      	ldr	r3, [r0, #0]
    4d48:	2201      	movs	r2, #1
    4d4a:	751a      	strb	r2, [r3, #20]
}
    4d4c:	4770      	bx	lr
	...

00004d50 <_ZN6SERCOM12initSPIClockE18SercomSpiClockModem>:


}

void SERCOM::initSPIClock(SercomSpiClockMode clockMode, uint32_t baudrate)
{
    4d50:	b570      	push	{r4, r5, r6, lr}
  else
    cpol = 1;

  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg |=	( cpha << SERCOM_SPI_CTRLA_CPHA_Pos ) |
                            ( cpol << SERCOM_SPI_CTRLA_CPOL_Pos );
    4d52:	6803      	ldr	r3, [r0, #0]
{
  //Extract data from clockMode
  int cpha, cpol;

  if((clockMode & (0x1ul)) == 0 )
    cpha = 0;
    4d54:	2601      	movs	r6, #1
  else
    cpha = 1;

  if((clockMode & (0x2ul)) == 0)
    4d56:	078d      	lsls	r5, r1, #30
    4d58:	0fed      	lsrs	r5, r5, #31
{
  //Extract data from clockMode
  int cpha, cpol;

  if((clockMode & (0x1ul)) == 0 )
    cpha = 0;
    4d5a:	4031      	ands	r1, r6
  else
    cpol = 1;

  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg |=	( cpha << SERCOM_SPI_CTRLA_CPHA_Pos ) |
                            ( cpol << SERCOM_SPI_CTRLA_CPOL_Pos );
    4d5c:	681c      	ldr	r4, [r3, #0]
    4d5e:	076d      	lsls	r5, r5, #29
    cpol = 0;
  else
    cpol = 1;

  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg |=	( cpha << SERCOM_SPI_CTRLA_CPHA_Pos ) |
    4d60:	0709      	lsls	r1, r1, #28
    4d62:	4329      	orrs	r1, r5
                            ( cpol << SERCOM_SPI_CTRLA_CPOL_Pos );
    4d64:	4321      	orrs	r1, r4
    4d66:	6019      	str	r1, [r3, #0]

  //Synchronous arithmetic
  sercom->SPI.BAUD.reg = calculateBaudrateSynchronous(baudrate);
    4d68:	6804      	ldr	r4, [r0, #0]
//	return sercom->SPI.INTFLAG.bit.RXC;
//}

uint8_t SERCOM::calculateBaudrateSynchronous(uint32_t baudrate)
{
  return SERCOM_FREQ_REF / (2 * baudrate) - 1;
    4d6a:	0051      	lsls	r1, r2, #1
    4d6c:	4803      	ldr	r0, [pc, #12]	; (4d7c <_ZN6SERCOM12initSPIClockE18SercomSpiClockModem+0x2c>)
    4d6e:	f001 fb8b 	bl	6488 <__aeabi_uidiv>
    4d72:	3801      	subs	r0, #1
    4d74:	b2c0      	uxtb	r0, r0
  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg |=	( cpha << SERCOM_SPI_CTRLA_CPHA_Pos ) |
                            ( cpol << SERCOM_SPI_CTRLA_CPOL_Pos );

  //Synchronous arithmetic
  sercom->SPI.BAUD.reg = calculateBaudrateSynchronous(baudrate);
    4d76:	7320      	strb	r0, [r4, #12]
}
    4d78:	bd70      	pop	{r4, r5, r6, pc}
    4d7a:	46c0      	nop			; (mov r8, r8)
    4d7c:	02dc6c00 	.word	0x02dc6c00

00004d80 <_ZN6SERCOM8resetSPIEv>:

void SERCOM::resetSPI()
{
  //Setting the Software Reset bit to 1
  sercom->SPI.CTRLA.bit.SWRST = 1;
    4d80:	6803      	ldr	r3, [r0, #0]
    4d82:	2101      	movs	r1, #1
    4d84:	681a      	ldr	r2, [r3, #0]
    4d86:	430a      	orrs	r2, r1
    4d88:	601a      	str	r2, [r3, #0]

  //Wait both bits Software Reset from CTRLA and SYNCBUSY are equal to 0
  while(sercom->SPI.CTRLA.bit.SWRST || sercom->SPI.SYNCBUSY.bit.SWRST);
    4d8a:	6802      	ldr	r2, [r0, #0]
    4d8c:	6811      	ldr	r1, [r2, #0]
    4d8e:	2301      	movs	r3, #1
    4d90:	4219      	tst	r1, r3
    4d92:	d1fb      	bne.n	4d8c <_ZN6SERCOM8resetSPIEv+0xc>
    4d94:	69d1      	ldr	r1, [r2, #28]
    4d96:	4219      	tst	r1, r3
    4d98:	d1f8      	bne.n	4d8c <_ZN6SERCOM8resetSPIEv+0xc>
}
    4d9a:	4770      	bx	lr

00004d9c <_ZN6SERCOM9enableSPIEv>:

void SERCOM::enableSPI()
{
  //Setting the enable bit to 1
  sercom->SPI.CTRLA.bit.ENABLE = 1;
    4d9c:	6803      	ldr	r3, [r0, #0]
    4d9e:	2102      	movs	r1, #2
    4da0:	681a      	ldr	r2, [r3, #0]
    4da2:	430a      	orrs	r2, r1
    4da4:	601a      	str	r2, [r3, #0]

  while(sercom->SPI.SYNCBUSY.bit.ENABLE)
    4da6:	6802      	ldr	r2, [r0, #0]
    4da8:	69d3      	ldr	r3, [r2, #28]
    4daa:	0799      	lsls	r1, r3, #30
    4dac:	d4fc      	bmi.n	4da8 <_ZN6SERCOM9enableSPIEv+0xc>
  {
    //Waiting then enable bit from SYNCBUSY is equal to 0;
  }
}
    4dae:	4770      	bx	lr

00004db0 <_ZN6SERCOM10disableSPIEv>:

void SERCOM::disableSPI()
{
  while(sercom->SPI.SYNCBUSY.bit.ENABLE)
    4db0:	6803      	ldr	r3, [r0, #0]
    4db2:	69da      	ldr	r2, [r3, #28]
    4db4:	0791      	lsls	r1, r2, #30
    4db6:	d4fc      	bmi.n	4db2 <_ZN6SERCOM10disableSPIEv+0x2>
  {
    //Waiting then enable bit from SYNCBUSY is equal to 0;
  }

  //Setting the enable bit to 0
  sercom->SPI.CTRLA.bit.ENABLE = 0;
    4db8:	681a      	ldr	r2, [r3, #0]
    4dba:	2102      	movs	r1, #2
    4dbc:	438a      	bics	r2, r1
    4dbe:	601a      	str	r2, [r3, #0]
}
    4dc0:	4770      	bx	lr

00004dc2 <_ZN6SERCOM15transferDataSPIEh>:
  enableSPI();
}

uint8_t SERCOM::transferDataSPI(uint8_t data)
{
  sercom->SPI.DATA.bit.DATA = data; // Writing data into Data register
    4dc2:	6803      	ldr	r3, [r0, #0]
    4dc4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    4dc6:	0a52      	lsrs	r2, r2, #9
    4dc8:	0252      	lsls	r2, r2, #9
    4dca:	4311      	orrs	r1, r2
    4dcc:	6299      	str	r1, [r3, #40]	; 0x28

  while( sercom->SPI.INTFLAG.bit.RXC == 0 )
    4dce:	6803      	ldr	r3, [r0, #0]
    4dd0:	7e1a      	ldrb	r2, [r3, #24]
    4dd2:	0751      	lsls	r1, r2, #29
    4dd4:	d5fc      	bpl.n	4dd0 <_ZN6SERCOM15transferDataSPIEh+0xe>
  {
    // Waiting Complete Reception
  }

  return sercom->SPI.DATA.bit.DATA;  // Reading data
    4dd6:	6a98      	ldr	r0, [r3, #40]	; 0x28
    4dd8:	b2c0      	uxtb	r0, r0
}
    4dda:	4770      	bx	lr

00004ddc <_ZN6SERCOM13initClockNVICEv>:
void SERCOM::initClockNVIC( void )
{
  uint8_t clockId = 0;
  IRQn_Type IdNvic=PendSV_IRQn ; // Dummy init to intercept potential error later

  if(sercom == SERCOM0)
    4ddc:	6803      	ldr	r3, [r0, #0]
    4dde:	4a22      	ldr	r2, [pc, #136]	; (4e68 <_ZN6SERCOM13initClockNVICEv+0x8c>)
  }
}


void SERCOM::initClockNVIC( void )
{
    4de0:	b530      	push	{r4, r5, lr}
  uint8_t clockId = 0;
  IRQn_Type IdNvic=PendSV_IRQn ; // Dummy init to intercept potential error later

  if(sercom == SERCOM0)
    4de2:	4293      	cmp	r3, r2
    4de4:	d011      	beq.n	4e0a <_ZN6SERCOM13initClockNVICEv+0x2e>
  {
    clockId = GCM_SERCOM0_CORE;
    IdNvic = SERCOM0_IRQn;
  }
  else if(sercom == SERCOM1)
    4de6:	4a21      	ldr	r2, [pc, #132]	; (4e6c <_ZN6SERCOM13initClockNVICEv+0x90>)
    4de8:	4293      	cmp	r3, r2
    4dea:	d011      	beq.n	4e10 <_ZN6SERCOM13initClockNVICEv+0x34>
  {
    clockId = GCM_SERCOM1_CORE;
    IdNvic = SERCOM1_IRQn;
  }
  else if(sercom == SERCOM2)
    4dec:	4a20      	ldr	r2, [pc, #128]	; (4e70 <_ZN6SERCOM13initClockNVICEv+0x94>)
    4dee:	4293      	cmp	r3, r2
    4df0:	d011      	beq.n	4e16 <_ZN6SERCOM13initClockNVICEv+0x3a>
  {
    clockId = GCM_SERCOM2_CORE;
    IdNvic = SERCOM2_IRQn;
  }
  else if(sercom == SERCOM3)
    4df2:	4a20      	ldr	r2, [pc, #128]	; (4e74 <_ZN6SERCOM13initClockNVICEv+0x98>)
    4df4:	4293      	cmp	r3, r2
    4df6:	d011      	beq.n	4e1c <_ZN6SERCOM13initClockNVICEv+0x40>
  {
    clockId = GCM_SERCOM3_CORE;
    IdNvic = SERCOM3_IRQn;
  }
  else if(sercom == SERCOM4)
    4df8:	4a1f      	ldr	r2, [pc, #124]	; (4e78 <_ZN6SERCOM13initClockNVICEv+0x9c>)
    4dfa:	4293      	cmp	r3, r2
    4dfc:	d011      	beq.n	4e22 <_ZN6SERCOM13initClockNVICEv+0x46>
  {
    clockId = GCM_SERCOM4_CORE;
    IdNvic = SERCOM4_IRQn;
  }
  else if(sercom == SERCOM5)
    4dfe:	4a1f      	ldr	r2, [pc, #124]	; (4e7c <_ZN6SERCOM13initClockNVICEv+0xa0>)
    4e00:	4293      	cmp	r3, r2
    4e02:	d130      	bne.n	4e66 <_ZN6SERCOM13initClockNVICEv+0x8a>
  {
    clockId = GCM_SERCOM5_CORE;
    IdNvic = SERCOM5_IRQn;
    4e04:	230e      	movs	r3, #14
    clockId = GCM_SERCOM4_CORE;
    IdNvic = SERCOM4_IRQn;
  }
  else if(sercom == SERCOM5)
  {
    clockId = GCM_SERCOM5_CORE;
    4e06:	2219      	movs	r2, #25
    4e08:	e00d      	b.n	4e26 <_ZN6SERCOM13initClockNVICEv+0x4a>
  IRQn_Type IdNvic=PendSV_IRQn ; // Dummy init to intercept potential error later

  if(sercom == SERCOM0)
  {
    clockId = GCM_SERCOM0_CORE;
    IdNvic = SERCOM0_IRQn;
    4e0a:	2309      	movs	r3, #9
  uint8_t clockId = 0;
  IRQn_Type IdNvic=PendSV_IRQn ; // Dummy init to intercept potential error later

  if(sercom == SERCOM0)
  {
    clockId = GCM_SERCOM0_CORE;
    4e0c:	2214      	movs	r2, #20
    4e0e:	e00a      	b.n	4e26 <_ZN6SERCOM13initClockNVICEv+0x4a>
    IdNvic = SERCOM0_IRQn;
  }
  else if(sercom == SERCOM1)
  {
    clockId = GCM_SERCOM1_CORE;
    IdNvic = SERCOM1_IRQn;
    4e10:	230a      	movs	r3, #10
    clockId = GCM_SERCOM0_CORE;
    IdNvic = SERCOM0_IRQn;
  }
  else if(sercom == SERCOM1)
  {
    clockId = GCM_SERCOM1_CORE;
    4e12:	2215      	movs	r2, #21
    4e14:	e007      	b.n	4e26 <_ZN6SERCOM13initClockNVICEv+0x4a>
    IdNvic = SERCOM1_IRQn;
  }
  else if(sercom == SERCOM2)
  {
    clockId = GCM_SERCOM2_CORE;
    IdNvic = SERCOM2_IRQn;
    4e16:	230b      	movs	r3, #11
    clockId = GCM_SERCOM1_CORE;
    IdNvic = SERCOM1_IRQn;
  }
  else if(sercom == SERCOM2)
  {
    clockId = GCM_SERCOM2_CORE;
    4e18:	2216      	movs	r2, #22
    4e1a:	e004      	b.n	4e26 <_ZN6SERCOM13initClockNVICEv+0x4a>
    IdNvic = SERCOM2_IRQn;
  }
  else if(sercom == SERCOM3)
  {
    clockId = GCM_SERCOM3_CORE;
    IdNvic = SERCOM3_IRQn;
    4e1c:	230c      	movs	r3, #12
    clockId = GCM_SERCOM2_CORE;
    IdNvic = SERCOM2_IRQn;
  }
  else if(sercom == SERCOM3)
  {
    clockId = GCM_SERCOM3_CORE;
    4e1e:	2217      	movs	r2, #23
    4e20:	e001      	b.n	4e26 <_ZN6SERCOM13initClockNVICEv+0x4a>
    IdNvic = SERCOM3_IRQn;
  }
  else if(sercom == SERCOM4)
  {
    clockId = GCM_SERCOM4_CORE;
    IdNvic = SERCOM4_IRQn;
    4e22:	230d      	movs	r3, #13
    clockId = GCM_SERCOM3_CORE;
    IdNvic = SERCOM3_IRQn;
  }
  else if(sercom == SERCOM4)
  {
    clockId = GCM_SERCOM4_CORE;
    4e24:	2218      	movs	r2, #24
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    4e26:	b2dc      	uxtb	r4, r3
    4e28:	4915      	ldr	r1, [pc, #84]	; (4e80 <_ZN6SERCOM13initClockNVICEv+0xa4>)
    4e2a:	2001      	movs	r0, #1
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    4e2c:	089b      	lsrs	r3, r3, #2
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    4e2e:	40a0      	lsls	r0, r4
    4e30:	009b      	lsls	r3, r3, #2
    4e32:	6008      	str	r0, [r1, #0]
    4e34:	185b      	adds	r3, r3, r1
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    4e36:	2003      	movs	r0, #3
    4e38:	21c0      	movs	r1, #192	; 0xc0
    4e3a:	0089      	lsls	r1, r1, #2
    4e3c:	4004      	ands	r4, r0
    4e3e:	585d      	ldr	r5, [r3, r1]
    4e40:	00e0      	lsls	r0, r4, #3
    4e42:	24ff      	movs	r4, #255	; 0xff
    4e44:	4084      	lsls	r4, r0
    4e46:	43a5      	bics	r5, r4
    4e48:	1c2c      	adds	r4, r5, #0
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
    4e4a:	25c0      	movs	r5, #192	; 0xc0
    4e4c:	4085      	lsls	r5, r0
    4e4e:	1c28      	adds	r0, r5, #0
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    4e50:	4320      	orrs	r0, r4
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
    4e52:	5058      	str	r0, [r3, r1]
  NVIC_SetPriority (IdNvic, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority */

  //Setting clock
  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID( clockId ) | // Generic Clock 0 (SERCOMx)
                      GCLK_CLKCTRL_GEN_GCLK0 | // Generic Clock Generator 0 is source
                      GCLK_CLKCTRL_CLKEN ;
    4e54:	2380      	movs	r3, #128	; 0x80
    4e56:	01db      	lsls	r3, r3, #7
    4e58:	431a      	orrs	r2, r3
    4e5a:	4b0a      	ldr	r3, [pc, #40]	; (4e84 <_ZN6SERCOM13initClockNVICEv+0xa8>)
    4e5c:	805a      	strh	r2, [r3, #2]

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
    4e5e:	785a      	ldrb	r2, [r3, #1]
    4e60:	b252      	sxtb	r2, r2
    4e62:	2a00      	cmp	r2, #0
    4e64:	dbfb      	blt.n	4e5e <_ZN6SERCOM13initClockNVICEv+0x82>
  {
    /* Wait for synchronization */
  }
}
    4e66:	bd30      	pop	{r4, r5, pc}
    4e68:	42000800 	.word	0x42000800
    4e6c:	42000c00 	.word	0x42000c00
    4e70:	42001000 	.word	0x42001000
    4e74:	42001400 	.word	0x42001400
    4e78:	42001800 	.word	0x42001800
    4e7c:	42001c00 	.word	0x42001c00
    4e80:	e000e100 	.word	0xe000e100
    4e84:	40000c00 	.word	0x40000c00

00004e88 <_ZN6SERCOM8initUARTE14SercomUartMode20SercomUartSampleRatem>:
/* 	=========================
 *	===== Sercom UART
 *	=========================
*/
void SERCOM::initUART(SercomUartMode mode, SercomUartSampleRate sampleRate, uint32_t baudrate)
{
    4e88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4e8a:	1c04      	adds	r4, r0, #0
    4e8c:	1c15      	adds	r5, r2, #0
    4e8e:	1c0e      	adds	r6, r1, #0
    4e90:	1c1f      	adds	r7, r3, #0
  initClockNVIC();
    4e92:	f7ff ffa3 	bl	4ddc <_ZN6SERCOM13initClockNVICEv>
  resetUART();
    4e96:	1c20      	adds	r0, r4, #0
    4e98:	f7ff ff0b 	bl	4cb2 <_ZN6SERCOM9resetUARTEv>

  //Setting the CTRLA register
  sercom->USART.CTRLA.reg =	SERCOM_USART_CTRLA_MODE(mode) |
    4e9c:	00b1      	lsls	r1, r6, #2
    4e9e:	221c      	movs	r2, #28
    4ea0:	400a      	ands	r2, r1
                SERCOM_USART_CTRLA_SAMPR(sampleRate);
    4ea2:	0769      	lsls	r1, r5, #29
    4ea4:	6823      	ldr	r3, [r4, #0]
    4ea6:	0c09      	lsrs	r1, r1, #16
{
  initClockNVIC();
  resetUART();

  //Setting the CTRLA register
  sercom->USART.CTRLA.reg =	SERCOM_USART_CTRLA_MODE(mode) |
    4ea8:	430a      	orrs	r2, r1
                SERCOM_USART_CTRLA_SAMPR(sampleRate);
    4eaa:	601a      	str	r2, [r3, #0]

  //Setting the Interrupt register
  sercom->USART.INTENSET.reg =	SERCOM_USART_INTENSET_RXC |  //Received complete
                                SERCOM_USART_INTENSET_ERROR; //All others errors
    4eac:	6822      	ldr	r2, [r4, #0]
    4eae:	2384      	movs	r3, #132	; 0x84
    4eb0:	7593      	strb	r3, [r2, #22]

  if ( mode == UART_INT_CLOCK )
    4eb2:	2e01      	cmp	r6, #1
    4eb4:	d11a      	bne.n	4eec <_ZN6SERCOM8initUARTE14SercomUartMode20SercomUartSampleRatem+0x64>
    uint16_t sampleRateValue;

    if (sampleRate == SAMPLE_RATE_x16) {
      sampleRateValue = 16;
    } else {
      sampleRateValue = 8;
    4eb6:	2108      	movs	r1, #8

  if ( mode == UART_INT_CLOCK )
  {
    uint16_t sampleRateValue;

    if (sampleRate == SAMPLE_RATE_x16) {
    4eb8:	2d01      	cmp	r5, #1
    4eba:	d100      	bne.n	4ebe <_ZN6SERCOM8initUARTE14SercomUartMode20SercomUartSampleRatem+0x36>
      sampleRateValue = 16;
    4ebc:	2110      	movs	r1, #16
    }

    // Asynchronous fractional mode (Table 24-2 in datasheet)
    //   BAUD = fref / (sampleRateValue * fbaud)
    // (multiply by 8, to calculate fractional piece)
    uint32_t baudTimes8 = (SystemCoreClock * 8) / (sampleRateValue * baudrate);
    4ebe:	4b0c      	ldr	r3, [pc, #48]	; (4ef0 <_ZN6SERCOM8initUARTE14SercomUartMode20SercomUartSampleRatem+0x68>)
    4ec0:	4379      	muls	r1, r7
    4ec2:	6818      	ldr	r0, [r3, #0]
    4ec4:	00c0      	lsls	r0, r0, #3
    4ec6:	f001 fadf 	bl	6488 <__aeabi_uidiv>

    sercom->USART.BAUD.FRAC.FP   = (baudTimes8 % 8);
    4eca:	6823      	ldr	r3, [r4, #0]
    4ecc:	2107      	movs	r1, #7
    4ece:	899a      	ldrh	r2, [r3, #12]
    4ed0:	4001      	ands	r1, r0
    4ed2:	04d2      	lsls	r2, r2, #19
    4ed4:	0349      	lsls	r1, r1, #13
    4ed6:	0cd2      	lsrs	r2, r2, #19
    4ed8:	430a      	orrs	r2, r1
    4eda:	819a      	strh	r2, [r3, #12]
    sercom->USART.BAUD.FRAC.BAUD = (baudTimes8 / 8);
    4edc:	6823      	ldr	r3, [r4, #0]
    4ede:	0400      	lsls	r0, r0, #16
    4ee0:	0cc2      	lsrs	r2, r0, #19
    4ee2:	8998      	ldrh	r0, [r3, #12]
    4ee4:	0b40      	lsrs	r0, r0, #13
    4ee6:	0340      	lsls	r0, r0, #13
    4ee8:	4310      	orrs	r0, r2
    4eea:	8198      	strh	r0, [r3, #12]
  }
}
    4eec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4eee:	46c0      	nop			; (mov r8, r8)
    4ef0:	20000004 	.word	0x20000004

00004ef4 <_ZN6SERCOM7initSPIE14SercomSpiTXPad11SercomRXPad17SercomSpiCharSize15SercomDataOrder>:
/*	=========================
 *	===== Sercom SPI
 *	=========================
*/
void SERCOM::initSPI(SercomSpiTXPad mosi, SercomRXPad miso, SercomSpiCharSize charSize, SercomDataOrder dataOrder)
{
    4ef4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    4ef6:	9301      	str	r3, [sp, #4]
    4ef8:	ab08      	add	r3, sp, #32
    4efa:	1c04      	adds	r4, r0, #0
    4efc:	781f      	ldrb	r7, [r3, #0]
    4efe:	1c0d      	adds	r5, r1, #0
    4f00:	1c16      	adds	r6, r2, #0
  resetSPI();
    4f02:	f7ff ff3d 	bl	4d80 <_ZN6SERCOM8resetSPIEv>
  initClockNVIC();
    4f06:	1c20      	adds	r0, r4, #0
    4f08:	f7ff ff68 	bl	4ddc <_ZN6SERCOM13initClockNVICEv>

  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg =	SERCOM_SPI_CTRLA_MODE_SPI_MASTER |
                          SERCOM_SPI_CTRLA_DOPO(mosi) |
                          SERCOM_SPI_CTRLA_DIPO(miso) |
                          dataOrder << SERCOM_SPI_CTRLA_DORD_Pos;
    4f0c:	07bf      	lsls	r7, r7, #30
  initClockNVIC();

  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg =	SERCOM_SPI_CTRLA_MODE_SPI_MASTER |
                          SERCOM_SPI_CTRLA_DOPO(mosi) |
                          SERCOM_SPI_CTRLA_DIPO(miso) |
    4f0e:	220c      	movs	r2, #12
    4f10:	4317      	orrs	r7, r2
    4f12:	22c0      	movs	r2, #192	; 0xc0
    4f14:	0392      	lsls	r2, r2, #14
    4f16:	0536      	lsls	r6, r6, #20
    4f18:	4016      	ands	r6, r2
  resetSPI();
  initClockNVIC();

  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg =	SERCOM_SPI_CTRLA_MODE_SPI_MASTER |
                          SERCOM_SPI_CTRLA_DOPO(mosi) |
    4f1a:	22c0      	movs	r2, #192	; 0xc0
    4f1c:	0292      	lsls	r2, r2, #10
    4f1e:	042d      	lsls	r5, r5, #16
                          SERCOM_SPI_CTRLA_DIPO(miso) |
                          dataOrder << SERCOM_SPI_CTRLA_DORD_Pos;
    4f20:	6823      	ldr	r3, [r4, #0]
  initClockNVIC();

  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg =	SERCOM_SPI_CTRLA_MODE_SPI_MASTER |
                          SERCOM_SPI_CTRLA_DOPO(mosi) |
                          SERCOM_SPI_CTRLA_DIPO(miso) |
    4f22:	433e      	orrs	r6, r7
                          dataOrder << SERCOM_SPI_CTRLA_DORD_Pos;

  //Setting the CTRLB register
  sercom->SPI.CTRLB.reg = SERCOM_SPI_CTRLB_CHSIZE(charSize) |
    4f24:	9901      	ldr	r1, [sp, #4]
  resetSPI();
  initClockNVIC();

  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg =	SERCOM_SPI_CTRLA_MODE_SPI_MASTER |
                          SERCOM_SPI_CTRLA_DOPO(mosi) |
    4f26:	4015      	ands	r5, r2
                          SERCOM_SPI_CTRLA_DIPO(miso) |
    4f28:	4335      	orrs	r5, r6
                          dataOrder << SERCOM_SPI_CTRLA_DORD_Pos;

  //Setting the CTRLB register
  sercom->SPI.CTRLB.reg = SERCOM_SPI_CTRLB_CHSIZE(charSize) |
    4f2a:	2207      	movs	r2, #7

  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg =	SERCOM_SPI_CTRLA_MODE_SPI_MASTER |
                          SERCOM_SPI_CTRLA_DOPO(mosi) |
                          SERCOM_SPI_CTRLA_DIPO(miso) |
                          dataOrder << SERCOM_SPI_CTRLA_DORD_Pos;
    4f2c:	601d      	str	r5, [r3, #0]

  //Setting the CTRLB register
  sercom->SPI.CTRLB.reg = SERCOM_SPI_CTRLB_CHSIZE(charSize) |
    4f2e:	400a      	ands	r2, r1
    4f30:	2180      	movs	r1, #128	; 0x80
                          SERCOM_SPI_CTRLB_RXEN;	//Active the SPI receiver.
    4f32:	6823      	ldr	r3, [r4, #0]
                          SERCOM_SPI_CTRLA_DOPO(mosi) |
                          SERCOM_SPI_CTRLA_DIPO(miso) |
                          dataOrder << SERCOM_SPI_CTRLA_DORD_Pos;

  //Setting the CTRLB register
  sercom->SPI.CTRLB.reg = SERCOM_SPI_CTRLB_CHSIZE(charSize) |
    4f34:	0289      	lsls	r1, r1, #10
    4f36:	430a      	orrs	r2, r1
                          SERCOM_SPI_CTRLB_RXEN;	//Active the SPI receiver.
    4f38:	605a      	str	r2, [r3, #4]


}
    4f3a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

00004f3c <_ZN4UartcvbEv>:
    size_t write(const uint8_t data);
    using Print::write; // pull in write(str) and write(buf, size) from Print

    void IrqHandler();

    operator bool() { return true; }
    4f3c:	2001      	movs	r0, #1
    4f3e:	4770      	bx	lr

00004f40 <_ZN4Uart5beginEm>:
  uc_padRX=_padRX ;
  uc_padTX=_padTX;
}

void Uart::begin(unsigned long baudrate)
{
    4f40:	b508      	push	{r3, lr}
  begin(baudrate, SERIAL_8N1);
    4f42:	6803      	ldr	r3, [r0, #0]
    4f44:	4a01      	ldr	r2, [pc, #4]	; (4f4c <_ZN4Uart5beginEm+0xc>)
    4f46:	6a1b      	ldr	r3, [r3, #32]
    4f48:	4798      	blx	r3
}
    4f4a:	bd08      	pop	{r3, pc}
    4f4c:	00000413 	.word	0x00000413

00004f50 <_ZN4Uart3endEv>:

  sercom->enableUART();
}

void Uart::end()
{
    4f50:	b510      	push	{r4, lr}
    4f52:	1c04      	adds	r4, r0, #0
  sercom->resetUART();
    4f54:	6900      	ldr	r0, [r0, #16]
    4f56:	f7ff feac 	bl	4cb2 <_ZN6SERCOM9resetUARTEv>
  rxBuffer.clear();
    4f5a:	1c20      	adds	r0, r4, #0
    4f5c:	3014      	adds	r0, #20
    4f5e:	f001 f91f 	bl	61a0 <_ZN10RingBuffer5clearEv>
  txBuffer.clear();
    4f62:	1c20      	adds	r0, r4, #0
    4f64:	305c      	adds	r0, #92	; 0x5c
    4f66:	f001 f91b 	bl	61a0 <_ZN10RingBuffer5clearEv>
}
    4f6a:	bd10      	pop	{r4, pc}

00004f6c <_ZN4Uart9availableEv>:
    sercom->clearStatusUART();
  }
}

int Uart::available()
{
    4f6c:	b508      	push	{r3, lr}
  return rxBuffer.available();
    4f6e:	3014      	adds	r0, #20
    4f70:	f001 f928 	bl	61c4 <_ZN10RingBuffer9availableEv>
}
    4f74:	bd08      	pop	{r3, pc}

00004f76 <_ZN4Uart5flushEv>:
  rxBuffer.clear();
  txBuffer.clear();
}

void Uart::flush()
{
    4f76:	b510      	push	{r4, lr}
    4f78:	1c04      	adds	r4, r0, #0
  while(txBuffer.available()); // wait until TX buffer is empty
    4f7a:	1c20      	adds	r0, r4, #0
    4f7c:	305c      	adds	r0, #92	; 0x5c
    4f7e:	f001 f921 	bl	61c4 <_ZN10RingBuffer9availableEv>
    4f82:	2800      	cmp	r0, #0
    4f84:	d1f9      	bne.n	4f7a <_ZN4Uart5flushEv+0x4>

  sercom->flushUART();
    4f86:	6920      	ldr	r0, [r4, #16]
    4f88:	f7ff feab 	bl	4ce2 <_ZN6SERCOM9flushUARTEv>
}
    4f8c:	bd10      	pop	{r4, pc}

00004f8e <_ZN4Uart4readEv>:
{
  return rxBuffer.peek();
}

int Uart::read()
{
    4f8e:	b508      	push	{r3, lr}
  return rxBuffer.read_char();
    4f90:	3014      	adds	r0, #20
    4f92:	f001 f909 	bl	61a8 <_ZN10RingBuffer9read_charEv>
}
    4f96:	bd08      	pop	{r3, pc}

00004f98 <_ZN4Uart17availableForWriteEv>:
{
  return rxBuffer.available();
}

int Uart::availableForWrite()
{
    4f98:	b508      	push	{r3, lr}
  return txBuffer.availableForStore();
    4f9a:	305c      	adds	r0, #92	; 0x5c
    4f9c:	f001 f918 	bl	61d0 <_ZN10RingBuffer17availableForStoreEv>
}
    4fa0:	bd08      	pop	{r3, pc}

00004fa2 <_ZN4Uart4peekEv>:

int Uart::peek()
{
    4fa2:	b508      	push	{r3, lr}
  return rxBuffer.peek();
    4fa4:	3014      	adds	r0, #20
    4fa6:	f001 f91d 	bl	61e4 <_ZN10RingBuffer4peekEv>
}
    4faa:	bd08      	pop	{r3, pc}

00004fac <_ZN4Uart5writeEh>:
{
  return rxBuffer.read_char();
}

size_t Uart::write(const uint8_t data)
{
    4fac:	b570      	push	{r4, r5, r6, lr}
    4fae:	1c04      	adds	r4, r0, #0
  if (sercom->isDataRegisterEmptyUART() && txBuffer.available() == 0) {
    4fb0:	6900      	ldr	r0, [r0, #16]
{
  return rxBuffer.read_char();
}

size_t Uart::write(const uint8_t data)
{
    4fb2:	1c0e      	adds	r6, r1, #0
  if (sercom->isDataRegisterEmptyUART() && txBuffer.available() == 0) {
    4fb4:	f7ff feb1 	bl	4d1a <_ZN6SERCOM23isDataRegisterEmptyUARTEv>
    4fb8:	1c25      	adds	r5, r4, #0
    4fba:	355c      	adds	r5, #92	; 0x5c
    4fbc:	2800      	cmp	r0, #0
    4fbe:	d004      	beq.n	4fca <_ZN4Uart5writeEh+0x1e>
    4fc0:	1c28      	adds	r0, r5, #0
    4fc2:	f001 f8ff 	bl	61c4 <_ZN10RingBuffer9availableEv>
    4fc6:	2800      	cmp	r0, #0
    4fc8:	d00c      	beq.n	4fe4 <_ZN4Uart5writeEh+0x38>
    sercom->writeDataUART(data);
  } else {
    while(txBuffer.isFull()); // spin lock until a spot opens up in the buffer
    4fca:	1c28      	adds	r0, r5, #0
    4fcc:	f001 f913 	bl	61f6 <_ZN10RingBuffer6isFullEv>
    4fd0:	2800      	cmp	r0, #0
    4fd2:	d1fa      	bne.n	4fca <_ZN4Uart5writeEh+0x1e>

    txBuffer.store_char(data);
    4fd4:	1c28      	adds	r0, r5, #0
    4fd6:	1c31      	adds	r1, r6, #0
    4fd8:	f001 f8d7 	bl	618a <_ZN10RingBuffer10store_charEh>

    sercom->enableDataRegisterEmptyInterruptUART();
    4fdc:	6920      	ldr	r0, [r4, #16]
    4fde:	f7ff feac 	bl	4d3a <_ZN6SERCOM36enableDataRegisterEmptyInterruptUARTEv>
    4fe2:	e003      	b.n	4fec <_ZN4Uart5writeEh+0x40>
}

size_t Uart::write(const uint8_t data)
{
  if (sercom->isDataRegisterEmptyUART() && txBuffer.available() == 0) {
    sercom->writeDataUART(data);
    4fe4:	6920      	ldr	r0, [r4, #16]
    4fe6:	1c31      	adds	r1, r6, #0
    4fe8:	f7ff fea0 	bl	4d2c <_ZN6SERCOM13writeDataUARTEh>

    sercom->enableDataRegisterEmptyInterruptUART();
  }

  return 1;
}
    4fec:	2001      	movs	r0, #1
    4fee:	bd70      	pop	{r4, r5, r6, pc}

00004ff0 <_ZN4UartC1EP6SERCOMhh11SercomRXPad15SercomUartTXPad>:

#include "Uart.h"
#include "Arduino.h"
#include "wiring_private.h"

Uart::Uart(SERCOM *_s, uint8_t _pinRX, uint8_t _pinTX, SercomRXPad _padRX, SercomUartTXPad _padTX)
    4ff0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    4ff2:	1c1d      	adds	r5, r3, #0
    4ff4:	ab08      	add	r3, sp, #32
    4ff6:	781b      	ldrb	r3, [r3, #0]
    4ff8:	1c04      	adds	r4, r0, #0
    4ffa:	9300      	str	r3, [sp, #0]
    4ffc:	ab09      	add	r3, sp, #36	; 0x24
    4ffe:	781b      	ldrb	r3, [r3, #0]
    5000:	1c16      	adds	r6, r2, #0
    5002:	9301      	str	r3, [sp, #4]
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    5004:	2300      	movs	r3, #0
    5006:	6043      	str	r3, [r0, #4]
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
    5008:	23fa      	movs	r3, #250	; 0xfa
    500a:	009b      	lsls	r3, r3, #2
    500c:	6083      	str	r3, [r0, #8]
    500e:	4b0b      	ldr	r3, [pc, #44]	; (503c <_ZN4UartC1EP6SERCOMhh11SercomRXPad15SercomUartTXPad+0x4c>)
    5010:	1c0f      	adds	r7, r1, #0
    5012:	3308      	adds	r3, #8
    5014:	6003      	str	r3, [r0, #0]
    5016:	3014      	adds	r0, #20
    5018:	f001 f8ac 	bl	6174 <_ZN10RingBufferC1Ev>
    501c:	1c20      	adds	r0, r4, #0
    501e:	305c      	adds	r0, #92	; 0x5c
    5020:	f001 f8a8 	bl	6174 <_ZN10RingBufferC1Ev>
{
  sercom = _s;
  uc_pinRX = _pinRX;
  uc_pinTX = _pinTX;
  uc_padRX=_padRX ;
    5024:	9a00      	ldr	r2, [sp, #0]
#include "wiring_private.h"

Uart::Uart(SERCOM *_s, uint8_t _pinRX, uint8_t _pinTX, SercomRXPad _padRX, SercomUartTXPad _padTX)
{
  sercom = _s;
  uc_pinRX = _pinRX;
    5026:	1c23      	adds	r3, r4, #0
    5028:	33a4      	adds	r3, #164	; 0xa4
#include "Arduino.h"
#include "wiring_private.h"

Uart::Uart(SERCOM *_s, uint8_t _pinRX, uint8_t _pinTX, SercomRXPad _padRX, SercomUartTXPad _padTX)
{
  sercom = _s;
    502a:	6127      	str	r7, [r4, #16]
  uc_pinRX = _pinRX;
  uc_pinTX = _pinTX;
  uc_padRX=_padRX ;
    502c:	709a      	strb	r2, [r3, #2]
  uc_padTX=_padTX;
    502e:	9a01      	ldr	r2, [sp, #4]
#include "wiring_private.h"

Uart::Uart(SERCOM *_s, uint8_t _pinRX, uint8_t _pinTX, SercomRXPad _padRX, SercomUartTXPad _padTX)
{
  sercom = _s;
  uc_pinRX = _pinRX;
    5030:	701e      	strb	r6, [r3, #0]
  uc_pinTX = _pinTX;
    5032:	705d      	strb	r5, [r3, #1]
  uc_padRX=_padRX ;
  uc_padTX=_padTX;
}
    5034:	1c20      	adds	r0, r4, #0
{
  sercom = _s;
  uc_pinRX = _pinRX;
  uc_pinTX = _pinTX;
  uc_padRX=_padRX ;
  uc_padTX=_padTX;
    5036:	70da      	strb	r2, [r3, #3]
}
    5038:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    503a:	46c0      	nop			; (mov r8, r8)
    503c:	000090e8 	.word	0x000090e8

00005040 <_ZN4Uart10IrqHandlerEv>:

  sercom->flushUART();
}

void Uart::IrqHandler()
{
    5040:	b538      	push	{r3, r4, r5, lr}
    5042:	1c04      	adds	r4, r0, #0
  if (sercom->availableDataUART()) {
    5044:	6900      	ldr	r0, [r0, #16]
    5046:	f7ff fe58 	bl	4cfa <_ZN6SERCOM17availableDataUARTEv>
    504a:	2800      	cmp	r0, #0
    504c:	d007      	beq.n	505e <_ZN4Uart10IrqHandlerEv+0x1e>
    rxBuffer.store_char(sercom->readDataUART());
    504e:	6920      	ldr	r0, [r4, #16]
    5050:	f7ff fe68 	bl	4d24 <_ZN6SERCOM12readDataUARTEv>
    5054:	1c01      	adds	r1, r0, #0
    5056:	1c20      	adds	r0, r4, #0
    5058:	3014      	adds	r0, #20
    505a:	f001 f896 	bl	618a <_ZN10RingBuffer10store_charEh>
  }

  if (sercom->isDataRegisterEmptyUART()) {
    505e:	6920      	ldr	r0, [r4, #16]
    5060:	f7ff fe5b 	bl	4d1a <_ZN6SERCOM23isDataRegisterEmptyUARTEv>
    5064:	2800      	cmp	r0, #0
    5066:	d011      	beq.n	508c <_ZN4Uart10IrqHandlerEv+0x4c>
    if (txBuffer.available()) {
    5068:	1c25      	adds	r5, r4, #0
    506a:	355c      	adds	r5, #92	; 0x5c
    506c:	1c28      	adds	r0, r5, #0
    506e:	f001 f8a9 	bl	61c4 <_ZN10RingBuffer9availableEv>
    5072:	2800      	cmp	r0, #0
    5074:	d007      	beq.n	5086 <_ZN4Uart10IrqHandlerEv+0x46>
      uint8_t data = txBuffer.read_char();
    5076:	1c28      	adds	r0, r5, #0
    5078:	f001 f896 	bl	61a8 <_ZN10RingBuffer9read_charEv>

      sercom->writeDataUART(data);
    507c:	b2c1      	uxtb	r1, r0
    507e:	6920      	ldr	r0, [r4, #16]
    5080:	f7ff fe54 	bl	4d2c <_ZN6SERCOM13writeDataUARTEh>
    5084:	e002      	b.n	508c <_ZN4Uart10IrqHandlerEv+0x4c>
    } else {
      sercom->disableDataRegisterEmptyInterruptUART();
    5086:	6920      	ldr	r0, [r4, #16]
    5088:	f7ff fe5d 	bl	4d46 <_ZN6SERCOM37disableDataRegisterEmptyInterruptUARTEv>
    }
  }

  if (sercom->isUARTError()) {
    508c:	6920      	ldr	r0, [r4, #16]
    508e:	f7ff fe39 	bl	4d04 <_ZN6SERCOM11isUARTErrorEv>
    5092:	2800      	cmp	r0, #0
    5094:	d005      	beq.n	50a2 <_ZN4Uart10IrqHandlerEv+0x62>
    sercom->acknowledgeUARTError();
    5096:	6920      	ldr	r0, [r4, #16]
    5098:	f7ff fe38 	bl	4d0c <_ZN6SERCOM20acknowledgeUARTErrorEv>
    // TODO: if (sercom->isBufferOverflowErrorUART()) ....
    // TODO: if (sercom->isFrameErrorUART()) ....
    // TODO: if (sercom->isParityErrorUART()) ....
    sercom->clearStatusUART();
    509c:	6920      	ldr	r0, [r4, #16]
    509e:	f7ff fe28 	bl	4cf2 <_ZN6SERCOM15clearStatusUARTEv>
  }
}
    50a2:	bd38      	pop	{r3, r4, r5, pc}

000050a4 <_ZN4Uart16extractNbStopBitEt>:
  return 1;
}

SercomNumberStopBit Uart::extractNbStopBit(uint16_t config)
{
  switch(config & HARDSER_STOP_BIT_MASK)
    50a4:	23f0      	movs	r3, #240	; 0xf0
    50a6:	1c08      	adds	r0, r1, #0
    50a8:	4018      	ands	r0, r3
  {
    case HARDSER_STOP_BIT_1:
    default:
      return SERCOM_STOP_BIT_1;
    50aa:	3830      	subs	r0, #48	; 0x30
    50ac:	4243      	negs	r3, r0
    50ae:	4158      	adcs	r0, r3

    case HARDSER_STOP_BIT_2:
      return SERCOM_STOP_BITS_2;
  }
}
    50b0:	4770      	bx	lr

000050b2 <_ZN4Uart15extractCharSizeEt>:

SercomUartCharSize Uart::extractCharSize(uint16_t config)
{
  switch(config & HARDSER_DATA_MASK)
    50b2:	23f0      	movs	r3, #240	; 0xf0
    50b4:	011b      	lsls	r3, r3, #4
    50b6:	4019      	ands	r1, r3
    50b8:	2380      	movs	r3, #128	; 0x80
    50ba:	009b      	lsls	r3, r3, #2
    50bc:	4299      	cmp	r1, r3
    50be:	d00c      	beq.n	50da <_ZN4Uart15extractCharSizeEt+0x28>
    50c0:	23c0      	movs	r3, #192	; 0xc0
    50c2:	009b      	lsls	r3, r3, #2
    50c4:	4299      	cmp	r1, r3
    50c6:	d006      	beq.n	50d6 <_ZN4Uart15extractCharSizeEt+0x24>
    50c8:	2380      	movs	r3, #128	; 0x80
    50ca:	005b      	lsls	r3, r3, #1
  {
    case HARDSER_DATA_5:
      return UART_CHAR_SIZE_5_BITS;
    50cc:	2005      	movs	r0, #5
  }
}

SercomUartCharSize Uart::extractCharSize(uint16_t config)
{
  switch(config & HARDSER_DATA_MASK)
    50ce:	4299      	cmp	r1, r3
    50d0:	d004      	beq.n	50dc <_ZN4Uart15extractCharSizeEt+0x2a>
    case HARDSER_DATA_7:
      return UART_CHAR_SIZE_7_BITS;

    case HARDSER_DATA_8:
    default:
      return UART_CHAR_SIZE_8_BITS;
    50d2:	2000      	movs	r0, #0
    50d4:	e002      	b.n	50dc <_ZN4Uart15extractCharSizeEt+0x2a>

    case HARDSER_DATA_6:
      return UART_CHAR_SIZE_6_BITS;

    case HARDSER_DATA_7:
      return UART_CHAR_SIZE_7_BITS;
    50d6:	2007      	movs	r0, #7
    50d8:	e000      	b.n	50dc <_ZN4Uart15extractCharSizeEt+0x2a>
  {
    case HARDSER_DATA_5:
      return UART_CHAR_SIZE_5_BITS;

    case HARDSER_DATA_6:
      return UART_CHAR_SIZE_6_BITS;
    50da:	2006      	movs	r0, #6
    case HARDSER_DATA_8:
    default:
      return UART_CHAR_SIZE_8_BITS;

  }
}
    50dc:	4770      	bx	lr

000050de <_ZN4Uart13extractParityEt>:

SercomParityMode Uart::extractParity(uint16_t config)
{
  switch(config & HARDSER_PARITY_MASK)
    50de:	230f      	movs	r3, #15
    50e0:	4019      	ands	r1, r3
    50e2:	2901      	cmp	r1, #1
    50e4:	d005      	beq.n	50f2 <_ZN4Uart13extractParityEt+0x14>
  {
    case HARDSER_PARITY_NONE:
    default:
      return SERCOM_NO_PARITY;
    50e6:	3902      	subs	r1, #2
    50e8:	424b      	negs	r3, r1
    50ea:	414b      	adcs	r3, r1
    50ec:	2002      	movs	r0, #2
    50ee:	1ac0      	subs	r0, r0, r3
    50f0:	e000      	b.n	50f4 <_ZN4Uart13extractParityEt+0x16>

    case HARDSER_PARITY_EVEN:
      return SERCOM_EVEN_PARITY;
    50f2:	2000      	movs	r0, #0

    case HARDSER_PARITY_ODD:
      return SERCOM_ODD_PARITY;
  }
}
    50f4:	4770      	bx	lr
	...

000050f8 <_ZN4Uart5beginEmt>:
{
  begin(baudrate, SERIAL_8N1);
}

void Uart::begin(unsigned long baudrate, uint16_t config)
{
    50f8:	b5f0      	push	{r4, r5, r6, r7, lr}
  pinPeripheral(uc_pinRX, g_APinDescription[uc_pinRX].ulPinType);
    50fa:	1c03      	adds	r3, r0, #0
{
  begin(baudrate, SERIAL_8N1);
}

void Uart::begin(unsigned long baudrate, uint16_t config)
{
    50fc:	b085      	sub	sp, #20
    50fe:	9103      	str	r1, [sp, #12]
  pinPeripheral(uc_pinRX, g_APinDescription[uc_pinRX].ulPinType);
    5100:	33a4      	adds	r3, #164	; 0xa4
{
  begin(baudrate, SERIAL_8N1);
}

void Uart::begin(unsigned long baudrate, uint16_t config)
{
    5102:	1c04      	adds	r4, r0, #0
  pinPeripheral(uc_pinRX, g_APinDescription[uc_pinRX].ulPinType);
    5104:	2718      	movs	r7, #24
    5106:	7818      	ldrb	r0, [r3, #0]
    5108:	1c3b      	adds	r3, r7, #0
    510a:	4343      	muls	r3, r0
    510c:	4e1b      	ldr	r6, [pc, #108]	; (517c <_ZN4Uart5beginEmt+0x84>)
    510e:	2108      	movs	r1, #8
    5110:	18f3      	adds	r3, r6, r3
    5112:	5659      	ldrsb	r1, [r3, r1]
{
  begin(baudrate, SERIAL_8N1);
}

void Uart::begin(unsigned long baudrate, uint16_t config)
{
    5114:	1c15      	adds	r5, r2, #0
  pinPeripheral(uc_pinRX, g_APinDescription[uc_pinRX].ulPinType);
    5116:	f7ff fb8f 	bl	4838 <pinPeripheral>
  pinPeripheral(uc_pinTX, g_APinDescription[uc_pinTX].ulPinType);
    511a:	1c23      	adds	r3, r4, #0
    511c:	33a5      	adds	r3, #165	; 0xa5
    511e:	7818      	ldrb	r0, [r3, #0]
    5120:	2108      	movs	r1, #8
    5122:	4347      	muls	r7, r0
    5124:	19f6      	adds	r6, r6, r7
    5126:	5671      	ldrsb	r1, [r6, r1]
    5128:	f7ff fb86 	bl	4838 <pinPeripheral>

  sercom->initUART(UART_INT_CLOCK, SAMPLE_RATE_x16, baudrate);
    512c:	2101      	movs	r1, #1
    512e:	1c0a      	adds	r2, r1, #0
    5130:	9b03      	ldr	r3, [sp, #12]
    5132:	6920      	ldr	r0, [r4, #16]
    5134:	f7ff fea8 	bl	4e88 <_ZN6SERCOM8initUARTE14SercomUartMode20SercomUartSampleRatem>
  sercom->initFrame(extractCharSize(config), LSB_FIRST, extractParity(config), extractNbStopBit(config));
    5138:	1c29      	adds	r1, r5, #0
    513a:	1c20      	adds	r0, r4, #0
    513c:	f7ff ffb9 	bl	50b2 <_ZN4Uart15extractCharSizeEt>
    5140:	1c29      	adds	r1, r5, #0
    5142:	1c07      	adds	r7, r0, #0
    5144:	1c20      	adds	r0, r4, #0
    5146:	f7ff ffca 	bl	50de <_ZN4Uart13extractParityEt>
    514a:	1c29      	adds	r1, r5, #0
    514c:	1c06      	adds	r6, r0, #0
    514e:	1c20      	adds	r0, r4, #0
    5150:	f7ff ffa8 	bl	50a4 <_ZN4Uart16extractNbStopBitEt>
    5154:	1c39      	adds	r1, r7, #0
    5156:	9000      	str	r0, [sp, #0]
    5158:	1c33      	adds	r3, r6, #0
    515a:	6920      	ldr	r0, [r4, #16]
    515c:	2201      	movs	r2, #1
    515e:	f7ff fd79 	bl	4c54 <_ZN6SERCOM9initFrameE18SercomUartCharSize15SercomDataOrder16SercomParityMode19SercomNumberStopBit>
  sercom->initPads(uc_padTX, uc_padRX);
    5162:	1c23      	adds	r3, r4, #0
    5164:	33a7      	adds	r3, #167	; 0xa7
    5166:	7819      	ldrb	r1, [r3, #0]
    5168:	3b01      	subs	r3, #1
    516a:	781a      	ldrb	r2, [r3, #0]
    516c:	6920      	ldr	r0, [r4, #16]
    516e:	f7ff fd8d 	bl	4c8c <_ZN6SERCOM8initPadsE15SercomUartTXPad11SercomRXPad>

  sercom->enableUART();
    5172:	6920      	ldr	r0, [r4, #16]
    5174:	f7ff fdab 	bl	4cce <_ZN6SERCOM10enableUARTEv>
}
    5178:	b005      	add	sp, #20
    517a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    517c:	00008cb8 	.word	0x00008cb8

00005180 <__cxa_pure_virtual>:
#include <stdlib.h>

extern "C" void __cxa_pure_virtual(void) __attribute__ ((__noreturn__));
extern "C" void __cxa_deleted_virtual(void) __attribute__ ((__noreturn__));

void __cxa_pure_virtual(void) {
    5180:	e7fe      	b.n	5180 <__cxa_pure_virtual>

00005182 <_Z11initVariantv>:
#include "Arduino.h"

// Weak empty variant initialization function.
// May be redefined by variant files.
void initVariant() __attribute__((weak));
void initVariant() { }
    5182:	4770      	bx	lr

00005184 <main>:

/*
 * \brief Main entry point of Arduino application
 */
int main( void )
{
    5184:	b510      	push	{r4, lr}
  init();
    5186:	f7ff fa27 	bl	45d8 <init>

  __libc_init_array();
    518a:	f003 f8a5 	bl	82d8 <__libc_init_array>

  initVariant();
    518e:	f7ff fff8 	bl	5182 <_Z11initVariantv>

  delay(1);
    5192:	2001      	movs	r0, #1
    5194:	f7ff f94e 	bl	4434 <delay>
#if defined(USBCON)
  USBDevice.init();
    5198:	4c08      	ldr	r4, [pc, #32]	; (51bc <main+0x38>)
    519a:	1c20      	adds	r0, r4, #0
    519c:	f000 fa34 	bl	5608 <_ZN14USBDeviceClass4initEv>
  USBDevice.attach();
    51a0:	1c20      	adds	r0, r4, #0
    51a2:	f000 faa9 	bl	56f8 <_ZN14USBDeviceClass6attachEv>
#endif

  setup();
    51a6:	f7fd fba9 	bl	28fc <setup>

  for (;;)
  {
    loop();
    51aa:	f7fd f9ed 	bl	2588 <loop>
    if (serialEventRun) serialEventRun();
    51ae:	4b04      	ldr	r3, [pc, #16]	; (51c0 <main+0x3c>)
    51b0:	2b00      	cmp	r3, #0
    51b2:	d0fa      	beq.n	51aa <main+0x26>
    51b4:	e000      	b.n	51b8 <main+0x34>
    51b6:	bf00      	nop
    51b8:	e7f7      	b.n	51aa <main+0x26>
    51ba:	46c0      	nop			; (mov r8, r8)
    51bc:	20000797 	.word	0x20000797
    51c0:	00000000 	.word	0x00000000

000051c4 <_ZL5utox8mPc>:
	packMessages(false);

	return true;
}

static void utox8(uint32_t val, char* s) {
    51c4:	b510      	push	{r4, lr}
    51c6:	2307      	movs	r3, #7
	for (int i = 0; i < 8; i++) {
		int d = val & 0XF;
    51c8:	220f      	movs	r2, #15
    51ca:	4002      	ands	r2, r0
		val = (val >> 4);

		s[7 - i] = d > 9 ? 'A' + d - 10 : '0' + d;
    51cc:	1c14      	adds	r4, r2, #0
}

static void utox8(uint32_t val, char* s) {
	for (int i = 0; i < 8; i++) {
		int d = val & 0XF;
		val = (val >> 4);
    51ce:	0900      	lsrs	r0, r0, #4

		s[7 - i] = d > 9 ? 'A' + d - 10 : '0' + d;
    51d0:	3430      	adds	r4, #48	; 0x30
    51d2:	2a09      	cmp	r2, #9
    51d4:	dd00      	ble.n	51d8 <_ZL5utox8mPc+0x14>
    51d6:	3407      	adds	r4, #7
    51d8:	54cc      	strb	r4, [r1, r3]

	return true;
}

static void utox8(uint32_t val, char* s) {
	for (int i = 0; i < 8; i++) {
    51da:	3b01      	subs	r3, #1
    51dc:	d2f4      	bcs.n	51c8 <_ZL5utox8mPc+0x4>
		int d = val & 0XF;
		val = (val >> 4);

		s[7 - i] = d > 9 ? 'A' + d - 10 : '0' + d;
	}
}
    51de:	bd10      	pop	{r4, pc}

000051e0 <_ZN14USBDeviceClass6initEPEmm.part.4>:
	for (uint8_t i = 1; i < sizeof(EndPoints) && EndPoints[i] != 0; i++) {
		initEP(i, EndPoints[i]);
	}
}

void USBDeviceClass::initEP(uint32_t ep, uint32_t config)
    51e0:	b570      	push	{r4, r5, r6, lr}
    51e2:	b2c2      	uxtb	r2, r0
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
	inline void epBank0SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
    51e4:	4919      	ldr	r1, [pc, #100]	; (524c <_ZN14USBDeviceClass6initEPEmm.part.4+0x6c>)
    51e6:	0153      	lsls	r3, r2, #5
    51e8:	18cb      	adds	r3, r1, r3
    51ea:	689e      	ldr	r6, [r3, #8]
    51ec:	4d18      	ldr	r5, [pc, #96]	; (5250 <_ZN14USBDeviceClass6initEPEmm.part.4+0x70>)
    51ee:	24c0      	movs	r4, #192	; 0xc0
    51f0:	402e      	ands	r6, r5
    51f2:	05a4      	lsls	r4, r4, #22
    51f4:	4326      	orrs	r6, r4
    51f6:	609e      	str	r6, [r3, #8]
	}
	else if (config == USB_ENDPOINT_TYPE_CONTROL)
	{
		// Setup Control OUT
		usbd.epBank0SetSize(ep, 64);
		usbd.epBank0SetAddress(ep, &udd_ep_out_cache_buffer[ep]);
    51f8:	4e16      	ldr	r6, [pc, #88]	; (5254 <_ZN14USBDeviceClass6initEPEmm.part.4+0x74>)
    51fa:	0180      	lsls	r0, r0, #6

	// USB Device Endpoints function mapping
	// -------------------------------------

	// Config
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
    51fc:	6809      	ldr	r1, [r1, #0]
    51fe:	1830      	adds	r0, r6, r0
    5200:	3208      	adds	r2, #8
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
    5202:	6058      	str	r0, [r3, #4]

	// USB Device Endpoints function mapping
	// -------------------------------------

	// Config
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
    5204:	0152      	lsls	r2, r2, #5
    5206:	5c50      	ldrb	r0, [r2, r1]
    5208:	2607      	movs	r6, #7
    520a:	43b0      	bics	r0, r6
    520c:	2601      	movs	r6, #1
    520e:	4330      	orrs	r0, r6
    5210:	5450      	strb	r0, [r2, r1]
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
	inline void epBank0SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
	inline void epBank1SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
    5212:	699e      	ldr	r6, [r3, #24]
    5214:	4035      	ands	r5, r6
    5216:	432c      	orrs	r4, r5
    5218:	619c      	str	r4, [r3, #24]
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
    521a:	4c0f      	ldr	r4, [pc, #60]	; (5258 <_ZN14USBDeviceClass6initEPEmm.part.4+0x78>)
    521c:	615c      	str	r4, [r3, #20]
	// USB Device Endpoints function mapping
	// -------------------------------------

	// Config
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
	inline void epBank1SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = type; }
    521e:	5c50      	ldrb	r0, [r2, r1]
    5220:	2470      	movs	r4, #112	; 0x70
    5222:	43a0      	bics	r0, r4
    5224:	2410      	movs	r4, #16
    5226:	4320      	orrs	r0, r4
    5228:	5450      	strb	r0, [r2, r1]
	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
    522a:	689c      	ldr	r4, [r3, #8]
    522c:	480b      	ldr	r0, [pc, #44]	; (525c <_ZN14USBDeviceClass6initEPEmm.part.4+0x7c>)
	inline void epBank1DisableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENCLR.bit.TRCPT1 = 1; }

	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
    522e:	188a      	adds	r2, r1, r2
	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
    5230:	4020      	ands	r0, r4
    5232:	2480      	movs	r4, #128	; 0x80
    5234:	0364      	lsls	r4, r4, #13
    5236:	4320      	orrs	r0, r4
    5238:	6098      	str	r0, [r3, #8]
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
    523a:	6898      	ldr	r0, [r3, #8]
	inline void epBank1DisableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENCLR.bit.TRCPT1 = 1; }

	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
    523c:	2140      	movs	r1, #64	; 0x40
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
    523e:	0b80      	lsrs	r0, r0, #14
    5240:	0380      	lsls	r0, r0, #14
    5242:	6098      	str	r0, [r3, #8]
	inline void epBank1DisableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENCLR.bit.TRCPT1 = 1; }

	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
    5244:	7953      	ldrb	r3, [r2, #5]
    5246:	430b      	orrs	r3, r1
    5248:	7153      	strb	r3, [r2, #5]
		usbd.epBank0SetByteCount(ep, 0);

		// NAK on endpoint OUT, the bank is full.
		usbd.epBank0SetReady(ep);
	}
}
    524a:	bd70      	pop	{r4, r5, r6, pc}
    524c:	200007a0 	.word	0x200007a0
    5250:	8fffffff 	.word	0x8fffffff
    5254:	200005b8 	.word	0x200005b8
    5258:	200003f4 	.word	0x200003f4
    525c:	f0003fff 	.word	0xf0003fff

00005260 <_ZN20USBDevice_SAMD21G18x5resetEv>:

	// Endpoints descriptors table
	__attribute__((__aligned__(4)))	UsbDeviceDescriptor EP[USB_EPT_NUM];
};

void USBDevice_SAMD21G18x::reset() {
    5260:	b538      	push	{r3, r4, r5, lr}
	usb.CTRLA.bit.SWRST = 1;
    5262:	1c04      	adds	r4, r0, #0
    5264:	cc08      	ldmia	r4!, {r3}
    5266:	2101      	movs	r1, #1
    5268:	781a      	ldrb	r2, [r3, #0]

	// Endpoints descriptors table
	__attribute__((__aligned__(4)))	UsbDeviceDescriptor EP[USB_EPT_NUM];
};

void USBDevice_SAMD21G18x::reset() {
    526a:	1c05      	adds	r5, r0, #0
	usb.CTRLA.bit.SWRST = 1;
    526c:	430a      	orrs	r2, r1
    526e:	701a      	strb	r2, [r3, #0]
	memset(EP, 0, sizeof(EP));
    5270:	2280      	movs	r2, #128	; 0x80
    5272:	1c20      	adds	r0, r4, #0
    5274:	2100      	movs	r1, #0
    5276:	0052      	lsls	r2, r2, #1
    5278:	f003 f867 	bl	834a <memset>
	while (usb.SYNCBUSY.bit.SWRST) {}
    527c:	682b      	ldr	r3, [r5, #0]
    527e:	789a      	ldrb	r2, [r3, #2]
    5280:	07d1      	lsls	r1, r2, #31
    5282:	d4fc      	bmi.n	527e <_ZN20USBDevice_SAMD21G18x5resetEv+0x1e>
	usb.DESCADD.reg = (uint32_t)(&EP);
    5284:	625c      	str	r4, [r3, #36]	; 0x24
}
    5286:	bd38      	pop	{r3, r4, r5, pc}

00005288 <_ZN20USBDevice_SAMD21G18x9calibrateEv>:
	// Load Pad Calibration data from non-volatile memory
	uint32_t *pad_transn_p = (uint32_t *) USB_FUSES_TRANSN_ADDR;
	uint32_t *pad_transp_p = (uint32_t *) USB_FUSES_TRANSP_ADDR;
	uint32_t *pad_trim_p   = (uint32_t *) USB_FUSES_TRIM_ADDR;

	uint32_t pad_transn = (*pad_transn_p & USB_FUSES_TRANSN_Msk) >> USB_FUSES_TRANSN_Pos;
    5288:	4b13      	ldr	r3, [pc, #76]	; (52d8 <_ZN20USBDevice_SAMD21G18x9calibrateEv+0x50>)
	memset(EP, 0, sizeof(EP));
	while (usb.SYNCBUSY.bit.SWRST) {}
	usb.DESCADD.reg = (uint32_t)(&EP);
}

void USBDevice_SAMD21G18x::calibrate() {
    528a:	b5f0      	push	{r4, r5, r6, r7, lr}
	// Load Pad Calibration data from non-volatile memory
	uint32_t *pad_transn_p = (uint32_t *) USB_FUSES_TRANSN_ADDR;
	uint32_t *pad_transp_p = (uint32_t *) USB_FUSES_TRANSP_ADDR;
	uint32_t *pad_trim_p   = (uint32_t *) USB_FUSES_TRIM_ADDR;

	uint32_t pad_transn = (*pad_transn_p & USB_FUSES_TRANSN_Msk) >> USB_FUSES_TRANSN_Pos;
    528c:	681b      	ldr	r3, [r3, #0]
    528e:	0399      	lsls	r1, r3, #14
	uint32_t pad_transp = (*pad_transp_p & USB_FUSES_TRANSP_Msk) >> USB_FUSES_TRANSP_Pos;
    5290:	025a      	lsls	r2, r3, #9
	uint32_t pad_trim   = (*pad_trim_p   & USB_FUSES_TRIM_Msk  ) >> USB_FUSES_TRIM_Pos;
    5292:	019b      	lsls	r3, r3, #6
	// Load Pad Calibration data from non-volatile memory
	uint32_t *pad_transn_p = (uint32_t *) USB_FUSES_TRANSN_ADDR;
	uint32_t *pad_transp_p = (uint32_t *) USB_FUSES_TRANSP_ADDR;
	uint32_t *pad_trim_p   = (uint32_t *) USB_FUSES_TRIM_ADDR;

	uint32_t pad_transn = (*pad_transn_p & USB_FUSES_TRANSN_Msk) >> USB_FUSES_TRANSN_Pos;
    5294:	0ec9      	lsrs	r1, r1, #27
	uint32_t pad_transp = (*pad_transp_p & USB_FUSES_TRANSP_Msk) >> USB_FUSES_TRANSP_Pos;
    5296:	0ed2      	lsrs	r2, r2, #27
	uint32_t pad_trim   = (*pad_trim_p   & USB_FUSES_TRIM_Msk  ) >> USB_FUSES_TRIM_Pos;
    5298:	0f5b      	lsrs	r3, r3, #29

	if (pad_transn == 0x1F)  // maximum value (31)
    529a:	291f      	cmp	r1, #31
    529c:	d100      	bne.n	52a0 <_ZN20USBDevice_SAMD21G18x9calibrateEv+0x18>
		pad_transn = 5;
    529e:	2105      	movs	r1, #5
	if (pad_transp == 0x1F)  // maximum value (31)
    52a0:	2a1f      	cmp	r2, #31
    52a2:	d100      	bne.n	52a6 <_ZN20USBDevice_SAMD21G18x9calibrateEv+0x1e>
		pad_transp = 29;
    52a4:	221d      	movs	r2, #29
	if (pad_trim == 0x7)     // maximum value (7)
    52a6:	2b07      	cmp	r3, #7
    52a8:	d100      	bne.n	52ac <_ZN20USBDevice_SAMD21G18x9calibrateEv+0x24>
		pad_trim = 3;
    52aa:	2303      	movs	r3, #3

	usb.PADCAL.bit.TRANSN = pad_transn;
    52ac:	6804      	ldr	r4, [r0, #0]
    52ae:	018e      	lsls	r6, r1, #6
    52b0:	8d27      	ldrh	r7, [r4, #40]	; 0x28
    52b2:	490a      	ldr	r1, [pc, #40]	; (52dc <_ZN20USBDevice_SAMD21G18x9calibrateEv+0x54>)
    52b4:	251f      	movs	r5, #31
    52b6:	4039      	ands	r1, r7
    52b8:	4331      	orrs	r1, r6
    52ba:	8521      	strh	r1, [r4, #40]	; 0x28
	usb.PADCAL.bit.TRANSP = pad_transp;
    52bc:	6801      	ldr	r1, [r0, #0]
    52be:	402a      	ands	r2, r5
    52c0:	8d0c      	ldrh	r4, [r1, #40]	; 0x28
    52c2:	43ac      	bics	r4, r5
    52c4:	4322      	orrs	r2, r4
    52c6:	850a      	strh	r2, [r1, #40]	; 0x28
	usb.PADCAL.bit.TRIM   = pad_trim;
    52c8:	6802      	ldr	r2, [r0, #0]
    52ca:	0319      	lsls	r1, r3, #12
    52cc:	8d10      	ldrh	r0, [r2, #40]	; 0x28
    52ce:	4b04      	ldr	r3, [pc, #16]	; (52e0 <_ZN20USBDevice_SAMD21G18x9calibrateEv+0x58>)
    52d0:	4003      	ands	r3, r0
    52d2:	430b      	orrs	r3, r1
    52d4:	8513      	strh	r3, [r2, #40]	; 0x28
}
    52d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    52d8:	00806024 	.word	0x00806024
    52dc:	fffff83f 	.word	0xfffff83f
    52e0:	ffff8fff 	.word	0xffff8fff

000052e4 <_ZN7__GuardC1Ev>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    52e4:	f3ef 8310 	mrs	r3, PRIMASK
 * TODO: Move into a separate header file and make an API out of it
 */

class __Guard {
public:
	__Guard() : primask(__get_PRIMASK()), loops(1) {
    52e8:	6003      	str	r3, [r0, #0]
    52ea:	2301      	movs	r3, #1
    52ec:	6043      	str	r3, [r0, #4]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    52ee:	b672      	cpsid	i
		__disable_irq();
	}
    52f0:	4770      	bx	lr

000052f2 <_ZN7__GuardD1Ev>:
	~__Guard() {
		if (primask == 0) {
    52f2:	6803      	ldr	r3, [r0, #0]
    52f4:	2b00      	cmp	r3, #0
    52f6:	d102      	bne.n	52fe <_ZN7__GuardD1Ev+0xc>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    52f8:	b662      	cpsie	i
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
    52fa:	f3bf 8f6f 	isb	sy
			__enable_irq();
			// http://infocenter.arm.com/help/topic/com.arm.doc.dai0321a/BIHBFEIB.html
			__ISB();
		}
	}
    52fe:	4770      	bx	lr

00005300 <_ZNK26DoubleBufferedEPOutHandler9availableEv>:
			release();
		}
	}

	// Returns how many bytes are stored in the buffers
	virtual uint32_t available() const {
    5300:	b537      	push	{r0, r1, r2, r4, r5, lr}
		if (current == 0) {
    5302:	6905      	ldr	r5, [r0, #16]
			release();
		}
	}

	// Returns how many bytes are stored in the buffers
	virtual uint32_t available() const {
    5304:	1c04      	adds	r4, r0, #0
		if (current == 0) {
			bool ready = false;
			synchronized {
    5306:	4668      	mov	r0, sp
		}
	}

	// Returns how many bytes are stored in the buffers
	virtual uint32_t available() const {
		if (current == 0) {
    5308:	2d00      	cmp	r5, #0
    530a:	d112      	bne.n	5332 <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x32>
			bool ready = false;
			synchronized {
    530c:	f7ff ffea 	bl	52e4 <_ZN7__GuardC1Ev>
    5310:	9b01      	ldr	r3, [sp, #4]
    5312:	3b01      	subs	r3, #1
    5314:	d303      	bcc.n	531e <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x1e>
				ready = ready0;
    5316:	1d62      	adds	r2, r4, #5
    5318:	7fd5      	ldrb	r5, [r2, #31]
    531a:	b2ed      	uxtb	r5, r5
    531c:	e7f9      	b.n	5312 <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x12>
			}
    531e:	4668      	mov	r0, sp
    5320:	9301      	str	r3, [sp, #4]
    5322:	f7ff ffe6 	bl	52f2 <_ZN7__GuardD1Ev>
			return ready ? (last0 - first0) : 0;
    5326:	2000      	movs	r0, #0
    5328:	4285      	cmp	r5, r0
    532a:	d017      	beq.n	535c <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x5c>
    532c:	6a20      	ldr	r0, [r4, #32]
    532e:	69e3      	ldr	r3, [r4, #28]
    5330:	e013      	b.n	535a <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x5a>
		} else {
			bool ready = false;
			synchronized {
    5332:	f7ff ffd7 	bl	52e4 <_ZN7__GuardC1Ev>
    5336:	9b01      	ldr	r3, [sp, #4]
			synchronized {
				ready = ready0;
			}
			return ready ? (last0 - first0) : 0;
		} else {
			bool ready = false;
    5338:	2500      	movs	r5, #0
			synchronized {
    533a:	3b01      	subs	r3, #1
    533c:	d304      	bcc.n	5348 <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x48>
				ready = ready1;
    533e:	1c22      	adds	r2, r4, #0
    5340:	3234      	adds	r2, #52	; 0x34
    5342:	7815      	ldrb	r5, [r2, #0]
    5344:	b2ed      	uxtb	r5, r5
    5346:	e7f8      	b.n	533a <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x3a>
			}
    5348:	4668      	mov	r0, sp
    534a:	9301      	str	r3, [sp, #4]
    534c:	f7ff ffd1 	bl	52f2 <_ZN7__GuardD1Ev>
			return ready ? (last1 - first1) : 0;
    5350:	2000      	movs	r0, #0
    5352:	4285      	cmp	r5, r0
    5354:	d002      	beq.n	535c <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x5c>
    5356:	6b20      	ldr	r0, [r4, #48]	; 0x30
    5358:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    535a:	1ac0      	subs	r0, r0, r3
		}
	}
    535c:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
	...

00005360 <_ZN26DoubleBufferedEPOutHandler7releaseEv>:
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }

	inline void epBank0EnableSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTENSET.bit.RXSTP = 1; }
	inline void epBank0EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL0 = 1; }
	inline void epBank1EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL1 = 1; }
	inline void epBank0EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT0 = 1; }
    5360:	6843      	ldr	r3, [r0, #4]
			}
			return ready ? (last1 - first1) : 0;
		}
	}

	void release() {
    5362:	b510      	push	{r4, lr}
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }

	inline void epBank0EnableSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTENSET.bit.RXSTP = 1; }
	inline void epBank0EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL0 = 1; }
	inline void epBank1EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL1 = 1; }
	inline void epBank0EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT0 = 1; }
    5364:	681a      	ldr	r2, [r3, #0]
    5366:	7a03      	ldrb	r3, [r0, #8]
    5368:	2101      	movs	r1, #1
    536a:	015b      	lsls	r3, r3, #5
    536c:	18d3      	adds	r3, r2, r3
    536e:	33ff      	adds	r3, #255	; 0xff
    5370:	7a9a      	ldrb	r2, [r3, #10]
    5372:	430a      	orrs	r2, r1
    5374:	729a      	strb	r2, [r3, #10]
    5376:	7a03      	ldrb	r3, [r0, #8]
	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
    5378:	6842      	ldr	r2, [r0, #4]
    537a:	015b      	lsls	r3, r3, #5
    537c:	18d3      	adds	r3, r2, r3
    537e:	68c2      	ldr	r2, [r0, #12]
    5380:	689c      	ldr	r4, [r3, #8]
    5382:	0491      	lsls	r1, r2, #18
    5384:	4a0b      	ldr	r2, [pc, #44]	; (53b4 <_ZN26DoubleBufferedEPOutHandler7releaseEv+0x54>)
    5386:	0909      	lsrs	r1, r1, #4
    5388:	4022      	ands	r2, r4
    538a:	430a      	orrs	r2, r1
    538c:	609a      	str	r2, [r3, #8]
    538e:	7a03      	ldrb	r3, [r0, #8]
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
    5390:	6842      	ldr	r2, [r0, #4]
    5392:	015b      	lsls	r3, r3, #5
    5394:	18d3      	adds	r3, r2, r3
    5396:	689a      	ldr	r2, [r3, #8]
	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
    5398:	2140      	movs	r1, #64	; 0x40
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
    539a:	0b92      	lsrs	r2, r2, #14
    539c:	0392      	lsls	r2, r2, #14
    539e:	609a      	str	r2, [r3, #8]
	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
    53a0:	6843      	ldr	r3, [r0, #4]
    53a2:	681a      	ldr	r2, [r3, #0]
    53a4:	7a03      	ldrb	r3, [r0, #8]
    53a6:	3308      	adds	r3, #8
    53a8:	015b      	lsls	r3, r3, #5
    53aa:	18d3      	adds	r3, r2, r3
    53ac:	791a      	ldrb	r2, [r3, #4]
    53ae:	430a      	orrs	r2, r1
    53b0:	711a      	strb	r2, [r3, #4]
		// Release OUT EP
		usbd.epBank0EnableTransferComplete(ep);
		usbd.epBank0SetMultiPacketSize(ep, size);
		usbd.epBank0SetByteCount(ep, 0);
		usbd.epBank0ResetReady(ep);
	}
    53b2:	bd10      	pop	{r4, pc}
    53b4:	f0003fff 	.word	0xf0003fff

000053b8 <_ZN26DoubleBufferedEPOutHandler4recvEPvm>:
		usbd.epBank0SetAddress(ep, const_cast<uint8_t *>(data0));

		release();
	}

	virtual uint32_t recv(void *_data, uint32_t len)
    53b8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	{
		uint8_t *data = reinterpret_cast<uint8_t *>(_data);

		// R/W: current, first0/1, ready0/1, notify
		// R  : last0/1, data0/1
		if (current == 0) {
    53ba:	6905      	ldr	r5, [r0, #16]
		usbd.epBank0SetAddress(ep, const_cast<uint8_t *>(data0));

		release();
	}

	virtual uint32_t recv(void *_data, uint32_t len)
    53bc:	1c04      	adds	r4, r0, #0
    53be:	1c0e      	adds	r6, r1, #0
    53c0:	1c17      	adds	r7, r2, #0
		uint8_t *data = reinterpret_cast<uint8_t *>(_data);

		// R/W: current, first0/1, ready0/1, notify
		// R  : last0/1, data0/1
		if (current == 0) {
			synchronized {
    53c2:	4668      	mov	r0, sp
	{
		uint8_t *data = reinterpret_cast<uint8_t *>(_data);

		// R/W: current, first0/1, ready0/1, notify
		// R  : last0/1, data0/1
		if (current == 0) {
    53c4:	2d00      	cmp	r5, #0
    53c6:	d11f      	bne.n	5408 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x50>
			synchronized {
    53c8:	f7ff ff8c 	bl	52e4 <_ZN7__GuardC1Ev>
    53cc:	9b01      	ldr	r3, [sp, #4]
    53ce:	3b01      	subs	r3, #1
    53d0:	1c5a      	adds	r2, r3, #1
    53d2:	d006      	beq.n	53e2 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x2a>
				if (!ready0) {
    53d4:	1d62      	adds	r2, r4, #5
    53d6:	7fd1      	ldrb	r1, [r2, #31]
    53d8:	1e5a      	subs	r2, r3, #1
    53da:	2900      	cmp	r1, #0
    53dc:	d03a      	beq.n	5454 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x9c>
    53de:	1c13      	adds	r3, r2, #0
    53e0:	e7f6      	b.n	53d0 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x18>
					return 0;
				}
			}
    53e2:	4668      	mov	r0, sp
    53e4:	9301      	str	r3, [sp, #4]
    53e6:	f7ff ff84 	bl	52f2 <_ZN7__GuardD1Ev>
			// when ready0==true the buffer is not being filled and last0 is constant
			uint32_t i;
			for (i=0; i<len && first0 < last0; i++) {
    53ea:	2500      	movs	r5, #0
    53ec:	69e3      	ldr	r3, [r4, #28]
    53ee:	42bd      	cmp	r5, r7
    53f0:	d035      	beq.n	545e <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xa6>
    53f2:	6a22      	ldr	r2, [r4, #32]
    53f4:	4293      	cmp	r3, r2
    53f6:	d232      	bcs.n	545e <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xa6>
				data[i] = data0[first0++];
    53f8:	1c5a      	adds	r2, r3, #1
    53fa:	61e2      	str	r2, [r4, #28]
    53fc:	69a2      	ldr	r2, [r4, #24]
    53fe:	18d3      	adds	r3, r2, r3
    5400:	781b      	ldrb	r3, [r3, #0]
    5402:	5573      	strb	r3, [r6, r5]
					return 0;
				}
			}
			// when ready0==true the buffer is not being filled and last0 is constant
			uint32_t i;
			for (i=0; i<len && first0 < last0; i++) {
    5404:	3501      	adds	r5, #1
    5406:	e7f1      	b.n	53ec <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x34>
					}
				}
			}
			return i;
		} else {
			synchronized {
    5408:	f7ff ff6c 	bl	52e4 <_ZN7__GuardC1Ev>
    540c:	9b01      	ldr	r3, [sp, #4]
    540e:	3b01      	subs	r3, #1
    5410:	1c5a      	adds	r2, r3, #1
    5412:	d008      	beq.n	5426 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x6e>
				if (!ready1) {
    5414:	1c22      	adds	r2, r4, #0
    5416:	3234      	adds	r2, #52	; 0x34
    5418:	7815      	ldrb	r5, [r2, #0]
    541a:	1e5a      	subs	r2, r3, #1
    541c:	b2ed      	uxtb	r5, r5
    541e:	2d00      	cmp	r5, #0
    5420:	d018      	beq.n	5454 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x9c>
    5422:	1c13      	adds	r3, r2, #0
    5424:	e7f4      	b.n	5410 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x58>
					return 0;
				}
			}
    5426:	4668      	mov	r0, sp
    5428:	9301      	str	r3, [sp, #4]
    542a:	f7ff ff62 	bl	52f2 <_ZN7__GuardD1Ev>
			// when ready1==true the buffer is not being filled and last1 is constant
			uint32_t i;
			for (i=0; i<len && first1 < last1; i++) {
    542e:	2500      	movs	r5, #0
    5430:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    5432:	42bd      	cmp	r5, r7
    5434:	d026      	beq.n	5484 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xcc>
    5436:	6b22      	ldr	r2, [r4, #48]	; 0x30
    5438:	4293      	cmp	r3, r2
    543a:	d341      	bcc.n	54c0 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x108>
    543c:	e022      	b.n	5484 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xcc>
			}
			if (first0 == last0) {
				first0 = 0;
				current = 1;
				synchronized {
					ready0 = false;
    543e:	1d62      	adds	r2, r4, #5
    5440:	2100      	movs	r1, #0
    5442:	77d1      	strb	r1, [r2, #31]
					if (notify) {
    5444:	3230      	adds	r2, #48	; 0x30
    5446:	7816      	ldrb	r6, [r2, #0]
    5448:	1e58      	subs	r0, r3, #1
    544a:	428e      	cmp	r6, r1
    544c:	d114      	bne.n	5478 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xc0>
    544e:	1c03      	adds	r3, r0, #0
				data[i] = data0[first0++];
			}
			if (first0 == last0) {
				first0 = 0;
				current = 1;
				synchronized {
    5450:	1c5a      	adds	r2, r3, #1
    5452:	d1f4      	bne.n	543e <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x86>
					ready1 = false;
					if (notify) {
						notify = false;
						release();
					}
				}
    5454:	4668      	mov	r0, sp
    5456:	9301      	str	r3, [sp, #4]
    5458:	f7ff ff4b 	bl	52f2 <_ZN7__GuardD1Ev>
    545c:	e038      	b.n	54d0 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x118>
			// when ready0==true the buffer is not being filled and last0 is constant
			uint32_t i;
			for (i=0; i<len && first0 < last0; i++) {
				data[i] = data0[first0++];
			}
			if (first0 == last0) {
    545e:	6a22      	ldr	r2, [r4, #32]
    5460:	4293      	cmp	r3, r2
    5462:	d135      	bne.n	54d0 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x118>
				first0 = 0;
    5464:	2300      	movs	r3, #0
    5466:	61e3      	str	r3, [r4, #28]
				current = 1;
    5468:	2301      	movs	r3, #1
    546a:	6123      	str	r3, [r4, #16]
				synchronized {
    546c:	4668      	mov	r0, sp
    546e:	f7ff ff39 	bl	52e4 <_ZN7__GuardC1Ev>
    5472:	9b01      	ldr	r3, [sp, #4]
    5474:	3b01      	subs	r3, #1
    5476:	e7eb      	b.n	5450 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x98>
					ready0 = false;
					if (notify) {
						notify = false;
    5478:	7011      	strb	r1, [r2, #0]
						release();
    547a:	1c20      	adds	r0, r4, #0
    547c:	9301      	str	r3, [sp, #4]
    547e:	f7ff ff6f 	bl	5360 <_ZN26DoubleBufferedEPOutHandler7releaseEv>
    5482:	e7f6      	b.n	5472 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xba>
			// when ready1==true the buffer is not being filled and last1 is constant
			uint32_t i;
			for (i=0; i<len && first1 < last1; i++) {
				data[i] = data1[first1++];
			}
			if (first1 == last1) {
    5484:	6b22      	ldr	r2, [r4, #48]	; 0x30
    5486:	4293      	cmp	r3, r2
    5488:	d122      	bne.n	54d0 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x118>
				first1 = 0;
    548a:	2300      	movs	r3, #0
    548c:	62e3      	str	r3, [r4, #44]	; 0x2c
				current = 0;
    548e:	6123      	str	r3, [r4, #16]
				synchronized {
    5490:	4668      	mov	r0, sp
    5492:	f7ff ff27 	bl	52e4 <_ZN7__GuardC1Ev>
    5496:	9b01      	ldr	r3, [sp, #4]
    5498:	3b01      	subs	r3, #1
    549a:	1c5a      	adds	r2, r3, #1
    549c:	d0da      	beq.n	5454 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x9c>
					ready1 = false;
    549e:	1c22      	adds	r2, r4, #0
    54a0:	3234      	adds	r2, #52	; 0x34
    54a2:	2100      	movs	r1, #0
    54a4:	7011      	strb	r1, [r2, #0]
					if (notify) {
    54a6:	3201      	adds	r2, #1
    54a8:	7816      	ldrb	r6, [r2, #0]
    54aa:	1e58      	subs	r0, r3, #1
    54ac:	428e      	cmp	r6, r1
    54ae:	d101      	bne.n	54b4 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xfc>
    54b0:	1c03      	adds	r3, r0, #0
    54b2:	e7f2      	b.n	549a <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xe2>
						notify = false;
    54b4:	7011      	strb	r1, [r2, #0]
						release();
    54b6:	1c20      	adds	r0, r4, #0
    54b8:	9301      	str	r3, [sp, #4]
    54ba:	f7ff ff51 	bl	5360 <_ZN26DoubleBufferedEPOutHandler7releaseEv>
    54be:	e7ea      	b.n	5496 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xde>
				}
			}
			// when ready1==true the buffer is not being filled and last1 is constant
			uint32_t i;
			for (i=0; i<len && first1 < last1; i++) {
				data[i] = data1[first1++];
    54c0:	1c5a      	adds	r2, r3, #1
    54c2:	62e2      	str	r2, [r4, #44]	; 0x2c
    54c4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    54c6:	18d3      	adds	r3, r2, r3
    54c8:	781b      	ldrb	r3, [r3, #0]
    54ca:	5573      	strb	r3, [r6, r5]
					return 0;
				}
			}
			// when ready1==true the buffer is not being filled and last1 is constant
			uint32_t i;
			for (i=0; i<len && first1 < last1; i++) {
    54cc:	3501      	adds	r5, #1
    54ce:	e7af      	b.n	5430 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x78>
					}
				}
			}
			return i;
		}
	}
    54d0:	1c28      	adds	r0, r5, #0
    54d2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

000054d4 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv>:

	virtual void handleEndpoint()
    54d4:	b537      	push	{r0, r1, r2, r4, r5, lr}
	inline uint16_t epInterruptSummary() { return usb.EPINTSMRY.reg; }

	inline bool epBank0IsSetupReceived(ep_t ep)     { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.RXSTP; }
	inline bool epBank0IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL0; }
	inline bool epBank1IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL1; }
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
    54d6:	6843      	ldr	r3, [r0, #4]
    54d8:	7a02      	ldrb	r2, [r0, #8]
    54da:	681b      	ldr	r3, [r3, #0]
    54dc:	3208      	adds	r2, #8
    54de:	0152      	lsls	r2, r2, #5
    54e0:	189a      	adds	r2, r3, r2
			}
			return i;
		}
	}

	virtual void handleEndpoint()
    54e2:	1c04      	adds	r4, r0, #0
	inline uint16_t epInterruptSummary() { return usb.EPINTSMRY.reg; }

	inline bool epBank0IsSetupReceived(ep_t ep)     { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.RXSTP; }
	inline bool epBank0IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL0; }
	inline bool epBank1IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL1; }
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
    54e4:	79d0      	ldrb	r0, [r2, #7]
    54e6:	2301      	movs	r3, #1
    54e8:	21ff      	movs	r1, #255	; 0xff

	virtual void handleEndpoint()
	{
		// R/W : incoming, ready0/1
		//   W : last0/1, notify
		if (usbd.epBank0IsTransferComplete(ep))
    54ea:	4218      	tst	r0, r3
    54ec:	d055      	beq.n	559a <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0xc6>
	inline bool epBank1IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT1; }

	inline void epBank0AckSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP; }
	inline void epBank0AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(1); }
	inline void epBank1AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(2); }
	inline void epBank0AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(1); }
    54ee:	71d3      	strb	r3, [r2, #7]
    54f0:	68a0      	ldr	r0, [r4, #8]
			// Ack Transfer complete
			usbd.epBank0AckTransferComplete(ep);
			//usbd.epBank0AckTransferFailed(ep); // XXX

			// Update counters and swap banks for non-ZLP's
			if (incoming == 0) {
    54f2:	6965      	ldr	r5, [r4, #20]
    54f4:	6862      	ldr	r2, [r4, #4]
    54f6:	4001      	ands	r1, r0
    54f8:	2d00      	cmp	r5, #0
    54fa:	d11f      	bne.n	553c <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0x68>
	inline void epBank1SetStallReq(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.STALLRQ1 = 1; }
	inline void epBank0ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ0 = 1; }
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
    54fc:	0149      	lsls	r1, r1, #5
    54fe:	1852      	adds	r2, r2, r1
    5500:	6891      	ldr	r1, [r2, #8]
    5502:	0489      	lsls	r1, r1, #18
    5504:	0c89      	lsrs	r1, r1, #18
			usbd.epBank0AckTransferComplete(ep);
			//usbd.epBank0AckTransferFailed(ep); // XXX

			// Update counters and swap banks for non-ZLP's
			if (incoming == 0) {
				last0 = usbd.epBank0ByteCount(ep);
    5506:	6221      	str	r1, [r4, #32]
				if (last0 != 0) {
    5508:	6a21      	ldr	r1, [r4, #32]
    550a:	2900      	cmp	r1, #0
    550c:	d042      	beq.n	5594 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0xc0>
					incoming = 1;
    550e:	6163      	str	r3, [r4, #20]
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
    5510:	6aa3      	ldr	r3, [r4, #40]	; 0x28
			if (incoming == 0) {
				last0 = usbd.epBank0ByteCount(ep);
				if (last0 != 0) {
					incoming = 1;
					usbd.epBank0SetAddress(ep, const_cast<uint8_t *>(data1));
					synchronized {
    5512:	4668      	mov	r0, sp
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
    5514:	6053      	str	r3, [r2, #4]
			if (incoming == 0) {
				last0 = usbd.epBank0ByteCount(ep);
				if (last0 != 0) {
					incoming = 1;
					usbd.epBank0SetAddress(ep, const_cast<uint8_t *>(data1));
					synchronized {
    5516:	f7ff fee5 	bl	52e4 <_ZN7__GuardC1Ev>
    551a:	9b01      	ldr	r3, [sp, #4]
    551c:	3b01      	subs	r3, #1
    551e:	1c5d      	adds	r5, r3, #1
    5520:	d034      	beq.n	558c <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0xb8>
						ready0 = true;
    5522:	1d62      	adds	r2, r4, #5
    5524:	2001      	movs	r0, #1
    5526:	77d0      	strb	r0, [r2, #31]
						if (ready1) {
    5528:	322f      	adds	r2, #47	; 0x2f
    552a:	7811      	ldrb	r1, [r2, #0]
    552c:	1e5d      	subs	r5, r3, #1
    552e:	b2c9      	uxtb	r1, r1
    5530:	1812      	adds	r2, r2, r0
    5532:	2900      	cmp	r1, #0
    5534:	d115      	bne.n	5562 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0x8e>
							notify = true;
							return;
						}
						notify = false;
    5536:	7011      	strb	r1, [r2, #0]
    5538:	1c2b      	adds	r3, r5, #0
    553a:	e7f0      	b.n	551e <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0x4a>
	inline void epBank1SetStallReq(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.STALLRQ1 = 1; }
	inline void epBank0ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ0 = 1; }
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
    553c:	014b      	lsls	r3, r1, #5
    553e:	18d3      	adds	r3, r2, r3
    5540:	689a      	ldr	r2, [r3, #8]
    5542:	0492      	lsls	r2, r2, #18
    5544:	0c92      	lsrs	r2, r2, #18
						}
						notify = false;
					}
				}
			} else {
				last1 = usbd.epBank0ByteCount(ep);
    5546:	6322      	str	r2, [r4, #48]	; 0x30
				if (last1 != 0) {
    5548:	6b22      	ldr	r2, [r4, #48]	; 0x30
    554a:	2a00      	cmp	r2, #0
    554c:	d022      	beq.n	5594 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0xc0>
					incoming = 0;
    554e:	2200      	movs	r2, #0
    5550:	6162      	str	r2, [r4, #20]
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
    5552:	69a2      	ldr	r2, [r4, #24]
			} else {
				last1 = usbd.epBank0ByteCount(ep);
				if (last1 != 0) {
					incoming = 0;
					usbd.epBank0SetAddress(ep, const_cast<uint8_t *>(data0));
					synchronized {
    5554:	4668      	mov	r0, sp
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
    5556:	605a      	str	r2, [r3, #4]
			} else {
				last1 = usbd.epBank0ByteCount(ep);
				if (last1 != 0) {
					incoming = 0;
					usbd.epBank0SetAddress(ep, const_cast<uint8_t *>(data0));
					synchronized {
    5558:	f7ff fec4 	bl	52e4 <_ZN7__GuardC1Ev>
    555c:	9b01      	ldr	r3, [sp, #4]
    555e:	3b01      	subs	r3, #1
    5560:	e012      	b.n	5588 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0xb4>
    5562:	9301      	str	r3, [sp, #4]
						ready1 = true;
						if (ready0) {
							notify = true;
    5564:	7010      	strb	r0, [r2, #0]
							return;
    5566:	4668      	mov	r0, sp
    5568:	f7ff fec3 	bl	52f2 <_ZN7__GuardD1Ev>
    556c:	e015      	b.n	559a <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0xc6>
				last1 = usbd.epBank0ByteCount(ep);
				if (last1 != 0) {
					incoming = 0;
					usbd.epBank0SetAddress(ep, const_cast<uint8_t *>(data0));
					synchronized {
						ready1 = true;
    556e:	1c22      	adds	r2, r4, #0
    5570:	3234      	adds	r2, #52	; 0x34
    5572:	2001      	movs	r0, #1
    5574:	7010      	strb	r0, [r2, #0]
						if (ready0) {
    5576:	1d62      	adds	r2, r4, #5
    5578:	7fd1      	ldrb	r1, [r2, #31]
    557a:	1e5d      	subs	r5, r3, #1
    557c:	b2c9      	uxtb	r1, r1
    557e:	3230      	adds	r2, #48	; 0x30
    5580:	2900      	cmp	r1, #0
    5582:	d1ee      	bne.n	5562 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0x8e>
							notify = true;
							return;
						}
						notify = false;
    5584:	7011      	strb	r1, [r2, #0]
    5586:	1c2b      	adds	r3, r5, #0
			} else {
				last1 = usbd.epBank0ByteCount(ep);
				if (last1 != 0) {
					incoming = 0;
					usbd.epBank0SetAddress(ep, const_cast<uint8_t *>(data0));
					synchronized {
    5588:	1c5d      	adds	r5, r3, #1
    558a:	d1f0      	bne.n	556e <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0x9a>
						if (ready0) {
							notify = true;
							return;
						}
						notify = false;
					}
    558c:	4668      	mov	r0, sp
    558e:	9301      	str	r3, [sp, #4]
    5590:	f7ff feaf 	bl	52f2 <_ZN7__GuardD1Ev>
				}
			}
			release();
    5594:	1c20      	adds	r0, r4, #0
    5596:	f7ff fee3 	bl	5360 <_ZN26DoubleBufferedEPOutHandler7releaseEv>
		}
	}
    559a:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

0000559c <_ZN14USBDeviceClass14SendInterfacesEPm>:
		sendControl(_pack_buffer, _pack_size);
	}
}

uint8_t USBDeviceClass::SendInterfaces(uint32_t* total)
{
    559c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint8_t interfaces = 0;
    559e:	2300      	movs	r3, #0
    55a0:	466c      	mov	r4, sp
    55a2:	71e3      	strb	r3, [r4, #7]
    55a4:	3407      	adds	r4, #7

#if defined(CDC_ENABLED)
	total[0] += CDC_GetInterface(&interfaces);
    55a6:	1c20      	adds	r0, r4, #0
		sendControl(_pack_buffer, _pack_size);
	}
}

uint8_t USBDeviceClass::SendInterfaces(uint32_t* total)
{
    55a8:	1c0d      	adds	r5, r1, #0
	uint8_t interfaces = 0;

#if defined(CDC_ENABLED)
	total[0] += CDC_GetInterface(&interfaces);
    55aa:	f000 fe79 	bl	62a0 <_Z16CDC_GetInterfacePh>
    55ae:	682b      	ldr	r3, [r5, #0]
    55b0:	1818      	adds	r0, r3, r0
    55b2:	6028      	str	r0, [r5, #0]
#endif

#ifdef PLUGGABLE_USB_ENABLED
	total[0] += PluggableUSB().getInterface(&interfaces);
    55b4:	f000 ff1c 	bl	63f0 <_Z12PluggableUSBv>
    55b8:	1c21      	adds	r1, r4, #0
    55ba:	f000 fed3 	bl	6364 <_ZN13PluggableUSB_12getInterfaceEPh>
    55be:	682b      	ldr	r3, [r5, #0]
    55c0:	1818      	adds	r0, r3, r0
    55c2:	6028      	str	r0, [r5, #0]
#endif

	return interfaces;
    55c4:	7820      	ldrb	r0, [r4, #0]
}
    55c6:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

000055c8 <_ZN14USBDeviceClass14handleEndpointEh>:


void USBDeviceClass::handleEndpoint(uint8_t ep)
{
#if defined(CDC_ENABLED)
	if (ep == CDC_ENDPOINT_IN)
    55c8:	2903      	cmp	r1, #3
    55ca:	d10b      	bne.n	55e4 <_ZN14USBDeviceClass14handleEndpointEh+0x1c>
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
	inline void epBank1ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK1RDY = 1; }
    55cc:	4b0d      	ldr	r3, [pc, #52]	; (5604 <_ZN14USBDeviceClass14handleEndpointEh+0x3c>)
    55ce:	22b2      	movs	r2, #178	; 0xb2
    55d0:	681b      	ldr	r3, [r3, #0]
    55d2:	0052      	lsls	r2, r2, #1
    55d4:	5c98      	ldrb	r0, [r3, r2]
    55d6:	2180      	movs	r1, #128	; 0x80
    55d8:	4249      	negs	r1, r1
    55da:	4301      	orrs	r1, r0
    55dc:	5499      	strb	r1, [r3, r2]

	inline void epBank0AckSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP; }
	inline void epBank0AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(1); }
	inline void epBank1AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(2); }
	inline void epBank0AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(1); }
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }
    55de:	2102      	movs	r1, #2
    55e0:	2268      	movs	r2, #104	; 0x68
    55e2:	e00c      	b.n	55fe <_ZN14USBDeviceClass14handleEndpointEh+0x36>
	{
		// NAK on endpoint IN, the bank is not yet filled in.
		usbd.epBank1ResetReady(CDC_ENDPOINT_IN);
		usbd.epBank1AckTransferComplete(CDC_ENDPOINT_IN);
	}
	if (ep == CDC_ENDPOINT_ACM)
    55e4:	2901      	cmp	r1, #1
    55e6:	d10c      	bne.n	5602 <_ZN14USBDeviceClass14handleEndpointEh+0x3a>
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
	inline void epBank1ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK1RDY = 1; }
    55e8:	4b06      	ldr	r3, [pc, #24]	; (5604 <_ZN14USBDeviceClass14handleEndpointEh+0x3c>)
    55ea:	2292      	movs	r2, #146	; 0x92
    55ec:	681b      	ldr	r3, [r3, #0]
    55ee:	0052      	lsls	r2, r2, #1
    55f0:	5c98      	ldrb	r0, [r3, r2]
    55f2:	2180      	movs	r1, #128	; 0x80
    55f4:	4249      	negs	r1, r1
    55f6:	4301      	orrs	r1, r0
    55f8:	5499      	strb	r1, [r3, r2]

	inline void epBank0AckSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP; }
	inline void epBank0AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(1); }
	inline void epBank1AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(2); }
	inline void epBank0AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(1); }
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }
    55fa:	2102      	movs	r1, #2
    55fc:	2228      	movs	r2, #40	; 0x28
    55fe:	32ff      	adds	r2, #255	; 0xff
    5600:	5499      	strb	r1, [r3, r2]
#endif

#if defined(PLUGGABLE_USB_ENABLED)
	// Empty
#endif
}
    5602:	4770      	bx	lr
    5604:	200007a0 	.word	0x200007a0

00005608 <_ZN14USBDeviceClass4initEv>:

void USBDeviceClass::init()
{
    5608:	b538      	push	{r3, r4, r5, lr}
#ifdef PIN_LED_TXL
	txLEDPulse = 0;
    560a:	4b30      	ldr	r3, [pc, #192]	; (56cc <_ZN14USBDeviceClass4initEv+0xc4>)
    560c:	2400      	movs	r4, #0
	pinMode(PIN_LED_TXL, OUTPUT);
    560e:	2101      	movs	r1, #1
	// Empty
#endif
}

void USBDeviceClass::init()
{
    5610:	1c05      	adds	r5, r0, #0
#ifdef PIN_LED_TXL
	txLEDPulse = 0;
	pinMode(PIN_LED_TXL, OUTPUT);
    5612:	201a      	movs	r0, #26
}

void USBDeviceClass::init()
{
#ifdef PIN_LED_TXL
	txLEDPulse = 0;
    5614:	701c      	strb	r4, [r3, #0]
	pinMode(PIN_LED_TXL, OUTPUT);
    5616:	f7ff f885 	bl	4724 <pinMode>
	digitalWrite(PIN_LED_TXL, HIGH);
    561a:	201a      	movs	r0, #26
    561c:	2101      	movs	r1, #1
    561e:	f7ff f8db 	bl	47d8 <digitalWrite>
#endif

#ifdef PIN_LED_RXL
	rxLEDPulse = 0;
    5622:	4b2b      	ldr	r3, [pc, #172]	; (56d0 <_ZN14USBDeviceClass4initEv+0xc8>)
	pinMode(PIN_LED_RXL, OUTPUT);
    5624:	2019      	movs	r0, #25
    5626:	2101      	movs	r1, #1
	pinMode(PIN_LED_TXL, OUTPUT);
	digitalWrite(PIN_LED_TXL, HIGH);
#endif

#ifdef PIN_LED_RXL
	rxLEDPulse = 0;
    5628:	701c      	strb	r4, [r3, #0]
	pinMode(PIN_LED_RXL, OUTPUT);
    562a:	f7ff f87b 	bl	4724 <pinMode>
	digitalWrite(PIN_LED_RXL, HIGH);
    562e:	2019      	movs	r0, #25
    5630:	2101      	movs	r1, #1
    5632:	f7ff f8d1 	bl	47d8 <digitalWrite>
#endif

	// Enable USB clock
	PM->APBBMASK.reg |= PM_APBBMASK_USB;
    5636:	4b27      	ldr	r3, [pc, #156]	; (56d4 <_ZN14USBDeviceClass4initEv+0xcc>)
    5638:	2120      	movs	r1, #32
    563a:	69da      	ldr	r2, [r3, #28]

	// Set up the USB DP/DN pins
	PORT->Group[0].PINCFG[PIN_PA24G_USB_DM].bit.PMUXEN = 1;
    563c:	2001      	movs	r0, #1
	pinMode(PIN_LED_RXL, OUTPUT);
	digitalWrite(PIN_LED_RXL, HIGH);
#endif

	// Enable USB clock
	PM->APBBMASK.reg |= PM_APBBMASK_USB;
    563e:	430a      	orrs	r2, r1
    5640:	61da      	str	r2, [r3, #28]

	// Set up the USB DP/DN pins
	PORT->Group[0].PINCFG[PIN_PA24G_USB_DM].bit.PMUXEN = 1;
    5642:	4b25      	ldr	r3, [pc, #148]	; (56d8 <_ZN14USBDeviceClass4initEv+0xd0>)
	PORT->Group[0].PMUX[PIN_PA24G_USB_DM/2].reg &= ~(0xF << (4 * (PIN_PA24G_USB_DM & 0x01u)));
	PORT->Group[0].PMUX[PIN_PA24G_USB_DM/2].reg |= MUX_PA24G_USB_DM << (4 * (PIN_PA24G_USB_DM & 0x01u));
    5644:	2406      	movs	r4, #6

	// Enable USB clock
	PM->APBBMASK.reg |= PM_APBBMASK_USB;

	// Set up the USB DP/DN pins
	PORT->Group[0].PINCFG[PIN_PA24G_USB_DM].bit.PMUXEN = 1;
    5646:	781a      	ldrb	r2, [r3, #0]
    5648:	4302      	orrs	r2, r0
    564a:	701a      	strb	r2, [r3, #0]
	PORT->Group[0].PMUX[PIN_PA24G_USB_DM/2].reg &= ~(0xF << (4 * (PIN_PA24G_USB_DM & 0x01u)));
    564c:	4b23      	ldr	r3, [pc, #140]	; (56dc <_ZN14USBDeviceClass4initEv+0xd4>)
    564e:	220f      	movs	r2, #15
    5650:	7819      	ldrb	r1, [r3, #0]
    5652:	4391      	bics	r1, r2
    5654:	7019      	strb	r1, [r3, #0]
	PORT->Group[0].PMUX[PIN_PA24G_USB_DM/2].reg |= MUX_PA24G_USB_DM << (4 * (PIN_PA24G_USB_DM & 0x01u));
    5656:	7819      	ldrb	r1, [r3, #0]
    5658:	4321      	orrs	r1, r4
    565a:	7019      	strb	r1, [r3, #0]
	PORT->Group[0].PINCFG[PIN_PA25G_USB_DP].bit.PMUXEN = 1;
    565c:	4920      	ldr	r1, [pc, #128]	; (56e0 <_ZN14USBDeviceClass4initEv+0xd8>)
    565e:	780c      	ldrb	r4, [r1, #0]
    5660:	4320      	orrs	r0, r4
    5662:	7008      	strb	r0, [r1, #0]
	PORT->Group[0].PMUX[PIN_PA25G_USB_DP/2].reg &= ~(0xF << (4 * (PIN_PA25G_USB_DP & 0x01u)));
    5664:	7819      	ldrb	r1, [r3, #0]
    5666:	400a      	ands	r2, r1
    5668:	701a      	strb	r2, [r3, #0]
	PORT->Group[0].PMUX[PIN_PA25G_USB_DP/2].reg |= MUX_PA25G_USB_DP << (4 * (PIN_PA25G_USB_DP & 0x01u));
    566a:	781a      	ldrb	r2, [r3, #0]
    566c:	2160      	movs	r1, #96	; 0x60
    566e:	430a      	orrs	r2, r1
    5670:	701a      	strb	r2, [r3, #0]

	// Put Generic Clock Generator 0 as source for Generic Clock Multiplexer 6 (USB reference)
	GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(6)     | // Generic Clock Multiplexer 6
	                    GCLK_CLKCTRL_GEN_GCLK0 | // Generic Clock Generator 0 is source
	                    GCLK_CLKCTRL_CLKEN;
    5672:	4b1c      	ldr	r3, [pc, #112]	; (56e4 <_ZN14USBDeviceClass4initEv+0xdc>)
    5674:	4a1c      	ldr	r2, [pc, #112]	; (56e8 <_ZN14USBDeviceClass4initEv+0xe0>)
    5676:	805a      	strh	r2, [r3, #2]
	while (GCLK->STATUS.bit.SYNCBUSY)
    5678:	785a      	ldrb	r2, [r3, #1]
    567a:	09d2      	lsrs	r2, r2, #7
    567c:	d1fc      	bne.n	5678 <_ZN14USBDeviceClass4initEv+0x70>
		;

	USB_SetHandler(&UDD_Handler);
    567e:	481b      	ldr	r0, [pc, #108]	; (56ec <_ZN14USBDeviceClass4initEv+0xe4>)
    5680:	f7fe fecc 	bl	441c <USB_SetHandler>

	// Reset USB Device
	usbd.reset();
    5684:	4c1a      	ldr	r4, [pc, #104]	; (56f0 <_ZN14USBDeviceClass4initEv+0xe8>)
    5686:	1c20      	adds	r0, r4, #0
    5688:	f7ff fdea 	bl	5260 <_ZN20USBDevice_SAMD21G18x5resetEv>

	usbd.calibrate();
    568c:	1c20      	adds	r0, r4, #0
    568e:	f7ff fdfb 	bl	5288 <_ZN20USBDevice_SAMD21G18x9calibrateEv>
	// Enable
	inline void enable()  { usb.CTRLA.bit.ENABLE = 1; }
	inline void disable() { usb.CTRLA.bit.ENABLE = 0; }

	// USB mode (device/host)
	inline void setUSBDeviceMode() { usb.CTRLA.bit.MODE = USB_CTRLA_MODE_DEVICE_Val; }
    5692:	6823      	ldr	r3, [r4, #0]
    5694:	227f      	movs	r2, #127	; 0x7f
    5696:	7819      	ldrb	r1, [r3, #0]
    5698:	400a      	ands	r2, r1
    569a:	701a      	strb	r2, [r3, #0]
	inline void setUSBHostMode()   { usb.CTRLA.bit.MODE = USB_CTRLA_MODE_HOST_Val;   }

	inline void runInStandby()   { usb.CTRLA.bit.RUNSTDBY = 1; }
    569c:	781a      	ldrb	r2, [r3, #0]
    569e:	2104      	movs	r1, #4
    56a0:	430a      	orrs	r2, r1
    56a2:	701a      	strb	r2, [r3, #0]
	inline void noRunInStandby() { usb.CTRLA.bit.RUNSTDBY = 0; }
	inline void wakeupHost()     { usb.CTRLB.bit.UPRSM = 1; }

	// USB speed
	inline void setFullSpeed()       { usb.CTRLB.bit.SPDCONF = USB_DEVICE_CTRLB_SPDCONF_FS_Val;   }
    56a4:	891a      	ldrh	r2, [r3, #8]
    56a6:	210c      	movs	r1, #12
    56a8:	438a      	bics	r2, r1
    56aa:	811a      	strh	r2, [r3, #8]
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    56ac:	21c1      	movs	r1, #193	; 0xc1
    56ae:	4a11      	ldr	r2, [pc, #68]	; (56f4 <_ZN14USBDeviceClass4initEv+0xec>)
    56b0:	0089      	lsls	r1, r1, #2
    56b2:	5850      	ldr	r0, [r2, r1]
    56b4:	0200      	lsls	r0, r0, #8
    56b6:	0a00      	lsrs	r0, r0, #8
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
    56b8:	5050      	str	r0, [r2, r1]
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    56ba:	2180      	movs	r1, #128	; 0x80
    56bc:	6011      	str	r1, [r2, #0]

	// Reset USB Device
	void reset();

	// Enable
	inline void enable()  { usb.CTRLA.bit.ENABLE = 1; }
    56be:	781a      	ldrb	r2, [r3, #0]
    56c0:	2102      	movs	r1, #2
    56c2:	430a      	orrs	r2, r1
    56c4:	701a      	strb	r2, [r3, #0]
	NVIC_SetPriority((IRQn_Type) USB_IRQn, 0UL);
	NVIC_EnableIRQ((IRQn_Type) USB_IRQn);

	usbd.enable();

	initialized = true;
    56c6:	2301      	movs	r3, #1
    56c8:	702b      	strb	r3, [r5, #0]
}
    56ca:	bd38      	pop	{r3, r4, r5, pc}
    56cc:	200005b4 	.word	0x200005b4
    56d0:	2000079c 	.word	0x2000079c
    56d4:	40000400 	.word	0x40000400
    56d8:	41004458 	.word	0x41004458
    56dc:	4100443c 	.word	0x4100443c
    56e0:	41004459 	.word	0x41004459
    56e4:	40000c00 	.word	0x40000c00
    56e8:	00004006 	.word	0x00004006
    56ec:	00006155 	.word	0x00006155
    56f0:	200007a0 	.word	0x200007a0
    56f4:	e000e100 	.word	0xe000e100

000056f8 <_ZN14USBDeviceClass6attachEv>:

bool USBDeviceClass::attach()
{
	if (!initialized)
    56f8:	7800      	ldrb	r0, [r0, #0]
    56fa:	2800      	cmp	r0, #0
    56fc:	d010      	beq.n	5720 <_ZN14USBDeviceClass6attachEv+0x28>
	inline void setLowSpeed()        { usb.CTRLB.bit.SPDCONF = USB_DEVICE_CTRLB_SPDCONF_LS_Val;   }
	inline void setHiSpeed()         { usb.CTRLB.bit.SPDCONF = USB_DEVICE_CTRLB_SPDCONF_HS_Val;   }
	inline void setHiSpeedTestMode() { usb.CTRLB.bit.SPDCONF = USB_DEVICE_CTRLB_SPDCONF_HSTM_Val; }

	// Authorize attach if Vbus is present
	inline void attach() { usb.CTRLB.bit.DETACH = 0; }
    56fe:	4b09      	ldr	r3, [pc, #36]	; (5724 <_ZN14USBDeviceClass6attachEv+0x2c>)
    5700:	2101      	movs	r1, #1
    5702:	681b      	ldr	r3, [r3, #0]
    5704:	891a      	ldrh	r2, [r3, #8]
    5706:	438a      	bics	r2, r1
    5708:	811a      	strh	r2, [r3, #8]
	inline void detach() { usb.CTRLB.bit.DETACH = 1; }

	// USB Interrupts
	inline bool isEndOfResetInterrupt()        { return usb.INTFLAG.bit.EORST; }
	inline void ackEndOfResetInterrupt()       { usb.INTFLAG.reg = USB_DEVICE_INTFLAG_EORST; }
	inline void enableEndOfResetInterrupt()    { usb.INTENSET.bit.EORST = 1; }
    570a:	8b1a      	ldrh	r2, [r3, #24]
    570c:	2108      	movs	r1, #8
    570e:	430a      	orrs	r2, r1
    5710:	831a      	strh	r2, [r3, #24]
	inline void disableEndOfResetInterrupt()   { usb.INTENCLR.bit.EORST = 1; }

	inline bool isStartOfFrameInterrupt()      { return usb.INTFLAG.bit.SOF; }
	inline void ackStartOfFrameInterrupt()     { usb.INTFLAG.reg = USB_DEVICE_INTFLAG_SOF; }
	inline void enableStartOfFrameInterrupt()  { usb.INTENSET.bit.SOF = 1; }
    5712:	8b1a      	ldrh	r2, [r3, #24]
    5714:	2104      	movs	r1, #4
    5716:	430a      	orrs	r2, r1
    5718:	831a      	strh	r2, [r3, #24]

	usbd.attach();
	usbd.enableEndOfResetInterrupt();
	usbd.enableStartOfFrameInterrupt();

	_usbConfiguration = 0;
    571a:	4b03      	ldr	r3, [pc, #12]	; (5728 <_ZN14USBDeviceClass6attachEv+0x30>)
    571c:	2200      	movs	r2, #0
    571e:	601a      	str	r2, [r3, #0]
	return true;
}
    5720:	4770      	bx	lr
    5722:	46c0      	nop			; (mov r8, r8)
    5724:	200007a0 	.word	0x200007a0
    5728:	200008a4 	.word	0x200008a4

0000572c <_ZN14USBDeviceClass10setAddressEm>:

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
    572c:	4b0f      	ldr	r3, [pc, #60]	; (576c <_ZN14USBDeviceClass10setAddressEm+0x40>)
    572e:	699a      	ldr	r2, [r3, #24]
    5730:	0b92      	lsrs	r2, r2, #14
    5732:	0392      	lsls	r2, r2, #14
    5734:	619a      	str	r2, [r3, #24]

	inline void epBank0AckSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP; }
	inline void epBank0AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(1); }
	inline void epBank1AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(2); }
	inline void epBank0AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(1); }
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }
    5736:	681b      	ldr	r3, [r3, #0]
    5738:	2202      	movs	r2, #2
    573a:	33ff      	adds	r3, #255	; 0xff
    573c:	721a      	strb	r2, [r3, #8]

	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
    573e:	7998      	ldrb	r0, [r3, #6]
    5740:	2280      	movs	r2, #128	; 0x80
    5742:	4252      	negs	r2, r2
    5744:	4302      	orrs	r2, r0
    5746:	719a      	strb	r2, [r3, #6]

	inline bool epBank0IsSetupReceived(ep_t ep)     { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.RXSTP; }
	inline bool epBank0IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL0; }
	inline bool epBank1IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL1; }
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
	inline bool epBank1IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT1; }
    5748:	7a1a      	ldrb	r2, [r3, #8]

	// RAM buffer is full, we can send data (IN)
	usbd.epBank1SetReady(0);

	// Wait for transfer to complete
	while (!usbd.epBank1IsTransferComplete(0)) {}
    574a:	0790      	lsls	r0, r2, #30
    574c:	d5fc      	bpl.n	5748 <_ZN14USBDeviceClass10setAddressEm+0x1c>

	// Set USB address to addr
	USB->DEVICE.DADD.bit.DADD = addr; // Address
    574e:	4b08      	ldr	r3, [pc, #32]	; (5770 <_ZN14USBDeviceClass10setAddressEm+0x44>)
    5750:	1c08      	adds	r0, r1, #0
    5752:	7a99      	ldrb	r1, [r3, #10]
    5754:	227f      	movs	r2, #127	; 0x7f
    5756:	4010      	ands	r0, r2
    5758:	4391      	bics	r1, r2
    575a:	4301      	orrs	r1, r0
    575c:	7299      	strb	r1, [r3, #10]
	USB->DEVICE.DADD.bit.ADDEN = 1; // Enable
    575e:	7a99      	ldrb	r1, [r3, #10]
    5760:	2280      	movs	r2, #128	; 0x80
    5762:	4252      	negs	r2, r2
    5764:	430a      	orrs	r2, r1
    5766:	729a      	strb	r2, [r3, #10]
}
    5768:	4770      	bx	lr
    576a:	46c0      	nop			; (mov r8, r8)
    576c:	200007a0 	.word	0x200007a0
    5770:	41005000 	.word	0x41005000

00005774 <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup>:
{
	return _usbConfiguration != 0;
}

bool USBDeviceClass::handleClassInterfaceSetup(USBSetup& setup)
{
    5774:	b510      	push	{r4, lr}
	uint8_t i = setup.wIndex;

	#if defined(CDC_ENABLED)
	if (CDC_ACM_INTERFACE == i)
    5776:	790b      	ldrb	r3, [r1, #4]
{
	return _usbConfiguration != 0;
}

bool USBDeviceClass::handleClassInterfaceSetup(USBSetup& setup)
{
    5778:	1c0c      	adds	r4, r1, #0
	uint8_t i = setup.wIndex;

	#if defined(CDC_ENABLED)
	if (CDC_ACM_INTERFACE == i)
    577a:	2b00      	cmp	r3, #0
    577c:	d10b      	bne.n	5796 <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup+0x22>
	{
		if (CDC_Setup(setup) == false) {
    577e:	1c08      	adds	r0, r1, #0
    5780:	f000 fd9c 	bl	62bc <_Z9CDC_SetupR8USBSetup>
    5784:	2800      	cmp	r0, #0
    5786:	d104      	bne.n	5792 <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup+0x1e>

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
    5788:	4b09      	ldr	r3, [pc, #36]	; (57b0 <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup+0x3c>)
    578a:	699a      	ldr	r2, [r3, #24]
    578c:	0b92      	lsrs	r2, r2, #14
    578e:	0392      	lsls	r2, r2, #14
    5790:	619a      	str	r2, [r3, #24]
			sendZlp(0);
		}
		return true;
    5792:	2001      	movs	r0, #1
    5794:	e00b      	b.n	57ae <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup+0x3a>
	}
	#endif

	#if defined(PLUGGABLE_USB_ENABLED)
	bool ret = PluggableUSB().setup(setup);
    5796:	f000 fe2b 	bl	63f0 <_Z12PluggableUSBv>
    579a:	1c21      	adds	r1, r4, #0
    579c:	f000 fe16 	bl	63cc <_ZN13PluggableUSB_5setupER8USBSetup>
	if ( ret == false) {
    57a0:	2800      	cmp	r0, #0
    57a2:	d1f6      	bne.n	5792 <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup+0x1e>
    57a4:	4b02      	ldr	r3, [pc, #8]	; (57b0 <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup+0x3c>)
    57a6:	699a      	ldr	r2, [r3, #24]
    57a8:	0b92      	lsrs	r2, r2, #14
    57aa:	0392      	lsls	r2, r2, #14
    57ac:	619a      	str	r2, [r3, #24]
	}
	return ret;
	#endif

	return false;
}
    57ae:	bd10      	pop	{r4, pc}
    57b0:	200007a0 	.word	0x200007a0

000057b4 <_ZN14USBDeviceClass6initEPEmm>:
		initEP(i, EndPoints[i]);
	}
}

void USBDeviceClass::initEP(uint32_t ep, uint32_t config)
{
    57b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    57b6:	1c0d      	adds	r5, r1, #0
	if (config == (USB_ENDPOINT_TYPE_INTERRUPT | USB_ENDPOINT_IN(0)))
    57b8:	2a83      	cmp	r2, #131	; 0x83
    57ba:	d116      	bne.n	57ea <_ZN14USBDeviceClass6initEPEmm+0x36>
    57bc:	b2ca      	uxtb	r2, r1
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
	inline void epBank0SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
	inline void epBank1SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
    57be:	4942      	ldr	r1, [pc, #264]	; (58c8 <_ZN14USBDeviceClass6initEPEmm+0x114>)
    57c0:	0153      	lsls	r3, r2, #5
    57c2:	18cb      	adds	r3, r1, r3
    57c4:	699c      	ldr	r4, [r3, #24]
    57c6:	4841      	ldr	r0, [pc, #260]	; (58cc <_ZN14USBDeviceClass6initEPEmm+0x118>)
	{
		usbd.epBank1SetSize(ep, 64);
		usbd.epBank1SetAddress(ep, &udd_ep_in_cache_buffer[ep]);
    57c8:	01ad      	lsls	r5, r5, #6
    57ca:	4020      	ands	r0, r4
    57cc:	24c0      	movs	r4, #192	; 0xc0
    57ce:	05a4      	lsls	r4, r4, #22
    57d0:	4320      	orrs	r0, r4
    57d2:	6198      	str	r0, [r3, #24]
    57d4:	483e      	ldr	r0, [pc, #248]	; (58d0 <_ZN14USBDeviceClass6initEPEmm+0x11c>)
	// USB Device Endpoints function mapping
	// -------------------------------------

	// Config
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
	inline void epBank1SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = type; }
    57d6:	3208      	adds	r2, #8
    57d8:	1945      	adds	r5, r0, r5
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
    57da:	615d      	str	r5, [r3, #20]
	// USB Device Endpoints function mapping
	// -------------------------------------

	// Config
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
	inline void epBank1SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = type; }
    57dc:	680b      	ldr	r3, [r1, #0]
    57de:	0152      	lsls	r2, r2, #5
    57e0:	5cd1      	ldrb	r1, [r2, r3]
    57e2:	2070      	movs	r0, #112	; 0x70
    57e4:	4381      	bics	r1, r0
    57e6:	2040      	movs	r0, #64	; 0x40
    57e8:	e065      	b.n	58b6 <_ZN14USBDeviceClass6initEPEmm+0x102>
		usbd.epBank1SetType(ep, 4); // INTERRUPT IN
	}
	else if (config == (USB_ENDPOINT_TYPE_BULK | USB_ENDPOINT_OUT(0)))
    57ea:	2a02      	cmp	r2, #2
    57ec:	d145      	bne.n	587a <_ZN14USBDeviceClass6initEPEmm+0xc6>
	{
		epHandlers[ep] = new DoubleBufferedEPOutHandler(usbd, ep, 256);
    57ee:	2038      	movs	r0, #56	; 0x38
    57f0:	f000 fd0b 	bl	620a <_Znwj>
		usbd(usbDev),
		ep(endPoint), size(bufferSize),
		current(0), incoming(0),
		first0(0), last0(0), ready0(false),
		first1(0), last1(0), ready1(false),
		notify(false)
    57f4:	4b37      	ldr	r3, [pc, #220]	; (58d4 <_ZN14USBDeviceClass6initEPEmm+0x120>)
    57f6:	4f34      	ldr	r7, [pc, #208]	; (58c8 <_ZN14USBDeviceClass6initEPEmm+0x114>)
    57f8:	2680      	movs	r6, #128	; 0x80
    57fa:	6003      	str	r3, [r0, #0]
    57fc:	0076      	lsls	r6, r6, #1
    57fe:	2300      	movs	r3, #0
    5800:	1d42      	adds	r2, r0, #5
    5802:	6203      	str	r3, [r0, #32]
    5804:	6103      	str	r3, [r0, #16]
    5806:	6143      	str	r3, [r0, #20]
    5808:	61c3      	str	r3, [r0, #28]
    580a:	6047      	str	r7, [r0, #4]
    580c:	6085      	str	r5, [r0, #8]
    580e:	60c6      	str	r6, [r0, #12]
    5810:	77d3      	strb	r3, [r2, #31]
    5812:	322f      	adds	r2, #47	; 0x2f
    5814:	1c04      	adds	r4, r0, #0
    5816:	62c3      	str	r3, [r0, #44]	; 0x2c
    5818:	6303      	str	r3, [r0, #48]	; 0x30
    581a:	7013      	strb	r3, [r2, #0]
	{
		data0 = reinterpret_cast<uint8_t *>(malloc(size));
    581c:	1c30      	adds	r0, r6, #0
		usbd(usbDev),
		ep(endPoint), size(bufferSize),
		current(0), incoming(0),
		first0(0), last0(0), ready0(false),
		first1(0), last1(0), ready1(false),
		notify(false)
    581e:	7053      	strb	r3, [r2, #1]
	{
		data0 = reinterpret_cast<uint8_t *>(malloc(size));
    5820:	f002 fd80 	bl	8324 <malloc>
    5824:	61a0      	str	r0, [r4, #24]
		data1 = reinterpret_cast<uint8_t *>(malloc(size));
    5826:	1c30      	adds	r0, r6, #0
    5828:	f002 fd7c 	bl	8324 <malloc>
    582c:	23ff      	movs	r3, #255	; 0xff
    582e:	1c2a      	adds	r2, r5, #0
    5830:	401a      	ands	r2, r3
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
	inline void epBank0SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
    5832:	0152      	lsls	r2, r2, #5
		first0(0), last0(0), ready0(false),
		first1(0), last1(0), ready1(false),
		notify(false)
	{
		data0 = reinterpret_cast<uint8_t *>(malloc(size));
		data1 = reinterpret_cast<uint8_t *>(malloc(size));
    5834:	62a0      	str	r0, [r4, #40]	; 0x28
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
	inline void epBank0SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
    5836:	18bf      	adds	r7, r7, r2
    5838:	68b9      	ldr	r1, [r7, #8]
    583a:	4a24      	ldr	r2, [pc, #144]	; (58cc <_ZN14USBDeviceClass6initEPEmm+0x118>)

	// USB Device Endpoints function mapping
	// -------------------------------------

	// Config
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
    583c:	2607      	movs	r6, #7
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
	inline void epBank0SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
    583e:	400a      	ands	r2, r1
    5840:	21c0      	movs	r1, #192	; 0xc0
    5842:	0589      	lsls	r1, r1, #22
    5844:	430a      	orrs	r2, r1
    5846:	60ba      	str	r2, [r7, #8]
    5848:	68a1      	ldr	r1, [r4, #8]

	// USB Device Endpoints function mapping
	// -------------------------------------

	// Config
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
    584a:	6862      	ldr	r2, [r4, #4]
    584c:	4019      	ands	r1, r3
    584e:	6812      	ldr	r2, [r2, #0]
    5850:	3108      	adds	r1, #8
    5852:	0149      	lsls	r1, r1, #5
    5854:	5c88      	ldrb	r0, [r1, r2]
    5856:	00ad      	lsls	r5, r5, #2
    5858:	43b0      	bics	r0, r6
    585a:	2603      	movs	r6, #3
    585c:	4330      	orrs	r0, r6
    585e:	5488      	strb	r0, [r1, r2]
    5860:	68a1      	ldr	r1, [r4, #8]
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
    5862:	6862      	ldr	r2, [r4, #4]
    5864:	400b      	ands	r3, r1
    5866:	015b      	lsls	r3, r3, #5
    5868:	69a1      	ldr	r1, [r4, #24]
    586a:	18d3      	adds	r3, r2, r3
    586c:	6059      	str	r1, [r3, #4]
		usbd.epBank0SetSize(ep, 64);
		usbd.epBank0SetType(ep, 3); // BULK OUT

		usbd.epBank0SetAddress(ep, const_cast<uint8_t *>(data0));

		release();
    586e:	1c20      	adds	r0, r4, #0
    5870:	f7ff fd76 	bl	5360 <_ZN26DoubleBufferedEPOutHandler7releaseEv>
    5874:	4b18      	ldr	r3, [pc, #96]	; (58d8 <_ZN14USBDeviceClass6initEPEmm+0x124>)
    5876:	50ec      	str	r4, [r5, r3]
    5878:	e025      	b.n	58c6 <_ZN14USBDeviceClass6initEPEmm+0x112>
	}
	else if (config == (USB_ENDPOINT_TYPE_BULK | USB_ENDPOINT_IN(0)))
    587a:	2a82      	cmp	r2, #130	; 0x82
    587c:	d11e      	bne.n	58bc <_ZN14USBDeviceClass6initEPEmm+0x108>
    587e:	b2ca      	uxtb	r2, r1
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
	inline void epBank0SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
	inline void epBank1SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
    5880:	4911      	ldr	r1, [pc, #68]	; (58c8 <_ZN14USBDeviceClass6initEPEmm+0x114>)
    5882:	0153      	lsls	r3, r2, #5
    5884:	18cb      	adds	r3, r1, r3
    5886:	699c      	ldr	r4, [r3, #24]
    5888:	4810      	ldr	r0, [pc, #64]	; (58cc <_ZN14USBDeviceClass6initEPEmm+0x118>)
	{
		usbd.epBank1SetSize(ep, 64);
		usbd.epBank1SetAddress(ep, &udd_ep_in_cache_buffer[ep]);
    588a:	01ad      	lsls	r5, r5, #6
    588c:	4020      	ands	r0, r4
    588e:	24c0      	movs	r4, #192	; 0xc0
    5890:	05a4      	lsls	r4, r4, #22
    5892:	4320      	orrs	r0, r4
    5894:	6198      	str	r0, [r3, #24]
    5896:	480e      	ldr	r0, [pc, #56]	; (58d0 <_ZN14USBDeviceClass6initEPEmm+0x11c>)
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
	inline void epBank1ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK1RDY = 1; }
    5898:	3208      	adds	r2, #8
    589a:	1945      	adds	r5, r0, r5
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
    589c:	615d      	str	r5, [r3, #20]
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
	inline void epBank1ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK1RDY = 1; }
    589e:	680b      	ldr	r3, [r1, #0]
    58a0:	0152      	lsls	r2, r2, #5
    58a2:	1899      	adds	r1, r3, r2
    58a4:	790c      	ldrb	r4, [r1, #4]
    58a6:	2080      	movs	r0, #128	; 0x80
    58a8:	4240      	negs	r0, r0
    58aa:	4320      	orrs	r0, r4
    58ac:	7108      	strb	r0, [r1, #4]
	// USB Device Endpoints function mapping
	// -------------------------------------

	// Config
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
	inline void epBank1SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = type; }
    58ae:	5cd1      	ldrb	r1, [r2, r3]
    58b0:	2070      	movs	r0, #112	; 0x70
    58b2:	4381      	bics	r1, r0
    58b4:	2030      	movs	r0, #48	; 0x30
    58b6:	4301      	orrs	r1, r0
    58b8:	54d1      	strb	r1, [r2, r3]
    58ba:	e004      	b.n	58c6 <_ZN14USBDeviceClass6initEPEmm+0x112>
		// NAK on endpoint IN, the bank is not yet filled in.
		usbd.epBank1ResetReady(ep);

		usbd.epBank1SetType(ep, 3); // BULK IN
	}
	else if (config == USB_ENDPOINT_TYPE_CONTROL)
    58bc:	2a00      	cmp	r2, #0
    58be:	d102      	bne.n	58c6 <_ZN14USBDeviceClass6initEPEmm+0x112>
    58c0:	1c08      	adds	r0, r1, #0
    58c2:	f7ff fc8d 	bl	51e0 <_ZN14USBDeviceClass6initEPEmm.part.4>
		usbd.epBank0SetByteCount(ep, 0);

		// NAK on endpoint OUT, the bank is full.
		usbd.epBank0SetReady(ep);
	}
}
    58c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    58c8:	200007a0 	.word	0x200007a0
    58cc:	8fffffff 	.word	0x8fffffff
    58d0:	200003f4 	.word	0x200003f4
    58d4:	00009128 	.word	0x00009128
    58d8:	20000778 	.word	0x20000778

000058dc <_ZN14USBDeviceClass13initEndpointsEv>:
	0,
	0,
#endif
};

void USBDeviceClass::initEndpoints() {
    58dc:	b538      	push	{r3, r4, r5, lr}
    58de:	1c05      	adds	r5, r0, #0
	for (uint8_t i = 1; i < sizeof(EndPoints) && EndPoints[i] != 0; i++) {
    58e0:	2401      	movs	r4, #1
    58e2:	4b06      	ldr	r3, [pc, #24]	; (58fc <_ZN14USBDeviceClass13initEndpointsEv+0x20>)
    58e4:	00a2      	lsls	r2, r4, #2
    58e6:	58d2      	ldr	r2, [r2, r3]
    58e8:	2a00      	cmp	r2, #0
    58ea:	d006      	beq.n	58fa <_ZN14USBDeviceClass13initEndpointsEv+0x1e>
		initEP(i, EndPoints[i]);
    58ec:	1c21      	adds	r1, r4, #0
    58ee:	1c28      	adds	r0, r5, #0
	0,
#endif
};

void USBDeviceClass::initEndpoints() {
	for (uint8_t i = 1; i < sizeof(EndPoints) && EndPoints[i] != 0; i++) {
    58f0:	3401      	adds	r4, #1
		initEP(i, EndPoints[i]);
    58f2:	f7ff ff5f 	bl	57b4 <_ZN14USBDeviceClass6initEPEmm>
	0,
#endif
};

void USBDeviceClass::initEndpoints() {
	for (uint8_t i = 1; i < sizeof(EndPoints) && EndPoints[i] != 0; i++) {
    58f6:	b2e4      	uxtb	r4, r4
    58f8:	e7f3      	b.n	58e2 <_ZN14USBDeviceClass13initEndpointsEv+0x6>
		initEP(i, EndPoints[i]);
	}
}
    58fa:	bd38      	pop	{r3, r4, r5, pc}
    58fc:	2000000c 	.word	0x2000000c

00005900 <_ZN14USBDeviceClass9availableEm>:
	return read;
}

// Number of bytes, assumes a rx endpoint
uint32_t USBDeviceClass::available(uint32_t ep)
{
    5900:	b508      	push	{r3, lr}
	if (epHandlers[ep]) {
    5902:	4b08      	ldr	r3, [pc, #32]	; (5924 <_ZN14USBDeviceClass9availableEm+0x24>)
    5904:	008a      	lsls	r2, r1, #2
    5906:	58d0      	ldr	r0, [r2, r3]
    5908:	2800      	cmp	r0, #0
    590a:	d003      	beq.n	5914 <_ZN14USBDeviceClass9availableEm+0x14>
		return epHandlers[ep]->available();
    590c:	6803      	ldr	r3, [r0, #0]
    590e:	689b      	ldr	r3, [r3, #8]
    5910:	4798      	blx	r3
    5912:	e006      	b.n	5922 <_ZN14USBDeviceClass9availableEm+0x22>
    5914:	b2c9      	uxtb	r1, r1
	inline void epBank1SetStallReq(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.STALLRQ1 = 1; }
	inline void epBank0ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ0 = 1; }
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
    5916:	4b04      	ldr	r3, [pc, #16]	; (5928 <_ZN14USBDeviceClass9availableEm+0x28>)
    5918:	0149      	lsls	r1, r1, #5
    591a:	1859      	adds	r1, r3, r1
    591c:	6888      	ldr	r0, [r1, #8]
    591e:	0480      	lsls	r0, r0, #18
    5920:	0c80      	lsrs	r0, r0, #18
	} else {
		return usbd.epBank0ByteCount(ep);
	}
}
    5922:	bd08      	pop	{r3, pc}
    5924:	20000778 	.word	0x20000778
    5928:	200007a0 	.word	0x200007a0

0000592c <_ZN14USBDeviceClass5flushEm>:
		usbd.epBank0SetReady(ep);
	}
}

void USBDeviceClass::flush(uint32_t ep)
{
    592c:	b510      	push	{r4, lr}
    592e:	1c0c      	adds	r4, r1, #0
	if (available(ep)) {
    5930:	f7ff ffe6 	bl	5900 <_ZN14USBDeviceClass9availableEm>
    5934:	2800      	cmp	r0, #0
    5936:	d00c      	beq.n	5952 <_ZN14USBDeviceClass5flushEm+0x26>

	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
    5938:	4b06      	ldr	r3, [pc, #24]	; (5954 <_ZN14USBDeviceClass5flushEm+0x28>)
    593a:	b2e1      	uxtb	r1, r4
    593c:	681b      	ldr	r3, [r3, #0]
    593e:	3108      	adds	r1, #8
    5940:	0149      	lsls	r1, r1, #5
    5942:	1859      	adds	r1, r3, r1
    5944:	794a      	ldrb	r2, [r1, #5]
    5946:	2380      	movs	r3, #128	; 0x80
    5948:	425b      	negs	r3, r3
    594a:	4313      	orrs	r3, r2
    594c:	714b      	strb	r3, [r1, #5]

	inline void epBank0AckSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP; }
	inline void epBank0AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(1); }
	inline void epBank1AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(2); }
	inline void epBank0AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(1); }
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }
    594e:	2302      	movs	r3, #2
    5950:	71cb      	strb	r3, [r1, #7]
		usbd.epBank1SetReady(ep);

	 	// Clear the transfer complete flag
		usbd.epBank1AckTransferComplete(ep);
	}
}
    5952:	bd10      	pop	{r4, pc}
    5954:	200007a0 	.word	0x200007a0

00005958 <_ZN14USBDeviceClass14armRecvCtrlOUTEm>:
		return c;
	}
}

uint8_t USBDeviceClass::armRecvCtrlOUT(uint32_t ep)
{
    5958:	b570      	push	{r4, r5, r6, lr}
    595a:	b2ca      	uxtb	r2, r1
	// Get endpoint configuration from setting register
	usbd.epBank0SetAddress(ep, &udd_ep_out_cache_buffer[ep]);
    595c:	4b13      	ldr	r3, [pc, #76]	; (59ac <_ZN14USBDeviceClass14armRecvCtrlOUTEm+0x54>)
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
    595e:	4814      	ldr	r0, [pc, #80]	; (59b0 <_ZN14USBDeviceClass14armRecvCtrlOUTEm+0x58>)
    5960:	0154      	lsls	r4, r2, #5
    5962:	0189      	lsls	r1, r1, #6
    5964:	1859      	adds	r1, r3, r1
    5966:	1903      	adds	r3, r0, r4
    5968:	6059      	str	r1, [r3, #4]
	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
    596a:	689d      	ldr	r5, [r3, #8]
    596c:	4911      	ldr	r1, [pc, #68]	; (59b4 <_ZN14USBDeviceClass14armRecvCtrlOUTEm+0x5c>)
	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
    596e:	3208      	adds	r2, #8
	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
    5970:	4029      	ands	r1, r5
    5972:	2580      	movs	r5, #128	; 0x80
    5974:	02ad      	lsls	r5, r5, #10
    5976:	4329      	orrs	r1, r5
    5978:	6099      	str	r1, [r3, #8]
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
    597a:	6899      	ldr	r1, [r3, #8]
	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
    597c:	2640      	movs	r6, #64	; 0x40
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
    597e:	0b89      	lsrs	r1, r1, #14
    5980:	0389      	lsls	r1, r1, #14
    5982:	6099      	str	r1, [r3, #8]
	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
    5984:	6803      	ldr	r3, [r0, #0]
    5986:	0151      	lsls	r1, r2, #5
    5988:	1859      	adds	r1, r3, r1
    598a:	790d      	ldrb	r5, [r1, #4]
    598c:	4335      	orrs	r5, r6
    598e:	710d      	strb	r5, [r1, #4]
	inline void epBank1DisableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENCLR.bit.STALL1 = 1; }
	inline void epBank0DisableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENCLR.bit.TRCPT0 = 1; }
	inline void epBank1DisableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENCLR.bit.TRCPT1 = 1; }

	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
    5990:	0151      	lsls	r1, r2, #5
    5992:	1859      	adds	r1, r3, r1
    5994:	7989      	ldrb	r1, [r1, #6]
	usbd.epBank0SetByteCount(ep, 0);

	usbd.epBank0ResetReady(ep);

	// Wait OUT
	while (!usbd.epBank0IsReady(ep)) {}
    5996:	064d      	lsls	r5, r1, #25
    5998:	d5fa      	bpl.n	5990 <_ZN14USBDeviceClass14armRecvCtrlOUTEm+0x38>
	inline uint16_t epInterruptSummary() { return usb.EPINTSMRY.reg; }

	inline bool epBank0IsSetupReceived(ep_t ep)     { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.RXSTP; }
	inline bool epBank0IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL0; }
	inline bool epBank1IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL1; }
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
    599a:	0151      	lsls	r1, r2, #5
    599c:	1859      	adds	r1, r3, r1
    599e:	79c9      	ldrb	r1, [r1, #7]
	while (!usbd.epBank0IsTransferComplete(ep)) {}
    59a0:	07cd      	lsls	r5, r1, #31
    59a2:	d5fa      	bpl.n	599a <_ZN14USBDeviceClass14armRecvCtrlOUTEm+0x42>
	inline void epBank1SetStallReq(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.STALLRQ1 = 1; }
	inline void epBank0ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ0 = 1; }
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
    59a4:	1904      	adds	r4, r0, r4
    59a6:	68a0      	ldr	r0, [r4, #8]
	return usbd.epBank0ByteCount(ep);
    59a8:	b2c0      	uxtb	r0, r0
}
    59aa:	bd70      	pop	{r4, r5, r6, pc}
    59ac:	200005b8 	.word	0x200005b8
    59b0:	200007a0 	.word	0x200007a0
    59b4:	f0003fff 	.word	0xf0003fff

000059b8 <_ZN14USBDeviceClass11recvControlEPvm>:
	return f != USB->DEVICE.FNUM.bit.FNUM;
}


uint32_t USBDeviceClass::recvControl(void *_data, uint32_t len)
{
    59b8:	b538      	push	{r3, r4, r5, lr}
	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
    59ba:	4b0c      	ldr	r3, [pc, #48]	; (59ec <_ZN14USBDeviceClass11recvControlEPvm+0x34>)
    59bc:	1c14      	adds	r4, r2, #0
    59be:	681b      	ldr	r3, [r3, #0]
    59c0:	1c0d      	adds	r5, r1, #0
    59c2:	33ff      	adds	r3, #255	; 0xff
    59c4:	795a      	ldrb	r2, [r3, #5]
    59c6:	2140      	movs	r1, #64	; 0x40
    59c8:	430a      	orrs	r2, r1
    59ca:	715a      	strb	r2, [r3, #5]

	// The RAM Buffer is empty: we can receive data
	usbd.epBank0ResetReady(0);

	//usbd.epBank0AckSetupReceived(0);
	uint32_t read = armRecvCtrlOUT(0);
    59cc:	2100      	movs	r1, #0
    59ce:	f7ff ffc3 	bl	5958 <_ZN14USBDeviceClass14armRecvCtrlOUTEm>
    59d2:	42a0      	cmp	r0, r4
    59d4:	d900      	bls.n	59d8 <_ZN14USBDeviceClass11recvControlEPvm+0x20>
    59d6:	1c20      	adds	r0, r4, #0
	if (read > len)
		read = len;
	//while (!usbd.epBank0AckTransferComplete(0)) {}
	uint8_t *buffer = udd_ep_out_cache_buffer[0];
	for (uint32_t i=0; i<len; i++) {
    59d8:	2300      	movs	r3, #0
    59da:	42a3      	cmp	r3, r4
    59dc:	d004      	beq.n	59e8 <_ZN14USBDeviceClass11recvControlEPvm+0x30>
		data[i] = buffer[i];
    59de:	4a04      	ldr	r2, [pc, #16]	; (59f0 <_ZN14USBDeviceClass11recvControlEPvm+0x38>)
    59e0:	5c9a      	ldrb	r2, [r3, r2]
    59e2:	54ea      	strb	r2, [r5, r3]
	uint32_t read = armRecvCtrlOUT(0);
	if (read > len)
		read = len;
	//while (!usbd.epBank0AckTransferComplete(0)) {}
	uint8_t *buffer = udd_ep_out_cache_buffer[0];
	for (uint32_t i=0; i<len; i++) {
    59e4:	3301      	adds	r3, #1
    59e6:	e7f8      	b.n	59da <_ZN14USBDeviceClass11recvControlEPvm+0x22>
		data[i] = buffer[i];
	}

	return read;
}
    59e8:	bd38      	pop	{r3, r4, r5, pc}
    59ea:	46c0      	nop			; (mov r8, r8)
    59ec:	200007a0 	.word	0x200007a0
    59f0:	200005b8 	.word	0x200005b8

000059f4 <_ZN14USBDeviceClass7armRecvEm>:
	while (!usbd.epBank0IsTransferComplete(ep)) {}
	return usbd.epBank0ByteCount(ep);
}

uint8_t USBDeviceClass::armRecv(uint32_t ep)
{
    59f4:	b510      	push	{r4, lr}
    59f6:	b2c9      	uxtb	r1, r1
	inline void epBank1SetStallReq(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.STALLRQ1 = 1; }
	inline void epBank0ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ0 = 1; }
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
    59f8:	480c      	ldr	r0, [pc, #48]	; (5a2c <_ZN14USBDeviceClass7armRecvEm+0x38>)
    59fa:	0149      	lsls	r1, r1, #5
    59fc:	1843      	adds	r3, r0, r1
    59fe:	689a      	ldr	r2, [r3, #8]
    5a00:	0492      	lsls	r2, r2, #18
    5a02:	0c92      	lsrs	r2, r2, #18
	uint16_t count = usbd.epBank0ByteCount(ep);
	if (count >= 64) {
    5a04:	2a3f      	cmp	r2, #63	; 0x3f
    5a06:	d908      	bls.n	5a1a <_ZN14USBDeviceClass7armRecvEm+0x26>
		usbd.epBank0SetByteCount(ep, count - 64);
    5a08:	1c14      	adds	r4, r2, #0
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
    5a0a:	689a      	ldr	r2, [r3, #8]
    5a0c:	3c40      	subs	r4, #64	; 0x40
    5a0e:	04a4      	lsls	r4, r4, #18
    5a10:	0b92      	lsrs	r2, r2, #14
    5a12:	0ca4      	lsrs	r4, r4, #18
    5a14:	0392      	lsls	r2, r2, #14
    5a16:	4322      	orrs	r2, r4
    5a18:	e002      	b.n	5a20 <_ZN14USBDeviceClass7armRecvEm+0x2c>
    5a1a:	689a      	ldr	r2, [r3, #8]
    5a1c:	0b92      	lsrs	r2, r2, #14
    5a1e:	0392      	lsls	r2, r2, #14
    5a20:	609a      	str	r2, [r3, #8]
	inline void epBank1SetStallReq(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.STALLRQ1 = 1; }
	inline void epBank0ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ0 = 1; }
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
    5a22:	1841      	adds	r1, r0, r1
    5a24:	6888      	ldr	r0, [r1, #8]
	} else {
		usbd.epBank0SetByteCount(ep, 0);
	}
	return usbd.epBank0ByteCount(ep);
    5a26:	b2c0      	uxtb	r0, r0
}
    5a28:	bd10      	pop	{r4, pc}
    5a2a:	46c0      	nop			; (mov r8, r8)
    5a2c:	200007a0 	.word	0x200007a0

00005a30 <_ZN14USBDeviceClass4recvEmPvm>:
}

// Non Blocking receive
// Return number of bytes read
uint32_t USBDeviceClass::recv(uint32_t ep, void *_data, uint32_t len)
{
    5a30:	b5f0      	push	{r4, r5, r6, r7, lr}
    5a32:	1c1c      	adds	r4, r3, #0
	if (!_usbConfiguration)
    5a34:	4b2f      	ldr	r3, [pc, #188]	; (5af4 <_ZN14USBDeviceClass4recvEmPvm+0xc4>)
}

// Non Blocking receive
// Return number of bytes read
uint32_t USBDeviceClass::recv(uint32_t ep, void *_data, uint32_t len)
{
    5a36:	b085      	sub	sp, #20
	if (!_usbConfiguration)
    5a38:	681b      	ldr	r3, [r3, #0]
}

// Non Blocking receive
// Return number of bytes read
uint32_t USBDeviceClass::recv(uint32_t ep, void *_data, uint32_t len)
{
    5a3a:	1c06      	adds	r6, r0, #0
    5a3c:	1c0d      	adds	r5, r1, #0
    5a3e:	9202      	str	r2, [sp, #8]
	if (!_usbConfiguration)
    5a40:	2b00      	cmp	r3, #0
    5a42:	d051      	beq.n	5ae8 <_ZN14USBDeviceClass4recvEmPvm+0xb8>
		return -1;

#ifdef PIN_LED_RXL
	if (rxLEDPulse == 0)
    5a44:	4f2c      	ldr	r7, [pc, #176]	; (5af8 <_ZN14USBDeviceClass4recvEmPvm+0xc8>)
    5a46:	7839      	ldrb	r1, [r7, #0]
    5a48:	b2c9      	uxtb	r1, r1
    5a4a:	2900      	cmp	r1, #0
    5a4c:	d102      	bne.n	5a54 <_ZN14USBDeviceClass4recvEmPvm+0x24>
		digitalWrite(PIN_LED_RXL, LOW);
    5a4e:	2019      	movs	r0, #25
    5a50:	f7fe fec2 	bl	47d8 <digitalWrite>

	rxLEDPulse = TX_RX_LED_PULSE_MS;
    5a54:	2364      	movs	r3, #100	; 0x64
    5a56:	703b      	strb	r3, [r7, #0]
#endif

	if (epHandlers[ep]) {
    5a58:	4b28      	ldr	r3, [pc, #160]	; (5afc <_ZN14USBDeviceClass4recvEmPvm+0xcc>)
    5a5a:	00aa      	lsls	r2, r5, #2
    5a5c:	58d0      	ldr	r0, [r2, r3]
    5a5e:	2800      	cmp	r0, #0
    5a60:	d005      	beq.n	5a6e <_ZN14USBDeviceClass4recvEmPvm+0x3e>
		return epHandlers[ep]->recv(_data, len);
    5a62:	6803      	ldr	r3, [r0, #0]
    5a64:	9902      	ldr	r1, [sp, #8]
    5a66:	685b      	ldr	r3, [r3, #4]
    5a68:	1c22      	adds	r2, r4, #0
    5a6a:	4798      	blx	r3
    5a6c:	e040      	b.n	5af0 <_ZN14USBDeviceClass4recvEmPvm+0xc0>
	}

	if (available(ep) < len)
    5a6e:	1c30      	adds	r0, r6, #0
    5a70:	1c29      	adds	r1, r5, #0
    5a72:	f7ff ff45 	bl	5900 <_ZN14USBDeviceClass9availableEm>
    5a76:	42a0      	cmp	r0, r4
    5a78:	d204      	bcs.n	5a84 <_ZN14USBDeviceClass4recvEmPvm+0x54>
		len = available(ep);
    5a7a:	1c30      	adds	r0, r6, #0
    5a7c:	1c29      	adds	r1, r5, #0
    5a7e:	f7ff ff3f 	bl	5900 <_ZN14USBDeviceClass9availableEm>
    5a82:	1c04      	adds	r4, r0, #0

	armRecv(ep);
    5a84:	1c29      	adds	r1, r5, #0
    5a86:	1c30      	adds	r0, r6, #0
    5a88:	f7ff ffb4 	bl	59f4 <_ZN14USBDeviceClass7armRecvEm>
	inline void epBank1EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT1 = 1; }

	inline void epBank0DisableSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTENCLR.bit.RXSTP = 1; }
	inline void epBank0DisableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENCLR.bit.STALL0 = 1; }
	inline void epBank1DisableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENCLR.bit.STALL1 = 1; }
	inline void epBank0DisableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENCLR.bit.TRCPT0 = 1; }
    5a8c:	4f1c      	ldr	r7, [pc, #112]	; (5b00 <_ZN14USBDeviceClass4recvEmPvm+0xd0>)
    5a8e:	b2e9      	uxtb	r1, r5
    5a90:	014a      	lsls	r2, r1, #5
    5a92:	9101      	str	r1, [sp, #4]
    5a94:	6839      	ldr	r1, [r7, #0]
    5a96:	9203      	str	r2, [sp, #12]
    5a98:	188b      	adds	r3, r1, r2
    5a9a:	33ff      	adds	r3, #255	; 0xff
    5a9c:	7a5a      	ldrb	r2, [r3, #9]
    5a9e:	2101      	movs	r1, #1
    5aa0:	430a      	orrs	r2, r1

	usbd.epBank0DisableTransferComplete(ep);

	memcpy(_data, udd_ep_out_cache_buffer[ep], len);
    5aa2:	4918      	ldr	r1, [pc, #96]	; (5b04 <_ZN14USBDeviceClass4recvEmPvm+0xd4>)
    5aa4:	725a      	strb	r2, [r3, #9]
    5aa6:	01ab      	lsls	r3, r5, #6
    5aa8:	18c9      	adds	r1, r1, r3
    5aaa:	9802      	ldr	r0, [sp, #8]
    5aac:	1c22      	adds	r2, r4, #0
    5aae:	f002 fc43 	bl	8338 <memcpy>

	// release empty buffer
	if (len && !available(ep)) {
    5ab2:	2c00      	cmp	r4, #0
    5ab4:	d01b      	beq.n	5aee <_ZN14USBDeviceClass4recvEmPvm+0xbe>
    5ab6:	1c30      	adds	r0, r6, #0
    5ab8:	1c29      	adds	r1, r5, #0
    5aba:	f7ff ff21 	bl	5900 <_ZN14USBDeviceClass9availableEm>
    5abe:	2800      	cmp	r0, #0
    5ac0:	d115      	bne.n	5aee <_ZN14USBDeviceClass4recvEmPvm+0xbe>
	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
    5ac2:	9b01      	ldr	r3, [sp, #4]
    5ac4:	683a      	ldr	r2, [r7, #0]
    5ac6:	3308      	adds	r3, #8
    5ac8:	015b      	lsls	r3, r3, #5
    5aca:	18d3      	adds	r3, r2, r3
    5acc:	7919      	ldrb	r1, [r3, #4]
    5ace:	2040      	movs	r0, #64	; 0x40
    5ad0:	4301      	orrs	r1, r0
    5ad2:	7119      	strb	r1, [r3, #4]
	inline bool epBank1IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT1; }

	inline void epBank0AckSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP; }
	inline void epBank0AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(1); }
	inline void epBank1AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(2); }
	inline void epBank0AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(1); }
    5ad4:	2101      	movs	r1, #1
    5ad6:	71d9      	strb	r1, [r3, #7]
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }

	inline void epBank0EnableSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTENSET.bit.RXSTP = 1; }
	inline void epBank0EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL0 = 1; }
	inline void epBank1EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL1 = 1; }
	inline void epBank0EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT0 = 1; }
    5ad8:	9903      	ldr	r1, [sp, #12]
    5ada:	1853      	adds	r3, r2, r1
    5adc:	33ff      	adds	r3, #255	; 0xff
    5ade:	7a9a      	ldrb	r2, [r3, #10]
    5ae0:	2101      	movs	r1, #1
    5ae2:	430a      	orrs	r2, r1
    5ae4:	729a      	strb	r2, [r3, #10]
    5ae6:	e002      	b.n	5aee <_ZN14USBDeviceClass4recvEmPvm+0xbe>
// Non Blocking receive
// Return number of bytes read
uint32_t USBDeviceClass::recv(uint32_t ep, void *_data, uint32_t len)
{
	if (!_usbConfiguration)
		return -1;
    5ae8:	2001      	movs	r0, #1
    5aea:	4240      	negs	r0, r0
    5aec:	e000      	b.n	5af0 <_ZN14USBDeviceClass4recvEmPvm+0xc0>
    5aee:	1c20      	adds	r0, r4, #0
		// Enable Transfer complete 0 interrupt
		usbd.epBank0EnableTransferComplete(ep);
	}

	return len;
}
    5af0:	b005      	add	sp, #20
    5af2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5af4:	200008a4 	.word	0x200008a4
    5af8:	2000079c 	.word	0x2000079c
    5afc:	20000778 	.word	0x20000778
    5b00:	200007a0 	.word	0x200007a0
    5b04:	200005b8 	.word	0x200005b8

00005b08 <_ZN14USBDeviceClass4recvEm>:

// Recv 1 byte if ready
int USBDeviceClass::recv(uint32_t ep)
{
    5b08:	b513      	push	{r0, r1, r4, lr}
	uint8_t c;
	if (recv(ep, &c, 1) != 1) {
    5b0a:	466c      	mov	r4, sp
    5b0c:	3407      	adds	r4, #7
    5b0e:	1c22      	adds	r2, r4, #0
    5b10:	2301      	movs	r3, #1
    5b12:	f7ff ff8d 	bl	5a30 <_ZN14USBDeviceClass4recvEmPvm>
    5b16:	2801      	cmp	r0, #1
    5b18:	d101      	bne.n	5b1e <_ZN14USBDeviceClass4recvEm+0x16>
		return -1;
	} else {
		return c;
    5b1a:	7820      	ldrb	r0, [r4, #0]
    5b1c:	e001      	b.n	5b22 <_ZN14USBDeviceClass4recvEm+0x1a>
// Recv 1 byte if ready
int USBDeviceClass::recv(uint32_t ep)
{
	uint8_t c;
	if (recv(ep, &c, 1) != 1) {
		return -1;
    5b1e:	2001      	movs	r0, #1
    5b20:	4240      	negs	r0, r0
	} else {
		return c;
	}
}
    5b22:	bd16      	pop	{r1, r2, r4, pc}

00005b24 <_ZN14USBDeviceClass4sendEmPKvm>:
	0
};

// Blocking Send of data to an endpoint
uint32_t USBDeviceClass::send(uint32_t ep, const void *data, uint32_t len)
{
    5b24:	b5f0      	push	{r4, r5, r6, r7, lr}
    5b26:	1c1c      	adds	r4, r3, #0
	uint32_t written = 0;
	uint32_t length = 0;

	if (!_usbConfiguration)
    5b28:	4b3f      	ldr	r3, [pc, #252]	; (5c28 <_ZN14USBDeviceClass4sendEmPKvm+0x104>)
	0
};

// Blocking Send of data to an endpoint
uint32_t USBDeviceClass::send(uint32_t ep, const void *data, uint32_t len)
{
    5b2a:	b085      	sub	sp, #20
	uint32_t written = 0;
	uint32_t length = 0;

	if (!_usbConfiguration)
    5b2c:	681b      	ldr	r3, [r3, #0]
	0
};

// Blocking Send of data to an endpoint
uint32_t USBDeviceClass::send(uint32_t ep, const void *data, uint32_t len)
{
    5b2e:	1c0e      	adds	r6, r1, #0
    5b30:	9202      	str	r2, [sp, #8]
	uint32_t written = 0;
	uint32_t length = 0;

	if (!_usbConfiguration)
    5b32:	2b00      	cmp	r3, #0
    5b34:	d06a      	beq.n	5c0c <_ZN14USBDeviceClass4sendEmPKvm+0xe8>
		return -1;
	if (len > 16384)
    5b36:	2380      	movs	r3, #128	; 0x80
    5b38:	01db      	lsls	r3, r3, #7
    5b3a:	429c      	cmp	r4, r3
    5b3c:	d866      	bhi.n	5c0c <_ZN14USBDeviceClass4sendEmPKvm+0xe8>
		return -1;

#ifdef PIN_LED_TXL
	if (txLEDPulse == 0)
    5b3e:	4d3b      	ldr	r5, [pc, #236]	; (5c2c <_ZN14USBDeviceClass4sendEmPKvm+0x108>)
    5b40:	7829      	ldrb	r1, [r5, #0]
    5b42:	b2c9      	uxtb	r1, r1
    5b44:	2900      	cmp	r1, #0
    5b46:	d102      	bne.n	5b4e <_ZN14USBDeviceClass4sendEmPKvm+0x2a>
		digitalWrite(PIN_LED_TXL, LOW);
    5b48:	201a      	movs	r0, #26
    5b4a:	f7fe fe45 	bl	47d8 <digitalWrite>

	txLEDPulse = TX_RX_LED_PULSE_MS;
    5b4e:	2364      	movs	r3, #100	; 0x64
};

// Blocking Send of data to an endpoint
uint32_t USBDeviceClass::send(uint32_t ep, const void *data, uint32_t len)
{
	uint32_t written = 0;
    5b50:	2200      	movs	r2, #0

#ifdef PIN_LED_TXL
	if (txLEDPulse == 0)
		digitalWrite(PIN_LED_TXL, LOW);

	txLEDPulse = TX_RX_LED_PULSE_MS;
    5b52:	702b      	strb	r3, [r5, #0]
};

// Blocking Send of data to an endpoint
uint32_t USBDeviceClass::send(uint32_t ep, const void *data, uint32_t len)
{
	uint32_t written = 0;
    5b54:	9200      	str	r2, [sp, #0]

	txLEDPulse = TX_RX_LED_PULSE_MS;
#endif

	// Flash area
	while (len != 0)
    5b56:	2c00      	cmp	r4, #0
    5b58:	d056      	beq.n	5c08 <_ZN14USBDeviceClass4sendEmPKvm+0xe4>
	inline void epBank0DisableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENCLR.bit.TRCPT0 = 1; }
	inline void epBank1DisableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENCLR.bit.TRCPT1 = 1; }

	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
    5b5a:	4d35      	ldr	r5, [pc, #212]	; (5c30 <_ZN14USBDeviceClass4sendEmPKvm+0x10c>)
    5b5c:	b2f7      	uxtb	r7, r6
    5b5e:	682b      	ldr	r3, [r5, #0]
    5b60:	9301      	str	r3, [sp, #4]
    5b62:	1c3b      	adds	r3, r7, #0
    5b64:	3308      	adds	r3, #8
    5b66:	9a01      	ldr	r2, [sp, #4]
    5b68:	015b      	lsls	r3, r3, #5
    5b6a:	18d3      	adds	r3, r2, r3
    5b6c:	799b      	ldrb	r3, [r3, #6]
    5b6e:	09db      	lsrs	r3, r3, #7
	{
		if (usbd.epBank1IsReady(ep)) {
    5b70:	d01a      	beq.n	5ba8 <_ZN14USBDeviceClass4sendEmPKvm+0x84>
			// previous transfer is still not complete

			// convert the timeout from microseconds to a number of times through
			// the wait loop; it takes (roughly) 23 clock cycles per iteration.
			uint32_t timeout = microsecondsToClockCycles(TX_TIMEOUT_MS * 1000) / 23;
    5b72:	4b30      	ldr	r3, [pc, #192]	; (5c34 <_ZN14USBDeviceClass4sendEmPKvm+0x110>)
    5b74:	4930      	ldr	r1, [pc, #192]	; (5c38 <_ZN14USBDeviceClass4sendEmPKvm+0x114>)
    5b76:	6818      	ldr	r0, [r3, #0]
    5b78:	f000 fc86 	bl	6488 <__aeabi_uidiv>
    5b7c:	4b2f      	ldr	r3, [pc, #188]	; (5c3c <_ZN14USBDeviceClass4sendEmPKvm+0x118>)
    5b7e:	2117      	movs	r1, #23
    5b80:	4358      	muls	r0, r3
    5b82:	f000 fc81 	bl	6488 <__aeabi_uidiv>

	inline bool epBank0IsSetupReceived(ep_t ep)     { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.RXSTP; }
	inline bool epBank0IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL0; }
	inline bool epBank1IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL1; }
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
	inline bool epBank1IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT1; }
    5b86:	1c3b      	adds	r3, r7, #0
    5b88:	3308      	adds	r3, #8
    5b8a:	9a01      	ldr	r2, [sp, #4]
    5b8c:	015b      	lsls	r3, r3, #5
    5b8e:	18d3      	adds	r3, r2, r3
    5b90:	79db      	ldrb	r3, [r3, #7]

			// Wait for (previous) transfer to complete
			// inspired by Paul Stoffregen's work on Teensy
			while (!usbd.epBank1IsTransferComplete(ep)) {
    5b92:	079a      	lsls	r2, r3, #30
    5b94:	d408      	bmi.n	5ba8 <_ZN14USBDeviceClass4sendEmPKvm+0x84>
				if (LastTransmitTimedOut[ep] || timeout-- == 0) {
    5b96:	4b2a      	ldr	r3, [pc, #168]	; (5c40 <_ZN14USBDeviceClass4sendEmPKvm+0x11c>)
    5b98:	5d9a      	ldrb	r2, [r3, r6]
    5b9a:	2a00      	cmp	r2, #0
    5b9c:	d138      	bne.n	5c10 <_ZN14USBDeviceClass4sendEmPKvm+0xec>
    5b9e:	1e42      	subs	r2, r0, #1
    5ba0:	2800      	cmp	r0, #0
    5ba2:	d035      	beq.n	5c10 <_ZN14USBDeviceClass4sendEmPKvm+0xec>
    5ba4:	1c10      	adds	r0, r2, #0
    5ba6:	e7ee      	b.n	5b86 <_ZN14USBDeviceClass4sendEmPKvm+0x62>
					return -1;
				}
			}
		}

		LastTransmitTimedOut[ep] = 0;
    5ba8:	4b25      	ldr	r3, [pc, #148]	; (5c40 <_ZN14USBDeviceClass4sendEmPKvm+0x11c>)
    5baa:	2200      	movs	r2, #0
    5bac:	559a      	strb	r2, [r3, r6]
    5bae:	1e25      	subs	r5, r4, #0
    5bb0:	2d3f      	cmp	r5, #63	; 0x3f
    5bb2:	d900      	bls.n	5bb6 <_ZN14USBDeviceClass4sendEmPKvm+0x92>
    5bb4:	253f      	movs	r5, #63	; 0x3f
		} else {
			length = len;
		}

		/* memcopy could be safer in multi threaded environment */
		memcpy(&udd_ep_in_cache_buffer[ep], data, length);
    5bb6:	4a23      	ldr	r2, [pc, #140]	; (5c44 <_ZN14USBDeviceClass4sendEmPKvm+0x120>)
    5bb8:	01b3      	lsls	r3, r6, #6
    5bba:	18d3      	adds	r3, r2, r3
    5bbc:	1c18      	adds	r0, r3, #0
    5bbe:	9902      	ldr	r1, [sp, #8]
    5bc0:	1c2a      	adds	r2, r5, #0
    5bc2:	9303      	str	r3, [sp, #12]
    5bc4:	f002 fbb8 	bl	8338 <memcpy>
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
    5bc8:	4a19      	ldr	r2, [pc, #100]	; (5c30 <_ZN14USBDeviceClass4sendEmPKvm+0x10c>)
    5bca:	017b      	lsls	r3, r7, #5
    5bcc:	18d3      	adds	r3, r2, r3
    5bce:	9a03      	ldr	r2, [sp, #12]

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
    5bd0:	04a9      	lsls	r1, r5, #18
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
    5bd2:	615a      	str	r2, [r3, #20]

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
    5bd4:	699a      	ldr	r2, [r3, #24]
    5bd6:	0c89      	lsrs	r1, r1, #18
    5bd8:	0b92      	lsrs	r2, r2, #14
    5bda:	0392      	lsls	r2, r2, #14
    5bdc:	430a      	orrs	r2, r1
    5bde:	619a      	str	r2, [r3, #24]

	inline void epBank0AckSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP; }
	inline void epBank0AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(1); }
	inline void epBank1AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(2); }
	inline void epBank0AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(1); }
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }
    5be0:	1c3b      	adds	r3, r7, #0
    5be2:	9a01      	ldr	r2, [sp, #4]
    5be4:	3308      	adds	r3, #8
    5be6:	015b      	lsls	r3, r3, #5
    5be8:	18d3      	adds	r3, r2, r3
    5bea:	2202      	movs	r2, #2
    5bec:	71da      	strb	r2, [r3, #7]

	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
    5bee:	7959      	ldrb	r1, [r3, #5]
    5bf0:	2280      	movs	r2, #128	; 0x80
    5bf2:	4252      	negs	r2, r2
    5bf4:	430a      	orrs	r2, r1
    5bf6:	715a      	strb	r2, [r3, #5]
		usbd.epBank1AckTransferComplete(ep);

		// RAM buffer is full, we can send data (IN)
		usbd.epBank1SetReady(ep);

		written += length;
    5bf8:	9b00      	ldr	r3, [sp, #0]
		len -= length;
		data = (char *)data + length;
    5bfa:	9a02      	ldr	r2, [sp, #8]
		usbd.epBank1AckTransferComplete(ep);

		// RAM buffer is full, we can send data (IN)
		usbd.epBank1SetReady(ep);

		written += length;
    5bfc:	195b      	adds	r3, r3, r5
		len -= length;
		data = (char *)data + length;
    5bfe:	1952      	adds	r2, r2, r5
		usbd.epBank1AckTransferComplete(ep);

		// RAM buffer is full, we can send data (IN)
		usbd.epBank1SetReady(ep);

		written += length;
    5c00:	9300      	str	r3, [sp, #0]
		len -= length;
    5c02:	1b64      	subs	r4, r4, r5
		data = (char *)data + length;
    5c04:	9202      	str	r2, [sp, #8]
    5c06:	e7a6      	b.n	5b56 <_ZN14USBDeviceClass4sendEmPKvm+0x32>
    5c08:	9800      	ldr	r0, [sp, #0]
    5c0a:	e00b      	b.n	5c24 <_ZN14USBDeviceClass4sendEmPKvm+0x100>
{
	uint32_t written = 0;
	uint32_t length = 0;

	if (!_usbConfiguration)
		return -1;
    5c0c:	2001      	movs	r0, #1
    5c0e:	e008      	b.n	5c22 <_ZN14USBDeviceClass4sendEmPKvm+0xfe>

			// Wait for (previous) transfer to complete
			// inspired by Paul Stoffregen's work on Teensy
			while (!usbd.epBank1IsTransferComplete(ep)) {
				if (LastTransmitTimedOut[ep] || timeout-- == 0) {
					LastTransmitTimedOut[ep] = 1;
    5c10:	2201      	movs	r2, #1
    5c12:	559a      	strb	r2, [r3, r6]

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
    5c14:	017b      	lsls	r3, r7, #5
    5c16:	18ed      	adds	r5, r5, r3
    5c18:	69ab      	ldr	r3, [r5, #24]

					// set byte count to zero, so that ZLP is sent
					// instead of stale data
					usbd.epBank1SetByteCount(ep, 0);
					return -1;
    5c1a:	1c10      	adds	r0, r2, #0
    5c1c:	0b9b      	lsrs	r3, r3, #14
    5c1e:	039b      	lsls	r3, r3, #14
    5c20:	61ab      	str	r3, [r5, #24]
    5c22:	4240      	negs	r0, r0
		written += length;
		len -= length;
		data = (char *)data + length;
	}
	return written;
}
    5c24:	b005      	add	sp, #20
    5c26:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5c28:	200008a4 	.word	0x200008a4
    5c2c:	200005b4 	.word	0x200005b4
    5c30:	200007a0 	.word	0x200007a0
    5c34:	20000004 	.word	0x20000004
    5c38:	000f4240 	.word	0x000f4240
    5c3c:	00011170 	.word	0x00011170
    5c40:	200003ec 	.word	0x200003ec
    5c44:	200003f4 	.word	0x200003f4

00005c48 <_ZN14USBDeviceClass7armSendEmPKvm>:

uint32_t USBDeviceClass::armSend(uint32_t ep, const void* data, uint32_t len)
{
    5c48:	b570      	push	{r4, r5, r6, lr}
	memcpy(&udd_ep_in_cache_buffer[ep], data, len);
    5c4a:	4d0e      	ldr	r5, [pc, #56]	; (5c84 <_ZN14USBDeviceClass7armSendEmPKvm+0x3c>)
	}
	return written;
}

uint32_t USBDeviceClass::armSend(uint32_t ep, const void* data, uint32_t len)
{
    5c4c:	1c1c      	adds	r4, r3, #0
	memcpy(&udd_ep_in_cache_buffer[ep], data, len);
    5c4e:	018b      	lsls	r3, r1, #6
    5c50:	18ed      	adds	r5, r5, r3
    5c52:	1c28      	adds	r0, r5, #0
	}
	return written;
}

uint32_t USBDeviceClass::armSend(uint32_t ep, const void* data, uint32_t len)
{
    5c54:	1c0e      	adds	r6, r1, #0
	memcpy(&udd_ep_in_cache_buffer[ep], data, len);
    5c56:	1c11      	adds	r1, r2, #0
    5c58:	1c22      	adds	r2, r4, #0
    5c5a:	f002 fb6d 	bl	8338 <memcpy>
    5c5e:	b2f6      	uxtb	r6, r6
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
    5c60:	4909      	ldr	r1, [pc, #36]	; (5c88 <_ZN14USBDeviceClass7armSendEmPKvm+0x40>)
    5c62:	0176      	lsls	r6, r6, #5
    5c64:	1989      	adds	r1, r1, r6
    5c66:	614d      	str	r5, [r1, #20]
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
    5c68:	698a      	ldr	r2, [r1, #24]
    5c6a:	4b08      	ldr	r3, [pc, #32]	; (5c8c <_ZN14USBDeviceClass7armSendEmPKvm+0x44>)
	usbd.epBank1SetAddress(ep, &udd_ep_in_cache_buffer[ep]);
	usbd.epBank1SetMultiPacketSize(ep, 0);
	usbd.epBank1SetByteCount(ep, len);

	return len;
}
    5c6c:	1c20      	adds	r0, r4, #0
    5c6e:	4013      	ands	r3, r2
    5c70:	618b      	str	r3, [r1, #24]

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
    5c72:	698b      	ldr	r3, [r1, #24]
    5c74:	04a2      	lsls	r2, r4, #18
    5c76:	0b9b      	lsrs	r3, r3, #14
    5c78:	0c92      	lsrs	r2, r2, #18
    5c7a:	039b      	lsls	r3, r3, #14
    5c7c:	4313      	orrs	r3, r2
    5c7e:	618b      	str	r3, [r1, #24]
    5c80:	bd70      	pop	{r4, r5, r6, pc}
    5c82:	46c0      	nop			; (mov r8, r8)
    5c84:	200003f4 	.word	0x200003f4
    5c88:	200007a0 	.word	0x200007a0
    5c8c:	f0003fff 	.word	0xf0003fff

00005c90 <_ZN14USBDeviceClass11sendControlEPKvm>:

uint32_t USBDeviceClass::sendControl(const void* _data, uint32_t len)
{
    5c90:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	const uint8_t *data = reinterpret_cast<const uint8_t *>(_data);
	uint32_t length = len;
	uint32_t sent = 0;
	uint32_t pos = 0;

	if (_dry_run == true)
    5c92:	4b11      	ldr	r3, [pc, #68]	; (5cd8 <_ZN14USBDeviceClass11sendControlEPKvm+0x48>)

	return len;
}

uint32_t USBDeviceClass::sendControl(const void* _data, uint32_t len)
{
    5c94:	9001      	str	r0, [sp, #4]
	const uint8_t *data = reinterpret_cast<const uint8_t *>(_data);
	uint32_t length = len;
	uint32_t sent = 0;
	uint32_t pos = 0;

	if (_dry_run == true)
    5c96:	781b      	ldrb	r3, [r3, #0]

	return len;
}

uint32_t USBDeviceClass::sendControl(const void* _data, uint32_t len)
{
    5c98:	1c0f      	adds	r7, r1, #0
    5c9a:	1c14      	adds	r4, r2, #0
	const uint8_t *data = reinterpret_cast<const uint8_t *>(_data);
	uint32_t length = len;
	uint32_t sent = 0;
	uint32_t pos = 0;

	if (_dry_run == true)
    5c9c:	2b00      	cmp	r3, #0
    5c9e:	d119      	bne.n	5cd4 <_ZN14USBDeviceClass11sendControlEPKvm+0x44>
		return length;

	if (_pack_message == true) {
    5ca0:	4b0e      	ldr	r3, [pc, #56]	; (5cdc <_ZN14USBDeviceClass11sendControlEPKvm+0x4c>)
    5ca2:	781e      	ldrb	r6, [r3, #0]
    5ca4:	2e00      	cmp	r6, #0
    5ca6:	d101      	bne.n	5cac <_ZN14USBDeviceClass11sendControlEPKvm+0x1c>
    5ca8:	1c15      	adds	r5, r2, #0
    5caa:	e008      	b.n	5cbe <_ZN14USBDeviceClass11sendControlEPKvm+0x2e>
		memcpy(&_pack_buffer[_pack_size], data, len);
    5cac:	4d0c      	ldr	r5, [pc, #48]	; (5ce0 <_ZN14USBDeviceClass11sendControlEPKvm+0x50>)
    5cae:	480d      	ldr	r0, [pc, #52]	; (5ce4 <_ZN14USBDeviceClass11sendControlEPKvm+0x54>)
    5cb0:	882e      	ldrh	r6, [r5, #0]
    5cb2:	1980      	adds	r0, r0, r6
		_pack_size += len;
    5cb4:	1936      	adds	r6, r6, r4

	if (_dry_run == true)
		return length;

	if (_pack_message == true) {
		memcpy(&_pack_buffer[_pack_size], data, len);
    5cb6:	f002 fb3f 	bl	8338 <memcpy>
		_pack_size += len;
    5cba:	802e      	strh	r6, [r5, #0]
    5cbc:	e00a      	b.n	5cd4 <_ZN14USBDeviceClass11sendControlEPKvm+0x44>
		return length;
	}

 	while (len > 0)
    5cbe:	2d00      	cmp	r5, #0
    5cc0:	d008      	beq.n	5cd4 <_ZN14USBDeviceClass11sendControlEPKvm+0x44>
 	{
		sent = armSend(EP0, data + pos, len);
    5cc2:	19ba      	adds	r2, r7, r6
    5cc4:	1c2b      	adds	r3, r5, #0
    5cc6:	9801      	ldr	r0, [sp, #4]
    5cc8:	2100      	movs	r1, #0
    5cca:	f7ff ffbd 	bl	5c48 <_ZN14USBDeviceClass7armSendEmPKvm>
		pos += sent;
    5cce:	1836      	adds	r6, r6, r0
		len -= sent;
    5cd0:	1a2d      	subs	r5, r5, r0
    5cd2:	e7f4      	b.n	5cbe <_ZN14USBDeviceClass11sendControlEPKvm+0x2e>
 	}

	return length;
}
    5cd4:	1c20      	adds	r0, r4, #0
    5cd6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    5cd8:	20000796 	.word	0x20000796
    5cdc:	20000794 	.word	0x20000794
    5ce0:	200003ea 	.word	0x200003ea
    5ce4:	200002e9 	.word	0x200002e9

00005ce8 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh>:

// Send a USB descriptor string. The string is stored as a
// plain ASCII string but is sent out as UTF-16 with the
// correct 2-byte prefix
bool USBDeviceClass::sendStringDescriptor(const uint8_t *string, uint8_t maxlen)
{
    5ce8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5cea:	1c0e      	adds	r6, r1, #0
    5cec:	af00      	add	r7, sp, #0
    5cee:	1e15      	subs	r5, r2, #0
	if (maxlen < 2)
    5cf0:	2d01      	cmp	r5, #1
    5cf2:	d928      	bls.n	5d46 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x5e>
		return false;

	uint8_t buffer[maxlen];
    5cf4:	1dd3      	adds	r3, r2, #7
    5cf6:	08db      	lsrs	r3, r3, #3
    5cf8:	00db      	lsls	r3, r3, #3
    5cfa:	466a      	mov	r2, sp
    5cfc:	1ad2      	subs	r2, r2, r3
    5cfe:	4695      	mov	sp, r2
	buffer[0] = strlen((const char*)string) * 2 + 2;
    5d00:	1c08      	adds	r0, r1, #0
    5d02:	f002 fb91 	bl	8428 <strlen>
    5d06:	3001      	adds	r0, #1
bool USBDeviceClass::sendStringDescriptor(const uint8_t *string, uint8_t maxlen)
{
	if (maxlen < 2)
		return false;

	uint8_t buffer[maxlen];
    5d08:	466c      	mov	r4, sp
	buffer[0] = strlen((const char*)string) * 2 + 2;
    5d0a:	0040      	lsls	r0, r0, #1
	buffer[1] = 0x03;
    5d0c:	2303      	movs	r3, #3
{
	if (maxlen < 2)
		return false;

	uint8_t buffer[maxlen];
	buffer[0] = strlen((const char*)string) * 2 + 2;
    5d0e:	7020      	strb	r0, [r4, #0]
	buffer[1] = 0x03;
    5d10:	7063      	strb	r3, [r4, #1]

	uint8_t i;
	for (i = 2; i < maxlen && *string; i++) {
    5d12:	2202      	movs	r2, #2
    5d14:	42aa      	cmp	r2, r5
    5d16:	d20e      	bcs.n	5d36 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x4e>
    5d18:	7833      	ldrb	r3, [r6, #0]
    5d1a:	2b00      	cmp	r3, #0
    5d1c:	d00b      	beq.n	5d36 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x4e>
		buffer[i++] = *string++;
    5d1e:	1c51      	adds	r1, r2, #1
    5d20:	b2c9      	uxtb	r1, r1
    5d22:	3601      	adds	r6, #1
    5d24:	54a3      	strb	r3, [r4, r2]
		if (i == maxlen) break;
    5d26:	42a9      	cmp	r1, r5
    5d28:	d004      	beq.n	5d34 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x4c>
		buffer[i] = 0;
    5d2a:	2300      	movs	r3, #0
	uint8_t buffer[maxlen];
	buffer[0] = strlen((const char*)string) * 2 + 2;
	buffer[1] = 0x03;

	uint8_t i;
	for (i = 2; i < maxlen && *string; i++) {
    5d2c:	3202      	adds	r2, #2
		buffer[i++] = *string++;
		if (i == maxlen) break;
		buffer[i] = 0;
    5d2e:	5463      	strb	r3, [r4, r1]
	uint8_t buffer[maxlen];
	buffer[0] = strlen((const char*)string) * 2 + 2;
	buffer[1] = 0x03;

	uint8_t i;
	for (i = 2; i < maxlen && *string; i++) {
    5d30:	b2d2      	uxtb	r2, r2
    5d32:	e7ef      	b.n	5d14 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x2c>
		buffer[i++] = *string++;
    5d34:	1c2a      	adds	r2, r5, #0
		if (i == maxlen) break;
		buffer[i] = 0;
	}

	return USBDevice.sendControl(buffer, i);
    5d36:	4805      	ldr	r0, [pc, #20]	; (5d4c <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x64>)
    5d38:	1c21      	adds	r1, r4, #0
    5d3a:	f7ff ffa9 	bl	5c90 <_ZN14USBDeviceClass11sendControlEPKvm>
    5d3e:	1e43      	subs	r3, r0, #1
    5d40:	4198      	sbcs	r0, r3
    5d42:	b2c0      	uxtb	r0, r0
    5d44:	e000      	b.n	5d48 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x60>
// plain ASCII string but is sent out as UTF-16 with the
// correct 2-byte prefix
bool USBDeviceClass::sendStringDescriptor(const uint8_t *string, uint8_t maxlen)
{
	if (maxlen < 2)
		return false;
    5d46:	2000      	movs	r0, #0
		if (i == maxlen) break;
		buffer[i] = 0;
	}

	return USBDevice.sendControl(buffer, i);
}
    5d48:	46bd      	mov	sp, r7
    5d4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5d4c:	20000797 	.word	0x20000797

00005d50 <_ZN14USBDeviceClass12packMessagesEb.part.6>:
bool _dry_run = false;
bool _pack_message = false;
uint16_t _pack_size = 0;
uint8_t _pack_buffer[256];

void USBDeviceClass::packMessages(bool val)
    5d50:	b508      	push	{r3, lr}
{
	if (val) {
		_pack_message = true;
		_pack_size = 0;
	} else {
		_pack_message = false;
    5d52:	4b04      	ldr	r3, [pc, #16]	; (5d64 <_ZN14USBDeviceClass12packMessagesEb.part.6+0x14>)
    5d54:	2200      	movs	r2, #0
    5d56:	701a      	strb	r2, [r3, #0]
		sendControl(_pack_buffer, _pack_size);
    5d58:	4b03      	ldr	r3, [pc, #12]	; (5d68 <_ZN14USBDeviceClass12packMessagesEb.part.6+0x18>)
    5d5a:	4904      	ldr	r1, [pc, #16]	; (5d6c <_ZN14USBDeviceClass12packMessagesEb.part.6+0x1c>)
    5d5c:	881a      	ldrh	r2, [r3, #0]
    5d5e:	f7ff ff97 	bl	5c90 <_ZN14USBDeviceClass11sendControlEPKvm>
	}
}
    5d62:	bd08      	pop	{r3, pc}
    5d64:	20000794 	.word	0x20000794
    5d68:	200003ea 	.word	0x200003ea
    5d6c:	200002e9 	.word	0x200002e9

00005d70 <_ZN14USBDeviceClass17sendConfigurationEm>:
}

// Construct a dynamic configuration descriptor
// This really needs dynamic endpoint allocation etc
uint32_t USBDeviceClass::sendConfiguration(uint32_t maxlen)
{
    5d70:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t total = 0;
	// Count and measure interfaces
	_dry_run = true;
    5d72:	4a20      	ldr	r2, [pc, #128]	; (5df4 <_ZN14USBDeviceClass17sendConfigurationEm+0x84>)
}

// Construct a dynamic configuration descriptor
// This really needs dynamic endpoint allocation etc
uint32_t USBDeviceClass::sendConfiguration(uint32_t maxlen)
{
    5d74:	b087      	sub	sp, #28
	uint32_t total = 0;
	// Count and measure interfaces
	_dry_run = true;
    5d76:	2301      	movs	r3, #1

// Construct a dynamic configuration descriptor
// This really needs dynamic endpoint allocation etc
uint32_t USBDeviceClass::sendConfiguration(uint32_t maxlen)
{
	uint32_t total = 0;
    5d78:	2600      	movs	r6, #0
}

// Construct a dynamic configuration descriptor
// This really needs dynamic endpoint allocation etc
uint32_t USBDeviceClass::sendConfiguration(uint32_t maxlen)
{
    5d7a:	9100      	str	r1, [sp, #0]
	uint32_t total = 0;
	// Count and measure interfaces
	_dry_run = true;
	uint8_t interfaces = SendInterfaces(&total);
    5d7c:	a902      	add	r1, sp, #8
// This really needs dynamic endpoint allocation etc
uint32_t USBDeviceClass::sendConfiguration(uint32_t maxlen)
{
	uint32_t total = 0;
	// Count and measure interfaces
	_dry_run = true;
    5d7e:	7013      	strb	r3, [r2, #0]
}

// Construct a dynamic configuration descriptor
// This really needs dynamic endpoint allocation etc
uint32_t USBDeviceClass::sendConfiguration(uint32_t maxlen)
{
    5d80:	1c05      	adds	r5, r0, #0
	uint32_t total = 0;
    5d82:	9602      	str	r6, [sp, #8]
	// Count and measure interfaces
	_dry_run = true;
	uint8_t interfaces = SendInterfaces(&total);
    5d84:	f7ff fc0a 	bl	559c <_ZN14USBDeviceClass14SendInterfacesEPm>

	_Pragma("pack(1)")
	ConfigDescriptor config = D_CONFIG((uint16_t)(total + sizeof(ConfigDescriptor)), interfaces);
    5d88:	ac03      	add	r4, sp, #12
    5d8a:	2709      	movs	r7, #9
uint32_t USBDeviceClass::sendConfiguration(uint32_t maxlen)
{
	uint32_t total = 0;
	// Count and measure interfaces
	_dry_run = true;
	uint8_t interfaces = SendInterfaces(&total);
    5d8c:	9001      	str	r0, [sp, #4]

	_Pragma("pack(1)")
	ConfigDescriptor config = D_CONFIG((uint16_t)(total + sizeof(ConfigDescriptor)), interfaces);
    5d8e:	1c3a      	adds	r2, r7, #0
    5d90:	1c20      	adds	r0, r4, #0
    5d92:	1c31      	adds	r1, r6, #0
    5d94:	f002 fad9 	bl	834a <memset>
    5d98:	2302      	movs	r3, #2
    5d9a:	7063      	strb	r3, [r4, #1]
    5d9c:	23a0      	movs	r3, #160	; 0xa0
    5d9e:	71e3      	strb	r3, [r4, #7]
    5da0:	23fa      	movs	r3, #250	; 0xfa
    5da2:	7223      	strb	r3, [r4, #8]
    5da4:	9b02      	ldr	r3, [sp, #8]
    5da6:	2201      	movs	r2, #1
    5da8:	19db      	adds	r3, r3, r7
    5daa:	8063      	strh	r3, [r4, #2]
    5dac:	9b01      	ldr	r3, [sp, #4]
    5dae:	7162      	strb	r2, [r4, #5]
    5db0:	7123      	strb	r3, [r4, #4]
	_Pragma("pack()")

	//	Now send them
	_dry_run = false;
    5db2:	4a10      	ldr	r2, [pc, #64]	; (5df4 <_ZN14USBDeviceClass17sendConfigurationEm+0x84>)

	if (maxlen == sizeof(ConfigDescriptor)) {
    5db4:	9b00      	ldr	r3, [sp, #0]
	// Count and measure interfaces
	_dry_run = true;
	uint8_t interfaces = SendInterfaces(&total);

	_Pragma("pack(1)")
	ConfigDescriptor config = D_CONFIG((uint16_t)(total + sizeof(ConfigDescriptor)), interfaces);
    5db6:	7027      	strb	r7, [r4, #0]
	_Pragma("pack()")

	//	Now send them
	_dry_run = false;
    5db8:	7016      	strb	r6, [r2, #0]

	if (maxlen == sizeof(ConfigDescriptor)) {
    5dba:	42bb      	cmp	r3, r7
    5dbc:	d105      	bne.n	5dca <_ZN14USBDeviceClass17sendConfigurationEm+0x5a>
		sendControl(&config, sizeof(ConfigDescriptor));
    5dbe:	1c28      	adds	r0, r5, #0
    5dc0:	1c21      	adds	r1, r4, #0
    5dc2:	1c1a      	adds	r2, r3, #0
    5dc4:	f7ff ff64 	bl	5c90 <_ZN14USBDeviceClass11sendControlEPKvm>
		return true;
    5dc8:	e011      	b.n	5dee <_ZN14USBDeviceClass17sendConfigurationEm+0x7e>
uint8_t _pack_buffer[256];

void USBDeviceClass::packMessages(bool val)
{
	if (val) {
		_pack_message = true;
    5dca:	4b0b      	ldr	r3, [pc, #44]	; (5df8 <_ZN14USBDeviceClass17sendConfigurationEm+0x88>)
    5dcc:	2201      	movs	r2, #1
    5dce:	701a      	strb	r2, [r3, #0]
		_pack_size = 0;
    5dd0:	4b0a      	ldr	r3, [pc, #40]	; (5dfc <_ZN14USBDeviceClass17sendConfigurationEm+0x8c>)
	}

	total = 0;

	packMessages(true);
	sendControl(&config, sizeof(ConfigDescriptor));
    5dd2:	1c21      	adds	r1, r4, #0
    5dd4:	1c3a      	adds	r2, r7, #0
    5dd6:	1c28      	adds	r0, r5, #0

void USBDeviceClass::packMessages(bool val)
{
	if (val) {
		_pack_message = true;
		_pack_size = 0;
    5dd8:	801e      	strh	r6, [r3, #0]
	if (maxlen == sizeof(ConfigDescriptor)) {
		sendControl(&config, sizeof(ConfigDescriptor));
		return true;
	}

	total = 0;
    5dda:	9602      	str	r6, [sp, #8]

	packMessages(true);
	sendControl(&config, sizeof(ConfigDescriptor));
    5ddc:	f7ff ff58 	bl	5c90 <_ZN14USBDeviceClass11sendControlEPKvm>
	SendInterfaces(&total);
    5de0:	1c28      	adds	r0, r5, #0
    5de2:	a902      	add	r1, sp, #8
    5de4:	f7ff fbda 	bl	559c <_ZN14USBDeviceClass14SendInterfacesEPm>
    5de8:	1c28      	adds	r0, r5, #0
    5dea:	f7ff ffb1 	bl	5d50 <_ZN14USBDeviceClass12packMessagesEb.part.6>
	packMessages(false);

	return true;
}
    5dee:	2001      	movs	r0, #1
    5df0:	b007      	add	sp, #28
    5df2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5df4:	20000796 	.word	0x20000796
    5df8:	20000794 	.word	0x20000794
    5dfc:	200003ea 	.word	0x200003ea

00005e00 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup>:
		s[7 - i] = d > 9 ? 'A' + d - 10 : '0' + d;
	}
}

bool USBDeviceClass::sendDescriptor(USBSetup &setup)
{
    5e00:	b570      	push	{r4, r5, r6, lr}
	uint8_t t = setup.wValueH;
    5e02:	78ce      	ldrb	r6, [r1, #3]
		s[7 - i] = d > 9 ? 'A' + d - 10 : '0' + d;
	}
}

bool USBDeviceClass::sendDescriptor(USBSetup &setup)
{
    5e04:	b092      	sub	sp, #72	; 0x48
    5e06:	1c05      	adds	r5, r0, #0
    5e08:	1c0c      	adds	r4, r1, #0
	uint8_t desc_length = 0;
	bool _cdcComposite;
	int ret;
	const uint8_t *desc_addr = 0;

	if (t == USB_CONFIGURATION_DESCRIPTOR_TYPE)
    5e0a:	2e02      	cmp	r6, #2
    5e0c:	d108      	bne.n	5e20 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x20>
	{
		return USBDevice.sendConfiguration(setup.wLength);
    5e0e:	88c9      	ldrh	r1, [r1, #6]
    5e10:	482d      	ldr	r0, [pc, #180]	; (5ec8 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xc8>)
    5e12:	f7ff ffad 	bl	5d70 <_ZN14USBDeviceClass17sendConfigurationEm>
    5e16:	1c03      	adds	r3, r0, #0
    5e18:	1e58      	subs	r0, r3, #1
    5e1a:	4183      	sbcs	r3, r0
    5e1c:	b2d8      	uxtb	r0, r3
    5e1e:	e051      	b.n	5ec4 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xc4>
	}

#ifdef PLUGGABLE_USB_ENABLED
	ret = PluggableUSB().getDescriptor(setup);
    5e20:	f000 fae6 	bl	63f0 <_Z12PluggableUSBv>
    5e24:	1c21      	adds	r1, r4, #0
    5e26:	f000 fab2 	bl	638e <_ZN13PluggableUSB_13getDescriptorER8USBSetup>
	if (ret != 0) {
    5e2a:	2800      	cmp	r0, #0
    5e2c:	d003      	beq.n	5e36 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x36>
		return (ret > 0 ? true : false);
    5e2e:	17c3      	asrs	r3, r0, #31
    5e30:	1a1b      	subs	r3, r3, r0
    5e32:	0fd8      	lsrs	r0, r3, #31
    5e34:	e046      	b.n	5ec4 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xc4>
	}
#endif

	if (t == USB_DEVICE_DESCRIPTOR_TYPE)
    5e36:	2e01      	cmp	r6, #1
    5e38:	d104      	bne.n	5e44 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x44>
		if (setup.wLength == 8)
			_cdcComposite = 1;

		desc_addr = _cdcComposite ?  (const uint8_t*)&USB_DeviceDescriptorB : (const uint8_t*)&USB_DeviceDescriptor;

		if (*desc_addr > setup.wLength) {
    5e3a:	88e2      	ldrh	r2, [r4, #6]
    5e3c:	4923      	ldr	r1, [pc, #140]	; (5ecc <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xcc>)
    5e3e:	2a11      	cmp	r2, #17
    5e40:	d83b      	bhi.n	5eba <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xba>
    5e42:	e037      	b.n	5eb4 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xb4>
			desc_length = setup.wLength;
		}
	}
	else if (USB_STRING_DESCRIPTOR_TYPE == t)
    5e44:	2e03      	cmp	r6, #3
    5e46:	d13d      	bne.n	5ec4 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xc4>
	{
		if (setup.wValueL == 0) {
    5e48:	78a2      	ldrb	r2, [r4, #2]
    5e4a:	2a00      	cmp	r2, #0
    5e4c:	d105      	bne.n	5e5a <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x5a>
#endif
		}
		else {
			return false;
		}
		if (*desc_addr > setup.wLength) {
    5e4e:	4920      	ldr	r1, [pc, #128]	; (5ed0 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xd0>)
    5e50:	88e2      	ldrh	r2, [r4, #6]
    5e52:	780b      	ldrb	r3, [r1, #0]
    5e54:	4293      	cmp	r3, r2
    5e56:	d82d      	bhi.n	5eb4 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xb4>
    5e58:	e02f      	b.n	5eba <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xba>
	else if (USB_STRING_DESCRIPTOR_TYPE == t)
	{
		if (setup.wValueL == 0) {
			desc_addr = (const uint8_t*)&STRING_LANGUAGE;
		}
		else if (setup.wValueL == IPRODUCT) {
    5e5a:	2a02      	cmp	r2, #2
    5e5c:	d103      	bne.n	5e66 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x66>
			return sendStringDescriptor(STRING_PRODUCT, setup.wLength);
    5e5e:	79a2      	ldrb	r2, [r4, #6]
    5e60:	1c28      	adds	r0, r5, #0
    5e62:	491c      	ldr	r1, [pc, #112]	; (5ed4 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xd4>)
    5e64:	e004      	b.n	5e70 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x70>
		}
		else if (setup.wValueL == IMANUFACTURER) {
    5e66:	2a01      	cmp	r2, #1
    5e68:	d105      	bne.n	5e76 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x76>
			return sendStringDescriptor(STRING_MANUFACTURER, setup.wLength);
    5e6a:	79a2      	ldrb	r2, [r4, #6]
    5e6c:	491a      	ldr	r1, [pc, #104]	; (5ed8 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xd8>)
    5e6e:	1c28      	adds	r0, r5, #0
    5e70:	f7ff ff3a 	bl	5ce8 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh>
    5e74:	e026      	b.n	5ec4 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xc4>
		}
		else if (setup.wValueL == ISERIAL) {
    5e76:	2a03      	cmp	r2, #3
    5e78:	d124      	bne.n	5ec4 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xc4>
			#define SERIAL_NUMBER_WORD_1	*(volatile uint32_t*)(0x0080A040)
			#define SERIAL_NUMBER_WORD_2	*(volatile uint32_t*)(0x0080A044)
			#define SERIAL_NUMBER_WORD_3	*(volatile uint32_t*)(0x0080A048)

			char name[ISERIAL_MAX_LEN];
			utox8(SERIAL_NUMBER_WORD_0, &name[0]);
    5e7a:	4b18      	ldr	r3, [pc, #96]	; (5edc <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xdc>)
    5e7c:	a901      	add	r1, sp, #4
    5e7e:	6818      	ldr	r0, [r3, #0]
    5e80:	f7ff f9a0 	bl	51c4 <_ZL5utox8mPc>
			utox8(SERIAL_NUMBER_WORD_1, &name[8]);
    5e84:	4b16      	ldr	r3, [pc, #88]	; (5ee0 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xe0>)
    5e86:	a903      	add	r1, sp, #12
    5e88:	6818      	ldr	r0, [r3, #0]
    5e8a:	f7ff f99b 	bl	51c4 <_ZL5utox8mPc>
			utox8(SERIAL_NUMBER_WORD_2, &name[16]);
    5e8e:	4b15      	ldr	r3, [pc, #84]	; (5ee4 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xe4>)
    5e90:	a905      	add	r1, sp, #20
    5e92:	6818      	ldr	r0, [r3, #0]
    5e94:	f7ff f996 	bl	51c4 <_ZL5utox8mPc>
			utox8(SERIAL_NUMBER_WORD_3, &name[24]);
    5e98:	4b13      	ldr	r3, [pc, #76]	; (5ee8 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xe8>)
    5e9a:	a907      	add	r1, sp, #28
    5e9c:	6818      	ldr	r0, [r3, #0]
    5e9e:	f7ff f991 	bl	51c4 <_ZL5utox8mPc>

			PluggableUSB().getShortName(&name[32]);
    5ea2:	f000 faa5 	bl	63f0 <_Z12PluggableUSBv>
    5ea6:	a909      	add	r1, sp, #36	; 0x24
    5ea8:	f000 fa81 	bl	63ae <_ZN13PluggableUSB_12getShortNameEPc>
			return sendStringDescriptor((uint8_t*)name, setup.wLength);
    5eac:	79a2      	ldrb	r2, [r4, #6]
    5eae:	1c28      	adds	r0, r5, #0
    5eb0:	a901      	add	r1, sp, #4
    5eb2:	e7dd      	b.n	5e70 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x70>
		}
		else {
			return false;
		}
		if (*desc_addr > setup.wLength) {
			desc_length = setup.wLength;
    5eb4:	b2d2      	uxtb	r2, r2

	if (desc_addr == 0) {
		return false;
	}

	if (desc_length == 0) {
    5eb6:	2a00      	cmp	r2, #0
    5eb8:	d100      	bne.n	5ebc <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xbc>
		desc_length = *desc_addr;
    5eba:	780a      	ldrb	r2, [r1, #0]
	}

	sendControl(desc_addr, desc_length);
    5ebc:	1c28      	adds	r0, r5, #0
    5ebe:	f7ff fee7 	bl	5c90 <_ZN14USBDeviceClass11sendControlEPKvm>

	return true;
    5ec2:	2001      	movs	r0, #1
}
    5ec4:	b012      	add	sp, #72	; 0x48
    5ec6:	bd70      	pop	{r4, r5, r6, pc}
    5ec8:	20000797 	.word	0x20000797
    5ecc:	00009148 	.word	0x00009148
    5ed0:	00009144 	.word	0x00009144
    5ed4:	0000915a 	.word	0x0000915a
    5ed8:	00009138 	.word	0x00009138
    5edc:	0080a00c 	.word	0x0080a00c
    5ee0:	0080a040 	.word	0x0080a040
    5ee4:	0080a044 	.word	0x0080a044
    5ee8:	0080a048 	.word	0x0080a048

00005eec <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup>:
	// Set the byte count as zero
	usbd.epBank1SetByteCount(ep, 0);
}

bool USBDeviceClass::handleStandardSetup(USBSetup &setup)
{
    5eec:	b573      	push	{r0, r1, r4, r5, r6, lr}
    5eee:	1c05      	adds	r5, r0, #0
	switch (setup.bRequest) {
    5ef0:	7848      	ldrb	r0, [r1, #1]
	// Set the byte count as zero
	usbd.epBank1SetByteCount(ep, 0);
}

bool USBDeviceClass::handleStandardSetup(USBSetup &setup)
{
    5ef2:	1c0c      	adds	r4, r1, #0
	switch (setup.bRequest) {
    5ef4:	280b      	cmp	r0, #11
    5ef6:	d878      	bhi.n	5fea <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xfe>
    5ef8:	f000 fabc 	bl	6474 <__gnu_thumb1_case_uqi>
    5efc:	28771c08 	.word	0x28771c08
    5f00:	06433e77 	.word	0x06433e77
    5f04:	6f684b47 	.word	0x6f684b47

	case GET_DESCRIPTOR:
		return sendDescriptor(setup);

	case SET_DESCRIPTOR:
		return false;
    5f08:	2000      	movs	r0, #0
    5f0a:	e06f      	b.n	5fec <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x100>

bool USBDeviceClass::handleStandardSetup(USBSetup &setup)
{
	switch (setup.bRequest) {
	case GET_STATUS:
		if (setup.bmRequestType == 0)  // device
    5f0c:	7809      	ldrb	r1, [r1, #0]
    5f0e:	aa01      	add	r2, sp, #4
    5f10:	2900      	cmp	r1, #0
    5f12:	d103      	bne.n	5f1c <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x30>
		{
			// Send the device status
			// TODO: Check current configuration for power mode (if device is configured)
			// TODO: Check if remote wake-up is enabled
			uint8_t buff[] = { 0, 0 };
    5f14:	7011      	strb	r1, [r2, #0]
    5f16:	7051      	strb	r1, [r2, #1]
			armSend(0, buff, 2);
    5f18:	1c28      	adds	r0, r5, #0
    5f1a:	e009      	b.n	5f30 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x44>
		// if( setup.bmRequestType == 2 ) // Endpoint:
		else
		{
			// Send the endpoint status
			// Check if the endpoint if currently halted
			uint8_t buff[] = { 0, 0 };
    5f1c:	2300      	movs	r3, #0
    5f1e:	7013      	strb	r3, [r2, #0]
    5f20:	7053      	strb	r3, [r2, #1]
			if (isEndpointHalt == 1)
    5f22:	4b33      	ldr	r3, [pc, #204]	; (5ff0 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x104>)
    5f24:	781b      	ldrb	r3, [r3, #0]
    5f26:	2b01      	cmp	r3, #1
    5f28:	d100      	bne.n	5f2c <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x40>
				buff[0] = 1;
    5f2a:	7013      	strb	r3, [r2, #0]
			armSend(0, buff, 2);
    5f2c:	1c28      	adds	r0, r5, #0
    5f2e:	2100      	movs	r1, #0
    5f30:	2302      	movs	r3, #2
    5f32:	e04f      	b.n	5fd4 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xe8>
			return true;
		}

	case CLEAR_FEATURE:
		// Check which is the selected feature
		if (setup.wValueL == 1) // DEVICEREMOTEWAKEUP
    5f34:	788a      	ldrb	r2, [r1, #2]
    5f36:	2300      	movs	r3, #0
    5f38:	2a01      	cmp	r2, #1
    5f3a:	d104      	bne.n	5f46 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x5a>
		{
			// Enable remote wake-up and send a ZLP
			uint8_t buff[] = { 0, 0 };
    5f3c:	aa01      	add	r2, sp, #4
    5f3e:	7013      	strb	r3, [r2, #0]
    5f40:	7053      	strb	r3, [r2, #1]
			if (isRemoteWakeUpEnabled == 1)
    5f42:	4b2c      	ldr	r3, [pc, #176]	; (5ff4 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x108>)
    5f44:	e7ee      	b.n	5f24 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x38>
			armSend(0, buff, 2);
			return true;
		}
		else // if( setup.wValueL == 0) // ENDPOINTHALT
		{
			isEndpointHalt = 0;
    5f46:	4a2a      	ldr	r2, [pc, #168]	; (5ff0 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x104>)
    5f48:	7013      	strb	r3, [r2, #0]
    5f4a:	e049      	b.n	5fe0 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xf4>
			return true;
		}

	case SET_FEATURE:
		// Check which is the selected feature
		if (setup.wValueL == 1) // DEVICEREMOTEWAKEUP
    5f4c:	788e      	ldrb	r6, [r1, #2]
    5f4e:	2e01      	cmp	r6, #1
    5f50:	d107      	bne.n	5f62 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x76>
		{
			// Enable remote wake-up and send a ZLP
			isRemoteWakeUpEnabled = 1;
    5f52:	4b28      	ldr	r3, [pc, #160]	; (5ff4 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x108>)
			uint8_t buff[] = { 0 };
    5f54:	aa01      	add	r2, sp, #4
    5f56:	2100      	movs	r1, #0
	case SET_FEATURE:
		// Check which is the selected feature
		if (setup.wValueL == 1) // DEVICEREMOTEWAKEUP
		{
			// Enable remote wake-up and send a ZLP
			isRemoteWakeUpEnabled = 1;
    5f58:	701e      	strb	r6, [r3, #0]
			uint8_t buff[] = { 0 };
    5f5a:	7011      	strb	r1, [r2, #0]
			armSend(0, buff, 1);
    5f5c:	1c28      	adds	r0, r5, #0
    5f5e:	1c33      	adds	r3, r6, #0
    5f60:	e038      	b.n	5fd4 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xe8>
			return true;
		}
		if (setup.wValueL == 0) // ENDPOINTHALT
    5f62:	2e00      	cmp	r6, #0
    5f64:	d108      	bne.n	5f78 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x8c>
		{
			// Halt endpoint
			isEndpointHalt = 1;
    5f66:	4a22      	ldr	r2, [pc, #136]	; (5ff0 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x104>)
    5f68:	2301      	movs	r3, #1
    5f6a:	7013      	strb	r3, [r2, #0]
    5f6c:	4a22      	ldr	r2, [pc, #136]	; (5ff8 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x10c>)
    5f6e:	6991      	ldr	r1, [r2, #24]
    5f70:	0b89      	lsrs	r1, r1, #14
    5f72:	0389      	lsls	r1, r1, #14
    5f74:	6191      	str	r1, [r2, #24]
    5f76:	e038      	b.n	5fea <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xfe>
			sendZlp(0);
			return true;
		}

	case SET_ADDRESS:
		setAddress(setup.wValueL);
    5f78:	78a1      	ldrb	r1, [r4, #2]
    5f7a:	1c28      	adds	r0, r5, #0
    5f7c:	f7ff fbd6 	bl	572c <_ZN14USBDeviceClass10setAddressEm>
    5f80:	e033      	b.n	5fea <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xfe>
		return true;

	case GET_DESCRIPTOR:
		return sendDescriptor(setup);
    5f82:	1c28      	adds	r0, r5, #0
    5f84:	f7ff ff3c 	bl	5e00 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup>
    5f88:	e030      	b.n	5fec <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x100>

	case SET_DESCRIPTOR:
		return false;

	case GET_CONFIGURATION:
		armSend(0, (void*)&_usbConfiguration, 1);
    5f8a:	1c28      	adds	r0, r5, #0
    5f8c:	2100      	movs	r1, #0
    5f8e:	4a1b      	ldr	r2, [pc, #108]	; (5ffc <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x110>)
    5f90:	e01f      	b.n	5fd2 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xe6>
		return true;

	case SET_CONFIGURATION:
		if (REQUEST_DEVICE == (setup.bmRequestType & REQUEST_RECIPIENT)) {
    5f92:	780a      	ldrb	r2, [r1, #0]
			#endif

			sendZlp(0);
			return true;
		} else {
			return false;
    5f94:	2000      	movs	r0, #0
	case GET_CONFIGURATION:
		armSend(0, (void*)&_usbConfiguration, 1);
		return true;

	case SET_CONFIGURATION:
		if (REQUEST_DEVICE == (setup.bmRequestType & REQUEST_RECIPIENT)) {
    5f96:	06d3      	lsls	r3, r2, #27
    5f98:	d128      	bne.n	5fec <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x100>

			initEndpoints();
    5f9a:	1c28      	adds	r0, r5, #0
    5f9c:	f7ff fc9e 	bl	58dc <_ZN14USBDeviceClass13initEndpointsEv>
			_usbConfiguration = setup.wValueL;
    5fa0:	78a2      	ldrb	r2, [r4, #2]

	inline void epBank0EnableSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTENSET.bit.RXSTP = 1; }
	inline void epBank0EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL0 = 1; }
	inline void epBank1EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL1 = 1; }
	inline void epBank0EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT0 = 1; }
	inline void epBank1EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT1 = 1; }
    5fa2:	4915      	ldr	r1, [pc, #84]	; (5ff8 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x10c>)
    5fa4:	4b15      	ldr	r3, [pc, #84]	; (5ffc <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x110>)
    5fa6:	2402      	movs	r4, #2
    5fa8:	601a      	str	r2, [r3, #0]
    5faa:	680a      	ldr	r2, [r1, #0]
    5fac:	232a      	movs	r3, #42	; 0x2a
    5fae:	33ff      	adds	r3, #255	; 0xff
    5fb0:	5cd0      	ldrb	r0, [r2, r3]
    5fb2:	4320      	orrs	r0, r4
    5fb4:	54d0      	strb	r0, [r2, r3]
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }

	inline void epBank0EnableSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTENSET.bit.RXSTP = 1; }
	inline void epBank0EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL0 = 1; }
	inline void epBank1EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL1 = 1; }
	inline void epBank0EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT0 = 1; }
    5fb6:	204a      	movs	r0, #74	; 0x4a
    5fb8:	30ff      	adds	r0, #255	; 0xff
    5fba:	5c14      	ldrb	r4, [r2, r0]
    5fbc:	2301      	movs	r3, #1
    5fbe:	431c      	orrs	r4, r3
    5fc0:	5414      	strb	r4, [r2, r0]

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
    5fc2:	698a      	ldr	r2, [r1, #24]
    5fc4:	0b92      	lsrs	r2, r2, #14
    5fc6:	0392      	lsls	r2, r2, #14
    5fc8:	618a      	str	r2, [r1, #24]
    5fca:	e00e      	b.n	5fea <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xfe>
		} else {
			return false;
		}

	case GET_INTERFACE:
		armSend(0, (void*)&_usbSetInterface, 1);
    5fcc:	4a0c      	ldr	r2, [pc, #48]	; (6000 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x114>)
    5fce:	1c28      	adds	r0, r5, #0
    5fd0:	2100      	movs	r1, #0
    5fd2:	2301      	movs	r3, #1
    5fd4:	f7ff fe38 	bl	5c48 <_ZN14USBDeviceClass7armSendEmPKvm>
    5fd8:	e007      	b.n	5fea <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xfe>
		return true;

	case SET_INTERFACE:
		_usbSetInterface = setup.wValueL;
    5fda:	788a      	ldrb	r2, [r1, #2]
    5fdc:	4b08      	ldr	r3, [pc, #32]	; (6000 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x114>)
    5fde:	601a      	str	r2, [r3, #0]
    5fe0:	4b05      	ldr	r3, [pc, #20]	; (5ff8 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x10c>)
    5fe2:	699a      	ldr	r2, [r3, #24]
    5fe4:	0b92      	lsrs	r2, r2, #14
    5fe6:	0392      	lsls	r2, r2, #14
    5fe8:	619a      	str	r2, [r3, #24]
		sendZlp(0);
		return true;

	default:
		return true;
    5fea:	2001      	movs	r0, #1
	}
}
    5fec:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    5fee:	46c0      	nop			; (mov r8, r8)
    5ff0:	200002e8 	.word	0x200002e8
    5ff4:	20000795 	.word	0x20000795
    5ff8:	200007a0 	.word	0x200007a0
    5ffc:	200008a4 	.word	0x200008a4
    6000:	20000798 	.word	0x20000798

00006004 <_ZN14USBDeviceClass10ISRHandlerEv>:

void USBDeviceClass::ISRHandler()
{
    6004:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

	if (_pack_message == true) {
    6006:	4b4b      	ldr	r3, [pc, #300]	; (6134 <_ZN14USBDeviceClass10ISRHandlerEv+0x130>)
		return true;
	}
}

void USBDeviceClass::ISRHandler()
{
    6008:	1c07      	adds	r7, r0, #0

	if (_pack_message == true) {
    600a:	781c      	ldrb	r4, [r3, #0]
    600c:	2c00      	cmp	r4, #0
    600e:	d000      	beq.n	6012 <_ZN14USBDeviceClass10ISRHandlerEv+0xe>
    6010:	e08e      	b.n	6130 <_ZN14USBDeviceClass10ISRHandlerEv+0x12c>
	// Authorize attach if Vbus is present
	inline void attach() { usb.CTRLB.bit.DETACH = 0; }
	inline void detach() { usb.CTRLB.bit.DETACH = 1; }

	// USB Interrupts
	inline bool isEndOfResetInterrupt()        { return usb.INTFLAG.bit.EORST; }
    6012:	4d49      	ldr	r5, [pc, #292]	; (6138 <_ZN14USBDeviceClass10ISRHandlerEv+0x134>)
    6014:	6828      	ldr	r0, [r5, #0]
    6016:	8b83      	ldrh	r3, [r0, #28]
		return;
	}
	// End-Of-Reset
	if (usbd.isEndOfResetInterrupt())
    6018:	0719      	lsls	r1, r3, #28
    601a:	d50d      	bpl.n	6038 <_ZN14USBDeviceClass10ISRHandlerEv+0x34>
    601c:	1c20      	adds	r0, r4, #0
    601e:	f7ff f8df 	bl	51e0 <_ZN14USBDeviceClass6initEPEmm.part.4>
	inline void epBank0AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(1); }
	inline void epBank1AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(2); }
	inline void epBank0AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(1); }
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }

	inline void epBank0EnableSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTENSET.bit.RXSTP = 1; }
    6022:	682b      	ldr	r3, [r5, #0]
    6024:	2010      	movs	r0, #16
    6026:	1c1a      	adds	r2, r3, #0
    6028:	32ff      	adds	r2, #255	; 0xff
    602a:	7a91      	ldrb	r1, [r2, #10]
    602c:	4301      	orrs	r1, r0
    602e:	7291      	strb	r1, [r2, #10]
		initEP(0, USB_ENDPOINT_TYPE_CONTROL);

		// Enable Setup-Received interrupt
		usbd.epBank0EnableSetupReceived(0);

		_usbConfiguration = 0;
    6030:	4a42      	ldr	r2, [pc, #264]	; (613c <_ZN14USBDeviceClass10ISRHandlerEv+0x138>)
    6032:	6014      	str	r4, [r2, #0]
	inline void attach() { usb.CTRLB.bit.DETACH = 0; }
	inline void detach() { usb.CTRLB.bit.DETACH = 1; }

	// USB Interrupts
	inline bool isEndOfResetInterrupt()        { return usb.INTFLAG.bit.EORST; }
	inline void ackEndOfResetInterrupt()       { usb.INTFLAG.reg = USB_DEVICE_INTFLAG_EORST; }
    6034:	2208      	movs	r2, #8
    6036:	839a      	strh	r2, [r3, #28]
	inline void enableEndOfResetInterrupt()    { usb.INTENSET.bit.EORST = 1; }
	inline void disableEndOfResetInterrupt()   { usb.INTENCLR.bit.EORST = 1; }

	inline bool isStartOfFrameInterrupt()      { return usb.INTFLAG.bit.SOF; }
    6038:	682b      	ldr	r3, [r5, #0]
    603a:	8b9a      	ldrh	r2, [r3, #28]

		usbd.ackEndOfResetInterrupt();
	}

	// Start-Of-Frame
	if (usbd.isStartOfFrameInterrupt())
    603c:	0750      	lsls	r0, r2, #29
    603e:	d51f      	bpl.n	6080 <_ZN14USBDeviceClass10ISRHandlerEv+0x7c>
	inline void ackStartOfFrameInterrupt()     { usb.INTFLAG.reg = USB_DEVICE_INTFLAG_SOF; }
    6040:	2204      	movs	r2, #4
    6042:	839a      	strh	r2, [r3, #28]
	{
		usbd.ackStartOfFrameInterrupt();

		// check whether the one-shot period has elapsed.  if so, turn off the LED
#ifdef PIN_LED_TXL
		if (txLEDPulse > 0) {
    6044:	4b3e      	ldr	r3, [pc, #248]	; (6140 <_ZN14USBDeviceClass10ISRHandlerEv+0x13c>)
    6046:	781a      	ldrb	r2, [r3, #0]
    6048:	2a00      	cmp	r2, #0
    604a:	d00a      	beq.n	6062 <_ZN14USBDeviceClass10ISRHandlerEv+0x5e>
			txLEDPulse--;
    604c:	781a      	ldrb	r2, [r3, #0]
    604e:	3a01      	subs	r2, #1
    6050:	b2d2      	uxtb	r2, r2
    6052:	701a      	strb	r2, [r3, #0]
			if (txLEDPulse == 0)
    6054:	781b      	ldrb	r3, [r3, #0]
    6056:	2b00      	cmp	r3, #0
    6058:	d103      	bne.n	6062 <_ZN14USBDeviceClass10ISRHandlerEv+0x5e>
				digitalWrite(PIN_LED_TXL, HIGH);
    605a:	201a      	movs	r0, #26
    605c:	2101      	movs	r1, #1
    605e:	f7fe fbbb 	bl	47d8 <digitalWrite>
		}
#endif

#ifdef PIN_LED_RXL
		if (rxLEDPulse > 0) {
    6062:	4b38      	ldr	r3, [pc, #224]	; (6144 <_ZN14USBDeviceClass10ISRHandlerEv+0x140>)
    6064:	781a      	ldrb	r2, [r3, #0]
    6066:	2a00      	cmp	r2, #0
    6068:	d00a      	beq.n	6080 <_ZN14USBDeviceClass10ISRHandlerEv+0x7c>
			rxLEDPulse--;
    606a:	781a      	ldrb	r2, [r3, #0]
    606c:	3a01      	subs	r2, #1
    606e:	b2d2      	uxtb	r2, r2
    6070:	701a      	strb	r2, [r3, #0]
			if (rxLEDPulse == 0)
    6072:	781b      	ldrb	r3, [r3, #0]
    6074:	2b00      	cmp	r3, #0
    6076:	d103      	bne.n	6080 <_ZN14USBDeviceClass10ISRHandlerEv+0x7c>
				digitalWrite(PIN_LED_RXL, HIGH);
    6078:	2019      	movs	r0, #25
    607a:	2101      	movs	r1, #1
    607c:	f7fe fbac 	bl	47d8 <digitalWrite>
	inline void epBank1SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = type; }

	// Interrupts
	inline uint16_t epInterruptSummary() { return usb.EPINTSMRY.reg; }

	inline bool epBank0IsSetupReceived(ep_t ep)     { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.RXSTP; }
    6080:	682b      	ldr	r3, [r5, #0]
    6082:	33ff      	adds	r3, #255	; 0xff
    6084:	7a1a      	ldrb	r2, [r3, #8]
		}
#endif
	}

	// Endpoint 0 Received Setup interrupt
	if (usbd.epBank0IsSetupReceived(0))
    6086:	06d1      	lsls	r1, r2, #27
    6088:	d526      	bpl.n	60d8 <_ZN14USBDeviceClass10ISRHandlerEv+0xd4>
	inline bool epBank0IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL0; }
	inline bool epBank1IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL1; }
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
	inline bool epBank1IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT1; }

	inline void epBank0AckSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP; }
    608a:	2210      	movs	r2, #16
    608c:	721a      	strb	r2, [r3, #8]
	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
    608e:	795a      	ldrb	r2, [r3, #5]
    6090:	2140      	movs	r1, #64	; 0x40
    6092:	430a      	orrs	r2, r1
		/* Clear the Bank 0 ready flag on Control OUT */
		// The RAM Buffer is empty: we can receive data
		usbd.epBank0ResetReady(0);

		bool ok;
		if (REQUEST_STANDARD == (setup->bmRequestType & REQUEST_TYPE)) {
    6094:	492c      	ldr	r1, [pc, #176]	; (6148 <_ZN14USBDeviceClass10ISRHandlerEv+0x144>)
    6096:	715a      	strb	r2, [r3, #5]
    6098:	780a      	ldrb	r2, [r1, #0]
    609a:	2360      	movs	r3, #96	; 0x60
			// Standard Requests
			ok = handleStandardSetup(*setup);
    609c:	1c38      	adds	r0, r7, #0
		/* Clear the Bank 0 ready flag on Control OUT */
		// The RAM Buffer is empty: we can receive data
		usbd.epBank0ResetReady(0);

		bool ok;
		if (REQUEST_STANDARD == (setup->bmRequestType & REQUEST_TYPE)) {
    609e:	421a      	tst	r2, r3
    60a0:	d102      	bne.n	60a8 <_ZN14USBDeviceClass10ISRHandlerEv+0xa4>
			// Standard Requests
			ok = handleStandardSetup(*setup);
    60a2:	f7ff ff23 	bl	5eec <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup>
    60a6:	e001      	b.n	60ac <_ZN14USBDeviceClass10ISRHandlerEv+0xa8>
		} else {
			// Class Interface Requests
			ok = handleClassInterfaceSetup(*setup);
    60a8:	f7ff fb64 	bl	5774 <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup>
		}

		if (ok) {
    60ac:	2800      	cmp	r0, #0
    60ae:	d006      	beq.n	60be <_ZN14USBDeviceClass10ISRHandlerEv+0xba>

	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
    60b0:	682b      	ldr	r3, [r5, #0]
    60b2:	2280      	movs	r2, #128	; 0x80
    60b4:	33ff      	adds	r3, #255	; 0xff
    60b6:	7999      	ldrb	r1, [r3, #6]
    60b8:	4252      	negs	r2, r2
    60ba:	430a      	orrs	r2, r1
    60bc:	e001      	b.n	60c2 <_ZN14USBDeviceClass10ISRHandlerEv+0xbe>
{
	// TODO: test
	// TODO: use .bit. notation

	// Stall endpoint
	USB->DEVICE.DeviceEndpoint[ep].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_STALLRQ(2);
    60be:	4b23      	ldr	r3, [pc, #140]	; (614c <_ZN14USBDeviceClass10ISRHandlerEv+0x148>)
    60c0:	2220      	movs	r2, #32
    60c2:	719a      	strb	r2, [r3, #6]
	// Interrupts
	inline uint16_t epInterruptSummary() { return usb.EPINTSMRY.reg; }

	inline bool epBank0IsSetupReceived(ep_t ep)     { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.RXSTP; }
	inline bool epBank0IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL0; }
	inline bool epBank1IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL1; }
    60c4:	682b      	ldr	r3, [r5, #0]
    60c6:	33ff      	adds	r3, #255	; 0xff
    60c8:	7a1a      	ldrb	r2, [r3, #8]
			usbd.epBank1SetReady(0);
		} else {
			stall(0);
		}

		if (usbd.epBank1IsStalled(0))
    60ca:	0650      	lsls	r0, r2, #25
    60cc:	d504      	bpl.n	60d8 <_ZN14USBDeviceClass10ISRHandlerEv+0xd4>
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
	inline bool epBank1IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT1; }

	inline void epBank0AckSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP; }
	inline void epBank0AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(1); }
	inline void epBank1AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(2); }
    60ce:	2240      	movs	r2, #64	; 0x40
    60d0:	721a      	strb	r2, [r3, #8]
	inline void epBank0EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT0 = 1; }
	inline void epBank1EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT1 = 1; }

	inline void epBank0DisableSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTENCLR.bit.RXSTP = 1; }
	inline void epBank0DisableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENCLR.bit.STALL0 = 1; }
	inline void epBank1DisableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENCLR.bit.STALL1 = 1; }
    60d2:	7a59      	ldrb	r1, [r3, #9]
    60d4:	430a      	orrs	r2, r1
    60d6:	725a      	strb	r2, [r3, #9]
	// Config
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
	inline void epBank1SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = type; }

	// Interrupts
	inline uint16_t epInterruptSummary() { return usb.EPINTSMRY.reg; }
    60d8:	6829      	ldr	r1, [r5, #0]
		}

	} // end Received Setup handler

	uint8_t i=0;
	uint8_t ept_int = usbd.epInterruptSummary() & 0xFE; // Remove endpoint number 0 (setup)
    60da:	23fe      	movs	r3, #254	; 0xfe
    60dc:	8c0e      	ldrh	r6, [r1, #32]
	while (ept_int != 0)
    60de:	2400      	movs	r4, #0
		}

	} // end Received Setup handler

	uint8_t i=0;
	uint8_t ept_int = usbd.epInterruptSummary() & 0xFE; // Remove endpoint number 0 (setup)
    60e0:	401e      	ands	r6, r3
    60e2:	b2e1      	uxtb	r1, r4
	while (ept_int != 0)
    60e4:	2e00      	cmp	r6, #0
    60e6:	d023      	beq.n	6130 <_ZN14USBDeviceClass10ISRHandlerEv+0x12c>
	{
		// Check if endpoint has a pending interrupt
		if ((ept_int & (1 << i)) != 0)
    60e8:	1c32      	adds	r2, r6, #0
    60ea:	2301      	movs	r3, #1
    60ec:	4122      	asrs	r2, r4
    60ee:	421a      	tst	r2, r3
    60f0:	d016      	beq.n	6120 <_ZN14USBDeviceClass10ISRHandlerEv+0x11c>

	inline bool epBank0IsSetupReceived(ep_t ep)     { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.RXSTP; }
	inline bool epBank0IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL0; }
	inline bool epBank1IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL1; }
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
    60f2:	1c22      	adds	r2, r4, #0
    60f4:	6828      	ldr	r0, [r5, #0]
    60f6:	3208      	adds	r2, #8
    60f8:	0152      	lsls	r2, r2, #5
    60fa:	1882      	adds	r2, r0, r2
    60fc:	79d0      	ldrb	r0, [r2, #7]
		{
			// Endpoint Transfer Complete (0/1) Interrupt
			if (usbd.epBank0IsTransferComplete(i) ||
    60fe:	4218      	tst	r0, r3
    6100:	d103      	bne.n	610a <_ZN14USBDeviceClass10ISRHandlerEv+0x106>
	inline bool epBank1IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT1; }
    6102:	79d2      	ldrb	r2, [r2, #7]
    6104:	40da      	lsrs	r2, r3
    6106:	421a      	tst	r2, r3
    6108:	d007      	beq.n	611a <_ZN14USBDeviceClass10ISRHandlerEv+0x116>
			    usbd.epBank1IsTransferComplete(i))
			{
				if (epHandlers[i]) {
    610a:	4b11      	ldr	r3, [pc, #68]	; (6150 <_ZN14USBDeviceClass10ISRHandlerEv+0x14c>)
    610c:	00a2      	lsls	r2, r4, #2
    610e:	58d0      	ldr	r0, [r2, r3]
    6110:	2800      	cmp	r0, #0
    6112:	d009      	beq.n	6128 <_ZN14USBDeviceClass10ISRHandlerEv+0x124>
					epHandlers[i]->handleEndpoint();
    6114:	6803      	ldr	r3, [r0, #0]
    6116:	681b      	ldr	r3, [r3, #0]
    6118:	4798      	blx	r3
				} else {
					handleEndpoint(i);
				}
			}
			ept_int &= ~(1 << i);
    611a:	2301      	movs	r3, #1
    611c:	40a3      	lsls	r3, r4
    611e:	439e      	bics	r6, r3
    6120:	3401      	adds	r4, #1
		}
		i++;
		if (i > USB_EPT_NUM)
    6122:	2c09      	cmp	r4, #9
    6124:	d1dd      	bne.n	60e2 <_ZN14USBDeviceClass10ISRHandlerEv+0xde>
    6126:	e003      	b.n	6130 <_ZN14USBDeviceClass10ISRHandlerEv+0x12c>
			    usbd.epBank1IsTransferComplete(i))
			{
				if (epHandlers[i]) {
					epHandlers[i]->handleEndpoint();
				} else {
					handleEndpoint(i);
    6128:	1c38      	adds	r0, r7, #0
    612a:	f7ff fa4d 	bl	55c8 <_ZN14USBDeviceClass14handleEndpointEh>
    612e:	e7f4      	b.n	611a <_ZN14USBDeviceClass10ISRHandlerEv+0x116>
		}
		i++;
		if (i > USB_EPT_NUM)
			break;  // fire exit
	}
}
    6130:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6132:	46c0      	nop			; (mov r8, r8)
    6134:	20000794 	.word	0x20000794
    6138:	200007a0 	.word	0x200007a0
    613c:	200008a4 	.word	0x200008a4
    6140:	200005b4 	.word	0x200005b4
    6144:	2000079c 	.word	0x2000079c
    6148:	200005b8 	.word	0x200005b8
    614c:	410050ff 	.word	0x410050ff
    6150:	20000778 	.word	0x20000778

00006154 <UDD_Handler>:
static char isEndpointHalt = 0;

extern void (*gpf_isr)(void);

// USB_Handler ISR
extern "C" void UDD_Handler(void) {
    6154:	b508      	push	{r3, lr}
	USBDevice.ISRHandler();
    6156:	4802      	ldr	r0, [pc, #8]	; (6160 <UDD_Handler+0xc>)
    6158:	f7ff ff54 	bl	6004 <_ZN14USBDeviceClass10ISRHandlerEv>
}
    615c:	bd08      	pop	{r3, pc}
    615e:	46c0      	nop			; (mov r8, r8)
    6160:	20000797 	.word	0x20000797

00006164 <_GLOBAL__sub_I__ZN20USBDevice_SAMD21G18x5resetEv>:

typedef uint8_t ep_t;

class USBDevice_SAMD21G18x {
public:
	USBDevice_SAMD21G18x() : usb(USB->DEVICE) {
    6164:	4a01      	ldr	r2, [pc, #4]	; (616c <_GLOBAL__sub_I__ZN20USBDevice_SAMD21G18x5resetEv+0x8>)
    6166:	4b02      	ldr	r3, [pc, #8]	; (6170 <_GLOBAL__sub_I__ZN20USBDevice_SAMD21G18x5resetEv+0xc>)
    6168:	601a      	str	r2, [r3, #0]
 * USB Device instance
 * -------------------
 */

// USBDevice class instance
USBDeviceClass USBDevice;
    616a:	4770      	bx	lr
    616c:	41005000 	.word	0x41005000
    6170:	200007a0 	.word	0x200007a0

00006174 <_ZN10RingBufferC1Ev>:
*/

#include "RingBuffer.h"
#include <string.h>

RingBuffer::RingBuffer( void )
    6174:	b510      	push	{r4, lr}
{
    memset( _aucBuffer, 0, SERIAL_BUFFER_SIZE ) ;
    6176:	2100      	movs	r1, #0
    6178:	2240      	movs	r2, #64	; 0x40
*/

#include "RingBuffer.h"
#include <string.h>

RingBuffer::RingBuffer( void )
    617a:	1c04      	adds	r4, r0, #0
{
    memset( _aucBuffer, 0, SERIAL_BUFFER_SIZE ) ;
    617c:	f002 f8e5 	bl	834a <memset>
  }
}

void RingBuffer::clear()
{
	_iHead = 0;
    6180:	2300      	movs	r3, #0

RingBuffer::RingBuffer( void )
{
    memset( _aucBuffer, 0, SERIAL_BUFFER_SIZE ) ;
    clear();
}
    6182:	1c20      	adds	r0, r4, #0
  }
}

void RingBuffer::clear()
{
	_iHead = 0;
    6184:	6423      	str	r3, [r4, #64]	; 0x40
	_iTail = 0;
    6186:	6463      	str	r3, [r4, #68]	; 0x44

RingBuffer::RingBuffer( void )
{
    memset( _aucBuffer, 0, SERIAL_BUFFER_SIZE ) ;
    clear();
}
    6188:	bd10      	pop	{r4, pc}

0000618a <_ZN10RingBuffer10store_charEh>:

void RingBuffer::store_char( uint8_t c )
{
  int i = nextIndex(_iHead);
    618a:	6c02      	ldr	r2, [r0, #64]	; 0x40
    memset( _aucBuffer, 0, SERIAL_BUFFER_SIZE ) ;
    clear();
}

void RingBuffer::store_char( uint8_t c )
{
    618c:	b510      	push	{r4, lr}
	return _aucBuffer[_iTail];
}

int RingBuffer::nextIndex(int index)
{
	return (uint32_t)(index + 1) % SERIAL_BUFFER_SIZE;
    618e:	233f      	movs	r3, #63	; 0x3f
    6190:	1c54      	adds	r4, r2, #1
    6192:	4023      	ands	r3, r4

  // if we should be storing the received character into the location
  // just before the tail (meaning that the head would advance to the
  // current location of the tail), we're about to overflow the buffer
  // and so we don't write the character or advance the head.
  if ( i != _iTail )
    6194:	6c44      	ldr	r4, [r0, #68]	; 0x44
    6196:	42a3      	cmp	r3, r4
    6198:	d001      	beq.n	619e <_ZN10RingBuffer10store_charEh+0x14>
  {
    _aucBuffer[_iHead] = c ;
    619a:	5481      	strb	r1, [r0, r2]
    _iHead = i ;
    619c:	6403      	str	r3, [r0, #64]	; 0x40
  }
}
    619e:	bd10      	pop	{r4, pc}

000061a0 <_ZN10RingBuffer5clearEv>:

void RingBuffer::clear()
{
	_iHead = 0;
    61a0:	2300      	movs	r3, #0
    61a2:	6403      	str	r3, [r0, #64]	; 0x40
	_iTail = 0;
    61a4:	6443      	str	r3, [r0, #68]	; 0x44
}
    61a6:	4770      	bx	lr

000061a8 <_ZN10RingBuffer9read_charEv>:

int RingBuffer::read_char()
{
	if(_iTail == _iHead)
    61a8:	6c43      	ldr	r3, [r0, #68]	; 0x44
    61aa:	6c02      	ldr	r2, [r0, #64]	; 0x40
    61ac:	4293      	cmp	r3, r2
    61ae:	d006      	beq.n	61be <_ZN10RingBuffer9read_charEv+0x16>
		return -1;

	uint8_t value = _aucBuffer[_iTail];
    61b0:	5cc2      	ldrb	r2, [r0, r3]
	return _aucBuffer[_iTail];
}

int RingBuffer::nextIndex(int index)
{
	return (uint32_t)(index + 1) % SERIAL_BUFFER_SIZE;
    61b2:	213f      	movs	r1, #63	; 0x3f
    61b4:	3301      	adds	r3, #1
    61b6:	400b      	ands	r3, r1
{
	if(_iTail == _iHead)
		return -1;

	uint8_t value = _aucBuffer[_iTail];
	_iTail = nextIndex(_iTail);
    61b8:	6443      	str	r3, [r0, #68]	; 0x44

	return value;
    61ba:	1c10      	adds	r0, r2, #0
    61bc:	e001      	b.n	61c2 <_ZN10RingBuffer9read_charEv+0x1a>
}

int RingBuffer::read_char()
{
	if(_iTail == _iHead)
		return -1;
    61be:	2001      	movs	r0, #1
    61c0:	4240      	negs	r0, r0

	uint8_t value = _aucBuffer[_iTail];
	_iTail = nextIndex(_iTail);

	return value;
}
    61c2:	4770      	bx	lr

000061c4 <_ZN10RingBuffer9availableEv>:

int RingBuffer::available()
{
	int delta = _iHead - _iTail;
    61c4:	6c02      	ldr	r2, [r0, #64]	; 0x40
    61c6:	6c43      	ldr	r3, [r0, #68]	; 0x44
    61c8:	1ad0      	subs	r0, r2, r3

	if(delta < 0)
    61ca:	d500      	bpl.n	61ce <_ZN10RingBuffer9availableEv+0xa>
		return SERIAL_BUFFER_SIZE + delta;
    61cc:	3040      	adds	r0, #64	; 0x40
	else
		return delta;
}
    61ce:	4770      	bx	lr

000061d0 <_ZN10RingBuffer17availableForStoreEv>:

int RingBuffer::availableForStore()
{
	if (_iHead >= _iTail)
    61d0:	6c03      	ldr	r3, [r0, #64]	; 0x40
    61d2:	6c40      	ldr	r0, [r0, #68]	; 0x44
    61d4:	4283      	cmp	r3, r0
    61d6:	db02      	blt.n	61de <_ZN10RingBuffer17availableForStoreEv+0xe>
		return SERIAL_BUFFER_SIZE - 1 - _iHead + _iTail;
    61d8:	1ac0      	subs	r0, r0, r3
    61da:	303f      	adds	r0, #63	; 0x3f
    61dc:	e001      	b.n	61e2 <_ZN10RingBuffer17availableForStoreEv+0x12>
	else
		return _iTail - _iHead - 1;
    61de:	1ac0      	subs	r0, r0, r3
    61e0:	3801      	subs	r0, #1
}
    61e2:	4770      	bx	lr

000061e4 <_ZN10RingBuffer4peekEv>:

int RingBuffer::peek()
{
	if(_iTail == _iHead)
    61e4:	6c43      	ldr	r3, [r0, #68]	; 0x44
    61e6:	6c02      	ldr	r2, [r0, #64]	; 0x40
    61e8:	4293      	cmp	r3, r2
    61ea:	d001      	beq.n	61f0 <_ZN10RingBuffer4peekEv+0xc>
		return -1;

	return _aucBuffer[_iTail];
    61ec:	5cc0      	ldrb	r0, [r0, r3]
    61ee:	e001      	b.n	61f4 <_ZN10RingBuffer4peekEv+0x10>
}

int RingBuffer::peek()
{
	if(_iTail == _iHead)
		return -1;
    61f0:	2001      	movs	r0, #1
    61f2:	4240      	negs	r0, r0

	return _aucBuffer[_iTail];
}
    61f4:	4770      	bx	lr

000061f6 <_ZN10RingBuffer6isFullEv>:

int RingBuffer::nextIndex(int index)
{
	return (uint32_t)(index + 1) % SERIAL_BUFFER_SIZE;
    61f6:	6c02      	ldr	r2, [r0, #64]	; 0x40
    61f8:	233f      	movs	r3, #63	; 0x3f
    61fa:	3201      	adds	r2, #1
    61fc:	401a      	ands	r2, r3
}

bool RingBuffer::isFull()
{
	return (nextIndex(_iHead) == _iTail);
    61fe:	6c43      	ldr	r3, [r0, #68]	; 0x44
    6200:	1ad0      	subs	r0, r2, r3
    6202:	4243      	negs	r3, r0
    6204:	4158      	adcs	r0, r3
    6206:	b2c0      	uxtb	r0, r0
}
    6208:	4770      	bx	lr

0000620a <_Znwj>:
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <stdlib.h>

void *operator new(size_t size) {
    620a:	b508      	push	{r3, lr}
  return malloc(size);
    620c:	f002 f88a 	bl	8324 <malloc>
}
    6210:	bd08      	pop	{r3, pc}

00006212 <_ZN7Serial_17availableForWriteEv>:
int Serial_::availableForWrite(void)
{
	// return the number of bytes left in the current bank,
	// always EP size - 1, because bank is flushed on every write
	return (EPX_SIZE - 1);
}
    6212:	203f      	movs	r0, #63	; 0x3f
    6214:	4770      	bx	lr

00006216 <_ZN7Serial_5writeEh>:
		setWriteError();
		return 0;
	}
}

size_t Serial_::write(uint8_t c) {
    6216:	b513      	push	{r0, r1, r4, lr}
	return write(&c, 1);
    6218:	6802      	ldr	r2, [r0, #0]
		setWriteError();
		return 0;
	}
}

size_t Serial_::write(uint8_t c) {
    621a:	466b      	mov	r3, sp
    621c:	71d9      	strb	r1, [r3, #7]
    621e:	3307      	adds	r3, #7
	return write(&c, 1);
    6220:	6854      	ldr	r4, [r2, #4]
    6222:	1c19      	adds	r1, r3, #0
    6224:	2201      	movs	r2, #1
    6226:	47a0      	blx	r4
}
    6228:	bd16      	pop	{r1, r2, r4, pc}

0000622a <_ZN7Serial_9availableEv>:
void Serial_::end(void)
{
}

int Serial_::available(void)
{
    622a:	b508      	push	{r3, lr}
	return usb.available(CDC_ENDPOINT_OUT);
    622c:	6900      	ldr	r0, [r0, #16]
    622e:	2102      	movs	r1, #2
    6230:	f7ff fb66 	bl	5900 <_ZN14USBDeviceClass9availableEm>
}
    6234:	bd08      	pop	{r3, pc}

00006236 <_ZN7Serial_5flushEv>:
	}
	return count;
}

void Serial_::flush(void)
{
    6236:	b508      	push	{r3, lr}
	usb.flush(CDC_ENDPOINT_IN);
    6238:	6900      	ldr	r0, [r0, #16]
    623a:	2103      	movs	r1, #3
    623c:	f7ff fb76 	bl	592c <_ZN14USBDeviceClass5flushEm>
}
    6240:	bd08      	pop	{r3, pc}

00006242 <_ZN7Serial_5writeEPKhj>:

size_t Serial_::write(const uint8_t *buffer, size_t size)
{
    6242:	b538      	push	{r3, r4, r5, lr}
    6244:	1c0d      	adds	r5, r1, #0
    6246:	1c04      	adds	r4, r0, #0
    6248:	1c13      	adds	r3, r2, #0
	uint32_t r = usb.send(CDC_ENDPOINT_IN, buffer, size);
    624a:	6900      	ldr	r0, [r0, #16]
    624c:	2103      	movs	r1, #3
    624e:	1c2a      	adds	r2, r5, #0
    6250:	f7ff fc68 	bl	5b24 <_ZN14USBDeviceClass4sendEmPKvm>

	if (r > 0) {
    6254:	2800      	cmp	r0, #0
    6256:	d101      	bne.n	625c <_ZN7Serial_5writeEPKhj+0x1a>
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    6258:	2301      	movs	r3, #1
    625a:	6063      	str	r3, [r4, #4]
		return r;
	} else {
		setWriteError();
		return 0;
	}
}
    625c:	bd38      	pop	{r3, r4, r5, pc}
	...

00006260 <_ZN7Serial_4peekEv>:
}

int _serialPeek = -1;

int Serial_::peek(void)
{
    6260:	b510      	push	{r4, lr}
	if (_serialPeek != -1)
    6262:	4c05      	ldr	r4, [pc, #20]	; (6278 <_ZN7Serial_4peekEv+0x18>)
    6264:	6823      	ldr	r3, [r4, #0]
    6266:	1c5a      	adds	r2, r3, #1
    6268:	d104      	bne.n	6274 <_ZN7Serial_4peekEv+0x14>
		return _serialPeek;
	_serialPeek = read();
    626a:	6803      	ldr	r3, [r0, #0]
    626c:	695b      	ldr	r3, [r3, #20]
    626e:	4798      	blx	r3
    6270:	6020      	str	r0, [r4, #0]
    6272:	1c03      	adds	r3, r0, #0
	return _serialPeek;
}
    6274:	1c18      	adds	r0, r3, #0
    6276:	bd10      	pop	{r4, pc}
    6278:	20000084 	.word	0x20000084

0000627c <_ZN7Serial_4readEv>:

int Serial_::read(void)
{
	if (_serialPeek != -1) {
    627c:	4a07      	ldr	r2, [pc, #28]	; (629c <_ZN7Serial_4readEv+0x20>)
	_serialPeek = read();
	return _serialPeek;
}

int Serial_::read(void)
{
    627e:	b508      	push	{r3, lr}
	if (_serialPeek != -1) {
    6280:	6813      	ldr	r3, [r2, #0]
    6282:	1c59      	adds	r1, r3, #1
    6284:	d004      	beq.n	6290 <_ZN7Serial_4readEv+0x14>
		int res = _serialPeek;
		_serialPeek = -1;
    6286:	2101      	movs	r1, #1
    6288:	4249      	negs	r1, r1
    628a:	6011      	str	r1, [r2, #0]
		return res;
    628c:	1c18      	adds	r0, r3, #0
    628e:	e003      	b.n	6298 <_ZN7Serial_4readEv+0x1c>
	}
	return usb.recv(CDC_ENDPOINT_OUT);
    6290:	6900      	ldr	r0, [r0, #16]
    6292:	2102      	movs	r1, #2
    6294:	f7ff fc38 	bl	5b08 <_ZN14USBDeviceClass4recvEm>
}
    6298:	bd08      	pop	{r3, pc}
    629a:	46c0      	nop			; (mov r8, r8)
    629c:	20000084 	.word	0x20000084

000062a0 <_Z16CDC_GetInterfacePh>:
{
	return sizeof(_cdcInterface);
}

int CDC_GetInterface(uint8_t* interfaceNum)
{
    62a0:	b508      	push	{r3, lr}
	interfaceNum[0] += 2;	// uses 2
    62a2:	7803      	ldrb	r3, [r0, #0]
	return USBDevice.sendControl(&_cdcInterface,sizeof(_cdcInterface));
    62a4:	4903      	ldr	r1, [pc, #12]	; (62b4 <_Z16CDC_GetInterfacePh+0x14>)
	return sizeof(_cdcInterface);
}

int CDC_GetInterface(uint8_t* interfaceNum)
{
	interfaceNum[0] += 2;	// uses 2
    62a6:	3302      	adds	r3, #2
    62a8:	7003      	strb	r3, [r0, #0]
	return USBDevice.sendControl(&_cdcInterface,sizeof(_cdcInterface));
    62aa:	2242      	movs	r2, #66	; 0x42
    62ac:	4802      	ldr	r0, [pc, #8]	; (62b8 <_Z16CDC_GetInterfacePh+0x18>)
    62ae:	f7ff fcef 	bl	5c90 <_ZN14USBDeviceClass11sendControlEPKvm>
}
    62b2:	bd08      	pop	{r3, pc}
    62b4:	20000040 	.word	0x20000040
    62b8:	20000797 	.word	0x20000797

000062bc <_Z9CDC_SetupR8USBSetup>:

bool CDC_Setup(USBSetup& setup)
{
    62bc:	b510      	push	{r4, lr}
	uint8_t requestType = setup.bmRequestType;
    62be:	7801      	ldrb	r1, [r0, #0]
	interfaceNum[0] += 2;	// uses 2
	return USBDevice.sendControl(&_cdcInterface,sizeof(_cdcInterface));
}

bool CDC_Setup(USBSetup& setup)
{
    62c0:	1c03      	adds	r3, r0, #0
	uint8_t requestType = setup.bmRequestType;
	uint8_t r = setup.bRequest;
    62c2:	7842      	ldrb	r2, [r0, #1]
		{
			breakValue = ((uint16_t)setup.wValueH << 8) | setup.wValueL;
			return false;
		}
	}
	return false;
    62c4:	2000      	movs	r0, #0
bool CDC_Setup(USBSetup& setup)
{
	uint8_t requestType = setup.bmRequestType;
	uint8_t r = setup.bRequest;

	if (requestType == REQUEST_DEVICETOHOST_CLASS_INTERFACE)
    62c6:	29a1      	cmp	r1, #161	; 0xa1
    62c8:	d108      	bne.n	62dc <_Z9CDC_SetupR8USBSetup+0x20>
	{
		if (r == CDC_GET_LINE_CODING)
    62ca:	2a21      	cmp	r2, #33	; 0x21
    62cc:	d12f      	bne.n	632e <_Z9CDC_SetupR8USBSetup+0x72>
		{
			USBDevice.sendControl((void*)&_usbLineInfo, 7);
    62ce:	4818      	ldr	r0, [pc, #96]	; (6330 <_Z9CDC_SetupR8USBSetup+0x74>)
    62d0:	4918      	ldr	r1, [pc, #96]	; (6334 <_Z9CDC_SetupR8USBSetup+0x78>)
    62d2:	2207      	movs	r2, #7
    62d4:	f7ff fcdc 	bl	5c90 <_ZN14USBDeviceClass11sendControlEPKvm>
			return true;
    62d8:	2001      	movs	r0, #1
    62da:	e028      	b.n	632e <_Z9CDC_SetupR8USBSetup+0x72>
		}
	}

	if (requestType == REQUEST_HOSTTODEVICE_CLASS_INTERFACE)
    62dc:	2921      	cmp	r1, #33	; 0x21
    62de:	d126      	bne.n	632e <_Z9CDC_SetupR8USBSetup+0x72>
	{
		if (r == CDC_SET_LINE_CODING)
    62e0:	2a20      	cmp	r2, #32
    62e2:	d105      	bne.n	62f0 <_Z9CDC_SetupR8USBSetup+0x34>
		{
			USBDevice.recvControl((void*)&_usbLineInfo, 7);
    62e4:	4913      	ldr	r1, [pc, #76]	; (6334 <_Z9CDC_SetupR8USBSetup+0x78>)
    62e6:	2207      	movs	r2, #7
    62e8:	4811      	ldr	r0, [pc, #68]	; (6330 <_Z9CDC_SetupR8USBSetup+0x74>)
    62ea:	f7ff fb65 	bl	59b8 <_ZN14USBDeviceClass11recvControlEPvm>
    62ee:	e004      	b.n	62fa <_Z9CDC_SetupR8USBSetup+0x3e>
		}

		if (r == CDC_SET_CONTROL_LINE_STATE)
    62f0:	2a22      	cmp	r2, #34	; 0x22
    62f2:	d110      	bne.n	6316 <_Z9CDC_SetupR8USBSetup+0x5a>
		{
			_usbLineInfo.lineState = setup.wValueL;
    62f4:	789a      	ldrb	r2, [r3, #2]
    62f6:	4b0f      	ldr	r3, [pc, #60]	; (6334 <_Z9CDC_SetupR8USBSetup+0x78>)
    62f8:	71da      	strb	r2, [r3, #7]
		if (r == CDC_SET_LINE_CODING || r == CDC_SET_CONTROL_LINE_STATE)
		{
			// auto-reset into the bootloader is triggered when the port, already
			// open at 1200 bps, is closed. We check DTR state to determine if host 
			// port is open (bit 0 of lineState).
			if (_usbLineInfo.dwDTERate == 1200 && (_usbLineInfo.lineState & 0x01) == 0)
    62fa:	4b0e      	ldr	r3, [pc, #56]	; (6334 <_Z9CDC_SetupR8USBSetup+0x78>)
    62fc:	2296      	movs	r2, #150	; 0x96
    62fe:	6819      	ldr	r1, [r3, #0]
    6300:	00d2      	lsls	r2, r2, #3
    6302:	4291      	cmp	r1, r2
    6304:	d110      	bne.n	6328 <_Z9CDC_SetupR8USBSetup+0x6c>
    6306:	79dc      	ldrb	r4, [r3, #7]
    6308:	2301      	movs	r3, #1
    630a:	401c      	ands	r4, r3
    630c:	d10c      	bne.n	6328 <_Z9CDC_SetupR8USBSetup+0x6c>
			{
				initiateReset(250);
    630e:	20fa      	movs	r0, #250	; 0xfa
    6310:	f7fe fc56 	bl	4bc0 <initiateReset>
    6314:	e00a      	b.n	632c <_Z9CDC_SetupR8USBSetup+0x70>
				cancelReset();
			}
			return false;
		}

		if (CDC_SEND_BREAK == r)
    6316:	2a23      	cmp	r2, #35	; 0x23
    6318:	d109      	bne.n	632e <_Z9CDC_SetupR8USBSetup+0x72>
		{
			breakValue = ((uint16_t)setup.wValueH << 8) | setup.wValueL;
    631a:	78da      	ldrb	r2, [r3, #3]
    631c:	789b      	ldrb	r3, [r3, #2]
    631e:	0212      	lsls	r2, r2, #8
    6320:	431a      	orrs	r2, r3
    6322:	4b05      	ldr	r3, [pc, #20]	; (6338 <_Z9CDC_SetupR8USBSetup+0x7c>)
    6324:	601a      	str	r2, [r3, #0]
			return false;
    6326:	e002      	b.n	632e <_Z9CDC_SetupR8USBSetup+0x72>
			{
				initiateReset(250);
			}
			else
			{
				cancelReset();
    6328:	f7fe fc50 	bl	4bcc <cancelReset>
			}
			return false;
    632c:	2000      	movs	r0, #0
			breakValue = ((uint16_t)setup.wValueH << 8) | setup.wValueL;
			return false;
		}
	}
	return false;
}
    632e:	bd10      	pop	{r4, pc}
    6330:	20000797 	.word	0x20000797
    6334:	20000034 	.word	0x20000034
    6338:	2000003c 	.word	0x2000003c

0000633c <_GLOBAL__sub_I__Z17_CDC_GetInterfacev>:
  public:
    Print() : write_error(0) {}
    633c:	4b06      	ldr	r3, [pc, #24]	; (6358 <_GLOBAL__sub_I__Z17_CDC_GetInterfacev+0x1c>)
    633e:	21fa      	movs	r1, #250	; 0xfa
    6340:	0089      	lsls	r1, r1, #2
    6342:	6099      	str	r1, [r3, #8]
//	Serial over CDC (Serial1 is the physical port)

class Serial_ : public Stream
{
public:
	Serial_(USBDeviceClass &_usb) : usb(_usb), stalled(false) { }
    6344:	4905      	ldr	r1, [pc, #20]	; (635c <_GLOBAL__sub_I__Z17_CDC_GetInterfacev+0x20>)
    6346:	2200      	movs	r2, #0
    6348:	3108      	adds	r1, #8
    634a:	6019      	str	r1, [r3, #0]
    634c:	4904      	ldr	r1, [pc, #16]	; (6360 <_GLOBAL__sub_I__Z17_CDC_GetInterfacev+0x24>)
    634e:	605a      	str	r2, [r3, #4]
    6350:	6119      	str	r1, [r3, #16]
    6352:	761a      	strb	r2, [r3, #24]

bool Serial_::rts() {
	return _usbLineInfo.lineState & 0x2;
}

Serial_ SerialUSB(USBDevice);
    6354:	4770      	bx	lr
    6356:	46c0      	nop			; (mov r8, r8)
    6358:	200008a8 	.word	0x200008a8
    635c:	00009168 	.word	0x00009168
    6360:	20000797 	.word	0x20000797

00006364 <_ZN13PluggableUSB_12getInterfaceEPh>:
#ifdef PLUGGABLE_USB_ENABLED

extern uint32_t EndPoints[];

int PluggableUSB_::getInterface(uint8_t* interfaceCount)
{
    6364:	b570      	push	{r4, r5, r6, lr}
	int sent = 0;
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
    6366:	6844      	ldr	r4, [r0, #4]
#ifdef PLUGGABLE_USB_ENABLED

extern uint32_t EndPoints[];

int PluggableUSB_::getInterface(uint8_t* interfaceCount)
{
    6368:	1c0e      	adds	r6, r1, #0
	int sent = 0;
    636a:	2500      	movs	r5, #0
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
    636c:	2c00      	cmp	r4, #0
    636e:	d009      	beq.n	6384 <_ZN13PluggableUSB_12getInterfaceEPh+0x20>
		int res = node->getInterface(interfaceCount);
    6370:	6823      	ldr	r3, [r4, #0]
    6372:	1c20      	adds	r0, r4, #0
    6374:	685b      	ldr	r3, [r3, #4]
    6376:	1c31      	adds	r1, r6, #0
    6378:	4798      	blx	r3
		if (res < 0)
    637a:	2800      	cmp	r0, #0
    637c:	db04      	blt.n	6388 <_ZN13PluggableUSB_12getInterfaceEPh+0x24>
			return -1;
		sent += res;
    637e:	182d      	adds	r5, r5, r0

int PluggableUSB_::getInterface(uint8_t* interfaceCount)
{
	int sent = 0;
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
    6380:	68e4      	ldr	r4, [r4, #12]
    6382:	e7f3      	b.n	636c <_ZN13PluggableUSB_12getInterfaceEPh+0x8>
    6384:	1c28      	adds	r0, r5, #0
    6386:	e001      	b.n	638c <_ZN13PluggableUSB_12getInterfaceEPh+0x28>
		int res = node->getInterface(interfaceCount);
		if (res < 0)
			return -1;
    6388:	2001      	movs	r0, #1
    638a:	4240      	negs	r0, r0
		sent += res;
	}
	return sent;
}
    638c:	bd70      	pop	{r4, r5, r6, pc}

0000638e <_ZN13PluggableUSB_13getDescriptorER8USBSetup>:

int PluggableUSB_::getDescriptor(USBSetup& setup)
{
    638e:	b538      	push	{r3, r4, r5, lr}
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
    6390:	6844      	ldr	r4, [r0, #4]
	}
	return sent;
}

int PluggableUSB_::getDescriptor(USBSetup& setup)
{
    6392:	1c0d      	adds	r5, r1, #0
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
    6394:	2c00      	cmp	r4, #0
    6396:	d008      	beq.n	63aa <_ZN13PluggableUSB_13getDescriptorER8USBSetup+0x1c>
		int ret = node->getDescriptor(setup);
    6398:	6823      	ldr	r3, [r4, #0]
    639a:	1c20      	adds	r0, r4, #0
    639c:	689b      	ldr	r3, [r3, #8]
    639e:	1c29      	adds	r1, r5, #0
    63a0:	4798      	blx	r3
		// ret!=0 -> request has been processed
		if (ret)
    63a2:	2800      	cmp	r0, #0
    63a4:	d102      	bne.n	63ac <_ZN13PluggableUSB_13getDescriptorER8USBSetup+0x1e>
}

int PluggableUSB_::getDescriptor(USBSetup& setup)
{
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
    63a6:	68e4      	ldr	r4, [r4, #12]
    63a8:	e7f4      	b.n	6394 <_ZN13PluggableUSB_13getDescriptorER8USBSetup+0x6>
		int ret = node->getDescriptor(setup);
		// ret!=0 -> request has been processed
		if (ret)
			return ret;
	}
	return 0;
    63aa:	1c20      	adds	r0, r4, #0
}
    63ac:	bd38      	pop	{r3, r4, r5, pc}

000063ae <_ZN13PluggableUSB_12getShortNameEPc>:

void PluggableUSB_::getShortName(char *iSerialNum)
{
    63ae:	b538      	push	{r3, r4, r5, lr}
       PluggableUSBModule* node;
       for (node = rootNode; node; node = node->next) {
    63b0:	6844      	ldr	r4, [r0, #4]
	}
	return 0;
}

void PluggableUSB_::getShortName(char *iSerialNum)
{
    63b2:	1c0d      	adds	r5, r1, #0
       PluggableUSBModule* node;
       for (node = rootNode; node; node = node->next) {
    63b4:	2c00      	cmp	r4, #0
    63b6:	d007      	beq.n	63c8 <_ZN13PluggableUSB_12getShortNameEPc+0x1a>
               iSerialNum += node->getShortName(iSerialNum);
    63b8:	6823      	ldr	r3, [r4, #0]
    63ba:	1c20      	adds	r0, r4, #0
    63bc:	1c29      	adds	r1, r5, #0
    63be:	68db      	ldr	r3, [r3, #12]
    63c0:	4798      	blx	r3
}

void PluggableUSB_::getShortName(char *iSerialNum)
{
       PluggableUSBModule* node;
       for (node = rootNode; node; node = node->next) {
    63c2:	68e4      	ldr	r4, [r4, #12]
               iSerialNum += node->getShortName(iSerialNum);
    63c4:	182d      	adds	r5, r5, r0
    63c6:	e7f5      	b.n	63b4 <_ZN13PluggableUSB_12getShortNameEPc+0x6>
       }
       *iSerialNum = 0;
    63c8:	702c      	strb	r4, [r5, #0]
}
    63ca:	bd38      	pop	{r3, r4, r5, pc}

000063cc <_ZN13PluggableUSB_5setupER8USBSetup>:

bool PluggableUSB_::setup(USBSetup& setup)
{
    63cc:	b538      	push	{r3, r4, r5, lr}
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
    63ce:	6844      	ldr	r4, [r0, #4]
       }
       *iSerialNum = 0;
}

bool PluggableUSB_::setup(USBSetup& setup)
{
    63d0:	1c0d      	adds	r5, r1, #0
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
    63d2:	2c00      	cmp	r4, #0
    63d4:	d008      	beq.n	63e8 <_ZN13PluggableUSB_5setupER8USBSetup+0x1c>
		if (node->setup(setup)) {
    63d6:	6823      	ldr	r3, [r4, #0]
    63d8:	1c20      	adds	r0, r4, #0
    63da:	681b      	ldr	r3, [r3, #0]
    63dc:	1c29      	adds	r1, r5, #0
    63de:	4798      	blx	r3
    63e0:	2800      	cmp	r0, #0
    63e2:	d103      	bne.n	63ec <_ZN13PluggableUSB_5setupER8USBSetup+0x20>
}

bool PluggableUSB_::setup(USBSetup& setup)
{
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
    63e4:	68e4      	ldr	r4, [r4, #12]
    63e6:	e7f4      	b.n	63d2 <_ZN13PluggableUSB_5setupER8USBSetup+0x6>
		if (node->setup(setup)) {
			return true;
		}
	}
	return false;
    63e8:	1c20      	adds	r0, r4, #0
    63ea:	e000      	b.n	63ee <_ZN13PluggableUSB_5setupER8USBSetup+0x22>
bool PluggableUSB_::setup(USBSetup& setup)
{
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
		if (node->setup(setup)) {
			return true;
    63ec:	2001      	movs	r0, #1
		}
	}
	return false;
}
    63ee:	bd38      	pop	{r3, r4, r5, pc}

000063f0 <_Z12PluggableUSBv>:
	// restart USB layer???
}

PluggableUSB_& PluggableUSB()
{
	static PluggableUSB_ obj;
    63f0:	4b06      	ldr	r3, [pc, #24]	; (640c <_Z12PluggableUSBv+0x1c>)
    63f2:	2201      	movs	r2, #1
    63f4:	6819      	ldr	r1, [r3, #0]
	return true;
	// restart USB layer???
}

PluggableUSB_& PluggableUSB()
{
    63f6:	b510      	push	{r4, lr}
	static PluggableUSB_ obj;
    63f8:	4011      	ands	r1, r2
    63fa:	4805      	ldr	r0, [pc, #20]	; (6410 <_Z12PluggableUSBv+0x20>)
    63fc:	d105      	bne.n	640a <_Z12PluggableUSBv+0x1a>
	return obj;
}

PluggableUSB_::PluggableUSB_() : lastIf(CDC_ACM_INTERFACE + CDC_INTERFACE_COUNT),
                                 lastEp(CDC_FIRST_ENDPOINT + CDC_ENPOINT_COUNT),
                                 rootNode(NULL)
    63fe:	2402      	movs	r4, #2
    6400:	7004      	strb	r4, [r0, #0]
    6402:	2404      	movs	r4, #4
    6404:	7044      	strb	r4, [r0, #1]
    6406:	6041      	str	r1, [r0, #4]
	// restart USB layer???
}

PluggableUSB_& PluggableUSB()
{
	static PluggableUSB_ obj;
    6408:	601a      	str	r2, [r3, #0]
	return obj;
}
    640a:	bd10      	pop	{r4, pc}
    640c:	200008cc 	.word	0x200008cc
    6410:	200008c4 	.word	0x200008c4

00006414 <__fpclassifyd>:
    6414:	1c0b      	adds	r3, r1, #0
    6416:	1c01      	adds	r1, r0, #0
    6418:	1c02      	adds	r2, r0, #0
    641a:	b530      	push	{r4, r5, lr}
    641c:	4319      	orrs	r1, r3
    641e:	2002      	movs	r0, #2
    6420:	2900      	cmp	r1, #0
    6422:	d100      	bne.n	6426 <__fpclassifyd+0x12>
    6424:	bd30      	pop	{r4, r5, pc}
    6426:	2180      	movs	r1, #128	; 0x80
    6428:	0609      	lsls	r1, r1, #24
    642a:	428b      	cmp	r3, r1
    642c:	d016      	beq.n	645c <__fpclassifyd+0x48>
    642e:	490d      	ldr	r1, [pc, #52]	; (6464 <__fpclassifyd+0x50>)
    6430:	2004      	movs	r0, #4
    6432:	185c      	adds	r4, r3, r1
    6434:	490c      	ldr	r1, [pc, #48]	; (6468 <__fpclassifyd+0x54>)
    6436:	428c      	cmp	r4, r1
    6438:	d9f4      	bls.n	6424 <__fpclassifyd+0x10>
    643a:	4d0c      	ldr	r5, [pc, #48]	; (646c <__fpclassifyd+0x58>)
    643c:	195c      	adds	r4, r3, r5
    643e:	428c      	cmp	r4, r1
    6440:	d9f0      	bls.n	6424 <__fpclassifyd+0x10>
    6442:	4c0b      	ldr	r4, [pc, #44]	; (6470 <__fpclassifyd+0x5c>)
    6444:	0059      	lsls	r1, r3, #1
    6446:	0849      	lsrs	r1, r1, #1
    6448:	2003      	movs	r0, #3
    644a:	42a1      	cmp	r1, r4
    644c:	d9ea      	bls.n	6424 <__fpclassifyd+0x10>
    644e:	4c07      	ldr	r4, [pc, #28]	; (646c <__fpclassifyd+0x58>)
    6450:	2000      	movs	r0, #0
    6452:	42a1      	cmp	r1, r4
    6454:	d1e6      	bne.n	6424 <__fpclassifyd+0x10>
    6456:	4250      	negs	r0, r2
    6458:	4150      	adcs	r0, r2
    645a:	e7e3      	b.n	6424 <__fpclassifyd+0x10>
    645c:	2a00      	cmp	r2, #0
    645e:	d0e1      	beq.n	6424 <__fpclassifyd+0x10>
    6460:	e7ef      	b.n	6442 <__fpclassifyd+0x2e>
    6462:	46c0      	nop			; (mov r8, r8)
    6464:	fff00000 	.word	0xfff00000
    6468:	7fdfffff 	.word	0x7fdfffff
    646c:	7ff00000 	.word	0x7ff00000
    6470:	000fffff 	.word	0x000fffff

00006474 <__gnu_thumb1_case_uqi>:
    6474:	b402      	push	{r1}
    6476:	4671      	mov	r1, lr
    6478:	0849      	lsrs	r1, r1, #1
    647a:	0049      	lsls	r1, r1, #1
    647c:	5c09      	ldrb	r1, [r1, r0]
    647e:	0049      	lsls	r1, r1, #1
    6480:	448e      	add	lr, r1
    6482:	bc02      	pop	{r1}
    6484:	4770      	bx	lr
    6486:	46c0      	nop			; (mov r8, r8)

00006488 <__aeabi_uidiv>:
    6488:	2900      	cmp	r1, #0
    648a:	d034      	beq.n	64f6 <.udivsi3_skip_div0_test+0x6a>

0000648c <.udivsi3_skip_div0_test>:
    648c:	2301      	movs	r3, #1
    648e:	2200      	movs	r2, #0
    6490:	b410      	push	{r4}
    6492:	4288      	cmp	r0, r1
    6494:	d32c      	bcc.n	64f0 <.udivsi3_skip_div0_test+0x64>
    6496:	2401      	movs	r4, #1
    6498:	0724      	lsls	r4, r4, #28
    649a:	42a1      	cmp	r1, r4
    649c:	d204      	bcs.n	64a8 <.udivsi3_skip_div0_test+0x1c>
    649e:	4281      	cmp	r1, r0
    64a0:	d202      	bcs.n	64a8 <.udivsi3_skip_div0_test+0x1c>
    64a2:	0109      	lsls	r1, r1, #4
    64a4:	011b      	lsls	r3, r3, #4
    64a6:	e7f8      	b.n	649a <.udivsi3_skip_div0_test+0xe>
    64a8:	00e4      	lsls	r4, r4, #3
    64aa:	42a1      	cmp	r1, r4
    64ac:	d204      	bcs.n	64b8 <.udivsi3_skip_div0_test+0x2c>
    64ae:	4281      	cmp	r1, r0
    64b0:	d202      	bcs.n	64b8 <.udivsi3_skip_div0_test+0x2c>
    64b2:	0049      	lsls	r1, r1, #1
    64b4:	005b      	lsls	r3, r3, #1
    64b6:	e7f8      	b.n	64aa <.udivsi3_skip_div0_test+0x1e>
    64b8:	4288      	cmp	r0, r1
    64ba:	d301      	bcc.n	64c0 <.udivsi3_skip_div0_test+0x34>
    64bc:	1a40      	subs	r0, r0, r1
    64be:	431a      	orrs	r2, r3
    64c0:	084c      	lsrs	r4, r1, #1
    64c2:	42a0      	cmp	r0, r4
    64c4:	d302      	bcc.n	64cc <.udivsi3_skip_div0_test+0x40>
    64c6:	1b00      	subs	r0, r0, r4
    64c8:	085c      	lsrs	r4, r3, #1
    64ca:	4322      	orrs	r2, r4
    64cc:	088c      	lsrs	r4, r1, #2
    64ce:	42a0      	cmp	r0, r4
    64d0:	d302      	bcc.n	64d8 <.udivsi3_skip_div0_test+0x4c>
    64d2:	1b00      	subs	r0, r0, r4
    64d4:	089c      	lsrs	r4, r3, #2
    64d6:	4322      	orrs	r2, r4
    64d8:	08cc      	lsrs	r4, r1, #3
    64da:	42a0      	cmp	r0, r4
    64dc:	d302      	bcc.n	64e4 <.udivsi3_skip_div0_test+0x58>
    64de:	1b00      	subs	r0, r0, r4
    64e0:	08dc      	lsrs	r4, r3, #3
    64e2:	4322      	orrs	r2, r4
    64e4:	2800      	cmp	r0, #0
    64e6:	d003      	beq.n	64f0 <.udivsi3_skip_div0_test+0x64>
    64e8:	091b      	lsrs	r3, r3, #4
    64ea:	d001      	beq.n	64f0 <.udivsi3_skip_div0_test+0x64>
    64ec:	0909      	lsrs	r1, r1, #4
    64ee:	e7e3      	b.n	64b8 <.udivsi3_skip_div0_test+0x2c>
    64f0:	1c10      	adds	r0, r2, #0
    64f2:	bc10      	pop	{r4}
    64f4:	4770      	bx	lr
    64f6:	2800      	cmp	r0, #0
    64f8:	d001      	beq.n	64fe <.udivsi3_skip_div0_test+0x72>
    64fa:	2000      	movs	r0, #0
    64fc:	43c0      	mvns	r0, r0
    64fe:	b407      	push	{r0, r1, r2}
    6500:	4802      	ldr	r0, [pc, #8]	; (650c <.udivsi3_skip_div0_test+0x80>)
    6502:	a102      	add	r1, pc, #8	; (adr r1, 650c <.udivsi3_skip_div0_test+0x80>)
    6504:	1840      	adds	r0, r0, r1
    6506:	9002      	str	r0, [sp, #8]
    6508:	bd03      	pop	{r0, r1, pc}
    650a:	46c0      	nop			; (mov r8, r8)
    650c:	000000d9 	.word	0x000000d9

00006510 <__aeabi_uidivmod>:
    6510:	2900      	cmp	r1, #0
    6512:	d0f0      	beq.n	64f6 <.udivsi3_skip_div0_test+0x6a>
    6514:	b503      	push	{r0, r1, lr}
    6516:	f7ff ffb9 	bl	648c <.udivsi3_skip_div0_test>
    651a:	bc0e      	pop	{r1, r2, r3}
    651c:	4342      	muls	r2, r0
    651e:	1a89      	subs	r1, r1, r2
    6520:	4718      	bx	r3
    6522:	46c0      	nop			; (mov r8, r8)

00006524 <__aeabi_idiv>:
    6524:	2900      	cmp	r1, #0
    6526:	d041      	beq.n	65ac <.divsi3_skip_div0_test+0x84>

00006528 <.divsi3_skip_div0_test>:
    6528:	b410      	push	{r4}
    652a:	1c04      	adds	r4, r0, #0
    652c:	404c      	eors	r4, r1
    652e:	46a4      	mov	ip, r4
    6530:	2301      	movs	r3, #1
    6532:	2200      	movs	r2, #0
    6534:	2900      	cmp	r1, #0
    6536:	d500      	bpl.n	653a <.divsi3_skip_div0_test+0x12>
    6538:	4249      	negs	r1, r1
    653a:	2800      	cmp	r0, #0
    653c:	d500      	bpl.n	6540 <.divsi3_skip_div0_test+0x18>
    653e:	4240      	negs	r0, r0
    6540:	4288      	cmp	r0, r1
    6542:	d32c      	bcc.n	659e <.divsi3_skip_div0_test+0x76>
    6544:	2401      	movs	r4, #1
    6546:	0724      	lsls	r4, r4, #28
    6548:	42a1      	cmp	r1, r4
    654a:	d204      	bcs.n	6556 <.divsi3_skip_div0_test+0x2e>
    654c:	4281      	cmp	r1, r0
    654e:	d202      	bcs.n	6556 <.divsi3_skip_div0_test+0x2e>
    6550:	0109      	lsls	r1, r1, #4
    6552:	011b      	lsls	r3, r3, #4
    6554:	e7f8      	b.n	6548 <.divsi3_skip_div0_test+0x20>
    6556:	00e4      	lsls	r4, r4, #3
    6558:	42a1      	cmp	r1, r4
    655a:	d204      	bcs.n	6566 <.divsi3_skip_div0_test+0x3e>
    655c:	4281      	cmp	r1, r0
    655e:	d202      	bcs.n	6566 <.divsi3_skip_div0_test+0x3e>
    6560:	0049      	lsls	r1, r1, #1
    6562:	005b      	lsls	r3, r3, #1
    6564:	e7f8      	b.n	6558 <.divsi3_skip_div0_test+0x30>
    6566:	4288      	cmp	r0, r1
    6568:	d301      	bcc.n	656e <.divsi3_skip_div0_test+0x46>
    656a:	1a40      	subs	r0, r0, r1
    656c:	431a      	orrs	r2, r3
    656e:	084c      	lsrs	r4, r1, #1
    6570:	42a0      	cmp	r0, r4
    6572:	d302      	bcc.n	657a <.divsi3_skip_div0_test+0x52>
    6574:	1b00      	subs	r0, r0, r4
    6576:	085c      	lsrs	r4, r3, #1
    6578:	4322      	orrs	r2, r4
    657a:	088c      	lsrs	r4, r1, #2
    657c:	42a0      	cmp	r0, r4
    657e:	d302      	bcc.n	6586 <.divsi3_skip_div0_test+0x5e>
    6580:	1b00      	subs	r0, r0, r4
    6582:	089c      	lsrs	r4, r3, #2
    6584:	4322      	orrs	r2, r4
    6586:	08cc      	lsrs	r4, r1, #3
    6588:	42a0      	cmp	r0, r4
    658a:	d302      	bcc.n	6592 <.divsi3_skip_div0_test+0x6a>
    658c:	1b00      	subs	r0, r0, r4
    658e:	08dc      	lsrs	r4, r3, #3
    6590:	4322      	orrs	r2, r4
    6592:	2800      	cmp	r0, #0
    6594:	d003      	beq.n	659e <.divsi3_skip_div0_test+0x76>
    6596:	091b      	lsrs	r3, r3, #4
    6598:	d001      	beq.n	659e <.divsi3_skip_div0_test+0x76>
    659a:	0909      	lsrs	r1, r1, #4
    659c:	e7e3      	b.n	6566 <.divsi3_skip_div0_test+0x3e>
    659e:	1c10      	adds	r0, r2, #0
    65a0:	4664      	mov	r4, ip
    65a2:	2c00      	cmp	r4, #0
    65a4:	d500      	bpl.n	65a8 <.divsi3_skip_div0_test+0x80>
    65a6:	4240      	negs	r0, r0
    65a8:	bc10      	pop	{r4}
    65aa:	4770      	bx	lr
    65ac:	2800      	cmp	r0, #0
    65ae:	d006      	beq.n	65be <.divsi3_skip_div0_test+0x96>
    65b0:	db03      	blt.n	65ba <.divsi3_skip_div0_test+0x92>
    65b2:	2000      	movs	r0, #0
    65b4:	43c0      	mvns	r0, r0
    65b6:	0840      	lsrs	r0, r0, #1
    65b8:	e001      	b.n	65be <.divsi3_skip_div0_test+0x96>
    65ba:	2080      	movs	r0, #128	; 0x80
    65bc:	0600      	lsls	r0, r0, #24
    65be:	b407      	push	{r0, r1, r2}
    65c0:	4802      	ldr	r0, [pc, #8]	; (65cc <.divsi3_skip_div0_test+0xa4>)
    65c2:	a102      	add	r1, pc, #8	; (adr r1, 65cc <.divsi3_skip_div0_test+0xa4>)
    65c4:	1840      	adds	r0, r0, r1
    65c6:	9002      	str	r0, [sp, #8]
    65c8:	bd03      	pop	{r0, r1, pc}
    65ca:	46c0      	nop			; (mov r8, r8)
    65cc:	00000019 	.word	0x00000019

000065d0 <__aeabi_idivmod>:
    65d0:	2900      	cmp	r1, #0
    65d2:	d0eb      	beq.n	65ac <.divsi3_skip_div0_test+0x84>
    65d4:	b503      	push	{r0, r1, lr}
    65d6:	f7ff ffa7 	bl	6528 <.divsi3_skip_div0_test>
    65da:	bc0e      	pop	{r1, r2, r3}
    65dc:	4342      	muls	r2, r0
    65de:	1a89      	subs	r1, r1, r2
    65e0:	4718      	bx	r3
    65e2:	46c0      	nop			; (mov r8, r8)

000065e4 <__aeabi_idiv0>:
    65e4:	4770      	bx	lr
    65e6:	46c0      	nop			; (mov r8, r8)

000065e8 <__aeabi_cdrcmple>:
    65e8:	4684      	mov	ip, r0
    65ea:	1c10      	adds	r0, r2, #0
    65ec:	4662      	mov	r2, ip
    65ee:	468c      	mov	ip, r1
    65f0:	1c19      	adds	r1, r3, #0
    65f2:	4663      	mov	r3, ip
    65f4:	e000      	b.n	65f8 <__aeabi_cdcmpeq>
    65f6:	46c0      	nop			; (mov r8, r8)

000065f8 <__aeabi_cdcmpeq>:
    65f8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    65fa:	f000 ff5d 	bl	74b8 <__ledf2>
    65fe:	2800      	cmp	r0, #0
    6600:	d401      	bmi.n	6606 <__aeabi_cdcmpeq+0xe>
    6602:	2100      	movs	r1, #0
    6604:	42c8      	cmn	r0, r1
    6606:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

00006608 <__aeabi_dcmpeq>:
    6608:	b510      	push	{r4, lr}
    660a:	f000 fe8d 	bl	7328 <__eqdf2>
    660e:	4240      	negs	r0, r0
    6610:	3001      	adds	r0, #1
    6612:	bd10      	pop	{r4, pc}

00006614 <__aeabi_dcmplt>:
    6614:	b510      	push	{r4, lr}
    6616:	f000 ff4f 	bl	74b8 <__ledf2>
    661a:	2800      	cmp	r0, #0
    661c:	db01      	blt.n	6622 <__aeabi_dcmplt+0xe>
    661e:	2000      	movs	r0, #0
    6620:	bd10      	pop	{r4, pc}
    6622:	2001      	movs	r0, #1
    6624:	bd10      	pop	{r4, pc}
    6626:	46c0      	nop			; (mov r8, r8)

00006628 <__aeabi_dcmple>:
    6628:	b510      	push	{r4, lr}
    662a:	f000 ff45 	bl	74b8 <__ledf2>
    662e:	2800      	cmp	r0, #0
    6630:	dd01      	ble.n	6636 <__aeabi_dcmple+0xe>
    6632:	2000      	movs	r0, #0
    6634:	bd10      	pop	{r4, pc}
    6636:	2001      	movs	r0, #1
    6638:	bd10      	pop	{r4, pc}
    663a:	46c0      	nop			; (mov r8, r8)

0000663c <__aeabi_dcmpgt>:
    663c:	b510      	push	{r4, lr}
    663e:	f000 febd 	bl	73bc <__gedf2>
    6642:	2800      	cmp	r0, #0
    6644:	dc01      	bgt.n	664a <__aeabi_dcmpgt+0xe>
    6646:	2000      	movs	r0, #0
    6648:	bd10      	pop	{r4, pc}
    664a:	2001      	movs	r0, #1
    664c:	bd10      	pop	{r4, pc}
    664e:	46c0      	nop			; (mov r8, r8)

00006650 <__aeabi_dcmpge>:
    6650:	b510      	push	{r4, lr}
    6652:	f000 feb3 	bl	73bc <__gedf2>
    6656:	2800      	cmp	r0, #0
    6658:	da01      	bge.n	665e <__aeabi_dcmpge+0xe>
    665a:	2000      	movs	r0, #0
    665c:	bd10      	pop	{r4, pc}
    665e:	2001      	movs	r0, #1
    6660:	bd10      	pop	{r4, pc}
    6662:	46c0      	nop			; (mov r8, r8)
    6664:	0000      	movs	r0, r0
	...

00006668 <__aeabi_d2uiz>:
    6668:	b538      	push	{r3, r4, r5, lr}
    666a:	4b0e      	ldr	r3, [pc, #56]	; (66a4 <__aeabi_d2uiz+0x3c>)
    666c:	4a0c      	ldr	r2, [pc, #48]	; (66a0 <__aeabi_d2uiz+0x38>)
    666e:	1c04      	adds	r4, r0, #0
    6670:	1c0d      	adds	r5, r1, #0
    6672:	f7ff ffed 	bl	6650 <__aeabi_dcmpge>
    6676:	2800      	cmp	r0, #0
    6678:	d104      	bne.n	6684 <__aeabi_d2uiz+0x1c>
    667a:	1c20      	adds	r0, r4, #0
    667c:	1c29      	adds	r1, r5, #0
    667e:	f001 fd53 	bl	8128 <__aeabi_d2iz>
    6682:	bd38      	pop	{r3, r4, r5, pc}
    6684:	4b07      	ldr	r3, [pc, #28]	; (66a4 <__aeabi_d2uiz+0x3c>)
    6686:	4a06      	ldr	r2, [pc, #24]	; (66a0 <__aeabi_d2uiz+0x38>)
    6688:	1c20      	adds	r0, r4, #0
    668a:	1c29      	adds	r1, r5, #0
    668c:	f001 fa22 	bl	7ad4 <__aeabi_dsub>
    6690:	f001 fd4a 	bl	8128 <__aeabi_d2iz>
    6694:	2380      	movs	r3, #128	; 0x80
    6696:	061b      	lsls	r3, r3, #24
    6698:	18c0      	adds	r0, r0, r3
    669a:	e7f2      	b.n	6682 <__aeabi_d2uiz+0x1a>
    669c:	46c0      	nop			; (mov r8, r8)
    669e:	46c0      	nop			; (mov r8, r8)
    66a0:	00000000 	.word	0x00000000
    66a4:	41e00000 	.word	0x41e00000

000066a8 <__aeabi_dadd>:
    66a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    66aa:	465f      	mov	r7, fp
    66ac:	4656      	mov	r6, sl
    66ae:	4644      	mov	r4, r8
    66b0:	464d      	mov	r5, r9
    66b2:	b4f0      	push	{r4, r5, r6, r7}
    66b4:	030c      	lsls	r4, r1, #12
    66b6:	004d      	lsls	r5, r1, #1
    66b8:	0fce      	lsrs	r6, r1, #31
    66ba:	0a61      	lsrs	r1, r4, #9
    66bc:	0f44      	lsrs	r4, r0, #29
    66be:	4321      	orrs	r1, r4
    66c0:	00c4      	lsls	r4, r0, #3
    66c2:	0318      	lsls	r0, r3, #12
    66c4:	4680      	mov	r8, r0
    66c6:	0058      	lsls	r0, r3, #1
    66c8:	0d40      	lsrs	r0, r0, #21
    66ca:	4682      	mov	sl, r0
    66cc:	0fd8      	lsrs	r0, r3, #31
    66ce:	4684      	mov	ip, r0
    66d0:	4640      	mov	r0, r8
    66d2:	0a40      	lsrs	r0, r0, #9
    66d4:	0f53      	lsrs	r3, r2, #29
    66d6:	4303      	orrs	r3, r0
    66d8:	00d0      	lsls	r0, r2, #3
    66da:	0d6d      	lsrs	r5, r5, #21
    66dc:	1c37      	adds	r7, r6, #0
    66de:	4683      	mov	fp, r0
    66e0:	4652      	mov	r2, sl
    66e2:	4566      	cmp	r6, ip
    66e4:	d100      	bne.n	66e8 <__aeabi_dadd+0x40>
    66e6:	e09d      	b.n	6824 <__aeabi_dadd+0x17c>
    66e8:	1aaf      	subs	r7, r5, r2
    66ea:	2f00      	cmp	r7, #0
    66ec:	dc00      	bgt.n	66f0 <__aeabi_dadd+0x48>
    66ee:	e103      	b.n	68f8 <__aeabi_dadd+0x250>
    66f0:	2a00      	cmp	r2, #0
    66f2:	d138      	bne.n	6766 <__aeabi_dadd+0xbe>
    66f4:	4318      	orrs	r0, r3
    66f6:	d000      	beq.n	66fa <__aeabi_dadd+0x52>
    66f8:	e0e4      	b.n	68c4 <__aeabi_dadd+0x21c>
    66fa:	0763      	lsls	r3, r4, #29
    66fc:	d009      	beq.n	6712 <__aeabi_dadd+0x6a>
    66fe:	230f      	movs	r3, #15
    6700:	4023      	ands	r3, r4
    6702:	2b04      	cmp	r3, #4
    6704:	d005      	beq.n	6712 <__aeabi_dadd+0x6a>
    6706:	1d23      	adds	r3, r4, #4
    6708:	42a3      	cmp	r3, r4
    670a:	41a4      	sbcs	r4, r4
    670c:	4264      	negs	r4, r4
    670e:	1909      	adds	r1, r1, r4
    6710:	1c1c      	adds	r4, r3, #0
    6712:	0208      	lsls	r0, r1, #8
    6714:	d400      	bmi.n	6718 <__aeabi_dadd+0x70>
    6716:	e078      	b.n	680a <__aeabi_dadd+0x162>
    6718:	4bce      	ldr	r3, [pc, #824]	; (6a54 <__aeabi_dadd+0x3ac>)
    671a:	1c6a      	adds	r2, r5, #1
    671c:	429a      	cmp	r2, r3
    671e:	d100      	bne.n	6722 <__aeabi_dadd+0x7a>
    6720:	e105      	b.n	692e <__aeabi_dadd+0x286>
    6722:	4bcd      	ldr	r3, [pc, #820]	; (6a58 <__aeabi_dadd+0x3b0>)
    6724:	08e4      	lsrs	r4, r4, #3
    6726:	4019      	ands	r1, r3
    6728:	0748      	lsls	r0, r1, #29
    672a:	0552      	lsls	r2, r2, #21
    672c:	0249      	lsls	r1, r1, #9
    672e:	4304      	orrs	r4, r0
    6730:	0b0b      	lsrs	r3, r1, #12
    6732:	0d52      	lsrs	r2, r2, #21
    6734:	1c37      	adds	r7, r6, #0
    6736:	2000      	movs	r0, #0
    6738:	2100      	movs	r1, #0
    673a:	031b      	lsls	r3, r3, #12
    673c:	1c20      	adds	r0, r4, #0
    673e:	0b1c      	lsrs	r4, r3, #12
    6740:	0d0b      	lsrs	r3, r1, #20
    6742:	051b      	lsls	r3, r3, #20
    6744:	4dc5      	ldr	r5, [pc, #788]	; (6a5c <__aeabi_dadd+0x3b4>)
    6746:	4323      	orrs	r3, r4
    6748:	0552      	lsls	r2, r2, #21
    674a:	0852      	lsrs	r2, r2, #1
    674c:	401d      	ands	r5, r3
    674e:	4315      	orrs	r5, r2
    6750:	006d      	lsls	r5, r5, #1
    6752:	086d      	lsrs	r5, r5, #1
    6754:	07ff      	lsls	r7, r7, #31
    6756:	1c29      	adds	r1, r5, #0
    6758:	4339      	orrs	r1, r7
    675a:	bc3c      	pop	{r2, r3, r4, r5}
    675c:	4690      	mov	r8, r2
    675e:	4699      	mov	r9, r3
    6760:	46a2      	mov	sl, r4
    6762:	46ab      	mov	fp, r5
    6764:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6766:	48bb      	ldr	r0, [pc, #748]	; (6a54 <__aeabi_dadd+0x3ac>)
    6768:	4285      	cmp	r5, r0
    676a:	d0c6      	beq.n	66fa <__aeabi_dadd+0x52>
    676c:	2080      	movs	r0, #128	; 0x80
    676e:	0400      	lsls	r0, r0, #16
    6770:	4303      	orrs	r3, r0
    6772:	2f38      	cmp	r7, #56	; 0x38
    6774:	dd00      	ble.n	6778 <__aeabi_dadd+0xd0>
    6776:	e0ec      	b.n	6952 <__aeabi_dadd+0x2aa>
    6778:	2f1f      	cmp	r7, #31
    677a:	dd00      	ble.n	677e <__aeabi_dadd+0xd6>
    677c:	e120      	b.n	69c0 <__aeabi_dadd+0x318>
    677e:	2020      	movs	r0, #32
    6780:	1bc0      	subs	r0, r0, r7
    6782:	1c1a      	adds	r2, r3, #0
    6784:	4681      	mov	r9, r0
    6786:	4082      	lsls	r2, r0
    6788:	4658      	mov	r0, fp
    678a:	40f8      	lsrs	r0, r7
    678c:	4302      	orrs	r2, r0
    678e:	4694      	mov	ip, r2
    6790:	4658      	mov	r0, fp
    6792:	464a      	mov	r2, r9
    6794:	4090      	lsls	r0, r2
    6796:	1e42      	subs	r2, r0, #1
    6798:	4190      	sbcs	r0, r2
    679a:	40fb      	lsrs	r3, r7
    679c:	4662      	mov	r2, ip
    679e:	4302      	orrs	r2, r0
    67a0:	1c1f      	adds	r7, r3, #0
    67a2:	1aa2      	subs	r2, r4, r2
    67a4:	4294      	cmp	r4, r2
    67a6:	41a4      	sbcs	r4, r4
    67a8:	4264      	negs	r4, r4
    67aa:	1bc9      	subs	r1, r1, r7
    67ac:	1b09      	subs	r1, r1, r4
    67ae:	1c14      	adds	r4, r2, #0
    67b0:	020b      	lsls	r3, r1, #8
    67b2:	d5a2      	bpl.n	66fa <__aeabi_dadd+0x52>
    67b4:	0249      	lsls	r1, r1, #9
    67b6:	0a4f      	lsrs	r7, r1, #9
    67b8:	2f00      	cmp	r7, #0
    67ba:	d100      	bne.n	67be <__aeabi_dadd+0x116>
    67bc:	e0c4      	b.n	6948 <__aeabi_dadd+0x2a0>
    67be:	1c38      	adds	r0, r7, #0
    67c0:	f001 fd6c 	bl	829c <__clzsi2>
    67c4:	1c02      	adds	r2, r0, #0
    67c6:	3a08      	subs	r2, #8
    67c8:	2a1f      	cmp	r2, #31
    67ca:	dd00      	ble.n	67ce <__aeabi_dadd+0x126>
    67cc:	e0b7      	b.n	693e <__aeabi_dadd+0x296>
    67ce:	2128      	movs	r1, #40	; 0x28
    67d0:	1a09      	subs	r1, r1, r0
    67d2:	1c20      	adds	r0, r4, #0
    67d4:	4097      	lsls	r7, r2
    67d6:	40c8      	lsrs	r0, r1
    67d8:	4307      	orrs	r7, r0
    67da:	4094      	lsls	r4, r2
    67dc:	4295      	cmp	r5, r2
    67de:	dd00      	ble.n	67e2 <__aeabi_dadd+0x13a>
    67e0:	e0a9      	b.n	6936 <__aeabi_dadd+0x28e>
    67e2:	1b55      	subs	r5, r2, r5
    67e4:	1c69      	adds	r1, r5, #1
    67e6:	291f      	cmp	r1, #31
    67e8:	dd00      	ble.n	67ec <__aeabi_dadd+0x144>
    67ea:	e0d8      	b.n	699e <__aeabi_dadd+0x2f6>
    67ec:	221f      	movs	r2, #31
    67ee:	1b55      	subs	r5, r2, r5
    67f0:	1c3b      	adds	r3, r7, #0
    67f2:	1c22      	adds	r2, r4, #0
    67f4:	40ab      	lsls	r3, r5
    67f6:	40ca      	lsrs	r2, r1
    67f8:	40ac      	lsls	r4, r5
    67fa:	1e65      	subs	r5, r4, #1
    67fc:	41ac      	sbcs	r4, r5
    67fe:	4313      	orrs	r3, r2
    6800:	40cf      	lsrs	r7, r1
    6802:	431c      	orrs	r4, r3
    6804:	1c39      	adds	r1, r7, #0
    6806:	2500      	movs	r5, #0
    6808:	e777      	b.n	66fa <__aeabi_dadd+0x52>
    680a:	0748      	lsls	r0, r1, #29
    680c:	08e4      	lsrs	r4, r4, #3
    680e:	056a      	lsls	r2, r5, #21
    6810:	08c9      	lsrs	r1, r1, #3
    6812:	0d52      	lsrs	r2, r2, #21
    6814:	1c37      	adds	r7, r6, #0
    6816:	4304      	orrs	r4, r0
    6818:	4b8e      	ldr	r3, [pc, #568]	; (6a54 <__aeabi_dadd+0x3ac>)
    681a:	429d      	cmp	r5, r3
    681c:	d048      	beq.n	68b0 <__aeabi_dadd+0x208>
    681e:	0309      	lsls	r1, r1, #12
    6820:	0b0b      	lsrs	r3, r1, #12
    6822:	e788      	b.n	6736 <__aeabi_dadd+0x8e>
    6824:	1aaa      	subs	r2, r5, r2
    6826:	4694      	mov	ip, r2
    6828:	2a00      	cmp	r2, #0
    682a:	dc00      	bgt.n	682e <__aeabi_dadd+0x186>
    682c:	e098      	b.n	6960 <__aeabi_dadd+0x2b8>
    682e:	4650      	mov	r0, sl
    6830:	2800      	cmp	r0, #0
    6832:	d053      	beq.n	68dc <__aeabi_dadd+0x234>
    6834:	4887      	ldr	r0, [pc, #540]	; (6a54 <__aeabi_dadd+0x3ac>)
    6836:	4285      	cmp	r5, r0
    6838:	d100      	bne.n	683c <__aeabi_dadd+0x194>
    683a:	e75e      	b.n	66fa <__aeabi_dadd+0x52>
    683c:	2080      	movs	r0, #128	; 0x80
    683e:	0400      	lsls	r0, r0, #16
    6840:	4303      	orrs	r3, r0
    6842:	4662      	mov	r2, ip
    6844:	2a38      	cmp	r2, #56	; 0x38
    6846:	dd00      	ble.n	684a <__aeabi_dadd+0x1a2>
    6848:	e0fd      	b.n	6a46 <__aeabi_dadd+0x39e>
    684a:	2a1f      	cmp	r2, #31
    684c:	dd00      	ble.n	6850 <__aeabi_dadd+0x1a8>
    684e:	e14b      	b.n	6ae8 <__aeabi_dadd+0x440>
    6850:	2220      	movs	r2, #32
    6852:	4660      	mov	r0, ip
    6854:	1a10      	subs	r0, r2, r0
    6856:	1c1a      	adds	r2, r3, #0
    6858:	4082      	lsls	r2, r0
    685a:	4682      	mov	sl, r0
    685c:	4691      	mov	r9, r2
    685e:	4658      	mov	r0, fp
    6860:	4662      	mov	r2, ip
    6862:	40d0      	lsrs	r0, r2
    6864:	464a      	mov	r2, r9
    6866:	4302      	orrs	r2, r0
    6868:	4690      	mov	r8, r2
    686a:	4658      	mov	r0, fp
    686c:	4652      	mov	r2, sl
    686e:	4090      	lsls	r0, r2
    6870:	1e42      	subs	r2, r0, #1
    6872:	4190      	sbcs	r0, r2
    6874:	4642      	mov	r2, r8
    6876:	4302      	orrs	r2, r0
    6878:	4660      	mov	r0, ip
    687a:	40c3      	lsrs	r3, r0
    687c:	1912      	adds	r2, r2, r4
    687e:	42a2      	cmp	r2, r4
    6880:	41a4      	sbcs	r4, r4
    6882:	4264      	negs	r4, r4
    6884:	1859      	adds	r1, r3, r1
    6886:	1909      	adds	r1, r1, r4
    6888:	1c14      	adds	r4, r2, #0
    688a:	0208      	lsls	r0, r1, #8
    688c:	d400      	bmi.n	6890 <__aeabi_dadd+0x1e8>
    688e:	e734      	b.n	66fa <__aeabi_dadd+0x52>
    6890:	4b70      	ldr	r3, [pc, #448]	; (6a54 <__aeabi_dadd+0x3ac>)
    6892:	3501      	adds	r5, #1
    6894:	429d      	cmp	r5, r3
    6896:	d100      	bne.n	689a <__aeabi_dadd+0x1f2>
    6898:	e124      	b.n	6ae4 <__aeabi_dadd+0x43c>
    689a:	4b6f      	ldr	r3, [pc, #444]	; (6a58 <__aeabi_dadd+0x3b0>)
    689c:	0860      	lsrs	r0, r4, #1
    689e:	4019      	ands	r1, r3
    68a0:	2301      	movs	r3, #1
    68a2:	4023      	ands	r3, r4
    68a4:	1c1c      	adds	r4, r3, #0
    68a6:	4304      	orrs	r4, r0
    68a8:	07cb      	lsls	r3, r1, #31
    68aa:	431c      	orrs	r4, r3
    68ac:	0849      	lsrs	r1, r1, #1
    68ae:	e724      	b.n	66fa <__aeabi_dadd+0x52>
    68b0:	1c0b      	adds	r3, r1, #0
    68b2:	4323      	orrs	r3, r4
    68b4:	d100      	bne.n	68b8 <__aeabi_dadd+0x210>
    68b6:	e1c7      	b.n	6c48 <__aeabi_dadd+0x5a0>
    68b8:	2380      	movs	r3, #128	; 0x80
    68ba:	031b      	lsls	r3, r3, #12
    68bc:	430b      	orrs	r3, r1
    68be:	031b      	lsls	r3, r3, #12
    68c0:	0b1b      	lsrs	r3, r3, #12
    68c2:	e738      	b.n	6736 <__aeabi_dadd+0x8e>
    68c4:	3f01      	subs	r7, #1
    68c6:	2f00      	cmp	r7, #0
    68c8:	d164      	bne.n	6994 <__aeabi_dadd+0x2ec>
    68ca:	4658      	mov	r0, fp
    68cc:	1a22      	subs	r2, r4, r0
    68ce:	4294      	cmp	r4, r2
    68d0:	41a4      	sbcs	r4, r4
    68d2:	4264      	negs	r4, r4
    68d4:	1ac9      	subs	r1, r1, r3
    68d6:	1b09      	subs	r1, r1, r4
    68d8:	1c14      	adds	r4, r2, #0
    68da:	e769      	b.n	67b0 <__aeabi_dadd+0x108>
    68dc:	4658      	mov	r0, fp
    68de:	4318      	orrs	r0, r3
    68e0:	d100      	bne.n	68e4 <__aeabi_dadd+0x23c>
    68e2:	e70a      	b.n	66fa <__aeabi_dadd+0x52>
    68e4:	2201      	movs	r2, #1
    68e6:	4252      	negs	r2, r2
    68e8:	4494      	add	ip, r2
    68ea:	4660      	mov	r0, ip
    68ec:	2800      	cmp	r0, #0
    68ee:	d000      	beq.n	68f2 <__aeabi_dadd+0x24a>
    68f0:	e0c5      	b.n	6a7e <__aeabi_dadd+0x3d6>
    68f2:	4658      	mov	r0, fp
    68f4:	1902      	adds	r2, r0, r4
    68f6:	e7c2      	b.n	687e <__aeabi_dadd+0x1d6>
    68f8:	2f00      	cmp	r7, #0
    68fa:	d172      	bne.n	69e2 <__aeabi_dadd+0x33a>
    68fc:	1c68      	adds	r0, r5, #1
    68fe:	0540      	lsls	r0, r0, #21
    6900:	0d40      	lsrs	r0, r0, #21
    6902:	2801      	cmp	r0, #1
    6904:	dc00      	bgt.n	6908 <__aeabi_dadd+0x260>
    6906:	e0de      	b.n	6ac6 <__aeabi_dadd+0x41e>
    6908:	465a      	mov	r2, fp
    690a:	1aa2      	subs	r2, r4, r2
    690c:	4294      	cmp	r4, r2
    690e:	41bf      	sbcs	r7, r7
    6910:	1ac8      	subs	r0, r1, r3
    6912:	427f      	negs	r7, r7
    6914:	1bc7      	subs	r7, r0, r7
    6916:	0238      	lsls	r0, r7, #8
    6918:	d400      	bmi.n	691c <__aeabi_dadd+0x274>
    691a:	e088      	b.n	6a2e <__aeabi_dadd+0x386>
    691c:	465a      	mov	r2, fp
    691e:	1b14      	subs	r4, r2, r4
    6920:	45a3      	cmp	fp, r4
    6922:	4192      	sbcs	r2, r2
    6924:	1a59      	subs	r1, r3, r1
    6926:	4252      	negs	r2, r2
    6928:	1a8f      	subs	r7, r1, r2
    692a:	4666      	mov	r6, ip
    692c:	e744      	b.n	67b8 <__aeabi_dadd+0x110>
    692e:	1c37      	adds	r7, r6, #0
    6930:	2300      	movs	r3, #0
    6932:	2400      	movs	r4, #0
    6934:	e6ff      	b.n	6736 <__aeabi_dadd+0x8e>
    6936:	4948      	ldr	r1, [pc, #288]	; (6a58 <__aeabi_dadd+0x3b0>)
    6938:	1aad      	subs	r5, r5, r2
    693a:	4039      	ands	r1, r7
    693c:	e6dd      	b.n	66fa <__aeabi_dadd+0x52>
    693e:	1c27      	adds	r7, r4, #0
    6940:	3828      	subs	r0, #40	; 0x28
    6942:	4087      	lsls	r7, r0
    6944:	2400      	movs	r4, #0
    6946:	e749      	b.n	67dc <__aeabi_dadd+0x134>
    6948:	1c20      	adds	r0, r4, #0
    694a:	f001 fca7 	bl	829c <__clzsi2>
    694e:	3020      	adds	r0, #32
    6950:	e738      	b.n	67c4 <__aeabi_dadd+0x11c>
    6952:	465a      	mov	r2, fp
    6954:	431a      	orrs	r2, r3
    6956:	1e53      	subs	r3, r2, #1
    6958:	419a      	sbcs	r2, r3
    695a:	b2d2      	uxtb	r2, r2
    695c:	2700      	movs	r7, #0
    695e:	e720      	b.n	67a2 <__aeabi_dadd+0xfa>
    6960:	2a00      	cmp	r2, #0
    6962:	d000      	beq.n	6966 <__aeabi_dadd+0x2be>
    6964:	e0dd      	b.n	6b22 <__aeabi_dadd+0x47a>
    6966:	1c68      	adds	r0, r5, #1
    6968:	0542      	lsls	r2, r0, #21
    696a:	0d52      	lsrs	r2, r2, #21
    696c:	2a01      	cmp	r2, #1
    696e:	dc00      	bgt.n	6972 <__aeabi_dadd+0x2ca>
    6970:	e08e      	b.n	6a90 <__aeabi_dadd+0x3e8>
    6972:	4d38      	ldr	r5, [pc, #224]	; (6a54 <__aeabi_dadd+0x3ac>)
    6974:	42a8      	cmp	r0, r5
    6976:	d100      	bne.n	697a <__aeabi_dadd+0x2d2>
    6978:	e0b3      	b.n	6ae2 <__aeabi_dadd+0x43a>
    697a:	465d      	mov	r5, fp
    697c:	192a      	adds	r2, r5, r4
    697e:	42a2      	cmp	r2, r4
    6980:	41a4      	sbcs	r4, r4
    6982:	4264      	negs	r4, r4
    6984:	1859      	adds	r1, r3, r1
    6986:	1909      	adds	r1, r1, r4
    6988:	07cc      	lsls	r4, r1, #31
    698a:	0852      	lsrs	r2, r2, #1
    698c:	4314      	orrs	r4, r2
    698e:	0849      	lsrs	r1, r1, #1
    6990:	1c05      	adds	r5, r0, #0
    6992:	e6b2      	b.n	66fa <__aeabi_dadd+0x52>
    6994:	482f      	ldr	r0, [pc, #188]	; (6a54 <__aeabi_dadd+0x3ac>)
    6996:	4285      	cmp	r5, r0
    6998:	d000      	beq.n	699c <__aeabi_dadd+0x2f4>
    699a:	e6ea      	b.n	6772 <__aeabi_dadd+0xca>
    699c:	e6ad      	b.n	66fa <__aeabi_dadd+0x52>
    699e:	1c2b      	adds	r3, r5, #0
    69a0:	3b1f      	subs	r3, #31
    69a2:	1c3a      	adds	r2, r7, #0
    69a4:	40da      	lsrs	r2, r3
    69a6:	1c13      	adds	r3, r2, #0
    69a8:	2920      	cmp	r1, #32
    69aa:	d06d      	beq.n	6a88 <__aeabi_dadd+0x3e0>
    69ac:	223f      	movs	r2, #63	; 0x3f
    69ae:	1b55      	subs	r5, r2, r5
    69b0:	40af      	lsls	r7, r5
    69b2:	433c      	orrs	r4, r7
    69b4:	1e60      	subs	r0, r4, #1
    69b6:	4184      	sbcs	r4, r0
    69b8:	431c      	orrs	r4, r3
    69ba:	2100      	movs	r1, #0
    69bc:	2500      	movs	r5, #0
    69be:	e69c      	b.n	66fa <__aeabi_dadd+0x52>
    69c0:	1c38      	adds	r0, r7, #0
    69c2:	3820      	subs	r0, #32
    69c4:	1c1a      	adds	r2, r3, #0
    69c6:	40c2      	lsrs	r2, r0
    69c8:	1c10      	adds	r0, r2, #0
    69ca:	2f20      	cmp	r7, #32
    69cc:	d05e      	beq.n	6a8c <__aeabi_dadd+0x3e4>
    69ce:	2240      	movs	r2, #64	; 0x40
    69d0:	1bd7      	subs	r7, r2, r7
    69d2:	40bb      	lsls	r3, r7
    69d4:	465a      	mov	r2, fp
    69d6:	431a      	orrs	r2, r3
    69d8:	1e53      	subs	r3, r2, #1
    69da:	419a      	sbcs	r2, r3
    69dc:	4302      	orrs	r2, r0
    69de:	2700      	movs	r7, #0
    69e0:	e6df      	b.n	67a2 <__aeabi_dadd+0xfa>
    69e2:	2d00      	cmp	r5, #0
    69e4:	d03c      	beq.n	6a60 <__aeabi_dadd+0x3b8>
    69e6:	4d1b      	ldr	r5, [pc, #108]	; (6a54 <__aeabi_dadd+0x3ac>)
    69e8:	45aa      	cmp	sl, r5
    69ea:	d100      	bne.n	69ee <__aeabi_dadd+0x346>
    69ec:	e094      	b.n	6b18 <__aeabi_dadd+0x470>
    69ee:	2580      	movs	r5, #128	; 0x80
    69f0:	042d      	lsls	r5, r5, #16
    69f2:	427f      	negs	r7, r7
    69f4:	4329      	orrs	r1, r5
    69f6:	2f38      	cmp	r7, #56	; 0x38
    69f8:	dd00      	ble.n	69fc <__aeabi_dadd+0x354>
    69fa:	e0ad      	b.n	6b58 <__aeabi_dadd+0x4b0>
    69fc:	2f1f      	cmp	r7, #31
    69fe:	dd00      	ble.n	6a02 <__aeabi_dadd+0x35a>
    6a00:	e12c      	b.n	6c5c <__aeabi_dadd+0x5b4>
    6a02:	2520      	movs	r5, #32
    6a04:	1bed      	subs	r5, r5, r7
    6a06:	1c08      	adds	r0, r1, #0
    6a08:	1c26      	adds	r6, r4, #0
    6a0a:	40a8      	lsls	r0, r5
    6a0c:	40fe      	lsrs	r6, r7
    6a0e:	40ac      	lsls	r4, r5
    6a10:	4306      	orrs	r6, r0
    6a12:	1e65      	subs	r5, r4, #1
    6a14:	41ac      	sbcs	r4, r5
    6a16:	4334      	orrs	r4, r6
    6a18:	40f9      	lsrs	r1, r7
    6a1a:	465d      	mov	r5, fp
    6a1c:	1b2c      	subs	r4, r5, r4
    6a1e:	45a3      	cmp	fp, r4
    6a20:	4192      	sbcs	r2, r2
    6a22:	1a5b      	subs	r3, r3, r1
    6a24:	4252      	negs	r2, r2
    6a26:	1a99      	subs	r1, r3, r2
    6a28:	4655      	mov	r5, sl
    6a2a:	4666      	mov	r6, ip
    6a2c:	e6c0      	b.n	67b0 <__aeabi_dadd+0x108>
    6a2e:	1c13      	adds	r3, r2, #0
    6a30:	433b      	orrs	r3, r7
    6a32:	1c14      	adds	r4, r2, #0
    6a34:	2b00      	cmp	r3, #0
    6a36:	d000      	beq.n	6a3a <__aeabi_dadd+0x392>
    6a38:	e6be      	b.n	67b8 <__aeabi_dadd+0x110>
    6a3a:	2700      	movs	r7, #0
    6a3c:	2200      	movs	r2, #0
    6a3e:	2500      	movs	r5, #0
    6a40:	2100      	movs	r1, #0
    6a42:	2400      	movs	r4, #0
    6a44:	e6e8      	b.n	6818 <__aeabi_dadd+0x170>
    6a46:	465a      	mov	r2, fp
    6a48:	431a      	orrs	r2, r3
    6a4a:	1e53      	subs	r3, r2, #1
    6a4c:	419a      	sbcs	r2, r3
    6a4e:	b2d2      	uxtb	r2, r2
    6a50:	2300      	movs	r3, #0
    6a52:	e713      	b.n	687c <__aeabi_dadd+0x1d4>
    6a54:	000007ff 	.word	0x000007ff
    6a58:	ff7fffff 	.word	0xff7fffff
    6a5c:	800fffff 	.word	0x800fffff
    6a60:	1c0d      	adds	r5, r1, #0
    6a62:	4325      	orrs	r5, r4
    6a64:	d058      	beq.n	6b18 <__aeabi_dadd+0x470>
    6a66:	43ff      	mvns	r7, r7
    6a68:	2f00      	cmp	r7, #0
    6a6a:	d151      	bne.n	6b10 <__aeabi_dadd+0x468>
    6a6c:	1b04      	subs	r4, r0, r4
    6a6e:	45a3      	cmp	fp, r4
    6a70:	4192      	sbcs	r2, r2
    6a72:	1a59      	subs	r1, r3, r1
    6a74:	4252      	negs	r2, r2
    6a76:	1a89      	subs	r1, r1, r2
    6a78:	4655      	mov	r5, sl
    6a7a:	4666      	mov	r6, ip
    6a7c:	e698      	b.n	67b0 <__aeabi_dadd+0x108>
    6a7e:	4896      	ldr	r0, [pc, #600]	; (6cd8 <__aeabi_dadd+0x630>)
    6a80:	4285      	cmp	r5, r0
    6a82:	d000      	beq.n	6a86 <__aeabi_dadd+0x3de>
    6a84:	e6dd      	b.n	6842 <__aeabi_dadd+0x19a>
    6a86:	e638      	b.n	66fa <__aeabi_dadd+0x52>
    6a88:	2700      	movs	r7, #0
    6a8a:	e792      	b.n	69b2 <__aeabi_dadd+0x30a>
    6a8c:	2300      	movs	r3, #0
    6a8e:	e7a1      	b.n	69d4 <__aeabi_dadd+0x32c>
    6a90:	1c08      	adds	r0, r1, #0
    6a92:	4320      	orrs	r0, r4
    6a94:	2d00      	cmp	r5, #0
    6a96:	d000      	beq.n	6a9a <__aeabi_dadd+0x3f2>
    6a98:	e0c0      	b.n	6c1c <__aeabi_dadd+0x574>
    6a9a:	2800      	cmp	r0, #0
    6a9c:	d100      	bne.n	6aa0 <__aeabi_dadd+0x3f8>
    6a9e:	e0fb      	b.n	6c98 <__aeabi_dadd+0x5f0>
    6aa0:	4658      	mov	r0, fp
    6aa2:	4318      	orrs	r0, r3
    6aa4:	d100      	bne.n	6aa8 <__aeabi_dadd+0x400>
    6aa6:	e628      	b.n	66fa <__aeabi_dadd+0x52>
    6aa8:	4658      	mov	r0, fp
    6aaa:	1902      	adds	r2, r0, r4
    6aac:	42a2      	cmp	r2, r4
    6aae:	41a4      	sbcs	r4, r4
    6ab0:	4264      	negs	r4, r4
    6ab2:	1859      	adds	r1, r3, r1
    6ab4:	1909      	adds	r1, r1, r4
    6ab6:	1c14      	adds	r4, r2, #0
    6ab8:	020a      	lsls	r2, r1, #8
    6aba:	d400      	bmi.n	6abe <__aeabi_dadd+0x416>
    6abc:	e61d      	b.n	66fa <__aeabi_dadd+0x52>
    6abe:	4b87      	ldr	r3, [pc, #540]	; (6cdc <__aeabi_dadd+0x634>)
    6ac0:	2501      	movs	r5, #1
    6ac2:	4019      	ands	r1, r3
    6ac4:	e619      	b.n	66fa <__aeabi_dadd+0x52>
    6ac6:	1c08      	adds	r0, r1, #0
    6ac8:	4320      	orrs	r0, r4
    6aca:	2d00      	cmp	r5, #0
    6acc:	d139      	bne.n	6b42 <__aeabi_dadd+0x49a>
    6ace:	2800      	cmp	r0, #0
    6ad0:	d16d      	bne.n	6bae <__aeabi_dadd+0x506>
    6ad2:	4659      	mov	r1, fp
    6ad4:	4319      	orrs	r1, r3
    6ad6:	d100      	bne.n	6ada <__aeabi_dadd+0x432>
    6ad8:	e0bd      	b.n	6c56 <__aeabi_dadd+0x5ae>
    6ada:	1c19      	adds	r1, r3, #0
    6adc:	465c      	mov	r4, fp
    6ade:	4666      	mov	r6, ip
    6ae0:	e60b      	b.n	66fa <__aeabi_dadd+0x52>
    6ae2:	1c05      	adds	r5, r0, #0
    6ae4:	1c2a      	adds	r2, r5, #0
    6ae6:	e7ab      	b.n	6a40 <__aeabi_dadd+0x398>
    6ae8:	4660      	mov	r0, ip
    6aea:	3820      	subs	r0, #32
    6aec:	1c1a      	adds	r2, r3, #0
    6aee:	40c2      	lsrs	r2, r0
    6af0:	4660      	mov	r0, ip
    6af2:	4691      	mov	r9, r2
    6af4:	2820      	cmp	r0, #32
    6af6:	d100      	bne.n	6afa <__aeabi_dadd+0x452>
    6af8:	e0ab      	b.n	6c52 <__aeabi_dadd+0x5aa>
    6afa:	2240      	movs	r2, #64	; 0x40
    6afc:	1a12      	subs	r2, r2, r0
    6afe:	4093      	lsls	r3, r2
    6b00:	465a      	mov	r2, fp
    6b02:	431a      	orrs	r2, r3
    6b04:	1e53      	subs	r3, r2, #1
    6b06:	419a      	sbcs	r2, r3
    6b08:	464b      	mov	r3, r9
    6b0a:	431a      	orrs	r2, r3
    6b0c:	2300      	movs	r3, #0
    6b0e:	e6b5      	b.n	687c <__aeabi_dadd+0x1d4>
    6b10:	4d71      	ldr	r5, [pc, #452]	; (6cd8 <__aeabi_dadd+0x630>)
    6b12:	45aa      	cmp	sl, r5
    6b14:	d000      	beq.n	6b18 <__aeabi_dadd+0x470>
    6b16:	e76e      	b.n	69f6 <__aeabi_dadd+0x34e>
    6b18:	1c19      	adds	r1, r3, #0
    6b1a:	465c      	mov	r4, fp
    6b1c:	4655      	mov	r5, sl
    6b1e:	4666      	mov	r6, ip
    6b20:	e5eb      	b.n	66fa <__aeabi_dadd+0x52>
    6b22:	2d00      	cmp	r5, #0
    6b24:	d11e      	bne.n	6b64 <__aeabi_dadd+0x4bc>
    6b26:	1c0d      	adds	r5, r1, #0
    6b28:	4325      	orrs	r5, r4
    6b2a:	d073      	beq.n	6c14 <__aeabi_dadd+0x56c>
    6b2c:	43d5      	mvns	r5, r2
    6b2e:	2d00      	cmp	r5, #0
    6b30:	d16d      	bne.n	6c0e <__aeabi_dadd+0x566>
    6b32:	445c      	add	r4, fp
    6b34:	455c      	cmp	r4, fp
    6b36:	4192      	sbcs	r2, r2
    6b38:	1859      	adds	r1, r3, r1
    6b3a:	4252      	negs	r2, r2
    6b3c:	1889      	adds	r1, r1, r2
    6b3e:	4655      	mov	r5, sl
    6b40:	e6a3      	b.n	688a <__aeabi_dadd+0x1e2>
    6b42:	2800      	cmp	r0, #0
    6b44:	d149      	bne.n	6bda <__aeabi_dadd+0x532>
    6b46:	4659      	mov	r1, fp
    6b48:	4319      	orrs	r1, r3
    6b4a:	d100      	bne.n	6b4e <__aeabi_dadd+0x4a6>
    6b4c:	e096      	b.n	6c7c <__aeabi_dadd+0x5d4>
    6b4e:	1c19      	adds	r1, r3, #0
    6b50:	465c      	mov	r4, fp
    6b52:	4666      	mov	r6, ip
    6b54:	4d60      	ldr	r5, [pc, #384]	; (6cd8 <__aeabi_dadd+0x630>)
    6b56:	e5d0      	b.n	66fa <__aeabi_dadd+0x52>
    6b58:	430c      	orrs	r4, r1
    6b5a:	1e61      	subs	r1, r4, #1
    6b5c:	418c      	sbcs	r4, r1
    6b5e:	b2e4      	uxtb	r4, r4
    6b60:	2100      	movs	r1, #0
    6b62:	e75a      	b.n	6a1a <__aeabi_dadd+0x372>
    6b64:	4d5c      	ldr	r5, [pc, #368]	; (6cd8 <__aeabi_dadd+0x630>)
    6b66:	45aa      	cmp	sl, r5
    6b68:	d054      	beq.n	6c14 <__aeabi_dadd+0x56c>
    6b6a:	4255      	negs	r5, r2
    6b6c:	2280      	movs	r2, #128	; 0x80
    6b6e:	0410      	lsls	r0, r2, #16
    6b70:	4301      	orrs	r1, r0
    6b72:	2d38      	cmp	r5, #56	; 0x38
    6b74:	dd00      	ble.n	6b78 <__aeabi_dadd+0x4d0>
    6b76:	e085      	b.n	6c84 <__aeabi_dadd+0x5dc>
    6b78:	2d1f      	cmp	r5, #31
    6b7a:	dd00      	ble.n	6b7e <__aeabi_dadd+0x4d6>
    6b7c:	e095      	b.n	6caa <__aeabi_dadd+0x602>
    6b7e:	2220      	movs	r2, #32
    6b80:	1b50      	subs	r0, r2, r5
    6b82:	1c0a      	adds	r2, r1, #0
    6b84:	4684      	mov	ip, r0
    6b86:	4082      	lsls	r2, r0
    6b88:	1c20      	adds	r0, r4, #0
    6b8a:	40e8      	lsrs	r0, r5
    6b8c:	4302      	orrs	r2, r0
    6b8e:	4690      	mov	r8, r2
    6b90:	4662      	mov	r2, ip
    6b92:	4094      	lsls	r4, r2
    6b94:	1e60      	subs	r0, r4, #1
    6b96:	4184      	sbcs	r4, r0
    6b98:	4642      	mov	r2, r8
    6b9a:	4314      	orrs	r4, r2
    6b9c:	40e9      	lsrs	r1, r5
    6b9e:	445c      	add	r4, fp
    6ba0:	455c      	cmp	r4, fp
    6ba2:	4192      	sbcs	r2, r2
    6ba4:	18cb      	adds	r3, r1, r3
    6ba6:	4252      	negs	r2, r2
    6ba8:	1899      	adds	r1, r3, r2
    6baa:	4655      	mov	r5, sl
    6bac:	e66d      	b.n	688a <__aeabi_dadd+0x1e2>
    6bae:	4658      	mov	r0, fp
    6bb0:	4318      	orrs	r0, r3
    6bb2:	d100      	bne.n	6bb6 <__aeabi_dadd+0x50e>
    6bb4:	e5a1      	b.n	66fa <__aeabi_dadd+0x52>
    6bb6:	4658      	mov	r0, fp
    6bb8:	1a27      	subs	r7, r4, r0
    6bba:	42bc      	cmp	r4, r7
    6bbc:	4192      	sbcs	r2, r2
    6bbe:	1ac8      	subs	r0, r1, r3
    6bc0:	4252      	negs	r2, r2
    6bc2:	1a80      	subs	r0, r0, r2
    6bc4:	0202      	lsls	r2, r0, #8
    6bc6:	d56a      	bpl.n	6c9e <__aeabi_dadd+0x5f6>
    6bc8:	4658      	mov	r0, fp
    6bca:	1b04      	subs	r4, r0, r4
    6bcc:	45a3      	cmp	fp, r4
    6bce:	4192      	sbcs	r2, r2
    6bd0:	1a59      	subs	r1, r3, r1
    6bd2:	4252      	negs	r2, r2
    6bd4:	1a89      	subs	r1, r1, r2
    6bd6:	4666      	mov	r6, ip
    6bd8:	e58f      	b.n	66fa <__aeabi_dadd+0x52>
    6bda:	4658      	mov	r0, fp
    6bdc:	4318      	orrs	r0, r3
    6bde:	d036      	beq.n	6c4e <__aeabi_dadd+0x5a6>
    6be0:	0748      	lsls	r0, r1, #29
    6be2:	08e4      	lsrs	r4, r4, #3
    6be4:	4304      	orrs	r4, r0
    6be6:	2080      	movs	r0, #128	; 0x80
    6be8:	08c9      	lsrs	r1, r1, #3
    6bea:	0300      	lsls	r0, r0, #12
    6bec:	4201      	tst	r1, r0
    6bee:	d008      	beq.n	6c02 <__aeabi_dadd+0x55a>
    6bf0:	08dd      	lsrs	r5, r3, #3
    6bf2:	4205      	tst	r5, r0
    6bf4:	d105      	bne.n	6c02 <__aeabi_dadd+0x55a>
    6bf6:	4659      	mov	r1, fp
    6bf8:	08ca      	lsrs	r2, r1, #3
    6bfa:	075c      	lsls	r4, r3, #29
    6bfc:	4314      	orrs	r4, r2
    6bfe:	1c29      	adds	r1, r5, #0
    6c00:	4666      	mov	r6, ip
    6c02:	0f63      	lsrs	r3, r4, #29
    6c04:	00c9      	lsls	r1, r1, #3
    6c06:	4319      	orrs	r1, r3
    6c08:	00e4      	lsls	r4, r4, #3
    6c0a:	4d33      	ldr	r5, [pc, #204]	; (6cd8 <__aeabi_dadd+0x630>)
    6c0c:	e575      	b.n	66fa <__aeabi_dadd+0x52>
    6c0e:	4a32      	ldr	r2, [pc, #200]	; (6cd8 <__aeabi_dadd+0x630>)
    6c10:	4592      	cmp	sl, r2
    6c12:	d1ae      	bne.n	6b72 <__aeabi_dadd+0x4ca>
    6c14:	1c19      	adds	r1, r3, #0
    6c16:	465c      	mov	r4, fp
    6c18:	4655      	mov	r5, sl
    6c1a:	e56e      	b.n	66fa <__aeabi_dadd+0x52>
    6c1c:	2800      	cmp	r0, #0
    6c1e:	d037      	beq.n	6c90 <__aeabi_dadd+0x5e8>
    6c20:	4658      	mov	r0, fp
    6c22:	4318      	orrs	r0, r3
    6c24:	d013      	beq.n	6c4e <__aeabi_dadd+0x5a6>
    6c26:	2580      	movs	r5, #128	; 0x80
    6c28:	0748      	lsls	r0, r1, #29
    6c2a:	08e4      	lsrs	r4, r4, #3
    6c2c:	08c9      	lsrs	r1, r1, #3
    6c2e:	032d      	lsls	r5, r5, #12
    6c30:	4304      	orrs	r4, r0
    6c32:	4229      	tst	r1, r5
    6c34:	d0e5      	beq.n	6c02 <__aeabi_dadd+0x55a>
    6c36:	08d8      	lsrs	r0, r3, #3
    6c38:	4228      	tst	r0, r5
    6c3a:	d1e2      	bne.n	6c02 <__aeabi_dadd+0x55a>
    6c3c:	465d      	mov	r5, fp
    6c3e:	08ea      	lsrs	r2, r5, #3
    6c40:	075c      	lsls	r4, r3, #29
    6c42:	4314      	orrs	r4, r2
    6c44:	1c01      	adds	r1, r0, #0
    6c46:	e7dc      	b.n	6c02 <__aeabi_dadd+0x55a>
    6c48:	2300      	movs	r3, #0
    6c4a:	2400      	movs	r4, #0
    6c4c:	e573      	b.n	6736 <__aeabi_dadd+0x8e>
    6c4e:	4d22      	ldr	r5, [pc, #136]	; (6cd8 <__aeabi_dadd+0x630>)
    6c50:	e553      	b.n	66fa <__aeabi_dadd+0x52>
    6c52:	2300      	movs	r3, #0
    6c54:	e754      	b.n	6b00 <__aeabi_dadd+0x458>
    6c56:	2700      	movs	r7, #0
    6c58:	2200      	movs	r2, #0
    6c5a:	e6f1      	b.n	6a40 <__aeabi_dadd+0x398>
    6c5c:	1c3d      	adds	r5, r7, #0
    6c5e:	3d20      	subs	r5, #32
    6c60:	1c0a      	adds	r2, r1, #0
    6c62:	40ea      	lsrs	r2, r5
    6c64:	1c15      	adds	r5, r2, #0
    6c66:	2f20      	cmp	r7, #32
    6c68:	d031      	beq.n	6cce <__aeabi_dadd+0x626>
    6c6a:	2640      	movs	r6, #64	; 0x40
    6c6c:	1bf7      	subs	r7, r6, r7
    6c6e:	40b9      	lsls	r1, r7
    6c70:	430c      	orrs	r4, r1
    6c72:	1e61      	subs	r1, r4, #1
    6c74:	418c      	sbcs	r4, r1
    6c76:	432c      	orrs	r4, r5
    6c78:	2100      	movs	r1, #0
    6c7a:	e6ce      	b.n	6a1a <__aeabi_dadd+0x372>
    6c7c:	4a16      	ldr	r2, [pc, #88]	; (6cd8 <__aeabi_dadd+0x630>)
    6c7e:	2700      	movs	r7, #0
    6c80:	1c15      	adds	r5, r2, #0
    6c82:	e6dd      	b.n	6a40 <__aeabi_dadd+0x398>
    6c84:	430c      	orrs	r4, r1
    6c86:	1e61      	subs	r1, r4, #1
    6c88:	418c      	sbcs	r4, r1
    6c8a:	b2e4      	uxtb	r4, r4
    6c8c:	2100      	movs	r1, #0
    6c8e:	e786      	b.n	6b9e <__aeabi_dadd+0x4f6>
    6c90:	1c19      	adds	r1, r3, #0
    6c92:	465c      	mov	r4, fp
    6c94:	4d10      	ldr	r5, [pc, #64]	; (6cd8 <__aeabi_dadd+0x630>)
    6c96:	e530      	b.n	66fa <__aeabi_dadd+0x52>
    6c98:	1c19      	adds	r1, r3, #0
    6c9a:	465c      	mov	r4, fp
    6c9c:	e52d      	b.n	66fa <__aeabi_dadd+0x52>
    6c9e:	1c03      	adds	r3, r0, #0
    6ca0:	433b      	orrs	r3, r7
    6ca2:	d0d8      	beq.n	6c56 <__aeabi_dadd+0x5ae>
    6ca4:	1c01      	adds	r1, r0, #0
    6ca6:	1c3c      	adds	r4, r7, #0
    6ca8:	e527      	b.n	66fa <__aeabi_dadd+0x52>
    6caa:	2020      	movs	r0, #32
    6cac:	4240      	negs	r0, r0
    6cae:	1940      	adds	r0, r0, r5
    6cb0:	1c0a      	adds	r2, r1, #0
    6cb2:	40c2      	lsrs	r2, r0
    6cb4:	4690      	mov	r8, r2
    6cb6:	2d20      	cmp	r5, #32
    6cb8:	d00b      	beq.n	6cd2 <__aeabi_dadd+0x62a>
    6cba:	2040      	movs	r0, #64	; 0x40
    6cbc:	1b45      	subs	r5, r0, r5
    6cbe:	40a9      	lsls	r1, r5
    6cc0:	430c      	orrs	r4, r1
    6cc2:	1e61      	subs	r1, r4, #1
    6cc4:	418c      	sbcs	r4, r1
    6cc6:	4645      	mov	r5, r8
    6cc8:	432c      	orrs	r4, r5
    6cca:	2100      	movs	r1, #0
    6ccc:	e767      	b.n	6b9e <__aeabi_dadd+0x4f6>
    6cce:	2100      	movs	r1, #0
    6cd0:	e7ce      	b.n	6c70 <__aeabi_dadd+0x5c8>
    6cd2:	2100      	movs	r1, #0
    6cd4:	e7f4      	b.n	6cc0 <__aeabi_dadd+0x618>
    6cd6:	46c0      	nop			; (mov r8, r8)
    6cd8:	000007ff 	.word	0x000007ff
    6cdc:	ff7fffff 	.word	0xff7fffff

00006ce0 <__aeabi_ddiv>:
    6ce0:	b5f0      	push	{r4, r5, r6, r7, lr}
    6ce2:	4656      	mov	r6, sl
    6ce4:	4644      	mov	r4, r8
    6ce6:	465f      	mov	r7, fp
    6ce8:	464d      	mov	r5, r9
    6cea:	b4f0      	push	{r4, r5, r6, r7}
    6cec:	1c1f      	adds	r7, r3, #0
    6cee:	030b      	lsls	r3, r1, #12
    6cf0:	0b1b      	lsrs	r3, r3, #12
    6cf2:	4698      	mov	r8, r3
    6cf4:	004b      	lsls	r3, r1, #1
    6cf6:	b087      	sub	sp, #28
    6cf8:	1c04      	adds	r4, r0, #0
    6cfa:	4681      	mov	r9, r0
    6cfc:	0d5b      	lsrs	r3, r3, #21
    6cfe:	0fc8      	lsrs	r0, r1, #31
    6d00:	1c16      	adds	r6, r2, #0
    6d02:	469a      	mov	sl, r3
    6d04:	9000      	str	r0, [sp, #0]
    6d06:	2b00      	cmp	r3, #0
    6d08:	d051      	beq.n	6dae <__aeabi_ddiv+0xce>
    6d0a:	4b6a      	ldr	r3, [pc, #424]	; (6eb4 <__aeabi_ddiv+0x1d4>)
    6d0c:	459a      	cmp	sl, r3
    6d0e:	d031      	beq.n	6d74 <__aeabi_ddiv+0x94>
    6d10:	2280      	movs	r2, #128	; 0x80
    6d12:	4641      	mov	r1, r8
    6d14:	0352      	lsls	r2, r2, #13
    6d16:	430a      	orrs	r2, r1
    6d18:	0f63      	lsrs	r3, r4, #29
    6d1a:	00d2      	lsls	r2, r2, #3
    6d1c:	431a      	orrs	r2, r3
    6d1e:	4b66      	ldr	r3, [pc, #408]	; (6eb8 <__aeabi_ddiv+0x1d8>)
    6d20:	4690      	mov	r8, r2
    6d22:	2500      	movs	r5, #0
    6d24:	00e2      	lsls	r2, r4, #3
    6d26:	4691      	mov	r9, r2
    6d28:	449a      	add	sl, r3
    6d2a:	2400      	movs	r4, #0
    6d2c:	9502      	str	r5, [sp, #8]
    6d2e:	033b      	lsls	r3, r7, #12
    6d30:	0b1b      	lsrs	r3, r3, #12
    6d32:	469b      	mov	fp, r3
    6d34:	0ffd      	lsrs	r5, r7, #31
    6d36:	007b      	lsls	r3, r7, #1
    6d38:	1c31      	adds	r1, r6, #0
    6d3a:	0d5b      	lsrs	r3, r3, #21
    6d3c:	9501      	str	r5, [sp, #4]
    6d3e:	d060      	beq.n	6e02 <__aeabi_ddiv+0x122>
    6d40:	4a5c      	ldr	r2, [pc, #368]	; (6eb4 <__aeabi_ddiv+0x1d4>)
    6d42:	4293      	cmp	r3, r2
    6d44:	d054      	beq.n	6df0 <__aeabi_ddiv+0x110>
    6d46:	2180      	movs	r1, #128	; 0x80
    6d48:	4658      	mov	r0, fp
    6d4a:	0349      	lsls	r1, r1, #13
    6d4c:	4301      	orrs	r1, r0
    6d4e:	0f72      	lsrs	r2, r6, #29
    6d50:	00c9      	lsls	r1, r1, #3
    6d52:	4311      	orrs	r1, r2
    6d54:	4a58      	ldr	r2, [pc, #352]	; (6eb8 <__aeabi_ddiv+0x1d8>)
    6d56:	468b      	mov	fp, r1
    6d58:	189b      	adds	r3, r3, r2
    6d5a:	00f1      	lsls	r1, r6, #3
    6d5c:	2000      	movs	r0, #0
    6d5e:	9a00      	ldr	r2, [sp, #0]
    6d60:	4304      	orrs	r4, r0
    6d62:	406a      	eors	r2, r5
    6d64:	9203      	str	r2, [sp, #12]
    6d66:	2c0f      	cmp	r4, #15
    6d68:	d900      	bls.n	6d6c <__aeabi_ddiv+0x8c>
    6d6a:	e0ad      	b.n	6ec8 <__aeabi_ddiv+0x1e8>
    6d6c:	4e53      	ldr	r6, [pc, #332]	; (6ebc <__aeabi_ddiv+0x1dc>)
    6d6e:	00a4      	lsls	r4, r4, #2
    6d70:	5934      	ldr	r4, [r6, r4]
    6d72:	46a7      	mov	pc, r4
    6d74:	4640      	mov	r0, r8
    6d76:	4304      	orrs	r4, r0
    6d78:	d16e      	bne.n	6e58 <__aeabi_ddiv+0x178>
    6d7a:	2100      	movs	r1, #0
    6d7c:	2502      	movs	r5, #2
    6d7e:	2408      	movs	r4, #8
    6d80:	4688      	mov	r8, r1
    6d82:	4689      	mov	r9, r1
    6d84:	9502      	str	r5, [sp, #8]
    6d86:	e7d2      	b.n	6d2e <__aeabi_ddiv+0x4e>
    6d88:	9c00      	ldr	r4, [sp, #0]
    6d8a:	9802      	ldr	r0, [sp, #8]
    6d8c:	46c3      	mov	fp, r8
    6d8e:	4649      	mov	r1, r9
    6d90:	9401      	str	r4, [sp, #4]
    6d92:	2802      	cmp	r0, #2
    6d94:	d064      	beq.n	6e60 <__aeabi_ddiv+0x180>
    6d96:	2803      	cmp	r0, #3
    6d98:	d100      	bne.n	6d9c <__aeabi_ddiv+0xbc>
    6d9a:	e2ab      	b.n	72f4 <__aeabi_ddiv+0x614>
    6d9c:	2801      	cmp	r0, #1
    6d9e:	d000      	beq.n	6da2 <__aeabi_ddiv+0xc2>
    6da0:	e238      	b.n	7214 <__aeabi_ddiv+0x534>
    6da2:	9a01      	ldr	r2, [sp, #4]
    6da4:	2400      	movs	r4, #0
    6da6:	4002      	ands	r2, r0
    6da8:	2500      	movs	r5, #0
    6daa:	46a1      	mov	r9, r4
    6dac:	e060      	b.n	6e70 <__aeabi_ddiv+0x190>
    6dae:	4643      	mov	r3, r8
    6db0:	4323      	orrs	r3, r4
    6db2:	d04a      	beq.n	6e4a <__aeabi_ddiv+0x16a>
    6db4:	4640      	mov	r0, r8
    6db6:	2800      	cmp	r0, #0
    6db8:	d100      	bne.n	6dbc <__aeabi_ddiv+0xdc>
    6dba:	e1c0      	b.n	713e <__aeabi_ddiv+0x45e>
    6dbc:	f001 fa6e 	bl	829c <__clzsi2>
    6dc0:	1e03      	subs	r3, r0, #0
    6dc2:	2b27      	cmp	r3, #39	; 0x27
    6dc4:	dd00      	ble.n	6dc8 <__aeabi_ddiv+0xe8>
    6dc6:	e1b3      	b.n	7130 <__aeabi_ddiv+0x450>
    6dc8:	2128      	movs	r1, #40	; 0x28
    6dca:	1a0d      	subs	r5, r1, r0
    6dcc:	1c21      	adds	r1, r4, #0
    6dce:	3b08      	subs	r3, #8
    6dd0:	4642      	mov	r2, r8
    6dd2:	40e9      	lsrs	r1, r5
    6dd4:	409a      	lsls	r2, r3
    6dd6:	1c0d      	adds	r5, r1, #0
    6dd8:	4315      	orrs	r5, r2
    6dda:	1c22      	adds	r2, r4, #0
    6ddc:	409a      	lsls	r2, r3
    6dde:	46a8      	mov	r8, r5
    6de0:	4691      	mov	r9, r2
    6de2:	4b37      	ldr	r3, [pc, #220]	; (6ec0 <__aeabi_ddiv+0x1e0>)
    6de4:	2500      	movs	r5, #0
    6de6:	1a1b      	subs	r3, r3, r0
    6de8:	469a      	mov	sl, r3
    6dea:	2400      	movs	r4, #0
    6dec:	9502      	str	r5, [sp, #8]
    6dee:	e79e      	b.n	6d2e <__aeabi_ddiv+0x4e>
    6df0:	465a      	mov	r2, fp
    6df2:	4316      	orrs	r6, r2
    6df4:	2003      	movs	r0, #3
    6df6:	2e00      	cmp	r6, #0
    6df8:	d1b1      	bne.n	6d5e <__aeabi_ddiv+0x7e>
    6dfa:	46b3      	mov	fp, r6
    6dfc:	2100      	movs	r1, #0
    6dfe:	2002      	movs	r0, #2
    6e00:	e7ad      	b.n	6d5e <__aeabi_ddiv+0x7e>
    6e02:	465a      	mov	r2, fp
    6e04:	4332      	orrs	r2, r6
    6e06:	d01b      	beq.n	6e40 <__aeabi_ddiv+0x160>
    6e08:	465b      	mov	r3, fp
    6e0a:	2b00      	cmp	r3, #0
    6e0c:	d100      	bne.n	6e10 <__aeabi_ddiv+0x130>
    6e0e:	e18a      	b.n	7126 <__aeabi_ddiv+0x446>
    6e10:	4658      	mov	r0, fp
    6e12:	f001 fa43 	bl	829c <__clzsi2>
    6e16:	2827      	cmp	r0, #39	; 0x27
    6e18:	dd00      	ble.n	6e1c <__aeabi_ddiv+0x13c>
    6e1a:	e17d      	b.n	7118 <__aeabi_ddiv+0x438>
    6e1c:	2228      	movs	r2, #40	; 0x28
    6e1e:	1a17      	subs	r7, r2, r0
    6e20:	1c01      	adds	r1, r0, #0
    6e22:	1c32      	adds	r2, r6, #0
    6e24:	3908      	subs	r1, #8
    6e26:	465b      	mov	r3, fp
    6e28:	40fa      	lsrs	r2, r7
    6e2a:	408b      	lsls	r3, r1
    6e2c:	1c17      	adds	r7, r2, #0
    6e2e:	431f      	orrs	r7, r3
    6e30:	1c33      	adds	r3, r6, #0
    6e32:	408b      	lsls	r3, r1
    6e34:	46bb      	mov	fp, r7
    6e36:	1c19      	adds	r1, r3, #0
    6e38:	4b21      	ldr	r3, [pc, #132]	; (6ec0 <__aeabi_ddiv+0x1e0>)
    6e3a:	1a1b      	subs	r3, r3, r0
    6e3c:	2000      	movs	r0, #0
    6e3e:	e78e      	b.n	6d5e <__aeabi_ddiv+0x7e>
    6e40:	2700      	movs	r7, #0
    6e42:	46bb      	mov	fp, r7
    6e44:	2100      	movs	r1, #0
    6e46:	2001      	movs	r0, #1
    6e48:	e789      	b.n	6d5e <__aeabi_ddiv+0x7e>
    6e4a:	2000      	movs	r0, #0
    6e4c:	2501      	movs	r5, #1
    6e4e:	2404      	movs	r4, #4
    6e50:	4680      	mov	r8, r0
    6e52:	4681      	mov	r9, r0
    6e54:	9502      	str	r5, [sp, #8]
    6e56:	e76a      	b.n	6d2e <__aeabi_ddiv+0x4e>
    6e58:	2503      	movs	r5, #3
    6e5a:	240c      	movs	r4, #12
    6e5c:	9502      	str	r5, [sp, #8]
    6e5e:	e766      	b.n	6d2e <__aeabi_ddiv+0x4e>
    6e60:	9c01      	ldr	r4, [sp, #4]
    6e62:	9403      	str	r4, [sp, #12]
    6e64:	9d03      	ldr	r5, [sp, #12]
    6e66:	2201      	movs	r2, #1
    6e68:	402a      	ands	r2, r5
    6e6a:	2400      	movs	r4, #0
    6e6c:	4d11      	ldr	r5, [pc, #68]	; (6eb4 <__aeabi_ddiv+0x1d4>)
    6e6e:	46a1      	mov	r9, r4
    6e70:	2000      	movs	r0, #0
    6e72:	2100      	movs	r1, #0
    6e74:	0324      	lsls	r4, r4, #12
    6e76:	0b26      	lsrs	r6, r4, #12
    6e78:	0d0c      	lsrs	r4, r1, #20
    6e7a:	0524      	lsls	r4, r4, #20
    6e7c:	4b11      	ldr	r3, [pc, #68]	; (6ec4 <__aeabi_ddiv+0x1e4>)
    6e7e:	4334      	orrs	r4, r6
    6e80:	052d      	lsls	r5, r5, #20
    6e82:	4023      	ands	r3, r4
    6e84:	432b      	orrs	r3, r5
    6e86:	005b      	lsls	r3, r3, #1
    6e88:	085b      	lsrs	r3, r3, #1
    6e8a:	07d2      	lsls	r2, r2, #31
    6e8c:	1c19      	adds	r1, r3, #0
    6e8e:	4648      	mov	r0, r9
    6e90:	4311      	orrs	r1, r2
    6e92:	b007      	add	sp, #28
    6e94:	bc3c      	pop	{r2, r3, r4, r5}
    6e96:	4690      	mov	r8, r2
    6e98:	4699      	mov	r9, r3
    6e9a:	46a2      	mov	sl, r4
    6e9c:	46ab      	mov	fp, r5
    6e9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6ea0:	2200      	movs	r2, #0
    6ea2:	2480      	movs	r4, #128	; 0x80
    6ea4:	0324      	lsls	r4, r4, #12
    6ea6:	4691      	mov	r9, r2
    6ea8:	4d02      	ldr	r5, [pc, #8]	; (6eb4 <__aeabi_ddiv+0x1d4>)
    6eaa:	e7e1      	b.n	6e70 <__aeabi_ddiv+0x190>
    6eac:	2400      	movs	r4, #0
    6eae:	2500      	movs	r5, #0
    6eb0:	46a1      	mov	r9, r4
    6eb2:	e7dd      	b.n	6e70 <__aeabi_ddiv+0x190>
    6eb4:	000007ff 	.word	0x000007ff
    6eb8:	fffffc01 	.word	0xfffffc01
    6ebc:	00009190 	.word	0x00009190
    6ec0:	fffffc0d 	.word	0xfffffc0d
    6ec4:	800fffff 	.word	0x800fffff
    6ec8:	4655      	mov	r5, sl
    6eca:	1aed      	subs	r5, r5, r3
    6ecc:	9504      	str	r5, [sp, #16]
    6ece:	45d8      	cmp	r8, fp
    6ed0:	d900      	bls.n	6ed4 <__aeabi_ddiv+0x1f4>
    6ed2:	e153      	b.n	717c <__aeabi_ddiv+0x49c>
    6ed4:	d100      	bne.n	6ed8 <__aeabi_ddiv+0x1f8>
    6ed6:	e14e      	b.n	7176 <__aeabi_ddiv+0x496>
    6ed8:	9c04      	ldr	r4, [sp, #16]
    6eda:	2500      	movs	r5, #0
    6edc:	3c01      	subs	r4, #1
    6ede:	464e      	mov	r6, r9
    6ee0:	9404      	str	r4, [sp, #16]
    6ee2:	4647      	mov	r7, r8
    6ee4:	46a9      	mov	r9, r5
    6ee6:	4658      	mov	r0, fp
    6ee8:	0203      	lsls	r3, r0, #8
    6eea:	0e0c      	lsrs	r4, r1, #24
    6eec:	431c      	orrs	r4, r3
    6eee:	0209      	lsls	r1, r1, #8
    6ef0:	0c25      	lsrs	r5, r4, #16
    6ef2:	0423      	lsls	r3, r4, #16
    6ef4:	0c1b      	lsrs	r3, r3, #16
    6ef6:	9100      	str	r1, [sp, #0]
    6ef8:	1c38      	adds	r0, r7, #0
    6efa:	1c29      	adds	r1, r5, #0
    6efc:	9301      	str	r3, [sp, #4]
    6efe:	f7ff fac3 	bl	6488 <__aeabi_uidiv>
    6f02:	9901      	ldr	r1, [sp, #4]
    6f04:	4683      	mov	fp, r0
    6f06:	4341      	muls	r1, r0
    6f08:	1c38      	adds	r0, r7, #0
    6f0a:	468a      	mov	sl, r1
    6f0c:	1c29      	adds	r1, r5, #0
    6f0e:	f7ff faff 	bl	6510 <__aeabi_uidivmod>
    6f12:	0c33      	lsrs	r3, r6, #16
    6f14:	0409      	lsls	r1, r1, #16
    6f16:	4319      	orrs	r1, r3
    6f18:	458a      	cmp	sl, r1
    6f1a:	d90c      	bls.n	6f36 <__aeabi_ddiv+0x256>
    6f1c:	465b      	mov	r3, fp
    6f1e:	1909      	adds	r1, r1, r4
    6f20:	3b01      	subs	r3, #1
    6f22:	428c      	cmp	r4, r1
    6f24:	d900      	bls.n	6f28 <__aeabi_ddiv+0x248>
    6f26:	e147      	b.n	71b8 <__aeabi_ddiv+0x4d8>
    6f28:	458a      	cmp	sl, r1
    6f2a:	d800      	bhi.n	6f2e <__aeabi_ddiv+0x24e>
    6f2c:	e144      	b.n	71b8 <__aeabi_ddiv+0x4d8>
    6f2e:	2202      	movs	r2, #2
    6f30:	4252      	negs	r2, r2
    6f32:	4493      	add	fp, r2
    6f34:	1909      	adds	r1, r1, r4
    6f36:	4653      	mov	r3, sl
    6f38:	1acb      	subs	r3, r1, r3
    6f3a:	1c18      	adds	r0, r3, #0
    6f3c:	1c29      	adds	r1, r5, #0
    6f3e:	4698      	mov	r8, r3
    6f40:	f7ff faa2 	bl	6488 <__aeabi_uidiv>
    6f44:	1c07      	adds	r7, r0, #0
    6f46:	9801      	ldr	r0, [sp, #4]
    6f48:	1c29      	adds	r1, r5, #0
    6f4a:	4378      	muls	r0, r7
    6f4c:	4682      	mov	sl, r0
    6f4e:	4640      	mov	r0, r8
    6f50:	f7ff fade 	bl	6510 <__aeabi_uidivmod>
    6f54:	0436      	lsls	r6, r6, #16
    6f56:	040b      	lsls	r3, r1, #16
    6f58:	0c36      	lsrs	r6, r6, #16
    6f5a:	4333      	orrs	r3, r6
    6f5c:	459a      	cmp	sl, r3
    6f5e:	d909      	bls.n	6f74 <__aeabi_ddiv+0x294>
    6f60:	191b      	adds	r3, r3, r4
    6f62:	1e7a      	subs	r2, r7, #1
    6f64:	429c      	cmp	r4, r3
    6f66:	d900      	bls.n	6f6a <__aeabi_ddiv+0x28a>
    6f68:	e124      	b.n	71b4 <__aeabi_ddiv+0x4d4>
    6f6a:	459a      	cmp	sl, r3
    6f6c:	d800      	bhi.n	6f70 <__aeabi_ddiv+0x290>
    6f6e:	e121      	b.n	71b4 <__aeabi_ddiv+0x4d4>
    6f70:	3f02      	subs	r7, #2
    6f72:	191b      	adds	r3, r3, r4
    6f74:	465e      	mov	r6, fp
    6f76:	0432      	lsls	r2, r6, #16
    6f78:	4317      	orrs	r7, r2
    6f7a:	0c38      	lsrs	r0, r7, #16
    6f7c:	46bb      	mov	fp, r7
    6f7e:	9e00      	ldr	r6, [sp, #0]
    6f80:	9f00      	ldr	r7, [sp, #0]
    6f82:	4651      	mov	r1, sl
    6f84:	0c3f      	lsrs	r7, r7, #16
    6f86:	0432      	lsls	r2, r6, #16
    6f88:	1a5b      	subs	r3, r3, r1
    6f8a:	4659      	mov	r1, fp
    6f8c:	46ba      	mov	sl, r7
    6f8e:	0c12      	lsrs	r2, r2, #16
    6f90:	040f      	lsls	r7, r1, #16
    6f92:	0c3f      	lsrs	r7, r7, #16
    6f94:	4690      	mov	r8, r2
    6f96:	4651      	mov	r1, sl
    6f98:	437a      	muls	r2, r7
    6f9a:	434f      	muls	r7, r1
    6f9c:	4641      	mov	r1, r8
    6f9e:	4341      	muls	r1, r0
    6fa0:	4656      	mov	r6, sl
    6fa2:	4370      	muls	r0, r6
    6fa4:	19cf      	adds	r7, r1, r7
    6fa6:	0c16      	lsrs	r6, r2, #16
    6fa8:	19be      	adds	r6, r7, r6
    6faa:	42b1      	cmp	r1, r6
    6fac:	d902      	bls.n	6fb4 <__aeabi_ddiv+0x2d4>
    6fae:	2780      	movs	r7, #128	; 0x80
    6fb0:	027f      	lsls	r7, r7, #9
    6fb2:	19c0      	adds	r0, r0, r7
    6fb4:	0c31      	lsrs	r1, r6, #16
    6fb6:	0412      	lsls	r2, r2, #16
    6fb8:	0436      	lsls	r6, r6, #16
    6fba:	0c12      	lsrs	r2, r2, #16
    6fbc:	1840      	adds	r0, r0, r1
    6fbe:	18b6      	adds	r6, r6, r2
    6fc0:	4283      	cmp	r3, r0
    6fc2:	d200      	bcs.n	6fc6 <__aeabi_ddiv+0x2e6>
    6fc4:	e0c4      	b.n	7150 <__aeabi_ddiv+0x470>
    6fc6:	d100      	bne.n	6fca <__aeabi_ddiv+0x2ea>
    6fc8:	e0be      	b.n	7148 <__aeabi_ddiv+0x468>
    6fca:	1a19      	subs	r1, r3, r0
    6fcc:	4648      	mov	r0, r9
    6fce:	1b86      	subs	r6, r0, r6
    6fd0:	45b1      	cmp	r9, r6
    6fd2:	41bf      	sbcs	r7, r7
    6fd4:	427f      	negs	r7, r7
    6fd6:	1bcf      	subs	r7, r1, r7
    6fd8:	42a7      	cmp	r7, r4
    6fda:	d100      	bne.n	6fde <__aeabi_ddiv+0x2fe>
    6fdc:	e113      	b.n	7206 <__aeabi_ddiv+0x526>
    6fde:	1c29      	adds	r1, r5, #0
    6fe0:	1c38      	adds	r0, r7, #0
    6fe2:	f7ff fa51 	bl	6488 <__aeabi_uidiv>
    6fe6:	9901      	ldr	r1, [sp, #4]
    6fe8:	9002      	str	r0, [sp, #8]
    6fea:	4341      	muls	r1, r0
    6fec:	1c38      	adds	r0, r7, #0
    6fee:	4689      	mov	r9, r1
    6ff0:	1c29      	adds	r1, r5, #0
    6ff2:	f7ff fa8d 	bl	6510 <__aeabi_uidivmod>
    6ff6:	0c33      	lsrs	r3, r6, #16
    6ff8:	0409      	lsls	r1, r1, #16
    6ffa:	4319      	orrs	r1, r3
    6ffc:	4589      	cmp	r9, r1
    6ffe:	d90c      	bls.n	701a <__aeabi_ddiv+0x33a>
    7000:	9b02      	ldr	r3, [sp, #8]
    7002:	1909      	adds	r1, r1, r4
    7004:	3b01      	subs	r3, #1
    7006:	428c      	cmp	r4, r1
    7008:	d900      	bls.n	700c <__aeabi_ddiv+0x32c>
    700a:	e0ff      	b.n	720c <__aeabi_ddiv+0x52c>
    700c:	4589      	cmp	r9, r1
    700e:	d800      	bhi.n	7012 <__aeabi_ddiv+0x332>
    7010:	e0fc      	b.n	720c <__aeabi_ddiv+0x52c>
    7012:	9f02      	ldr	r7, [sp, #8]
    7014:	1909      	adds	r1, r1, r4
    7016:	3f02      	subs	r7, #2
    7018:	9702      	str	r7, [sp, #8]
    701a:	464f      	mov	r7, r9
    701c:	1bcf      	subs	r7, r1, r7
    701e:	1c38      	adds	r0, r7, #0
    7020:	1c29      	adds	r1, r5, #0
    7022:	9705      	str	r7, [sp, #20]
    7024:	f7ff fa30 	bl	6488 <__aeabi_uidiv>
    7028:	1c07      	adds	r7, r0, #0
    702a:	9801      	ldr	r0, [sp, #4]
    702c:	1c29      	adds	r1, r5, #0
    702e:	4378      	muls	r0, r7
    7030:	4681      	mov	r9, r0
    7032:	9805      	ldr	r0, [sp, #20]
    7034:	f7ff fa6c 	bl	6510 <__aeabi_uidivmod>
    7038:	0436      	lsls	r6, r6, #16
    703a:	0409      	lsls	r1, r1, #16
    703c:	0c36      	lsrs	r6, r6, #16
    703e:	430e      	orrs	r6, r1
    7040:	45b1      	cmp	r9, r6
    7042:	d909      	bls.n	7058 <__aeabi_ddiv+0x378>
    7044:	1936      	adds	r6, r6, r4
    7046:	1e7b      	subs	r3, r7, #1
    7048:	42b4      	cmp	r4, r6
    704a:	d900      	bls.n	704e <__aeabi_ddiv+0x36e>
    704c:	e0e0      	b.n	7210 <__aeabi_ddiv+0x530>
    704e:	45b1      	cmp	r9, r6
    7050:	d800      	bhi.n	7054 <__aeabi_ddiv+0x374>
    7052:	e0dd      	b.n	7210 <__aeabi_ddiv+0x530>
    7054:	3f02      	subs	r7, #2
    7056:	1936      	adds	r6, r6, r4
    7058:	9d02      	ldr	r5, [sp, #8]
    705a:	4649      	mov	r1, r9
    705c:	1a76      	subs	r6, r6, r1
    705e:	0429      	lsls	r1, r5, #16
    7060:	4339      	orrs	r1, r7
    7062:	040b      	lsls	r3, r1, #16
    7064:	4657      	mov	r7, sl
    7066:	0c0a      	lsrs	r2, r1, #16
    7068:	0c1b      	lsrs	r3, r3, #16
    706a:	4640      	mov	r0, r8
    706c:	4645      	mov	r5, r8
    706e:	4358      	muls	r0, r3
    7070:	4355      	muls	r5, r2
    7072:	437b      	muls	r3, r7
    7074:	437a      	muls	r2, r7
    7076:	18eb      	adds	r3, r5, r3
    7078:	0c07      	lsrs	r7, r0, #16
    707a:	19db      	adds	r3, r3, r7
    707c:	429d      	cmp	r5, r3
    707e:	d902      	bls.n	7086 <__aeabi_ddiv+0x3a6>
    7080:	2580      	movs	r5, #128	; 0x80
    7082:	026d      	lsls	r5, r5, #9
    7084:	1952      	adds	r2, r2, r5
    7086:	0c1d      	lsrs	r5, r3, #16
    7088:	0400      	lsls	r0, r0, #16
    708a:	041b      	lsls	r3, r3, #16
    708c:	0c00      	lsrs	r0, r0, #16
    708e:	1952      	adds	r2, r2, r5
    7090:	181b      	adds	r3, r3, r0
    7092:	4296      	cmp	r6, r2
    7094:	d335      	bcc.n	7102 <__aeabi_ddiv+0x422>
    7096:	d100      	bne.n	709a <__aeabi_ddiv+0x3ba>
    7098:	e0fc      	b.n	7294 <__aeabi_ddiv+0x5b4>
    709a:	2301      	movs	r3, #1
    709c:	4319      	orrs	r1, r3
    709e:	9e04      	ldr	r6, [sp, #16]
    70a0:	4f99      	ldr	r7, [pc, #612]	; (7308 <__aeabi_ddiv+0x628>)
    70a2:	19f5      	adds	r5, r6, r7
    70a4:	2d00      	cmp	r5, #0
    70a6:	dc00      	bgt.n	70aa <__aeabi_ddiv+0x3ca>
    70a8:	e0a1      	b.n	71ee <__aeabi_ddiv+0x50e>
    70aa:	0748      	lsls	r0, r1, #29
    70ac:	d009      	beq.n	70c2 <__aeabi_ddiv+0x3e2>
    70ae:	230f      	movs	r3, #15
    70b0:	400b      	ands	r3, r1
    70b2:	2b04      	cmp	r3, #4
    70b4:	d005      	beq.n	70c2 <__aeabi_ddiv+0x3e2>
    70b6:	1d0b      	adds	r3, r1, #4
    70b8:	428b      	cmp	r3, r1
    70ba:	4189      	sbcs	r1, r1
    70bc:	4249      	negs	r1, r1
    70be:	448b      	add	fp, r1
    70c0:	1c19      	adds	r1, r3, #0
    70c2:	465a      	mov	r2, fp
    70c4:	01d2      	lsls	r2, r2, #7
    70c6:	d507      	bpl.n	70d8 <__aeabi_ddiv+0x3f8>
    70c8:	4b90      	ldr	r3, [pc, #576]	; (730c <__aeabi_ddiv+0x62c>)
    70ca:	465c      	mov	r4, fp
    70cc:	9e04      	ldr	r6, [sp, #16]
    70ce:	2780      	movs	r7, #128	; 0x80
    70d0:	401c      	ands	r4, r3
    70d2:	00ff      	lsls	r7, r7, #3
    70d4:	46a3      	mov	fp, r4
    70d6:	19f5      	adds	r5, r6, r7
    70d8:	4b8d      	ldr	r3, [pc, #564]	; (7310 <__aeabi_ddiv+0x630>)
    70da:	429d      	cmp	r5, r3
    70dc:	dd7a      	ble.n	71d4 <__aeabi_ddiv+0x4f4>
    70de:	9c03      	ldr	r4, [sp, #12]
    70e0:	2201      	movs	r2, #1
    70e2:	4022      	ands	r2, r4
    70e4:	2400      	movs	r4, #0
    70e6:	4d8b      	ldr	r5, [pc, #556]	; (7314 <__aeabi_ddiv+0x634>)
    70e8:	46a1      	mov	r9, r4
    70ea:	e6c1      	b.n	6e70 <__aeabi_ddiv+0x190>
    70ec:	2480      	movs	r4, #128	; 0x80
    70ee:	0324      	lsls	r4, r4, #12
    70f0:	4647      	mov	r7, r8
    70f2:	4227      	tst	r7, r4
    70f4:	d14c      	bne.n	7190 <__aeabi_ddiv+0x4b0>
    70f6:	433c      	orrs	r4, r7
    70f8:	0324      	lsls	r4, r4, #12
    70fa:	0b24      	lsrs	r4, r4, #12
    70fc:	9a00      	ldr	r2, [sp, #0]
    70fe:	4d85      	ldr	r5, [pc, #532]	; (7314 <__aeabi_ddiv+0x634>)
    7100:	e6b6      	b.n	6e70 <__aeabi_ddiv+0x190>
    7102:	1936      	adds	r6, r6, r4
    7104:	1e48      	subs	r0, r1, #1
    7106:	42b4      	cmp	r4, r6
    7108:	d95e      	bls.n	71c8 <__aeabi_ddiv+0x4e8>
    710a:	1c01      	adds	r1, r0, #0
    710c:	4296      	cmp	r6, r2
    710e:	d1c4      	bne.n	709a <__aeabi_ddiv+0x3ba>
    7110:	9e00      	ldr	r6, [sp, #0]
    7112:	429e      	cmp	r6, r3
    7114:	d1c1      	bne.n	709a <__aeabi_ddiv+0x3ba>
    7116:	e7c2      	b.n	709e <__aeabi_ddiv+0x3be>
    7118:	1c03      	adds	r3, r0, #0
    711a:	3b28      	subs	r3, #40	; 0x28
    711c:	1c31      	adds	r1, r6, #0
    711e:	4099      	lsls	r1, r3
    7120:	468b      	mov	fp, r1
    7122:	2100      	movs	r1, #0
    7124:	e688      	b.n	6e38 <__aeabi_ddiv+0x158>
    7126:	1c30      	adds	r0, r6, #0
    7128:	f001 f8b8 	bl	829c <__clzsi2>
    712c:	3020      	adds	r0, #32
    712e:	e672      	b.n	6e16 <__aeabi_ddiv+0x136>
    7130:	3b28      	subs	r3, #40	; 0x28
    7132:	1c21      	adds	r1, r4, #0
    7134:	4099      	lsls	r1, r3
    7136:	2200      	movs	r2, #0
    7138:	4688      	mov	r8, r1
    713a:	4691      	mov	r9, r2
    713c:	e651      	b.n	6de2 <__aeabi_ddiv+0x102>
    713e:	1c20      	adds	r0, r4, #0
    7140:	f001 f8ac 	bl	829c <__clzsi2>
    7144:	3020      	adds	r0, #32
    7146:	e63b      	b.n	6dc0 <__aeabi_ddiv+0xe0>
    7148:	2100      	movs	r1, #0
    714a:	45b1      	cmp	r9, r6
    714c:	d300      	bcc.n	7150 <__aeabi_ddiv+0x470>
    714e:	e73d      	b.n	6fcc <__aeabi_ddiv+0x2ec>
    7150:	9f00      	ldr	r7, [sp, #0]
    7152:	465a      	mov	r2, fp
    7154:	44b9      	add	r9, r7
    7156:	45b9      	cmp	r9, r7
    7158:	41bf      	sbcs	r7, r7
    715a:	427f      	negs	r7, r7
    715c:	193f      	adds	r7, r7, r4
    715e:	18fb      	adds	r3, r7, r3
    7160:	3a01      	subs	r2, #1
    7162:	429c      	cmp	r4, r3
    7164:	d21e      	bcs.n	71a4 <__aeabi_ddiv+0x4c4>
    7166:	4298      	cmp	r0, r3
    7168:	d900      	bls.n	716c <__aeabi_ddiv+0x48c>
    716a:	e07e      	b.n	726a <__aeabi_ddiv+0x58a>
    716c:	d100      	bne.n	7170 <__aeabi_ddiv+0x490>
    716e:	e0b5      	b.n	72dc <__aeabi_ddiv+0x5fc>
    7170:	1a19      	subs	r1, r3, r0
    7172:	4693      	mov	fp, r2
    7174:	e72a      	b.n	6fcc <__aeabi_ddiv+0x2ec>
    7176:	4589      	cmp	r9, r1
    7178:	d800      	bhi.n	717c <__aeabi_ddiv+0x49c>
    717a:	e6ad      	b.n	6ed8 <__aeabi_ddiv+0x1f8>
    717c:	4648      	mov	r0, r9
    717e:	4646      	mov	r6, r8
    7180:	4642      	mov	r2, r8
    7182:	0877      	lsrs	r7, r6, #1
    7184:	07d3      	lsls	r3, r2, #31
    7186:	0846      	lsrs	r6, r0, #1
    7188:	07c0      	lsls	r0, r0, #31
    718a:	431e      	orrs	r6, r3
    718c:	4681      	mov	r9, r0
    718e:	e6aa      	b.n	6ee6 <__aeabi_ddiv+0x206>
    7190:	4658      	mov	r0, fp
    7192:	4220      	tst	r0, r4
    7194:	d112      	bne.n	71bc <__aeabi_ddiv+0x4dc>
    7196:	4304      	orrs	r4, r0
    7198:	0324      	lsls	r4, r4, #12
    719a:	1c2a      	adds	r2, r5, #0
    719c:	0b24      	lsrs	r4, r4, #12
    719e:	4689      	mov	r9, r1
    71a0:	4d5c      	ldr	r5, [pc, #368]	; (7314 <__aeabi_ddiv+0x634>)
    71a2:	e665      	b.n	6e70 <__aeabi_ddiv+0x190>
    71a4:	42a3      	cmp	r3, r4
    71a6:	d1e3      	bne.n	7170 <__aeabi_ddiv+0x490>
    71a8:	9f00      	ldr	r7, [sp, #0]
    71aa:	454f      	cmp	r7, r9
    71ac:	d9db      	bls.n	7166 <__aeabi_ddiv+0x486>
    71ae:	1a21      	subs	r1, r4, r0
    71b0:	4693      	mov	fp, r2
    71b2:	e70b      	b.n	6fcc <__aeabi_ddiv+0x2ec>
    71b4:	1c17      	adds	r7, r2, #0
    71b6:	e6dd      	b.n	6f74 <__aeabi_ddiv+0x294>
    71b8:	469b      	mov	fp, r3
    71ba:	e6bc      	b.n	6f36 <__aeabi_ddiv+0x256>
    71bc:	433c      	orrs	r4, r7
    71be:	0324      	lsls	r4, r4, #12
    71c0:	0b24      	lsrs	r4, r4, #12
    71c2:	9a00      	ldr	r2, [sp, #0]
    71c4:	4d53      	ldr	r5, [pc, #332]	; (7314 <__aeabi_ddiv+0x634>)
    71c6:	e653      	b.n	6e70 <__aeabi_ddiv+0x190>
    71c8:	42b2      	cmp	r2, r6
    71ca:	d859      	bhi.n	7280 <__aeabi_ddiv+0x5a0>
    71cc:	d100      	bne.n	71d0 <__aeabi_ddiv+0x4f0>
    71ce:	e08a      	b.n	72e6 <__aeabi_ddiv+0x606>
    71d0:	1c01      	adds	r1, r0, #0
    71d2:	e762      	b.n	709a <__aeabi_ddiv+0x3ba>
    71d4:	465f      	mov	r7, fp
    71d6:	08c9      	lsrs	r1, r1, #3
    71d8:	077b      	lsls	r3, r7, #29
    71da:	9e03      	ldr	r6, [sp, #12]
    71dc:	430b      	orrs	r3, r1
    71de:	027c      	lsls	r4, r7, #9
    71e0:	056d      	lsls	r5, r5, #21
    71e2:	2201      	movs	r2, #1
    71e4:	4699      	mov	r9, r3
    71e6:	0b24      	lsrs	r4, r4, #12
    71e8:	0d6d      	lsrs	r5, r5, #21
    71ea:	4032      	ands	r2, r6
    71ec:	e640      	b.n	6e70 <__aeabi_ddiv+0x190>
    71ee:	4b4a      	ldr	r3, [pc, #296]	; (7318 <__aeabi_ddiv+0x638>)
    71f0:	9f04      	ldr	r7, [sp, #16]
    71f2:	1bdb      	subs	r3, r3, r7
    71f4:	2b38      	cmp	r3, #56	; 0x38
    71f6:	dd10      	ble.n	721a <__aeabi_ddiv+0x53a>
    71f8:	9c03      	ldr	r4, [sp, #12]
    71fa:	2201      	movs	r2, #1
    71fc:	4022      	ands	r2, r4
    71fe:	2400      	movs	r4, #0
    7200:	2500      	movs	r5, #0
    7202:	46a1      	mov	r9, r4
    7204:	e634      	b.n	6e70 <__aeabi_ddiv+0x190>
    7206:	2101      	movs	r1, #1
    7208:	4249      	negs	r1, r1
    720a:	e748      	b.n	709e <__aeabi_ddiv+0x3be>
    720c:	9302      	str	r3, [sp, #8]
    720e:	e704      	b.n	701a <__aeabi_ddiv+0x33a>
    7210:	1c1f      	adds	r7, r3, #0
    7212:	e721      	b.n	7058 <__aeabi_ddiv+0x378>
    7214:	9c01      	ldr	r4, [sp, #4]
    7216:	9403      	str	r4, [sp, #12]
    7218:	e741      	b.n	709e <__aeabi_ddiv+0x3be>
    721a:	2b1f      	cmp	r3, #31
    721c:	dc40      	bgt.n	72a0 <__aeabi_ddiv+0x5c0>
    721e:	483f      	ldr	r0, [pc, #252]	; (731c <__aeabi_ddiv+0x63c>)
    7220:	9f04      	ldr	r7, [sp, #16]
    7222:	1c0c      	adds	r4, r1, #0
    7224:	183a      	adds	r2, r7, r0
    7226:	4658      	mov	r0, fp
    7228:	4091      	lsls	r1, r2
    722a:	40dc      	lsrs	r4, r3
    722c:	4090      	lsls	r0, r2
    722e:	4320      	orrs	r0, r4
    7230:	1c0a      	adds	r2, r1, #0
    7232:	1e51      	subs	r1, r2, #1
    7234:	418a      	sbcs	r2, r1
    7236:	1c01      	adds	r1, r0, #0
    7238:	4311      	orrs	r1, r2
    723a:	465a      	mov	r2, fp
    723c:	40da      	lsrs	r2, r3
    723e:	1c13      	adds	r3, r2, #0
    7240:	0748      	lsls	r0, r1, #29
    7242:	d009      	beq.n	7258 <__aeabi_ddiv+0x578>
    7244:	220f      	movs	r2, #15
    7246:	400a      	ands	r2, r1
    7248:	2a04      	cmp	r2, #4
    724a:	d005      	beq.n	7258 <__aeabi_ddiv+0x578>
    724c:	1d0a      	adds	r2, r1, #4
    724e:	428a      	cmp	r2, r1
    7250:	4189      	sbcs	r1, r1
    7252:	4249      	negs	r1, r1
    7254:	185b      	adds	r3, r3, r1
    7256:	1c11      	adds	r1, r2, #0
    7258:	021a      	lsls	r2, r3, #8
    725a:	d534      	bpl.n	72c6 <__aeabi_ddiv+0x5e6>
    725c:	9c03      	ldr	r4, [sp, #12]
    725e:	2201      	movs	r2, #1
    7260:	4022      	ands	r2, r4
    7262:	2400      	movs	r4, #0
    7264:	2501      	movs	r5, #1
    7266:	46a1      	mov	r9, r4
    7268:	e602      	b.n	6e70 <__aeabi_ddiv+0x190>
    726a:	9f00      	ldr	r7, [sp, #0]
    726c:	2102      	movs	r1, #2
    726e:	4249      	negs	r1, r1
    7270:	44b9      	add	r9, r7
    7272:	448b      	add	fp, r1
    7274:	45b9      	cmp	r9, r7
    7276:	4189      	sbcs	r1, r1
    7278:	4249      	negs	r1, r1
    727a:	1909      	adds	r1, r1, r4
    727c:	18cb      	adds	r3, r1, r3
    727e:	e6a4      	b.n	6fca <__aeabi_ddiv+0x2ea>
    7280:	9d00      	ldr	r5, [sp, #0]
    7282:	1e88      	subs	r0, r1, #2
    7284:	0069      	lsls	r1, r5, #1
    7286:	42a9      	cmp	r1, r5
    7288:	41ad      	sbcs	r5, r5
    728a:	426d      	negs	r5, r5
    728c:	192c      	adds	r4, r5, r4
    728e:	1936      	adds	r6, r6, r4
    7290:	9100      	str	r1, [sp, #0]
    7292:	e73a      	b.n	710a <__aeabi_ddiv+0x42a>
    7294:	2b00      	cmp	r3, #0
    7296:	d000      	beq.n	729a <__aeabi_ddiv+0x5ba>
    7298:	e733      	b.n	7102 <__aeabi_ddiv+0x422>
    729a:	2400      	movs	r4, #0
    729c:	9400      	str	r4, [sp, #0]
    729e:	e737      	b.n	7110 <__aeabi_ddiv+0x430>
    72a0:	4a1f      	ldr	r2, [pc, #124]	; (7320 <__aeabi_ddiv+0x640>)
    72a2:	9c04      	ldr	r4, [sp, #16]
    72a4:	465d      	mov	r5, fp
    72a6:	1b12      	subs	r2, r2, r4
    72a8:	40d5      	lsrs	r5, r2
    72aa:	1c2a      	adds	r2, r5, #0
    72ac:	2b20      	cmp	r3, #32
    72ae:	d01f      	beq.n	72f0 <__aeabi_ddiv+0x610>
    72b0:	4e1c      	ldr	r6, [pc, #112]	; (7324 <__aeabi_ddiv+0x644>)
    72b2:	465f      	mov	r7, fp
    72b4:	19a3      	adds	r3, r4, r6
    72b6:	409f      	lsls	r7, r3
    72b8:	1c3b      	adds	r3, r7, #0
    72ba:	4319      	orrs	r1, r3
    72bc:	1e4b      	subs	r3, r1, #1
    72be:	4199      	sbcs	r1, r3
    72c0:	4311      	orrs	r1, r2
    72c2:	2300      	movs	r3, #0
    72c4:	e7bc      	b.n	7240 <__aeabi_ddiv+0x560>
    72c6:	075a      	lsls	r2, r3, #29
    72c8:	08c9      	lsrs	r1, r1, #3
    72ca:	430a      	orrs	r2, r1
    72cc:	9f03      	ldr	r7, [sp, #12]
    72ce:	4691      	mov	r9, r2
    72d0:	025b      	lsls	r3, r3, #9
    72d2:	2201      	movs	r2, #1
    72d4:	0b1c      	lsrs	r4, r3, #12
    72d6:	403a      	ands	r2, r7
    72d8:	2500      	movs	r5, #0
    72da:	e5c9      	b.n	6e70 <__aeabi_ddiv+0x190>
    72dc:	454e      	cmp	r6, r9
    72de:	d8c4      	bhi.n	726a <__aeabi_ddiv+0x58a>
    72e0:	4693      	mov	fp, r2
    72e2:	2100      	movs	r1, #0
    72e4:	e672      	b.n	6fcc <__aeabi_ddiv+0x2ec>
    72e6:	9f00      	ldr	r7, [sp, #0]
    72e8:	429f      	cmp	r7, r3
    72ea:	d3c9      	bcc.n	7280 <__aeabi_ddiv+0x5a0>
    72ec:	1c01      	adds	r1, r0, #0
    72ee:	e70f      	b.n	7110 <__aeabi_ddiv+0x430>
    72f0:	2300      	movs	r3, #0
    72f2:	e7e2      	b.n	72ba <__aeabi_ddiv+0x5da>
    72f4:	2480      	movs	r4, #128	; 0x80
    72f6:	0324      	lsls	r4, r4, #12
    72f8:	465f      	mov	r7, fp
    72fa:	433c      	orrs	r4, r7
    72fc:	0324      	lsls	r4, r4, #12
    72fe:	0b24      	lsrs	r4, r4, #12
    7300:	9a01      	ldr	r2, [sp, #4]
    7302:	4689      	mov	r9, r1
    7304:	4d03      	ldr	r5, [pc, #12]	; (7314 <__aeabi_ddiv+0x634>)
    7306:	e5b3      	b.n	6e70 <__aeabi_ddiv+0x190>
    7308:	000003ff 	.word	0x000003ff
    730c:	feffffff 	.word	0xfeffffff
    7310:	000007fe 	.word	0x000007fe
    7314:	000007ff 	.word	0x000007ff
    7318:	fffffc02 	.word	0xfffffc02
    731c:	0000041e 	.word	0x0000041e
    7320:	fffffbe2 	.word	0xfffffbe2
    7324:	0000043e 	.word	0x0000043e

00007328 <__eqdf2>:
    7328:	b5f0      	push	{r4, r5, r6, r7, lr}
    732a:	465f      	mov	r7, fp
    732c:	4656      	mov	r6, sl
    732e:	464d      	mov	r5, r9
    7330:	4644      	mov	r4, r8
    7332:	b4f0      	push	{r4, r5, r6, r7}
    7334:	1c0d      	adds	r5, r1, #0
    7336:	1c04      	adds	r4, r0, #0
    7338:	4680      	mov	r8, r0
    733a:	0fe8      	lsrs	r0, r5, #31
    733c:	4681      	mov	r9, r0
    733e:	0318      	lsls	r0, r3, #12
    7340:	030f      	lsls	r7, r1, #12
    7342:	0b00      	lsrs	r0, r0, #12
    7344:	0b3f      	lsrs	r7, r7, #12
    7346:	b083      	sub	sp, #12
    7348:	4684      	mov	ip, r0
    734a:	481b      	ldr	r0, [pc, #108]	; (73b8 <__eqdf2+0x90>)
    734c:	9700      	str	r7, [sp, #0]
    734e:	0049      	lsls	r1, r1, #1
    7350:	005e      	lsls	r6, r3, #1
    7352:	0fdf      	lsrs	r7, r3, #31
    7354:	0d49      	lsrs	r1, r1, #21
    7356:	4692      	mov	sl, r2
    7358:	0d76      	lsrs	r6, r6, #21
    735a:	46bb      	mov	fp, r7
    735c:	4281      	cmp	r1, r0
    735e:	d00c      	beq.n	737a <__eqdf2+0x52>
    7360:	4815      	ldr	r0, [pc, #84]	; (73b8 <__eqdf2+0x90>)
    7362:	4286      	cmp	r6, r0
    7364:	d010      	beq.n	7388 <__eqdf2+0x60>
    7366:	2001      	movs	r0, #1
    7368:	42b1      	cmp	r1, r6
    736a:	d015      	beq.n	7398 <__eqdf2+0x70>
    736c:	b003      	add	sp, #12
    736e:	bc3c      	pop	{r2, r3, r4, r5}
    7370:	4690      	mov	r8, r2
    7372:	4699      	mov	r9, r3
    7374:	46a2      	mov	sl, r4
    7376:	46ab      	mov	fp, r5
    7378:	bdf0      	pop	{r4, r5, r6, r7, pc}
    737a:	9f00      	ldr	r7, [sp, #0]
    737c:	2001      	movs	r0, #1
    737e:	4327      	orrs	r7, r4
    7380:	d1f4      	bne.n	736c <__eqdf2+0x44>
    7382:	480d      	ldr	r0, [pc, #52]	; (73b8 <__eqdf2+0x90>)
    7384:	4286      	cmp	r6, r0
    7386:	d1ee      	bne.n	7366 <__eqdf2+0x3e>
    7388:	4660      	mov	r0, ip
    738a:	4302      	orrs	r2, r0
    738c:	2001      	movs	r0, #1
    738e:	2a00      	cmp	r2, #0
    7390:	d1ec      	bne.n	736c <__eqdf2+0x44>
    7392:	2001      	movs	r0, #1
    7394:	42b1      	cmp	r1, r6
    7396:	d1e9      	bne.n	736c <__eqdf2+0x44>
    7398:	9b00      	ldr	r3, [sp, #0]
    739a:	4563      	cmp	r3, ip
    739c:	d1e6      	bne.n	736c <__eqdf2+0x44>
    739e:	45d0      	cmp	r8, sl
    73a0:	d1e4      	bne.n	736c <__eqdf2+0x44>
    73a2:	45d9      	cmp	r9, fp
    73a4:	d006      	beq.n	73b4 <__eqdf2+0x8c>
    73a6:	2900      	cmp	r1, #0
    73a8:	d1e0      	bne.n	736c <__eqdf2+0x44>
    73aa:	431c      	orrs	r4, r3
    73ac:	1c20      	adds	r0, r4, #0
    73ae:	1e44      	subs	r4, r0, #1
    73b0:	41a0      	sbcs	r0, r4
    73b2:	e7db      	b.n	736c <__eqdf2+0x44>
    73b4:	2000      	movs	r0, #0
    73b6:	e7d9      	b.n	736c <__eqdf2+0x44>
    73b8:	000007ff 	.word	0x000007ff

000073bc <__gedf2>:
    73bc:	b5f0      	push	{r4, r5, r6, r7, lr}
    73be:	465f      	mov	r7, fp
    73c0:	4656      	mov	r6, sl
    73c2:	464d      	mov	r5, r9
    73c4:	4644      	mov	r4, r8
    73c6:	b4f0      	push	{r4, r5, r6, r7}
    73c8:	0fcd      	lsrs	r5, r1, #31
    73ca:	0fde      	lsrs	r6, r3, #31
    73cc:	46ac      	mov	ip, r5
    73ce:	031d      	lsls	r5, r3, #12
    73d0:	0b2d      	lsrs	r5, r5, #12
    73d2:	46b1      	mov	r9, r6
    73d4:	4e37      	ldr	r6, [pc, #220]	; (74b4 <__gedf2+0xf8>)
    73d6:	030f      	lsls	r7, r1, #12
    73d8:	004c      	lsls	r4, r1, #1
    73da:	46ab      	mov	fp, r5
    73dc:	005d      	lsls	r5, r3, #1
    73de:	4680      	mov	r8, r0
    73e0:	0b3f      	lsrs	r7, r7, #12
    73e2:	0d64      	lsrs	r4, r4, #21
    73e4:	4692      	mov	sl, r2
    73e6:	0d6d      	lsrs	r5, r5, #21
    73e8:	42b4      	cmp	r4, r6
    73ea:	d032      	beq.n	7452 <__gedf2+0x96>
    73ec:	4e31      	ldr	r6, [pc, #196]	; (74b4 <__gedf2+0xf8>)
    73ee:	42b5      	cmp	r5, r6
    73f0:	d035      	beq.n	745e <__gedf2+0xa2>
    73f2:	2c00      	cmp	r4, #0
    73f4:	d10e      	bne.n	7414 <__gedf2+0x58>
    73f6:	4338      	orrs	r0, r7
    73f8:	4241      	negs	r1, r0
    73fa:	4141      	adcs	r1, r0
    73fc:	1c08      	adds	r0, r1, #0
    73fe:	2d00      	cmp	r5, #0
    7400:	d00b      	beq.n	741a <__gedf2+0x5e>
    7402:	2900      	cmp	r1, #0
    7404:	d119      	bne.n	743a <__gedf2+0x7e>
    7406:	45cc      	cmp	ip, r9
    7408:	d02d      	beq.n	7466 <__gedf2+0xaa>
    740a:	4665      	mov	r5, ip
    740c:	4268      	negs	r0, r5
    740e:	2301      	movs	r3, #1
    7410:	4318      	orrs	r0, r3
    7412:	e018      	b.n	7446 <__gedf2+0x8a>
    7414:	2d00      	cmp	r5, #0
    7416:	d1f6      	bne.n	7406 <__gedf2+0x4a>
    7418:	1c28      	adds	r0, r5, #0
    741a:	4659      	mov	r1, fp
    741c:	430a      	orrs	r2, r1
    741e:	4253      	negs	r3, r2
    7420:	4153      	adcs	r3, r2
    7422:	2800      	cmp	r0, #0
    7424:	d106      	bne.n	7434 <__gedf2+0x78>
    7426:	2b00      	cmp	r3, #0
    7428:	d0ed      	beq.n	7406 <__gedf2+0x4a>
    742a:	4663      	mov	r3, ip
    742c:	4258      	negs	r0, r3
    742e:	2301      	movs	r3, #1
    7430:	4318      	orrs	r0, r3
    7432:	e008      	b.n	7446 <__gedf2+0x8a>
    7434:	2000      	movs	r0, #0
    7436:	2b00      	cmp	r3, #0
    7438:	d105      	bne.n	7446 <__gedf2+0x8a>
    743a:	464a      	mov	r2, r9
    743c:	4250      	negs	r0, r2
    743e:	4150      	adcs	r0, r2
    7440:	4240      	negs	r0, r0
    7442:	2301      	movs	r3, #1
    7444:	4318      	orrs	r0, r3
    7446:	bc3c      	pop	{r2, r3, r4, r5}
    7448:	4690      	mov	r8, r2
    744a:	4699      	mov	r9, r3
    744c:	46a2      	mov	sl, r4
    744e:	46ab      	mov	fp, r5
    7450:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7452:	1c3e      	adds	r6, r7, #0
    7454:	4306      	orrs	r6, r0
    7456:	d0c9      	beq.n	73ec <__gedf2+0x30>
    7458:	2002      	movs	r0, #2
    745a:	4240      	negs	r0, r0
    745c:	e7f3      	b.n	7446 <__gedf2+0x8a>
    745e:	465e      	mov	r6, fp
    7460:	4316      	orrs	r6, r2
    7462:	d0c6      	beq.n	73f2 <__gedf2+0x36>
    7464:	e7f8      	b.n	7458 <__gedf2+0x9c>
    7466:	42ac      	cmp	r4, r5
    7468:	dc07      	bgt.n	747a <__gedf2+0xbe>
    746a:	da0b      	bge.n	7484 <__gedf2+0xc8>
    746c:	4661      	mov	r1, ip
    746e:	4248      	negs	r0, r1
    7470:	4148      	adcs	r0, r1
    7472:	4240      	negs	r0, r0
    7474:	2301      	movs	r3, #1
    7476:	4318      	orrs	r0, r3
    7478:	e7e5      	b.n	7446 <__gedf2+0x8a>
    747a:	4666      	mov	r6, ip
    747c:	4270      	negs	r0, r6
    747e:	2301      	movs	r3, #1
    7480:	4318      	orrs	r0, r3
    7482:	e7e0      	b.n	7446 <__gedf2+0x8a>
    7484:	455f      	cmp	r7, fp
    7486:	d80a      	bhi.n	749e <__gedf2+0xe2>
    7488:	d00e      	beq.n	74a8 <__gedf2+0xec>
    748a:	2000      	movs	r0, #0
    748c:	455f      	cmp	r7, fp
    748e:	d2da      	bcs.n	7446 <__gedf2+0x8a>
    7490:	4665      	mov	r5, ip
    7492:	4268      	negs	r0, r5
    7494:	4168      	adcs	r0, r5
    7496:	4240      	negs	r0, r0
    7498:	2301      	movs	r3, #1
    749a:	4318      	orrs	r0, r3
    749c:	e7d3      	b.n	7446 <__gedf2+0x8a>
    749e:	4662      	mov	r2, ip
    74a0:	4250      	negs	r0, r2
    74a2:	2301      	movs	r3, #1
    74a4:	4318      	orrs	r0, r3
    74a6:	e7ce      	b.n	7446 <__gedf2+0x8a>
    74a8:	45d0      	cmp	r8, sl
    74aa:	d8f8      	bhi.n	749e <__gedf2+0xe2>
    74ac:	2000      	movs	r0, #0
    74ae:	45d0      	cmp	r8, sl
    74b0:	d3ee      	bcc.n	7490 <__gedf2+0xd4>
    74b2:	e7c8      	b.n	7446 <__gedf2+0x8a>
    74b4:	000007ff 	.word	0x000007ff

000074b8 <__ledf2>:
    74b8:	b5f0      	push	{r4, r5, r6, r7, lr}
    74ba:	4656      	mov	r6, sl
    74bc:	464d      	mov	r5, r9
    74be:	4644      	mov	r4, r8
    74c0:	465f      	mov	r7, fp
    74c2:	b4f0      	push	{r4, r5, r6, r7}
    74c4:	1c0d      	adds	r5, r1, #0
    74c6:	b083      	sub	sp, #12
    74c8:	1c04      	adds	r4, r0, #0
    74ca:	9001      	str	r0, [sp, #4]
    74cc:	0fe8      	lsrs	r0, r5, #31
    74ce:	4681      	mov	r9, r0
    74d0:	0318      	lsls	r0, r3, #12
    74d2:	030f      	lsls	r7, r1, #12
    74d4:	0b00      	lsrs	r0, r0, #12
    74d6:	0b3f      	lsrs	r7, r7, #12
    74d8:	4684      	mov	ip, r0
    74da:	4835      	ldr	r0, [pc, #212]	; (75b0 <__ledf2+0xf8>)
    74dc:	9700      	str	r7, [sp, #0]
    74de:	0049      	lsls	r1, r1, #1
    74e0:	005e      	lsls	r6, r3, #1
    74e2:	0fdf      	lsrs	r7, r3, #31
    74e4:	0d49      	lsrs	r1, r1, #21
    74e6:	4692      	mov	sl, r2
    74e8:	0d76      	lsrs	r6, r6, #21
    74ea:	46b8      	mov	r8, r7
    74ec:	4281      	cmp	r1, r0
    74ee:	d034      	beq.n	755a <__ledf2+0xa2>
    74f0:	482f      	ldr	r0, [pc, #188]	; (75b0 <__ledf2+0xf8>)
    74f2:	4286      	cmp	r6, r0
    74f4:	d036      	beq.n	7564 <__ledf2+0xac>
    74f6:	2900      	cmp	r1, #0
    74f8:	d018      	beq.n	752c <__ledf2+0x74>
    74fa:	2e00      	cmp	r6, #0
    74fc:	d11f      	bne.n	753e <__ledf2+0x86>
    74fe:	1c34      	adds	r4, r6, #0
    7500:	4667      	mov	r7, ip
    7502:	433a      	orrs	r2, r7
    7504:	4253      	negs	r3, r2
    7506:	4153      	adcs	r3, r2
    7508:	2c00      	cmp	r4, #0
    750a:	d01f      	beq.n	754c <__ledf2+0x94>
    750c:	2000      	movs	r0, #0
    750e:	2b00      	cmp	r3, #0
    7510:	d105      	bne.n	751e <__ledf2+0x66>
    7512:	4642      	mov	r2, r8
    7514:	4250      	negs	r0, r2
    7516:	4150      	adcs	r0, r2
    7518:	4240      	negs	r0, r0
    751a:	2301      	movs	r3, #1
    751c:	4318      	orrs	r0, r3
    751e:	b003      	add	sp, #12
    7520:	bc3c      	pop	{r2, r3, r4, r5}
    7522:	4690      	mov	r8, r2
    7524:	4699      	mov	r9, r3
    7526:	46a2      	mov	sl, r4
    7528:	46ab      	mov	fp, r5
    752a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    752c:	9800      	ldr	r0, [sp, #0]
    752e:	4304      	orrs	r4, r0
    7530:	4260      	negs	r0, r4
    7532:	4160      	adcs	r0, r4
    7534:	1c04      	adds	r4, r0, #0
    7536:	2e00      	cmp	r6, #0
    7538:	d0e2      	beq.n	7500 <__ledf2+0x48>
    753a:	2800      	cmp	r0, #0
    753c:	d1e9      	bne.n	7512 <__ledf2+0x5a>
    753e:	45c1      	cmp	r9, r8
    7540:	d015      	beq.n	756e <__ledf2+0xb6>
    7542:	464f      	mov	r7, r9
    7544:	4278      	negs	r0, r7
    7546:	2301      	movs	r3, #1
    7548:	4318      	orrs	r0, r3
    754a:	e7e8      	b.n	751e <__ledf2+0x66>
    754c:	2b00      	cmp	r3, #0
    754e:	d0f6      	beq.n	753e <__ledf2+0x86>
    7550:	464b      	mov	r3, r9
    7552:	4258      	negs	r0, r3
    7554:	2301      	movs	r3, #1
    7556:	4318      	orrs	r0, r3
    7558:	e7e1      	b.n	751e <__ledf2+0x66>
    755a:	9f00      	ldr	r7, [sp, #0]
    755c:	2002      	movs	r0, #2
    755e:	4327      	orrs	r7, r4
    7560:	d1dd      	bne.n	751e <__ledf2+0x66>
    7562:	e7c5      	b.n	74f0 <__ledf2+0x38>
    7564:	4667      	mov	r7, ip
    7566:	2002      	movs	r0, #2
    7568:	4317      	orrs	r7, r2
    756a:	d1d8      	bne.n	751e <__ledf2+0x66>
    756c:	e7c3      	b.n	74f6 <__ledf2+0x3e>
    756e:	42b1      	cmp	r1, r6
    7570:	dd04      	ble.n	757c <__ledf2+0xc4>
    7572:	464a      	mov	r2, r9
    7574:	4250      	negs	r0, r2
    7576:	2301      	movs	r3, #1
    7578:	4318      	orrs	r0, r3
    757a:	e7d0      	b.n	751e <__ledf2+0x66>
    757c:	42b1      	cmp	r1, r6
    757e:	db07      	blt.n	7590 <__ledf2+0xd8>
    7580:	9800      	ldr	r0, [sp, #0]
    7582:	4560      	cmp	r0, ip
    7584:	d8e4      	bhi.n	7550 <__ledf2+0x98>
    7586:	d00a      	beq.n	759e <__ledf2+0xe6>
    7588:	9f00      	ldr	r7, [sp, #0]
    758a:	2000      	movs	r0, #0
    758c:	4567      	cmp	r7, ip
    758e:	d2c6      	bcs.n	751e <__ledf2+0x66>
    7590:	464f      	mov	r7, r9
    7592:	4278      	negs	r0, r7
    7594:	4178      	adcs	r0, r7
    7596:	4240      	negs	r0, r0
    7598:	2301      	movs	r3, #1
    759a:	4318      	orrs	r0, r3
    759c:	e7bf      	b.n	751e <__ledf2+0x66>
    759e:	9a01      	ldr	r2, [sp, #4]
    75a0:	4552      	cmp	r2, sl
    75a2:	d8d5      	bhi.n	7550 <__ledf2+0x98>
    75a4:	9a01      	ldr	r2, [sp, #4]
    75a6:	2000      	movs	r0, #0
    75a8:	4552      	cmp	r2, sl
    75aa:	d3f1      	bcc.n	7590 <__ledf2+0xd8>
    75ac:	e7b7      	b.n	751e <__ledf2+0x66>
    75ae:	46c0      	nop			; (mov r8, r8)
    75b0:	000007ff 	.word	0x000007ff

000075b4 <__aeabi_dmul>:
    75b4:	b5f0      	push	{r4, r5, r6, r7, lr}
    75b6:	4656      	mov	r6, sl
    75b8:	4644      	mov	r4, r8
    75ba:	465f      	mov	r7, fp
    75bc:	464d      	mov	r5, r9
    75be:	b4f0      	push	{r4, r5, r6, r7}
    75c0:	1c1f      	adds	r7, r3, #0
    75c2:	030b      	lsls	r3, r1, #12
    75c4:	0b1b      	lsrs	r3, r3, #12
    75c6:	469a      	mov	sl, r3
    75c8:	004b      	lsls	r3, r1, #1
    75ca:	b087      	sub	sp, #28
    75cc:	1c04      	adds	r4, r0, #0
    75ce:	4680      	mov	r8, r0
    75d0:	0d5b      	lsrs	r3, r3, #21
    75d2:	0fc8      	lsrs	r0, r1, #31
    75d4:	1c16      	adds	r6, r2, #0
    75d6:	9302      	str	r3, [sp, #8]
    75d8:	4681      	mov	r9, r0
    75da:	2b00      	cmp	r3, #0
    75dc:	d068      	beq.n	76b0 <__aeabi_dmul+0xfc>
    75de:	4b69      	ldr	r3, [pc, #420]	; (7784 <__aeabi_dmul+0x1d0>)
    75e0:	9902      	ldr	r1, [sp, #8]
    75e2:	4299      	cmp	r1, r3
    75e4:	d032      	beq.n	764c <__aeabi_dmul+0x98>
    75e6:	2280      	movs	r2, #128	; 0x80
    75e8:	4653      	mov	r3, sl
    75ea:	0352      	lsls	r2, r2, #13
    75ec:	431a      	orrs	r2, r3
    75ee:	00d2      	lsls	r2, r2, #3
    75f0:	0f63      	lsrs	r3, r4, #29
    75f2:	431a      	orrs	r2, r3
    75f4:	4692      	mov	sl, r2
    75f6:	4a64      	ldr	r2, [pc, #400]	; (7788 <__aeabi_dmul+0x1d4>)
    75f8:	00e0      	lsls	r0, r4, #3
    75fa:	1889      	adds	r1, r1, r2
    75fc:	4680      	mov	r8, r0
    75fe:	9102      	str	r1, [sp, #8]
    7600:	2400      	movs	r4, #0
    7602:	2500      	movs	r5, #0
    7604:	033b      	lsls	r3, r7, #12
    7606:	0b1b      	lsrs	r3, r3, #12
    7608:	469b      	mov	fp, r3
    760a:	0078      	lsls	r0, r7, #1
    760c:	0ffb      	lsrs	r3, r7, #31
    760e:	1c32      	adds	r2, r6, #0
    7610:	0d40      	lsrs	r0, r0, #21
    7612:	9303      	str	r3, [sp, #12]
    7614:	d100      	bne.n	7618 <__aeabi_dmul+0x64>
    7616:	e075      	b.n	7704 <__aeabi_dmul+0x150>
    7618:	4b5a      	ldr	r3, [pc, #360]	; (7784 <__aeabi_dmul+0x1d0>)
    761a:	4298      	cmp	r0, r3
    761c:	d069      	beq.n	76f2 <__aeabi_dmul+0x13e>
    761e:	2280      	movs	r2, #128	; 0x80
    7620:	4659      	mov	r1, fp
    7622:	0352      	lsls	r2, r2, #13
    7624:	430a      	orrs	r2, r1
    7626:	0f73      	lsrs	r3, r6, #29
    7628:	00d2      	lsls	r2, r2, #3
    762a:	431a      	orrs	r2, r3
    762c:	4b56      	ldr	r3, [pc, #344]	; (7788 <__aeabi_dmul+0x1d4>)
    762e:	4693      	mov	fp, r2
    7630:	18c0      	adds	r0, r0, r3
    7632:	00f2      	lsls	r2, r6, #3
    7634:	2300      	movs	r3, #0
    7636:	9903      	ldr	r1, [sp, #12]
    7638:	464e      	mov	r6, r9
    763a:	4071      	eors	r1, r6
    763c:	431c      	orrs	r4, r3
    763e:	2c0f      	cmp	r4, #15
    7640:	d900      	bls.n	7644 <__aeabi_dmul+0x90>
    7642:	e0a9      	b.n	7798 <__aeabi_dmul+0x1e4>
    7644:	4e51      	ldr	r6, [pc, #324]	; (778c <__aeabi_dmul+0x1d8>)
    7646:	00a4      	lsls	r4, r4, #2
    7648:	5934      	ldr	r4, [r6, r4]
    764a:	46a7      	mov	pc, r4
    764c:	4653      	mov	r3, sl
    764e:	431c      	orrs	r4, r3
    7650:	d000      	beq.n	7654 <__aeabi_dmul+0xa0>
    7652:	e087      	b.n	7764 <__aeabi_dmul+0x1b0>
    7654:	2500      	movs	r5, #0
    7656:	46aa      	mov	sl, r5
    7658:	46a8      	mov	r8, r5
    765a:	2408      	movs	r4, #8
    765c:	2502      	movs	r5, #2
    765e:	e7d1      	b.n	7604 <__aeabi_dmul+0x50>
    7660:	4649      	mov	r1, r9
    7662:	2d02      	cmp	r5, #2
    7664:	d06c      	beq.n	7740 <__aeabi_dmul+0x18c>
    7666:	2d03      	cmp	r5, #3
    7668:	d100      	bne.n	766c <__aeabi_dmul+0xb8>
    766a:	e217      	b.n	7a9c <__aeabi_dmul+0x4e8>
    766c:	2d01      	cmp	r5, #1
    766e:	d000      	beq.n	7672 <__aeabi_dmul+0xbe>
    7670:	e158      	b.n	7924 <__aeabi_dmul+0x370>
    7672:	400d      	ands	r5, r1
    7674:	b2ed      	uxtb	r5, r5
    7676:	2400      	movs	r4, #0
    7678:	46a9      	mov	r9, r5
    767a:	2300      	movs	r3, #0
    767c:	46a0      	mov	r8, r4
    767e:	2000      	movs	r0, #0
    7680:	2100      	movs	r1, #0
    7682:	0325      	lsls	r5, r4, #12
    7684:	0d0a      	lsrs	r2, r1, #20
    7686:	051c      	lsls	r4, r3, #20
    7688:	0b2d      	lsrs	r5, r5, #12
    768a:	0512      	lsls	r2, r2, #20
    768c:	4b40      	ldr	r3, [pc, #256]	; (7790 <__aeabi_dmul+0x1dc>)
    768e:	432a      	orrs	r2, r5
    7690:	4013      	ands	r3, r2
    7692:	4323      	orrs	r3, r4
    7694:	005b      	lsls	r3, r3, #1
    7696:	464c      	mov	r4, r9
    7698:	085b      	lsrs	r3, r3, #1
    769a:	07e2      	lsls	r2, r4, #31
    769c:	1c19      	adds	r1, r3, #0
    769e:	4640      	mov	r0, r8
    76a0:	4311      	orrs	r1, r2
    76a2:	b007      	add	sp, #28
    76a4:	bc3c      	pop	{r2, r3, r4, r5}
    76a6:	4690      	mov	r8, r2
    76a8:	4699      	mov	r9, r3
    76aa:	46a2      	mov	sl, r4
    76ac:	46ab      	mov	fp, r5
    76ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    76b0:	4653      	mov	r3, sl
    76b2:	4323      	orrs	r3, r4
    76b4:	d050      	beq.n	7758 <__aeabi_dmul+0x1a4>
    76b6:	4653      	mov	r3, sl
    76b8:	2b00      	cmp	r3, #0
    76ba:	d100      	bne.n	76be <__aeabi_dmul+0x10a>
    76bc:	e184      	b.n	79c8 <__aeabi_dmul+0x414>
    76be:	4650      	mov	r0, sl
    76c0:	f000 fdec 	bl	829c <__clzsi2>
    76c4:	1e03      	subs	r3, r0, #0
    76c6:	2b27      	cmp	r3, #39	; 0x27
    76c8:	dd00      	ble.n	76cc <__aeabi_dmul+0x118>
    76ca:	e176      	b.n	79ba <__aeabi_dmul+0x406>
    76cc:	2128      	movs	r1, #40	; 0x28
    76ce:	1a0d      	subs	r5, r1, r0
    76d0:	1c21      	adds	r1, r4, #0
    76d2:	3b08      	subs	r3, #8
    76d4:	4652      	mov	r2, sl
    76d6:	40e9      	lsrs	r1, r5
    76d8:	409a      	lsls	r2, r3
    76da:	1c0d      	adds	r5, r1, #0
    76dc:	4315      	orrs	r5, r2
    76de:	1c22      	adds	r2, r4, #0
    76e0:	409a      	lsls	r2, r3
    76e2:	46aa      	mov	sl, r5
    76e4:	4690      	mov	r8, r2
    76e6:	4b2b      	ldr	r3, [pc, #172]	; (7794 <__aeabi_dmul+0x1e0>)
    76e8:	2400      	movs	r4, #0
    76ea:	1a1b      	subs	r3, r3, r0
    76ec:	9302      	str	r3, [sp, #8]
    76ee:	2500      	movs	r5, #0
    76f0:	e788      	b.n	7604 <__aeabi_dmul+0x50>
    76f2:	465b      	mov	r3, fp
    76f4:	431e      	orrs	r6, r3
    76f6:	2303      	movs	r3, #3
    76f8:	2e00      	cmp	r6, #0
    76fa:	d19c      	bne.n	7636 <__aeabi_dmul+0x82>
    76fc:	46b3      	mov	fp, r6
    76fe:	2200      	movs	r2, #0
    7700:	2302      	movs	r3, #2
    7702:	e798      	b.n	7636 <__aeabi_dmul+0x82>
    7704:	465b      	mov	r3, fp
    7706:	4333      	orrs	r3, r6
    7708:	d021      	beq.n	774e <__aeabi_dmul+0x19a>
    770a:	4658      	mov	r0, fp
    770c:	2800      	cmp	r0, #0
    770e:	d100      	bne.n	7712 <__aeabi_dmul+0x15e>
    7710:	e14e      	b.n	79b0 <__aeabi_dmul+0x3fc>
    7712:	f000 fdc3 	bl	829c <__clzsi2>
    7716:	2827      	cmp	r0, #39	; 0x27
    7718:	dd00      	ble.n	771c <__aeabi_dmul+0x168>
    771a:	e142      	b.n	79a2 <__aeabi_dmul+0x3ee>
    771c:	2128      	movs	r1, #40	; 0x28
    771e:	1a0f      	subs	r7, r1, r0
    7720:	1c02      	adds	r2, r0, #0
    7722:	1c31      	adds	r1, r6, #0
    7724:	3a08      	subs	r2, #8
    7726:	465b      	mov	r3, fp
    7728:	40f9      	lsrs	r1, r7
    772a:	4093      	lsls	r3, r2
    772c:	1c0f      	adds	r7, r1, #0
    772e:	431f      	orrs	r7, r3
    7730:	1c33      	adds	r3, r6, #0
    7732:	4093      	lsls	r3, r2
    7734:	46bb      	mov	fp, r7
    7736:	1c1a      	adds	r2, r3, #0
    7738:	4b16      	ldr	r3, [pc, #88]	; (7794 <__aeabi_dmul+0x1e0>)
    773a:	1a18      	subs	r0, r3, r0
    773c:	2300      	movs	r3, #0
    773e:	e77a      	b.n	7636 <__aeabi_dmul+0x82>
    7740:	2301      	movs	r3, #1
    7742:	400b      	ands	r3, r1
    7744:	2400      	movs	r4, #0
    7746:	4699      	mov	r9, r3
    7748:	46a0      	mov	r8, r4
    774a:	4b0e      	ldr	r3, [pc, #56]	; (7784 <__aeabi_dmul+0x1d0>)
    774c:	e797      	b.n	767e <__aeabi_dmul+0xca>
    774e:	2700      	movs	r7, #0
    7750:	46bb      	mov	fp, r7
    7752:	2200      	movs	r2, #0
    7754:	2301      	movs	r3, #1
    7756:	e76e      	b.n	7636 <__aeabi_dmul+0x82>
    7758:	2100      	movs	r1, #0
    775a:	2404      	movs	r4, #4
    775c:	468a      	mov	sl, r1
    775e:	4688      	mov	r8, r1
    7760:	2501      	movs	r5, #1
    7762:	e74f      	b.n	7604 <__aeabi_dmul+0x50>
    7764:	240c      	movs	r4, #12
    7766:	2503      	movs	r5, #3
    7768:	e74c      	b.n	7604 <__aeabi_dmul+0x50>
    776a:	2500      	movs	r5, #0
    776c:	2480      	movs	r4, #128	; 0x80
    776e:	46a9      	mov	r9, r5
    7770:	0324      	lsls	r4, r4, #12
    7772:	46a8      	mov	r8, r5
    7774:	4b03      	ldr	r3, [pc, #12]	; (7784 <__aeabi_dmul+0x1d0>)
    7776:	e782      	b.n	767e <__aeabi_dmul+0xca>
    7778:	46da      	mov	sl, fp
    777a:	4690      	mov	r8, r2
    777c:	9903      	ldr	r1, [sp, #12]
    777e:	1c1d      	adds	r5, r3, #0
    7780:	e76f      	b.n	7662 <__aeabi_dmul+0xae>
    7782:	46c0      	nop			; (mov r8, r8)
    7784:	000007ff 	.word	0x000007ff
    7788:	fffffc01 	.word	0xfffffc01
    778c:	000091d0 	.word	0x000091d0
    7790:	800fffff 	.word	0x800fffff
    7794:	fffffc0d 	.word	0xfffffc0d
    7798:	9f02      	ldr	r7, [sp, #8]
    779a:	0c16      	lsrs	r6, r2, #16
    779c:	1838      	adds	r0, r7, r0
    779e:	9004      	str	r0, [sp, #16]
    77a0:	4640      	mov	r0, r8
    77a2:	0c07      	lsrs	r7, r0, #16
    77a4:	0400      	lsls	r0, r0, #16
    77a6:	0c00      	lsrs	r0, r0, #16
    77a8:	0412      	lsls	r2, r2, #16
    77aa:	0c12      	lsrs	r2, r2, #16
    77ac:	1c03      	adds	r3, r0, #0
    77ae:	4353      	muls	r3, r2
    77b0:	1c04      	adds	r4, r0, #0
    77b2:	1c3d      	adds	r5, r7, #0
    77b4:	4374      	muls	r4, r6
    77b6:	4355      	muls	r5, r2
    77b8:	4698      	mov	r8, r3
    77ba:	1c3b      	adds	r3, r7, #0
    77bc:	4373      	muls	r3, r6
    77be:	1964      	adds	r4, r4, r5
    77c0:	46a4      	mov	ip, r4
    77c2:	4644      	mov	r4, r8
    77c4:	9302      	str	r3, [sp, #8]
    77c6:	0c23      	lsrs	r3, r4, #16
    77c8:	4463      	add	r3, ip
    77ca:	429d      	cmp	r5, r3
    77cc:	d904      	bls.n	77d8 <__aeabi_dmul+0x224>
    77ce:	9d02      	ldr	r5, [sp, #8]
    77d0:	2480      	movs	r4, #128	; 0x80
    77d2:	0264      	lsls	r4, r4, #9
    77d4:	192d      	adds	r5, r5, r4
    77d6:	9502      	str	r5, [sp, #8]
    77d8:	0c1d      	lsrs	r5, r3, #16
    77da:	9503      	str	r5, [sp, #12]
    77dc:	4645      	mov	r5, r8
    77de:	042c      	lsls	r4, r5, #16
    77e0:	041b      	lsls	r3, r3, #16
    77e2:	0c24      	lsrs	r4, r4, #16
    77e4:	191c      	adds	r4, r3, r4
    77e6:	9405      	str	r4, [sp, #20]
    77e8:	465c      	mov	r4, fp
    77ea:	0c23      	lsrs	r3, r4, #16
    77ec:	1c05      	adds	r5, r0, #0
    77ee:	4358      	muls	r0, r3
    77f0:	0424      	lsls	r4, r4, #16
    77f2:	0c24      	lsrs	r4, r4, #16
    77f4:	4684      	mov	ip, r0
    77f6:	1c38      	adds	r0, r7, #0
    77f8:	4360      	muls	r0, r4
    77fa:	4365      	muls	r5, r4
    77fc:	435f      	muls	r7, r3
    77fe:	4681      	mov	r9, r0
    7800:	44cc      	add	ip, r9
    7802:	0c28      	lsrs	r0, r5, #16
    7804:	4460      	add	r0, ip
    7806:	46bb      	mov	fp, r7
    7808:	4581      	cmp	r9, r0
    780a:	d902      	bls.n	7812 <__aeabi_dmul+0x25e>
    780c:	2780      	movs	r7, #128	; 0x80
    780e:	027f      	lsls	r7, r7, #9
    7810:	44bb      	add	fp, r7
    7812:	042d      	lsls	r5, r5, #16
    7814:	0c07      	lsrs	r7, r0, #16
    7816:	0c2d      	lsrs	r5, r5, #16
    7818:	0400      	lsls	r0, r0, #16
    781a:	1940      	adds	r0, r0, r5
    781c:	4655      	mov	r5, sl
    781e:	46bc      	mov	ip, r7
    7820:	042f      	lsls	r7, r5, #16
    7822:	44e3      	add	fp, ip
    7824:	4684      	mov	ip, r0
    7826:	0c28      	lsrs	r0, r5, #16
    7828:	0c3d      	lsrs	r5, r7, #16
    782a:	1c2f      	adds	r7, r5, #0
    782c:	4357      	muls	r7, r2
    782e:	46b8      	mov	r8, r7
    7830:	1c2f      	adds	r7, r5, #0
    7832:	4377      	muls	r7, r6
    7834:	4342      	muls	r2, r0
    7836:	46b9      	mov	r9, r7
    7838:	4647      	mov	r7, r8
    783a:	0c3f      	lsrs	r7, r7, #16
    783c:	4491      	add	r9, r2
    783e:	46ba      	mov	sl, r7
    7840:	44d1      	add	r9, sl
    7842:	4346      	muls	r6, r0
    7844:	454a      	cmp	r2, r9
    7846:	d902      	bls.n	784e <__aeabi_dmul+0x29a>
    7848:	2280      	movs	r2, #128	; 0x80
    784a:	0252      	lsls	r2, r2, #9
    784c:	18b6      	adds	r6, r6, r2
    784e:	464f      	mov	r7, r9
    7850:	0c3a      	lsrs	r2, r7, #16
    7852:	18b6      	adds	r6, r6, r2
    7854:	043a      	lsls	r2, r7, #16
    7856:	4647      	mov	r7, r8
    7858:	043f      	lsls	r7, r7, #16
    785a:	0c3f      	lsrs	r7, r7, #16
    785c:	46b8      	mov	r8, r7
    785e:	1c2f      	adds	r7, r5, #0
    7860:	4367      	muls	r7, r4
    7862:	435d      	muls	r5, r3
    7864:	4344      	muls	r4, r0
    7866:	4358      	muls	r0, r3
    7868:	1965      	adds	r5, r4, r5
    786a:	9001      	str	r0, [sp, #4]
    786c:	0c38      	lsrs	r0, r7, #16
    786e:	182d      	adds	r5, r5, r0
    7870:	4442      	add	r2, r8
    7872:	46b8      	mov	r8, r7
    7874:	42ac      	cmp	r4, r5
    7876:	d904      	bls.n	7882 <__aeabi_dmul+0x2ce>
    7878:	9801      	ldr	r0, [sp, #4]
    787a:	2380      	movs	r3, #128	; 0x80
    787c:	025b      	lsls	r3, r3, #9
    787e:	18c0      	adds	r0, r0, r3
    7880:	9001      	str	r0, [sp, #4]
    7882:	9c03      	ldr	r4, [sp, #12]
    7884:	9f02      	ldr	r7, [sp, #8]
    7886:	1c20      	adds	r0, r4, #0
    7888:	4460      	add	r0, ip
    788a:	19c0      	adds	r0, r0, r7
    788c:	4560      	cmp	r0, ip
    788e:	41a4      	sbcs	r4, r4
    7890:	4647      	mov	r7, r8
    7892:	4264      	negs	r4, r4
    7894:	46a4      	mov	ip, r4
    7896:	042b      	lsls	r3, r5, #16
    7898:	043c      	lsls	r4, r7, #16
    789a:	4699      	mov	r9, r3
    789c:	0c24      	lsrs	r4, r4, #16
    789e:	444c      	add	r4, r9
    78a0:	46a0      	mov	r8, r4
    78a2:	44d8      	add	r8, fp
    78a4:	1880      	adds	r0, r0, r2
    78a6:	46c2      	mov	sl, r8
    78a8:	44e2      	add	sl, ip
    78aa:	4290      	cmp	r0, r2
    78ac:	4192      	sbcs	r2, r2
    78ae:	4657      	mov	r7, sl
    78b0:	4252      	negs	r2, r2
    78b2:	4691      	mov	r9, r2
    78b4:	19f2      	adds	r2, r6, r7
    78b6:	45e2      	cmp	sl, ip
    78b8:	41bf      	sbcs	r7, r7
    78ba:	427f      	negs	r7, r7
    78bc:	464b      	mov	r3, r9
    78be:	46bc      	mov	ip, r7
    78c0:	45d8      	cmp	r8, fp
    78c2:	41bf      	sbcs	r7, r7
    78c4:	18d4      	adds	r4, r2, r3
    78c6:	427f      	negs	r7, r7
    78c8:	4663      	mov	r3, ip
    78ca:	431f      	orrs	r7, r3
    78cc:	0c2d      	lsrs	r5, r5, #16
    78ce:	197f      	adds	r7, r7, r5
    78d0:	42b2      	cmp	r2, r6
    78d2:	4192      	sbcs	r2, r2
    78d4:	454c      	cmp	r4, r9
    78d6:	41ad      	sbcs	r5, r5
    78d8:	4252      	negs	r2, r2
    78da:	426d      	negs	r5, r5
    78dc:	4315      	orrs	r5, r2
    78de:	9e01      	ldr	r6, [sp, #4]
    78e0:	197d      	adds	r5, r7, r5
    78e2:	19ab      	adds	r3, r5, r6
    78e4:	0de2      	lsrs	r2, r4, #23
    78e6:	025b      	lsls	r3, r3, #9
    78e8:	9f05      	ldr	r7, [sp, #20]
    78ea:	4313      	orrs	r3, r2
    78ec:	0242      	lsls	r2, r0, #9
    78ee:	433a      	orrs	r2, r7
    78f0:	469a      	mov	sl, r3
    78f2:	1e53      	subs	r3, r2, #1
    78f4:	419a      	sbcs	r2, r3
    78f6:	0dc3      	lsrs	r3, r0, #23
    78f8:	1c10      	adds	r0, r2, #0
    78fa:	4318      	orrs	r0, r3
    78fc:	0264      	lsls	r4, r4, #9
    78fe:	4320      	orrs	r0, r4
    7900:	4680      	mov	r8, r0
    7902:	4650      	mov	r0, sl
    7904:	01c0      	lsls	r0, r0, #7
    7906:	d50d      	bpl.n	7924 <__aeabi_dmul+0x370>
    7908:	4645      	mov	r5, r8
    790a:	2201      	movs	r2, #1
    790c:	4656      	mov	r6, sl
    790e:	9c04      	ldr	r4, [sp, #16]
    7910:	086b      	lsrs	r3, r5, #1
    7912:	402a      	ands	r2, r5
    7914:	431a      	orrs	r2, r3
    7916:	07f3      	lsls	r3, r6, #31
    7918:	3401      	adds	r4, #1
    791a:	431a      	orrs	r2, r3
    791c:	0876      	lsrs	r6, r6, #1
    791e:	9404      	str	r4, [sp, #16]
    7920:	4690      	mov	r8, r2
    7922:	46b2      	mov	sl, r6
    7924:	9e04      	ldr	r6, [sp, #16]
    7926:	4f63      	ldr	r7, [pc, #396]	; (7ab4 <__aeabi_dmul+0x500>)
    7928:	19f3      	adds	r3, r6, r7
    792a:	2b00      	cmp	r3, #0
    792c:	dd61      	ble.n	79f2 <__aeabi_dmul+0x43e>
    792e:	4640      	mov	r0, r8
    7930:	0740      	lsls	r0, r0, #29
    7932:	d00b      	beq.n	794c <__aeabi_dmul+0x398>
    7934:	220f      	movs	r2, #15
    7936:	4644      	mov	r4, r8
    7938:	4022      	ands	r2, r4
    793a:	2a04      	cmp	r2, #4
    793c:	d006      	beq.n	794c <__aeabi_dmul+0x398>
    793e:	4642      	mov	r2, r8
    7940:	3204      	adds	r2, #4
    7942:	4542      	cmp	r2, r8
    7944:	4180      	sbcs	r0, r0
    7946:	4240      	negs	r0, r0
    7948:	4482      	add	sl, r0
    794a:	4690      	mov	r8, r2
    794c:	4655      	mov	r5, sl
    794e:	01ed      	lsls	r5, r5, #7
    7950:	d507      	bpl.n	7962 <__aeabi_dmul+0x3ae>
    7952:	4b59      	ldr	r3, [pc, #356]	; (7ab8 <__aeabi_dmul+0x504>)
    7954:	4656      	mov	r6, sl
    7956:	9f04      	ldr	r7, [sp, #16]
    7958:	2080      	movs	r0, #128	; 0x80
    795a:	401e      	ands	r6, r3
    795c:	00c0      	lsls	r0, r0, #3
    795e:	46b2      	mov	sl, r6
    7960:	183b      	adds	r3, r7, r0
    7962:	4a56      	ldr	r2, [pc, #344]	; (7abc <__aeabi_dmul+0x508>)
    7964:	4293      	cmp	r3, r2
    7966:	dd00      	ble.n	796a <__aeabi_dmul+0x3b6>
    7968:	e6ea      	b.n	7740 <__aeabi_dmul+0x18c>
    796a:	4644      	mov	r4, r8
    796c:	4655      	mov	r5, sl
    796e:	08e2      	lsrs	r2, r4, #3
    7970:	0768      	lsls	r0, r5, #29
    7972:	4310      	orrs	r0, r2
    7974:	2201      	movs	r2, #1
    7976:	026c      	lsls	r4, r5, #9
    7978:	055b      	lsls	r3, r3, #21
    797a:	400a      	ands	r2, r1
    797c:	4680      	mov	r8, r0
    797e:	0b24      	lsrs	r4, r4, #12
    7980:	0d5b      	lsrs	r3, r3, #21
    7982:	4691      	mov	r9, r2
    7984:	e67b      	b.n	767e <__aeabi_dmul+0xca>
    7986:	46da      	mov	sl, fp
    7988:	4690      	mov	r8, r2
    798a:	1c1d      	adds	r5, r3, #0
    798c:	e669      	b.n	7662 <__aeabi_dmul+0xae>
    798e:	2480      	movs	r4, #128	; 0x80
    7990:	0324      	lsls	r4, r4, #12
    7992:	4657      	mov	r7, sl
    7994:	4227      	tst	r7, r4
    7996:	d11c      	bne.n	79d2 <__aeabi_dmul+0x41e>
    7998:	433c      	orrs	r4, r7
    799a:	0324      	lsls	r4, r4, #12
    799c:	0b24      	lsrs	r4, r4, #12
    799e:	4b48      	ldr	r3, [pc, #288]	; (7ac0 <__aeabi_dmul+0x50c>)
    79a0:	e66d      	b.n	767e <__aeabi_dmul+0xca>
    79a2:	1c03      	adds	r3, r0, #0
    79a4:	3b28      	subs	r3, #40	; 0x28
    79a6:	1c31      	adds	r1, r6, #0
    79a8:	4099      	lsls	r1, r3
    79aa:	468b      	mov	fp, r1
    79ac:	2200      	movs	r2, #0
    79ae:	e6c3      	b.n	7738 <__aeabi_dmul+0x184>
    79b0:	1c30      	adds	r0, r6, #0
    79b2:	f000 fc73 	bl	829c <__clzsi2>
    79b6:	3020      	adds	r0, #32
    79b8:	e6ad      	b.n	7716 <__aeabi_dmul+0x162>
    79ba:	3b28      	subs	r3, #40	; 0x28
    79bc:	1c21      	adds	r1, r4, #0
    79be:	4099      	lsls	r1, r3
    79c0:	2200      	movs	r2, #0
    79c2:	468a      	mov	sl, r1
    79c4:	4690      	mov	r8, r2
    79c6:	e68e      	b.n	76e6 <__aeabi_dmul+0x132>
    79c8:	1c20      	adds	r0, r4, #0
    79ca:	f000 fc67 	bl	829c <__clzsi2>
    79ce:	3020      	adds	r0, #32
    79d0:	e678      	b.n	76c4 <__aeabi_dmul+0x110>
    79d2:	4658      	mov	r0, fp
    79d4:	4220      	tst	r0, r4
    79d6:	d107      	bne.n	79e8 <__aeabi_dmul+0x434>
    79d8:	4304      	orrs	r4, r0
    79da:	9903      	ldr	r1, [sp, #12]
    79dc:	0324      	lsls	r4, r4, #12
    79de:	0b24      	lsrs	r4, r4, #12
    79e0:	4689      	mov	r9, r1
    79e2:	4690      	mov	r8, r2
    79e4:	4b36      	ldr	r3, [pc, #216]	; (7ac0 <__aeabi_dmul+0x50c>)
    79e6:	e64a      	b.n	767e <__aeabi_dmul+0xca>
    79e8:	433c      	orrs	r4, r7
    79ea:	0324      	lsls	r4, r4, #12
    79ec:	0b24      	lsrs	r4, r4, #12
    79ee:	4b34      	ldr	r3, [pc, #208]	; (7ac0 <__aeabi_dmul+0x50c>)
    79f0:	e645      	b.n	767e <__aeabi_dmul+0xca>
    79f2:	4b34      	ldr	r3, [pc, #208]	; (7ac4 <__aeabi_dmul+0x510>)
    79f4:	9e04      	ldr	r6, [sp, #16]
    79f6:	1b9b      	subs	r3, r3, r6
    79f8:	2b38      	cmp	r3, #56	; 0x38
    79fa:	dd06      	ble.n	7a0a <__aeabi_dmul+0x456>
    79fc:	2301      	movs	r3, #1
    79fe:	400b      	ands	r3, r1
    7a00:	2400      	movs	r4, #0
    7a02:	4699      	mov	r9, r3
    7a04:	46a0      	mov	r8, r4
    7a06:	2300      	movs	r3, #0
    7a08:	e639      	b.n	767e <__aeabi_dmul+0xca>
    7a0a:	2b1f      	cmp	r3, #31
    7a0c:	dc25      	bgt.n	7a5a <__aeabi_dmul+0x4a6>
    7a0e:	9c04      	ldr	r4, [sp, #16]
    7a10:	4d2d      	ldr	r5, [pc, #180]	; (7ac8 <__aeabi_dmul+0x514>)
    7a12:	4646      	mov	r6, r8
    7a14:	1960      	adds	r0, r4, r5
    7a16:	4652      	mov	r2, sl
    7a18:	4644      	mov	r4, r8
    7a1a:	4086      	lsls	r6, r0
    7a1c:	40dc      	lsrs	r4, r3
    7a1e:	4082      	lsls	r2, r0
    7a20:	4657      	mov	r7, sl
    7a22:	1c30      	adds	r0, r6, #0
    7a24:	4322      	orrs	r2, r4
    7a26:	40df      	lsrs	r7, r3
    7a28:	1e44      	subs	r4, r0, #1
    7a2a:	41a0      	sbcs	r0, r4
    7a2c:	4302      	orrs	r2, r0
    7a2e:	1c3b      	adds	r3, r7, #0
    7a30:	0754      	lsls	r4, r2, #29
    7a32:	d009      	beq.n	7a48 <__aeabi_dmul+0x494>
    7a34:	200f      	movs	r0, #15
    7a36:	4010      	ands	r0, r2
    7a38:	2804      	cmp	r0, #4
    7a3a:	d005      	beq.n	7a48 <__aeabi_dmul+0x494>
    7a3c:	1d10      	adds	r0, r2, #4
    7a3e:	4290      	cmp	r0, r2
    7a40:	4192      	sbcs	r2, r2
    7a42:	4252      	negs	r2, r2
    7a44:	189b      	adds	r3, r3, r2
    7a46:	1c02      	adds	r2, r0, #0
    7a48:	021d      	lsls	r5, r3, #8
    7a4a:	d51a      	bpl.n	7a82 <__aeabi_dmul+0x4ce>
    7a4c:	2301      	movs	r3, #1
    7a4e:	400b      	ands	r3, r1
    7a50:	2400      	movs	r4, #0
    7a52:	4699      	mov	r9, r3
    7a54:	46a0      	mov	r8, r4
    7a56:	2301      	movs	r3, #1
    7a58:	e611      	b.n	767e <__aeabi_dmul+0xca>
    7a5a:	481c      	ldr	r0, [pc, #112]	; (7acc <__aeabi_dmul+0x518>)
    7a5c:	9c04      	ldr	r4, [sp, #16]
    7a5e:	4655      	mov	r5, sl
    7a60:	1b00      	subs	r0, r0, r4
    7a62:	40c5      	lsrs	r5, r0
    7a64:	1c28      	adds	r0, r5, #0
    7a66:	2b20      	cmp	r3, #32
    7a68:	d016      	beq.n	7a98 <__aeabi_dmul+0x4e4>
    7a6a:	4e19      	ldr	r6, [pc, #100]	; (7ad0 <__aeabi_dmul+0x51c>)
    7a6c:	4657      	mov	r7, sl
    7a6e:	19a2      	adds	r2, r4, r6
    7a70:	4097      	lsls	r7, r2
    7a72:	1c3a      	adds	r2, r7, #0
    7a74:	4643      	mov	r3, r8
    7a76:	431a      	orrs	r2, r3
    7a78:	1e53      	subs	r3, r2, #1
    7a7a:	419a      	sbcs	r2, r3
    7a7c:	4302      	orrs	r2, r0
    7a7e:	2300      	movs	r3, #0
    7a80:	e7d6      	b.n	7a30 <__aeabi_dmul+0x47c>
    7a82:	0758      	lsls	r0, r3, #29
    7a84:	025b      	lsls	r3, r3, #9
    7a86:	08d2      	lsrs	r2, r2, #3
    7a88:	0b1c      	lsrs	r4, r3, #12
    7a8a:	2301      	movs	r3, #1
    7a8c:	400b      	ands	r3, r1
    7a8e:	4310      	orrs	r0, r2
    7a90:	4699      	mov	r9, r3
    7a92:	4680      	mov	r8, r0
    7a94:	2300      	movs	r3, #0
    7a96:	e5f2      	b.n	767e <__aeabi_dmul+0xca>
    7a98:	2200      	movs	r2, #0
    7a9a:	e7eb      	b.n	7a74 <__aeabi_dmul+0x4c0>
    7a9c:	2480      	movs	r4, #128	; 0x80
    7a9e:	0324      	lsls	r4, r4, #12
    7aa0:	4650      	mov	r0, sl
    7aa2:	2301      	movs	r3, #1
    7aa4:	4304      	orrs	r4, r0
    7aa6:	4019      	ands	r1, r3
    7aa8:	0324      	lsls	r4, r4, #12
    7aaa:	0b24      	lsrs	r4, r4, #12
    7aac:	4689      	mov	r9, r1
    7aae:	4b04      	ldr	r3, [pc, #16]	; (7ac0 <__aeabi_dmul+0x50c>)
    7ab0:	e5e5      	b.n	767e <__aeabi_dmul+0xca>
    7ab2:	46c0      	nop			; (mov r8, r8)
    7ab4:	000003ff 	.word	0x000003ff
    7ab8:	feffffff 	.word	0xfeffffff
    7abc:	000007fe 	.word	0x000007fe
    7ac0:	000007ff 	.word	0x000007ff
    7ac4:	fffffc02 	.word	0xfffffc02
    7ac8:	0000041e 	.word	0x0000041e
    7acc:	fffffbe2 	.word	0xfffffbe2
    7ad0:	0000043e 	.word	0x0000043e

00007ad4 <__aeabi_dsub>:
    7ad4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7ad6:	465f      	mov	r7, fp
    7ad8:	4656      	mov	r6, sl
    7ada:	4644      	mov	r4, r8
    7adc:	464d      	mov	r5, r9
    7ade:	b4f0      	push	{r4, r5, r6, r7}
    7ae0:	030c      	lsls	r4, r1, #12
    7ae2:	004d      	lsls	r5, r1, #1
    7ae4:	0fcf      	lsrs	r7, r1, #31
    7ae6:	0a61      	lsrs	r1, r4, #9
    7ae8:	0f44      	lsrs	r4, r0, #29
    7aea:	4321      	orrs	r1, r4
    7aec:	00c4      	lsls	r4, r0, #3
    7aee:	0318      	lsls	r0, r3, #12
    7af0:	0fde      	lsrs	r6, r3, #31
    7af2:	4680      	mov	r8, r0
    7af4:	46b4      	mov	ip, r6
    7af6:	4646      	mov	r6, r8
    7af8:	0058      	lsls	r0, r3, #1
    7afa:	0a76      	lsrs	r6, r6, #9
    7afc:	0f53      	lsrs	r3, r2, #29
    7afe:	4333      	orrs	r3, r6
    7b00:	00d6      	lsls	r6, r2, #3
    7b02:	4ac9      	ldr	r2, [pc, #804]	; (7e28 <__aeabi_dsub+0x354>)
    7b04:	0d6d      	lsrs	r5, r5, #21
    7b06:	46ba      	mov	sl, r7
    7b08:	0d40      	lsrs	r0, r0, #21
    7b0a:	46b3      	mov	fp, r6
    7b0c:	4290      	cmp	r0, r2
    7b0e:	d100      	bne.n	7b12 <__aeabi_dsub+0x3e>
    7b10:	e0eb      	b.n	7cea <__aeabi_dsub+0x216>
    7b12:	4662      	mov	r2, ip
    7b14:	2601      	movs	r6, #1
    7b16:	4072      	eors	r2, r6
    7b18:	4694      	mov	ip, r2
    7b1a:	4567      	cmp	r7, ip
    7b1c:	d100      	bne.n	7b20 <__aeabi_dsub+0x4c>
    7b1e:	e0a1      	b.n	7c64 <__aeabi_dsub+0x190>
    7b20:	1a2f      	subs	r7, r5, r0
    7b22:	2f00      	cmp	r7, #0
    7b24:	dc00      	bgt.n	7b28 <__aeabi_dsub+0x54>
    7b26:	e108      	b.n	7d3a <__aeabi_dsub+0x266>
    7b28:	2800      	cmp	r0, #0
    7b2a:	d13b      	bne.n	7ba4 <__aeabi_dsub+0xd0>
    7b2c:	4658      	mov	r0, fp
    7b2e:	4318      	orrs	r0, r3
    7b30:	d000      	beq.n	7b34 <__aeabi_dsub+0x60>
    7b32:	e0e8      	b.n	7d06 <__aeabi_dsub+0x232>
    7b34:	0760      	lsls	r0, r4, #29
    7b36:	d009      	beq.n	7b4c <__aeabi_dsub+0x78>
    7b38:	230f      	movs	r3, #15
    7b3a:	4023      	ands	r3, r4
    7b3c:	2b04      	cmp	r3, #4
    7b3e:	d005      	beq.n	7b4c <__aeabi_dsub+0x78>
    7b40:	1d23      	adds	r3, r4, #4
    7b42:	42a3      	cmp	r3, r4
    7b44:	41a4      	sbcs	r4, r4
    7b46:	4264      	negs	r4, r4
    7b48:	1909      	adds	r1, r1, r4
    7b4a:	1c1c      	adds	r4, r3, #0
    7b4c:	020a      	lsls	r2, r1, #8
    7b4e:	d400      	bmi.n	7b52 <__aeabi_dsub+0x7e>
    7b50:	e079      	b.n	7c46 <__aeabi_dsub+0x172>
    7b52:	4bb5      	ldr	r3, [pc, #724]	; (7e28 <__aeabi_dsub+0x354>)
    7b54:	1c6a      	adds	r2, r5, #1
    7b56:	429a      	cmp	r2, r3
    7b58:	d100      	bne.n	7b5c <__aeabi_dsub+0x88>
    7b5a:	e109      	b.n	7d70 <__aeabi_dsub+0x29c>
    7b5c:	4bb3      	ldr	r3, [pc, #716]	; (7e2c <__aeabi_dsub+0x358>)
    7b5e:	08e4      	lsrs	r4, r4, #3
    7b60:	4019      	ands	r1, r3
    7b62:	0748      	lsls	r0, r1, #29
    7b64:	4304      	orrs	r4, r0
    7b66:	0249      	lsls	r1, r1, #9
    7b68:	0552      	lsls	r2, r2, #21
    7b6a:	2701      	movs	r7, #1
    7b6c:	4650      	mov	r0, sl
    7b6e:	0b0b      	lsrs	r3, r1, #12
    7b70:	0d52      	lsrs	r2, r2, #21
    7b72:	4007      	ands	r7, r0
    7b74:	2000      	movs	r0, #0
    7b76:	2100      	movs	r1, #0
    7b78:	031b      	lsls	r3, r3, #12
    7b7a:	1c20      	adds	r0, r4, #0
    7b7c:	0b1c      	lsrs	r4, r3, #12
    7b7e:	0d0b      	lsrs	r3, r1, #20
    7b80:	051b      	lsls	r3, r3, #20
    7b82:	4dab      	ldr	r5, [pc, #684]	; (7e30 <__aeabi_dsub+0x35c>)
    7b84:	4323      	orrs	r3, r4
    7b86:	0552      	lsls	r2, r2, #21
    7b88:	0852      	lsrs	r2, r2, #1
    7b8a:	401d      	ands	r5, r3
    7b8c:	4315      	orrs	r5, r2
    7b8e:	006d      	lsls	r5, r5, #1
    7b90:	086d      	lsrs	r5, r5, #1
    7b92:	07ff      	lsls	r7, r7, #31
    7b94:	1c29      	adds	r1, r5, #0
    7b96:	4339      	orrs	r1, r7
    7b98:	bc3c      	pop	{r2, r3, r4, r5}
    7b9a:	4690      	mov	r8, r2
    7b9c:	4699      	mov	r9, r3
    7b9e:	46a2      	mov	sl, r4
    7ba0:	46ab      	mov	fp, r5
    7ba2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7ba4:	48a0      	ldr	r0, [pc, #640]	; (7e28 <__aeabi_dsub+0x354>)
    7ba6:	4285      	cmp	r5, r0
    7ba8:	d0c4      	beq.n	7b34 <__aeabi_dsub+0x60>
    7baa:	2080      	movs	r0, #128	; 0x80
    7bac:	0400      	lsls	r0, r0, #16
    7bae:	4303      	orrs	r3, r0
    7bb0:	2f38      	cmp	r7, #56	; 0x38
    7bb2:	dd00      	ble.n	7bb6 <__aeabi_dsub+0xe2>
    7bb4:	e0f0      	b.n	7d98 <__aeabi_dsub+0x2c4>
    7bb6:	2f1f      	cmp	r7, #31
    7bb8:	dd00      	ble.n	7bbc <__aeabi_dsub+0xe8>
    7bba:	e124      	b.n	7e06 <__aeabi_dsub+0x332>
    7bbc:	2020      	movs	r0, #32
    7bbe:	1bc0      	subs	r0, r0, r7
    7bc0:	1c1a      	adds	r2, r3, #0
    7bc2:	465e      	mov	r6, fp
    7bc4:	4082      	lsls	r2, r0
    7bc6:	40fe      	lsrs	r6, r7
    7bc8:	4332      	orrs	r2, r6
    7bca:	4694      	mov	ip, r2
    7bcc:	465a      	mov	r2, fp
    7bce:	4082      	lsls	r2, r0
    7bd0:	1c10      	adds	r0, r2, #0
    7bd2:	1e42      	subs	r2, r0, #1
    7bd4:	4190      	sbcs	r0, r2
    7bd6:	40fb      	lsrs	r3, r7
    7bd8:	4662      	mov	r2, ip
    7bda:	4302      	orrs	r2, r0
    7bdc:	1c1f      	adds	r7, r3, #0
    7bde:	1aa2      	subs	r2, r4, r2
    7be0:	4294      	cmp	r4, r2
    7be2:	41a4      	sbcs	r4, r4
    7be4:	4264      	negs	r4, r4
    7be6:	1bc9      	subs	r1, r1, r7
    7be8:	1b09      	subs	r1, r1, r4
    7bea:	1c14      	adds	r4, r2, #0
    7bec:	020a      	lsls	r2, r1, #8
    7bee:	d5a1      	bpl.n	7b34 <__aeabi_dsub+0x60>
    7bf0:	0249      	lsls	r1, r1, #9
    7bf2:	0a4f      	lsrs	r7, r1, #9
    7bf4:	2f00      	cmp	r7, #0
    7bf6:	d100      	bne.n	7bfa <__aeabi_dsub+0x126>
    7bf8:	e0c9      	b.n	7d8e <__aeabi_dsub+0x2ba>
    7bfa:	1c38      	adds	r0, r7, #0
    7bfc:	f000 fb4e 	bl	829c <__clzsi2>
    7c00:	1c02      	adds	r2, r0, #0
    7c02:	3a08      	subs	r2, #8
    7c04:	2a1f      	cmp	r2, #31
    7c06:	dd00      	ble.n	7c0a <__aeabi_dsub+0x136>
    7c08:	e0bc      	b.n	7d84 <__aeabi_dsub+0x2b0>
    7c0a:	2128      	movs	r1, #40	; 0x28
    7c0c:	1c23      	adds	r3, r4, #0
    7c0e:	1a09      	subs	r1, r1, r0
    7c10:	4097      	lsls	r7, r2
    7c12:	40cb      	lsrs	r3, r1
    7c14:	431f      	orrs	r7, r3
    7c16:	4094      	lsls	r4, r2
    7c18:	4295      	cmp	r5, r2
    7c1a:	dd00      	ble.n	7c1e <__aeabi_dsub+0x14a>
    7c1c:	e0ae      	b.n	7d7c <__aeabi_dsub+0x2a8>
    7c1e:	1b55      	subs	r5, r2, r5
    7c20:	1c69      	adds	r1, r5, #1
    7c22:	291f      	cmp	r1, #31
    7c24:	dd00      	ble.n	7c28 <__aeabi_dsub+0x154>
    7c26:	e0dd      	b.n	7de4 <__aeabi_dsub+0x310>
    7c28:	221f      	movs	r2, #31
    7c2a:	1b55      	subs	r5, r2, r5
    7c2c:	1c3b      	adds	r3, r7, #0
    7c2e:	1c22      	adds	r2, r4, #0
    7c30:	40ab      	lsls	r3, r5
    7c32:	40ca      	lsrs	r2, r1
    7c34:	40ac      	lsls	r4, r5
    7c36:	1e65      	subs	r5, r4, #1
    7c38:	41ac      	sbcs	r4, r5
    7c3a:	4313      	orrs	r3, r2
    7c3c:	40cf      	lsrs	r7, r1
    7c3e:	431c      	orrs	r4, r3
    7c40:	1c39      	adds	r1, r7, #0
    7c42:	2500      	movs	r5, #0
    7c44:	e776      	b.n	7b34 <__aeabi_dsub+0x60>
    7c46:	0748      	lsls	r0, r1, #29
    7c48:	08e4      	lsrs	r4, r4, #3
    7c4a:	056a      	lsls	r2, r5, #21
    7c4c:	2701      	movs	r7, #1
    7c4e:	4656      	mov	r6, sl
    7c50:	08c9      	lsrs	r1, r1, #3
    7c52:	0d52      	lsrs	r2, r2, #21
    7c54:	4037      	ands	r7, r6
    7c56:	4304      	orrs	r4, r0
    7c58:	4b73      	ldr	r3, [pc, #460]	; (7e28 <__aeabi_dsub+0x354>)
    7c5a:	429d      	cmp	r5, r3
    7c5c:	d049      	beq.n	7cf2 <__aeabi_dsub+0x21e>
    7c5e:	0309      	lsls	r1, r1, #12
    7c60:	0b0b      	lsrs	r3, r1, #12
    7c62:	e787      	b.n	7b74 <__aeabi_dsub+0xa0>
    7c64:	1a2a      	subs	r2, r5, r0
    7c66:	4694      	mov	ip, r2
    7c68:	2a00      	cmp	r2, #0
    7c6a:	dc00      	bgt.n	7c6e <__aeabi_dsub+0x19a>
    7c6c:	e09b      	b.n	7da6 <__aeabi_dsub+0x2d2>
    7c6e:	2800      	cmp	r0, #0
    7c70:	d055      	beq.n	7d1e <__aeabi_dsub+0x24a>
    7c72:	486d      	ldr	r0, [pc, #436]	; (7e28 <__aeabi_dsub+0x354>)
    7c74:	4285      	cmp	r5, r0
    7c76:	d100      	bne.n	7c7a <__aeabi_dsub+0x1a6>
    7c78:	e75c      	b.n	7b34 <__aeabi_dsub+0x60>
    7c7a:	2080      	movs	r0, #128	; 0x80
    7c7c:	0400      	lsls	r0, r0, #16
    7c7e:	4303      	orrs	r3, r0
    7c80:	4660      	mov	r0, ip
    7c82:	2838      	cmp	r0, #56	; 0x38
    7c84:	dd00      	ble.n	7c88 <__aeabi_dsub+0x1b4>
    7c86:	e109      	b.n	7e9c <__aeabi_dsub+0x3c8>
    7c88:	281f      	cmp	r0, #31
    7c8a:	dd00      	ble.n	7c8e <__aeabi_dsub+0x1ba>
    7c8c:	e150      	b.n	7f30 <__aeabi_dsub+0x45c>
    7c8e:	4662      	mov	r2, ip
    7c90:	2020      	movs	r0, #32
    7c92:	1a80      	subs	r0, r0, r2
    7c94:	1c1e      	adds	r6, r3, #0
    7c96:	4086      	lsls	r6, r0
    7c98:	46b1      	mov	r9, r6
    7c9a:	465e      	mov	r6, fp
    7c9c:	40d6      	lsrs	r6, r2
    7c9e:	464a      	mov	r2, r9
    7ca0:	4332      	orrs	r2, r6
    7ca2:	465e      	mov	r6, fp
    7ca4:	4086      	lsls	r6, r0
    7ca6:	4690      	mov	r8, r2
    7ca8:	1c30      	adds	r0, r6, #0
    7caa:	1e42      	subs	r2, r0, #1
    7cac:	4190      	sbcs	r0, r2
    7cae:	4642      	mov	r2, r8
    7cb0:	4302      	orrs	r2, r0
    7cb2:	4660      	mov	r0, ip
    7cb4:	40c3      	lsrs	r3, r0
    7cb6:	1912      	adds	r2, r2, r4
    7cb8:	42a2      	cmp	r2, r4
    7cba:	41a4      	sbcs	r4, r4
    7cbc:	4264      	negs	r4, r4
    7cbe:	1859      	adds	r1, r3, r1
    7cc0:	1909      	adds	r1, r1, r4
    7cc2:	1c14      	adds	r4, r2, #0
    7cc4:	0208      	lsls	r0, r1, #8
    7cc6:	d400      	bmi.n	7cca <__aeabi_dsub+0x1f6>
    7cc8:	e734      	b.n	7b34 <__aeabi_dsub+0x60>
    7cca:	4b57      	ldr	r3, [pc, #348]	; (7e28 <__aeabi_dsub+0x354>)
    7ccc:	3501      	adds	r5, #1
    7cce:	429d      	cmp	r5, r3
    7cd0:	d100      	bne.n	7cd4 <__aeabi_dsub+0x200>
    7cd2:	e142      	b.n	7f5a <__aeabi_dsub+0x486>
    7cd4:	4b55      	ldr	r3, [pc, #340]	; (7e2c <__aeabi_dsub+0x358>)
    7cd6:	0860      	lsrs	r0, r4, #1
    7cd8:	4019      	ands	r1, r3
    7cda:	2301      	movs	r3, #1
    7cdc:	4023      	ands	r3, r4
    7cde:	1c1c      	adds	r4, r3, #0
    7ce0:	4304      	orrs	r4, r0
    7ce2:	07cb      	lsls	r3, r1, #31
    7ce4:	431c      	orrs	r4, r3
    7ce6:	0849      	lsrs	r1, r1, #1
    7ce8:	e724      	b.n	7b34 <__aeabi_dsub+0x60>
    7cea:	431e      	orrs	r6, r3
    7cec:	d000      	beq.n	7cf0 <__aeabi_dsub+0x21c>
    7cee:	e714      	b.n	7b1a <__aeabi_dsub+0x46>
    7cf0:	e70f      	b.n	7b12 <__aeabi_dsub+0x3e>
    7cf2:	1c0b      	adds	r3, r1, #0
    7cf4:	4323      	orrs	r3, r4
    7cf6:	d100      	bne.n	7cfa <__aeabi_dsub+0x226>
    7cf8:	e1cf      	b.n	809a <__aeabi_dsub+0x5c6>
    7cfa:	2380      	movs	r3, #128	; 0x80
    7cfc:	031b      	lsls	r3, r3, #12
    7cfe:	430b      	orrs	r3, r1
    7d00:	031b      	lsls	r3, r3, #12
    7d02:	0b1b      	lsrs	r3, r3, #12
    7d04:	e736      	b.n	7b74 <__aeabi_dsub+0xa0>
    7d06:	3f01      	subs	r7, #1
    7d08:	2f00      	cmp	r7, #0
    7d0a:	d166      	bne.n	7dda <__aeabi_dsub+0x306>
    7d0c:	465e      	mov	r6, fp
    7d0e:	1ba2      	subs	r2, r4, r6
    7d10:	4294      	cmp	r4, r2
    7d12:	41a4      	sbcs	r4, r4
    7d14:	4264      	negs	r4, r4
    7d16:	1ac9      	subs	r1, r1, r3
    7d18:	1b09      	subs	r1, r1, r4
    7d1a:	1c14      	adds	r4, r2, #0
    7d1c:	e766      	b.n	7bec <__aeabi_dsub+0x118>
    7d1e:	4658      	mov	r0, fp
    7d20:	4318      	orrs	r0, r3
    7d22:	d100      	bne.n	7d26 <__aeabi_dsub+0x252>
    7d24:	e706      	b.n	7b34 <__aeabi_dsub+0x60>
    7d26:	2601      	movs	r6, #1
    7d28:	4276      	negs	r6, r6
    7d2a:	44b4      	add	ip, r6
    7d2c:	4660      	mov	r0, ip
    7d2e:	2800      	cmp	r0, #0
    7d30:	d000      	beq.n	7d34 <__aeabi_dsub+0x260>
    7d32:	e0ca      	b.n	7eca <__aeabi_dsub+0x3f6>
    7d34:	465e      	mov	r6, fp
    7d36:	1932      	adds	r2, r6, r4
    7d38:	e7be      	b.n	7cb8 <__aeabi_dsub+0x1e4>
    7d3a:	2f00      	cmp	r7, #0
    7d3c:	d17a      	bne.n	7e34 <__aeabi_dsub+0x360>
    7d3e:	1c68      	adds	r0, r5, #1
    7d40:	0540      	lsls	r0, r0, #21
    7d42:	0d40      	lsrs	r0, r0, #21
    7d44:	2801      	cmp	r0, #1
    7d46:	dc00      	bgt.n	7d4a <__aeabi_dsub+0x276>
    7d48:	e0e3      	b.n	7f12 <__aeabi_dsub+0x43e>
    7d4a:	465a      	mov	r2, fp
    7d4c:	1aa2      	subs	r2, r4, r2
    7d4e:	4294      	cmp	r4, r2
    7d50:	41bf      	sbcs	r7, r7
    7d52:	1ac8      	subs	r0, r1, r3
    7d54:	427f      	negs	r7, r7
    7d56:	1bc7      	subs	r7, r0, r7
    7d58:	023e      	lsls	r6, r7, #8
    7d5a:	d400      	bmi.n	7d5e <__aeabi_dsub+0x28a>
    7d5c:	e092      	b.n	7e84 <__aeabi_dsub+0x3b0>
    7d5e:	4658      	mov	r0, fp
    7d60:	1b04      	subs	r4, r0, r4
    7d62:	45a3      	cmp	fp, r4
    7d64:	4192      	sbcs	r2, r2
    7d66:	1a59      	subs	r1, r3, r1
    7d68:	4252      	negs	r2, r2
    7d6a:	1a8f      	subs	r7, r1, r2
    7d6c:	46e2      	mov	sl, ip
    7d6e:	e741      	b.n	7bf4 <__aeabi_dsub+0x120>
    7d70:	4653      	mov	r3, sl
    7d72:	2701      	movs	r7, #1
    7d74:	401f      	ands	r7, r3
    7d76:	2400      	movs	r4, #0
    7d78:	2300      	movs	r3, #0
    7d7a:	e6fb      	b.n	7b74 <__aeabi_dsub+0xa0>
    7d7c:	492b      	ldr	r1, [pc, #172]	; (7e2c <__aeabi_dsub+0x358>)
    7d7e:	1aad      	subs	r5, r5, r2
    7d80:	4039      	ands	r1, r7
    7d82:	e6d7      	b.n	7b34 <__aeabi_dsub+0x60>
    7d84:	1c27      	adds	r7, r4, #0
    7d86:	3828      	subs	r0, #40	; 0x28
    7d88:	4087      	lsls	r7, r0
    7d8a:	2400      	movs	r4, #0
    7d8c:	e744      	b.n	7c18 <__aeabi_dsub+0x144>
    7d8e:	1c20      	adds	r0, r4, #0
    7d90:	f000 fa84 	bl	829c <__clzsi2>
    7d94:	3020      	adds	r0, #32
    7d96:	e733      	b.n	7c00 <__aeabi_dsub+0x12c>
    7d98:	465a      	mov	r2, fp
    7d9a:	431a      	orrs	r2, r3
    7d9c:	1e53      	subs	r3, r2, #1
    7d9e:	419a      	sbcs	r2, r3
    7da0:	b2d2      	uxtb	r2, r2
    7da2:	2700      	movs	r7, #0
    7da4:	e71b      	b.n	7bde <__aeabi_dsub+0x10a>
    7da6:	2a00      	cmp	r2, #0
    7da8:	d000      	beq.n	7dac <__aeabi_dsub+0x2d8>
    7daa:	e0e1      	b.n	7f70 <__aeabi_dsub+0x49c>
    7dac:	1c68      	adds	r0, r5, #1
    7dae:	0546      	lsls	r6, r0, #21
    7db0:	0d76      	lsrs	r6, r6, #21
    7db2:	2e01      	cmp	r6, #1
    7db4:	dc00      	bgt.n	7db8 <__aeabi_dsub+0x2e4>
    7db6:	e091      	b.n	7edc <__aeabi_dsub+0x408>
    7db8:	4d1b      	ldr	r5, [pc, #108]	; (7e28 <__aeabi_dsub+0x354>)
    7dba:	42a8      	cmp	r0, r5
    7dbc:	d100      	bne.n	7dc0 <__aeabi_dsub+0x2ec>
    7dbe:	e0f7      	b.n	7fb0 <__aeabi_dsub+0x4dc>
    7dc0:	465e      	mov	r6, fp
    7dc2:	1932      	adds	r2, r6, r4
    7dc4:	42a2      	cmp	r2, r4
    7dc6:	41a4      	sbcs	r4, r4
    7dc8:	4264      	negs	r4, r4
    7dca:	1859      	adds	r1, r3, r1
    7dcc:	1909      	adds	r1, r1, r4
    7dce:	07cc      	lsls	r4, r1, #31
    7dd0:	0852      	lsrs	r2, r2, #1
    7dd2:	4314      	orrs	r4, r2
    7dd4:	0849      	lsrs	r1, r1, #1
    7dd6:	1c05      	adds	r5, r0, #0
    7dd8:	e6ac      	b.n	7b34 <__aeabi_dsub+0x60>
    7dda:	4813      	ldr	r0, [pc, #76]	; (7e28 <__aeabi_dsub+0x354>)
    7ddc:	4285      	cmp	r5, r0
    7dde:	d000      	beq.n	7de2 <__aeabi_dsub+0x30e>
    7de0:	e6e6      	b.n	7bb0 <__aeabi_dsub+0xdc>
    7de2:	e6a7      	b.n	7b34 <__aeabi_dsub+0x60>
    7de4:	1c2b      	adds	r3, r5, #0
    7de6:	3b1f      	subs	r3, #31
    7de8:	1c3e      	adds	r6, r7, #0
    7dea:	40de      	lsrs	r6, r3
    7dec:	1c33      	adds	r3, r6, #0
    7dee:	2920      	cmp	r1, #32
    7df0:	d070      	beq.n	7ed4 <__aeabi_dsub+0x400>
    7df2:	223f      	movs	r2, #63	; 0x3f
    7df4:	1b55      	subs	r5, r2, r5
    7df6:	40af      	lsls	r7, r5
    7df8:	433c      	orrs	r4, r7
    7dfa:	1e60      	subs	r0, r4, #1
    7dfc:	4184      	sbcs	r4, r0
    7dfe:	431c      	orrs	r4, r3
    7e00:	2100      	movs	r1, #0
    7e02:	2500      	movs	r5, #0
    7e04:	e696      	b.n	7b34 <__aeabi_dsub+0x60>
    7e06:	1c38      	adds	r0, r7, #0
    7e08:	3820      	subs	r0, #32
    7e0a:	1c1e      	adds	r6, r3, #0
    7e0c:	40c6      	lsrs	r6, r0
    7e0e:	1c30      	adds	r0, r6, #0
    7e10:	2f20      	cmp	r7, #32
    7e12:	d061      	beq.n	7ed8 <__aeabi_dsub+0x404>
    7e14:	2240      	movs	r2, #64	; 0x40
    7e16:	1bd7      	subs	r7, r2, r7
    7e18:	40bb      	lsls	r3, r7
    7e1a:	465a      	mov	r2, fp
    7e1c:	431a      	orrs	r2, r3
    7e1e:	1e53      	subs	r3, r2, #1
    7e20:	419a      	sbcs	r2, r3
    7e22:	4302      	orrs	r2, r0
    7e24:	2700      	movs	r7, #0
    7e26:	e6da      	b.n	7bde <__aeabi_dsub+0x10a>
    7e28:	000007ff 	.word	0x000007ff
    7e2c:	ff7fffff 	.word	0xff7fffff
    7e30:	800fffff 	.word	0x800fffff
    7e34:	2d00      	cmp	r5, #0
    7e36:	d038      	beq.n	7eaa <__aeabi_dsub+0x3d6>
    7e38:	4db9      	ldr	r5, [pc, #740]	; (8120 <__aeabi_dsub+0x64c>)
    7e3a:	42a8      	cmp	r0, r5
    7e3c:	d100      	bne.n	7e40 <__aeabi_dsub+0x36c>
    7e3e:	e092      	b.n	7f66 <__aeabi_dsub+0x492>
    7e40:	2580      	movs	r5, #128	; 0x80
    7e42:	042d      	lsls	r5, r5, #16
    7e44:	427f      	negs	r7, r7
    7e46:	4329      	orrs	r1, r5
    7e48:	2f38      	cmp	r7, #56	; 0x38
    7e4a:	dd00      	ble.n	7e4e <__aeabi_dsub+0x37a>
    7e4c:	e0aa      	b.n	7fa4 <__aeabi_dsub+0x4d0>
    7e4e:	2f1f      	cmp	r7, #31
    7e50:	dd00      	ble.n	7e54 <__aeabi_dsub+0x380>
    7e52:	e12c      	b.n	80ae <__aeabi_dsub+0x5da>
    7e54:	2520      	movs	r5, #32
    7e56:	1bed      	subs	r5, r5, r7
    7e58:	1c0e      	adds	r6, r1, #0
    7e5a:	40ae      	lsls	r6, r5
    7e5c:	46b0      	mov	r8, r6
    7e5e:	1c26      	adds	r6, r4, #0
    7e60:	40fe      	lsrs	r6, r7
    7e62:	4642      	mov	r2, r8
    7e64:	40ac      	lsls	r4, r5
    7e66:	4316      	orrs	r6, r2
    7e68:	1e65      	subs	r5, r4, #1
    7e6a:	41ac      	sbcs	r4, r5
    7e6c:	4334      	orrs	r4, r6
    7e6e:	40f9      	lsrs	r1, r7
    7e70:	465a      	mov	r2, fp
    7e72:	1b14      	subs	r4, r2, r4
    7e74:	45a3      	cmp	fp, r4
    7e76:	4192      	sbcs	r2, r2
    7e78:	1a5b      	subs	r3, r3, r1
    7e7a:	4252      	negs	r2, r2
    7e7c:	1a99      	subs	r1, r3, r2
    7e7e:	1c05      	adds	r5, r0, #0
    7e80:	46e2      	mov	sl, ip
    7e82:	e6b3      	b.n	7bec <__aeabi_dsub+0x118>
    7e84:	1c13      	adds	r3, r2, #0
    7e86:	433b      	orrs	r3, r7
    7e88:	1c14      	adds	r4, r2, #0
    7e8a:	2b00      	cmp	r3, #0
    7e8c:	d000      	beq.n	7e90 <__aeabi_dsub+0x3bc>
    7e8e:	e6b1      	b.n	7bf4 <__aeabi_dsub+0x120>
    7e90:	2700      	movs	r7, #0
    7e92:	2200      	movs	r2, #0
    7e94:	2500      	movs	r5, #0
    7e96:	2100      	movs	r1, #0
    7e98:	2400      	movs	r4, #0
    7e9a:	e6dd      	b.n	7c58 <__aeabi_dsub+0x184>
    7e9c:	465a      	mov	r2, fp
    7e9e:	431a      	orrs	r2, r3
    7ea0:	1e53      	subs	r3, r2, #1
    7ea2:	419a      	sbcs	r2, r3
    7ea4:	b2d2      	uxtb	r2, r2
    7ea6:	2300      	movs	r3, #0
    7ea8:	e705      	b.n	7cb6 <__aeabi_dsub+0x1e2>
    7eaa:	1c0d      	adds	r5, r1, #0
    7eac:	4325      	orrs	r5, r4
    7eae:	d05a      	beq.n	7f66 <__aeabi_dsub+0x492>
    7eb0:	43ff      	mvns	r7, r7
    7eb2:	2f00      	cmp	r7, #0
    7eb4:	d153      	bne.n	7f5e <__aeabi_dsub+0x48a>
    7eb6:	465a      	mov	r2, fp
    7eb8:	1b14      	subs	r4, r2, r4
    7eba:	45a3      	cmp	fp, r4
    7ebc:	4192      	sbcs	r2, r2
    7ebe:	1a59      	subs	r1, r3, r1
    7ec0:	4252      	negs	r2, r2
    7ec2:	1a89      	subs	r1, r1, r2
    7ec4:	1c05      	adds	r5, r0, #0
    7ec6:	46e2      	mov	sl, ip
    7ec8:	e690      	b.n	7bec <__aeabi_dsub+0x118>
    7eca:	4895      	ldr	r0, [pc, #596]	; (8120 <__aeabi_dsub+0x64c>)
    7ecc:	4285      	cmp	r5, r0
    7ece:	d000      	beq.n	7ed2 <__aeabi_dsub+0x3fe>
    7ed0:	e6d6      	b.n	7c80 <__aeabi_dsub+0x1ac>
    7ed2:	e62f      	b.n	7b34 <__aeabi_dsub+0x60>
    7ed4:	2700      	movs	r7, #0
    7ed6:	e78f      	b.n	7df8 <__aeabi_dsub+0x324>
    7ed8:	2300      	movs	r3, #0
    7eda:	e79e      	b.n	7e1a <__aeabi_dsub+0x346>
    7edc:	1c08      	adds	r0, r1, #0
    7ede:	4320      	orrs	r0, r4
    7ee0:	2d00      	cmp	r5, #0
    7ee2:	d000      	beq.n	7ee6 <__aeabi_dsub+0x412>
    7ee4:	e0c3      	b.n	806e <__aeabi_dsub+0x59a>
    7ee6:	2800      	cmp	r0, #0
    7ee8:	d100      	bne.n	7eec <__aeabi_dsub+0x418>
    7eea:	e0f6      	b.n	80da <__aeabi_dsub+0x606>
    7eec:	4658      	mov	r0, fp
    7eee:	4318      	orrs	r0, r3
    7ef0:	d100      	bne.n	7ef4 <__aeabi_dsub+0x420>
    7ef2:	e61f      	b.n	7b34 <__aeabi_dsub+0x60>
    7ef4:	4658      	mov	r0, fp
    7ef6:	1902      	adds	r2, r0, r4
    7ef8:	42a2      	cmp	r2, r4
    7efa:	41a4      	sbcs	r4, r4
    7efc:	4264      	negs	r4, r4
    7efe:	1859      	adds	r1, r3, r1
    7f00:	1909      	adds	r1, r1, r4
    7f02:	1c14      	adds	r4, r2, #0
    7f04:	020a      	lsls	r2, r1, #8
    7f06:	d400      	bmi.n	7f0a <__aeabi_dsub+0x436>
    7f08:	e614      	b.n	7b34 <__aeabi_dsub+0x60>
    7f0a:	4b86      	ldr	r3, [pc, #536]	; (8124 <__aeabi_dsub+0x650>)
    7f0c:	2501      	movs	r5, #1
    7f0e:	4019      	ands	r1, r3
    7f10:	e610      	b.n	7b34 <__aeabi_dsub+0x60>
    7f12:	1c08      	adds	r0, r1, #0
    7f14:	4320      	orrs	r0, r4
    7f16:	2d00      	cmp	r5, #0
    7f18:	d13a      	bne.n	7f90 <__aeabi_dsub+0x4bc>
    7f1a:	2800      	cmp	r0, #0
    7f1c:	d000      	beq.n	7f20 <__aeabi_dsub+0x44c>
    7f1e:	e089      	b.n	8034 <__aeabi_dsub+0x560>
    7f20:	4659      	mov	r1, fp
    7f22:	4319      	orrs	r1, r3
    7f24:	d100      	bne.n	7f28 <__aeabi_dsub+0x454>
    7f26:	e0bf      	b.n	80a8 <__aeabi_dsub+0x5d4>
    7f28:	1c19      	adds	r1, r3, #0
    7f2a:	465c      	mov	r4, fp
    7f2c:	46e2      	mov	sl, ip
    7f2e:	e601      	b.n	7b34 <__aeabi_dsub+0x60>
    7f30:	4660      	mov	r0, ip
    7f32:	3820      	subs	r0, #32
    7f34:	1c1a      	adds	r2, r3, #0
    7f36:	40c2      	lsrs	r2, r0
    7f38:	4666      	mov	r6, ip
    7f3a:	1c10      	adds	r0, r2, #0
    7f3c:	2e20      	cmp	r6, #32
    7f3e:	d100      	bne.n	7f42 <__aeabi_dsub+0x46e>
    7f40:	e0b0      	b.n	80a4 <__aeabi_dsub+0x5d0>
    7f42:	2240      	movs	r2, #64	; 0x40
    7f44:	1b92      	subs	r2, r2, r6
    7f46:	4093      	lsls	r3, r2
    7f48:	465a      	mov	r2, fp
    7f4a:	431a      	orrs	r2, r3
    7f4c:	1e53      	subs	r3, r2, #1
    7f4e:	419a      	sbcs	r2, r3
    7f50:	4302      	orrs	r2, r0
    7f52:	2300      	movs	r3, #0
    7f54:	e6af      	b.n	7cb6 <__aeabi_dsub+0x1e2>
    7f56:	4d72      	ldr	r5, [pc, #456]	; (8120 <__aeabi_dsub+0x64c>)
    7f58:	2700      	movs	r7, #0
    7f5a:	1c2a      	adds	r2, r5, #0
    7f5c:	e79b      	b.n	7e96 <__aeabi_dsub+0x3c2>
    7f5e:	4d70      	ldr	r5, [pc, #448]	; (8120 <__aeabi_dsub+0x64c>)
    7f60:	42a8      	cmp	r0, r5
    7f62:	d000      	beq.n	7f66 <__aeabi_dsub+0x492>
    7f64:	e770      	b.n	7e48 <__aeabi_dsub+0x374>
    7f66:	1c19      	adds	r1, r3, #0
    7f68:	465c      	mov	r4, fp
    7f6a:	1c05      	adds	r5, r0, #0
    7f6c:	46e2      	mov	sl, ip
    7f6e:	e5e1      	b.n	7b34 <__aeabi_dsub+0x60>
    7f70:	2d00      	cmp	r5, #0
    7f72:	d120      	bne.n	7fb6 <__aeabi_dsub+0x4e2>
    7f74:	1c0d      	adds	r5, r1, #0
    7f76:	4325      	orrs	r5, r4
    7f78:	d075      	beq.n	8066 <__aeabi_dsub+0x592>
    7f7a:	43d5      	mvns	r5, r2
    7f7c:	2d00      	cmp	r5, #0
    7f7e:	d16f      	bne.n	8060 <__aeabi_dsub+0x58c>
    7f80:	445c      	add	r4, fp
    7f82:	455c      	cmp	r4, fp
    7f84:	4192      	sbcs	r2, r2
    7f86:	1859      	adds	r1, r3, r1
    7f88:	4252      	negs	r2, r2
    7f8a:	1889      	adds	r1, r1, r2
    7f8c:	1c05      	adds	r5, r0, #0
    7f8e:	e699      	b.n	7cc4 <__aeabi_dsub+0x1f0>
    7f90:	2800      	cmp	r0, #0
    7f92:	d135      	bne.n	8000 <__aeabi_dsub+0x52c>
    7f94:	4659      	mov	r1, fp
    7f96:	4319      	orrs	r1, r3
    7f98:	d0dd      	beq.n	7f56 <__aeabi_dsub+0x482>
    7f9a:	1c19      	adds	r1, r3, #0
    7f9c:	465c      	mov	r4, fp
    7f9e:	46e2      	mov	sl, ip
    7fa0:	4d5f      	ldr	r5, [pc, #380]	; (8120 <__aeabi_dsub+0x64c>)
    7fa2:	e5c7      	b.n	7b34 <__aeabi_dsub+0x60>
    7fa4:	430c      	orrs	r4, r1
    7fa6:	1e61      	subs	r1, r4, #1
    7fa8:	418c      	sbcs	r4, r1
    7faa:	b2e4      	uxtb	r4, r4
    7fac:	2100      	movs	r1, #0
    7fae:	e75f      	b.n	7e70 <__aeabi_dsub+0x39c>
    7fb0:	1c05      	adds	r5, r0, #0
    7fb2:	1c02      	adds	r2, r0, #0
    7fb4:	e76f      	b.n	7e96 <__aeabi_dsub+0x3c2>
    7fb6:	4d5a      	ldr	r5, [pc, #360]	; (8120 <__aeabi_dsub+0x64c>)
    7fb8:	42a8      	cmp	r0, r5
    7fba:	d054      	beq.n	8066 <__aeabi_dsub+0x592>
    7fbc:	4255      	negs	r5, r2
    7fbe:	2280      	movs	r2, #128	; 0x80
    7fc0:	0416      	lsls	r6, r2, #16
    7fc2:	4331      	orrs	r1, r6
    7fc4:	2d38      	cmp	r5, #56	; 0x38
    7fc6:	dd00      	ble.n	7fca <__aeabi_dsub+0x4f6>
    7fc8:	e081      	b.n	80ce <__aeabi_dsub+0x5fa>
    7fca:	2d1f      	cmp	r5, #31
    7fcc:	dd00      	ble.n	7fd0 <__aeabi_dsub+0x4fc>
    7fce:	e091      	b.n	80f4 <__aeabi_dsub+0x620>
    7fd0:	2220      	movs	r2, #32
    7fd2:	1b56      	subs	r6, r2, r5
    7fd4:	1c0a      	adds	r2, r1, #0
    7fd6:	46b4      	mov	ip, r6
    7fd8:	40b2      	lsls	r2, r6
    7fda:	1c26      	adds	r6, r4, #0
    7fdc:	40ee      	lsrs	r6, r5
    7fde:	4332      	orrs	r2, r6
    7fe0:	4690      	mov	r8, r2
    7fe2:	4662      	mov	r2, ip
    7fe4:	4094      	lsls	r4, r2
    7fe6:	1e66      	subs	r6, r4, #1
    7fe8:	41b4      	sbcs	r4, r6
    7fea:	4642      	mov	r2, r8
    7fec:	4314      	orrs	r4, r2
    7fee:	40e9      	lsrs	r1, r5
    7ff0:	445c      	add	r4, fp
    7ff2:	455c      	cmp	r4, fp
    7ff4:	4192      	sbcs	r2, r2
    7ff6:	18cb      	adds	r3, r1, r3
    7ff8:	4252      	negs	r2, r2
    7ffa:	1899      	adds	r1, r3, r2
    7ffc:	1c05      	adds	r5, r0, #0
    7ffe:	e661      	b.n	7cc4 <__aeabi_dsub+0x1f0>
    8000:	4658      	mov	r0, fp
    8002:	4318      	orrs	r0, r3
    8004:	d04c      	beq.n	80a0 <__aeabi_dsub+0x5cc>
    8006:	0748      	lsls	r0, r1, #29
    8008:	08e4      	lsrs	r4, r4, #3
    800a:	4304      	orrs	r4, r0
    800c:	2080      	movs	r0, #128	; 0x80
    800e:	08c9      	lsrs	r1, r1, #3
    8010:	0300      	lsls	r0, r0, #12
    8012:	4201      	tst	r1, r0
    8014:	d008      	beq.n	8028 <__aeabi_dsub+0x554>
    8016:	08dd      	lsrs	r5, r3, #3
    8018:	4205      	tst	r5, r0
    801a:	d105      	bne.n	8028 <__aeabi_dsub+0x554>
    801c:	4659      	mov	r1, fp
    801e:	08ca      	lsrs	r2, r1, #3
    8020:	075c      	lsls	r4, r3, #29
    8022:	4314      	orrs	r4, r2
    8024:	1c29      	adds	r1, r5, #0
    8026:	46e2      	mov	sl, ip
    8028:	0f63      	lsrs	r3, r4, #29
    802a:	00c9      	lsls	r1, r1, #3
    802c:	4319      	orrs	r1, r3
    802e:	00e4      	lsls	r4, r4, #3
    8030:	4d3b      	ldr	r5, [pc, #236]	; (8120 <__aeabi_dsub+0x64c>)
    8032:	e57f      	b.n	7b34 <__aeabi_dsub+0x60>
    8034:	4658      	mov	r0, fp
    8036:	4318      	orrs	r0, r3
    8038:	d100      	bne.n	803c <__aeabi_dsub+0x568>
    803a:	e57b      	b.n	7b34 <__aeabi_dsub+0x60>
    803c:	465e      	mov	r6, fp
    803e:	1ba7      	subs	r7, r4, r6
    8040:	42bc      	cmp	r4, r7
    8042:	4192      	sbcs	r2, r2
    8044:	1ac8      	subs	r0, r1, r3
    8046:	4252      	negs	r2, r2
    8048:	1a80      	subs	r0, r0, r2
    804a:	0206      	lsls	r6, r0, #8
    804c:	d54c      	bpl.n	80e8 <__aeabi_dsub+0x614>
    804e:	4658      	mov	r0, fp
    8050:	1b04      	subs	r4, r0, r4
    8052:	45a3      	cmp	fp, r4
    8054:	4192      	sbcs	r2, r2
    8056:	1a59      	subs	r1, r3, r1
    8058:	4252      	negs	r2, r2
    805a:	1a89      	subs	r1, r1, r2
    805c:	46e2      	mov	sl, ip
    805e:	e569      	b.n	7b34 <__aeabi_dsub+0x60>
    8060:	4a2f      	ldr	r2, [pc, #188]	; (8120 <__aeabi_dsub+0x64c>)
    8062:	4290      	cmp	r0, r2
    8064:	d1ae      	bne.n	7fc4 <__aeabi_dsub+0x4f0>
    8066:	1c19      	adds	r1, r3, #0
    8068:	465c      	mov	r4, fp
    806a:	1c05      	adds	r5, r0, #0
    806c:	e562      	b.n	7b34 <__aeabi_dsub+0x60>
    806e:	2800      	cmp	r0, #0
    8070:	d036      	beq.n	80e0 <__aeabi_dsub+0x60c>
    8072:	4658      	mov	r0, fp
    8074:	4318      	orrs	r0, r3
    8076:	d013      	beq.n	80a0 <__aeabi_dsub+0x5cc>
    8078:	2580      	movs	r5, #128	; 0x80
    807a:	0748      	lsls	r0, r1, #29
    807c:	08e4      	lsrs	r4, r4, #3
    807e:	08c9      	lsrs	r1, r1, #3
    8080:	032d      	lsls	r5, r5, #12
    8082:	4304      	orrs	r4, r0
    8084:	4229      	tst	r1, r5
    8086:	d0cf      	beq.n	8028 <__aeabi_dsub+0x554>
    8088:	08d8      	lsrs	r0, r3, #3
    808a:	4228      	tst	r0, r5
    808c:	d1cc      	bne.n	8028 <__aeabi_dsub+0x554>
    808e:	465d      	mov	r5, fp
    8090:	08ea      	lsrs	r2, r5, #3
    8092:	075c      	lsls	r4, r3, #29
    8094:	4314      	orrs	r4, r2
    8096:	1c01      	adds	r1, r0, #0
    8098:	e7c6      	b.n	8028 <__aeabi_dsub+0x554>
    809a:	2300      	movs	r3, #0
    809c:	2400      	movs	r4, #0
    809e:	e569      	b.n	7b74 <__aeabi_dsub+0xa0>
    80a0:	4d1f      	ldr	r5, [pc, #124]	; (8120 <__aeabi_dsub+0x64c>)
    80a2:	e547      	b.n	7b34 <__aeabi_dsub+0x60>
    80a4:	2300      	movs	r3, #0
    80a6:	e74f      	b.n	7f48 <__aeabi_dsub+0x474>
    80a8:	2700      	movs	r7, #0
    80aa:	2200      	movs	r2, #0
    80ac:	e6f3      	b.n	7e96 <__aeabi_dsub+0x3c2>
    80ae:	1c3d      	adds	r5, r7, #0
    80b0:	3d20      	subs	r5, #32
    80b2:	1c0e      	adds	r6, r1, #0
    80b4:	40ee      	lsrs	r6, r5
    80b6:	1c35      	adds	r5, r6, #0
    80b8:	2f20      	cmp	r7, #32
    80ba:	d02d      	beq.n	8118 <__aeabi_dsub+0x644>
    80bc:	2640      	movs	r6, #64	; 0x40
    80be:	1bf7      	subs	r7, r6, r7
    80c0:	40b9      	lsls	r1, r7
    80c2:	430c      	orrs	r4, r1
    80c4:	1e61      	subs	r1, r4, #1
    80c6:	418c      	sbcs	r4, r1
    80c8:	432c      	orrs	r4, r5
    80ca:	2100      	movs	r1, #0
    80cc:	e6d0      	b.n	7e70 <__aeabi_dsub+0x39c>
    80ce:	430c      	orrs	r4, r1
    80d0:	1e61      	subs	r1, r4, #1
    80d2:	418c      	sbcs	r4, r1
    80d4:	b2e4      	uxtb	r4, r4
    80d6:	2100      	movs	r1, #0
    80d8:	e78a      	b.n	7ff0 <__aeabi_dsub+0x51c>
    80da:	1c19      	adds	r1, r3, #0
    80dc:	465c      	mov	r4, fp
    80de:	e529      	b.n	7b34 <__aeabi_dsub+0x60>
    80e0:	1c19      	adds	r1, r3, #0
    80e2:	465c      	mov	r4, fp
    80e4:	4d0e      	ldr	r5, [pc, #56]	; (8120 <__aeabi_dsub+0x64c>)
    80e6:	e525      	b.n	7b34 <__aeabi_dsub+0x60>
    80e8:	1c03      	adds	r3, r0, #0
    80ea:	433b      	orrs	r3, r7
    80ec:	d0dc      	beq.n	80a8 <__aeabi_dsub+0x5d4>
    80ee:	1c01      	adds	r1, r0, #0
    80f0:	1c3c      	adds	r4, r7, #0
    80f2:	e51f      	b.n	7b34 <__aeabi_dsub+0x60>
    80f4:	2620      	movs	r6, #32
    80f6:	4276      	negs	r6, r6
    80f8:	1976      	adds	r6, r6, r5
    80fa:	1c0a      	adds	r2, r1, #0
    80fc:	40f2      	lsrs	r2, r6
    80fe:	4690      	mov	r8, r2
    8100:	2d20      	cmp	r5, #32
    8102:	d00b      	beq.n	811c <__aeabi_dsub+0x648>
    8104:	2640      	movs	r6, #64	; 0x40
    8106:	1b75      	subs	r5, r6, r5
    8108:	40a9      	lsls	r1, r5
    810a:	430c      	orrs	r4, r1
    810c:	1e61      	subs	r1, r4, #1
    810e:	418c      	sbcs	r4, r1
    8110:	4645      	mov	r5, r8
    8112:	432c      	orrs	r4, r5
    8114:	2100      	movs	r1, #0
    8116:	e76b      	b.n	7ff0 <__aeabi_dsub+0x51c>
    8118:	2100      	movs	r1, #0
    811a:	e7d2      	b.n	80c2 <__aeabi_dsub+0x5ee>
    811c:	2100      	movs	r1, #0
    811e:	e7f4      	b.n	810a <__aeabi_dsub+0x636>
    8120:	000007ff 	.word	0x000007ff
    8124:	ff7fffff 	.word	0xff7fffff

00008128 <__aeabi_d2iz>:
    8128:	b570      	push	{r4, r5, r6, lr}
    812a:	1c0b      	adds	r3, r1, #0
    812c:	4c12      	ldr	r4, [pc, #72]	; (8178 <__aeabi_d2iz+0x50>)
    812e:	0309      	lsls	r1, r1, #12
    8130:	0b0e      	lsrs	r6, r1, #12
    8132:	0059      	lsls	r1, r3, #1
    8134:	1c02      	adds	r2, r0, #0
    8136:	0d49      	lsrs	r1, r1, #21
    8138:	0fdd      	lsrs	r5, r3, #31
    813a:	2000      	movs	r0, #0
    813c:	42a1      	cmp	r1, r4
    813e:	dd11      	ble.n	8164 <__aeabi_d2iz+0x3c>
    8140:	480e      	ldr	r0, [pc, #56]	; (817c <__aeabi_d2iz+0x54>)
    8142:	4281      	cmp	r1, r0
    8144:	dc0f      	bgt.n	8166 <__aeabi_d2iz+0x3e>
    8146:	2080      	movs	r0, #128	; 0x80
    8148:	0340      	lsls	r0, r0, #13
    814a:	4306      	orrs	r6, r0
    814c:	480c      	ldr	r0, [pc, #48]	; (8180 <__aeabi_d2iz+0x58>)
    814e:	1a40      	subs	r0, r0, r1
    8150:	281f      	cmp	r0, #31
    8152:	dd0b      	ble.n	816c <__aeabi_d2iz+0x44>
    8154:	4a0b      	ldr	r2, [pc, #44]	; (8184 <__aeabi_d2iz+0x5c>)
    8156:	1a52      	subs	r2, r2, r1
    8158:	40d6      	lsrs	r6, r2
    815a:	1c32      	adds	r2, r6, #0
    815c:	4250      	negs	r0, r2
    815e:	2d00      	cmp	r5, #0
    8160:	d100      	bne.n	8164 <__aeabi_d2iz+0x3c>
    8162:	1c10      	adds	r0, r2, #0
    8164:	bd70      	pop	{r4, r5, r6, pc}
    8166:	4b08      	ldr	r3, [pc, #32]	; (8188 <__aeabi_d2iz+0x60>)
    8168:	18e8      	adds	r0, r5, r3
    816a:	e7fb      	b.n	8164 <__aeabi_d2iz+0x3c>
    816c:	4b07      	ldr	r3, [pc, #28]	; (818c <__aeabi_d2iz+0x64>)
    816e:	40c2      	lsrs	r2, r0
    8170:	18c9      	adds	r1, r1, r3
    8172:	408e      	lsls	r6, r1
    8174:	4332      	orrs	r2, r6
    8176:	e7f1      	b.n	815c <__aeabi_d2iz+0x34>
    8178:	000003fe 	.word	0x000003fe
    817c:	0000041d 	.word	0x0000041d
    8180:	00000433 	.word	0x00000433
    8184:	00000413 	.word	0x00000413
    8188:	7fffffff 	.word	0x7fffffff
    818c:	fffffbed 	.word	0xfffffbed

00008190 <__aeabi_ui2d>:
    8190:	b510      	push	{r4, lr}
    8192:	1e04      	subs	r4, r0, #0
    8194:	d028      	beq.n	81e8 <__aeabi_ui2d+0x58>
    8196:	f000 f881 	bl	829c <__clzsi2>
    819a:	4a15      	ldr	r2, [pc, #84]	; (81f0 <__aeabi_ui2d+0x60>)
    819c:	1a12      	subs	r2, r2, r0
    819e:	280a      	cmp	r0, #10
    81a0:	dd15      	ble.n	81ce <__aeabi_ui2d+0x3e>
    81a2:	380b      	subs	r0, #11
    81a4:	4084      	lsls	r4, r0
    81a6:	0324      	lsls	r4, r4, #12
    81a8:	0552      	lsls	r2, r2, #21
    81aa:	0b24      	lsrs	r4, r4, #12
    81ac:	0d52      	lsrs	r2, r2, #21
    81ae:	2300      	movs	r3, #0
    81b0:	2000      	movs	r0, #0
    81b2:	2100      	movs	r1, #0
    81b4:	0324      	lsls	r4, r4, #12
    81b6:	1c18      	adds	r0, r3, #0
    81b8:	0d0b      	lsrs	r3, r1, #20
    81ba:	0b24      	lsrs	r4, r4, #12
    81bc:	051b      	lsls	r3, r3, #20
    81be:	4323      	orrs	r3, r4
    81c0:	4c0c      	ldr	r4, [pc, #48]	; (81f4 <__aeabi_ui2d+0x64>)
    81c2:	0512      	lsls	r2, r2, #20
    81c4:	401c      	ands	r4, r3
    81c6:	4314      	orrs	r4, r2
    81c8:	0064      	lsls	r4, r4, #1
    81ca:	0861      	lsrs	r1, r4, #1
    81cc:	bd10      	pop	{r4, pc}
    81ce:	1c03      	adds	r3, r0, #0
    81d0:	3315      	adds	r3, #21
    81d2:	1c21      	adds	r1, r4, #0
    81d4:	4099      	lsls	r1, r3
    81d6:	1c0b      	adds	r3, r1, #0
    81d8:	210b      	movs	r1, #11
    81da:	1a08      	subs	r0, r1, r0
    81dc:	40c4      	lsrs	r4, r0
    81de:	0324      	lsls	r4, r4, #12
    81e0:	0552      	lsls	r2, r2, #21
    81e2:	0b24      	lsrs	r4, r4, #12
    81e4:	0d52      	lsrs	r2, r2, #21
    81e6:	e7e3      	b.n	81b0 <__aeabi_ui2d+0x20>
    81e8:	2200      	movs	r2, #0
    81ea:	2400      	movs	r4, #0
    81ec:	2300      	movs	r3, #0
    81ee:	e7df      	b.n	81b0 <__aeabi_ui2d+0x20>
    81f0:	0000041e 	.word	0x0000041e
    81f4:	800fffff 	.word	0x800fffff

000081f8 <__aeabi_f2d>:
    81f8:	0043      	lsls	r3, r0, #1
    81fa:	0e1b      	lsrs	r3, r3, #24
    81fc:	1c5a      	adds	r2, r3, #1
    81fe:	0241      	lsls	r1, r0, #9
    8200:	b2d2      	uxtb	r2, r2
    8202:	b570      	push	{r4, r5, r6, lr}
    8204:	0a4c      	lsrs	r4, r1, #9
    8206:	0fc5      	lsrs	r5, r0, #31
    8208:	2a01      	cmp	r2, #1
    820a:	dd17      	ble.n	823c <__aeabi_f2d+0x44>
    820c:	22e0      	movs	r2, #224	; 0xe0
    820e:	0092      	lsls	r2, r2, #2
    8210:	0764      	lsls	r4, r4, #29
    8212:	0b09      	lsrs	r1, r1, #12
    8214:	1898      	adds	r0, r3, r2
    8216:	2200      	movs	r2, #0
    8218:	2300      	movs	r3, #0
    821a:	0d1e      	lsrs	r6, r3, #20
    821c:	1c22      	adds	r2, r4, #0
    821e:	0534      	lsls	r4, r6, #20
    8220:	430c      	orrs	r4, r1
    8222:	491b      	ldr	r1, [pc, #108]	; (8290 <__aeabi_f2d+0x98>)
    8224:	0540      	lsls	r0, r0, #21
    8226:	0840      	lsrs	r0, r0, #1
    8228:	4021      	ands	r1, r4
    822a:	4301      	orrs	r1, r0
    822c:	0049      	lsls	r1, r1, #1
    822e:	0849      	lsrs	r1, r1, #1
    8230:	07ed      	lsls	r5, r5, #31
    8232:	1c0b      	adds	r3, r1, #0
    8234:	432b      	orrs	r3, r5
    8236:	1c10      	adds	r0, r2, #0
    8238:	1c19      	adds	r1, r3, #0
    823a:	bd70      	pop	{r4, r5, r6, pc}
    823c:	2b00      	cmp	r3, #0
    823e:	d115      	bne.n	826c <__aeabi_f2d+0x74>
    8240:	2c00      	cmp	r4, #0
    8242:	d01c      	beq.n	827e <__aeabi_f2d+0x86>
    8244:	1c20      	adds	r0, r4, #0
    8246:	f000 f829 	bl	829c <__clzsi2>
    824a:	280a      	cmp	r0, #10
    824c:	dc1a      	bgt.n	8284 <__aeabi_f2d+0x8c>
    824e:	210b      	movs	r1, #11
    8250:	1a09      	subs	r1, r1, r0
    8252:	1c23      	adds	r3, r4, #0
    8254:	40cb      	lsrs	r3, r1
    8256:	1c19      	adds	r1, r3, #0
    8258:	1c03      	adds	r3, r0, #0
    825a:	3315      	adds	r3, #21
    825c:	409c      	lsls	r4, r3
    825e:	4b0d      	ldr	r3, [pc, #52]	; (8294 <__aeabi_f2d+0x9c>)
    8260:	0309      	lsls	r1, r1, #12
    8262:	1a18      	subs	r0, r3, r0
    8264:	0540      	lsls	r0, r0, #21
    8266:	0b09      	lsrs	r1, r1, #12
    8268:	0d40      	lsrs	r0, r0, #21
    826a:	e7d4      	b.n	8216 <__aeabi_f2d+0x1e>
    826c:	2c00      	cmp	r4, #0
    826e:	d003      	beq.n	8278 <__aeabi_f2d+0x80>
    8270:	0764      	lsls	r4, r4, #29
    8272:	0b09      	lsrs	r1, r1, #12
    8274:	4808      	ldr	r0, [pc, #32]	; (8298 <__aeabi_f2d+0xa0>)
    8276:	e7ce      	b.n	8216 <__aeabi_f2d+0x1e>
    8278:	4807      	ldr	r0, [pc, #28]	; (8298 <__aeabi_f2d+0xa0>)
    827a:	2100      	movs	r1, #0
    827c:	e7cb      	b.n	8216 <__aeabi_f2d+0x1e>
    827e:	2000      	movs	r0, #0
    8280:	2100      	movs	r1, #0
    8282:	e7c8      	b.n	8216 <__aeabi_f2d+0x1e>
    8284:	1c01      	adds	r1, r0, #0
    8286:	390b      	subs	r1, #11
    8288:	408c      	lsls	r4, r1
    828a:	1c21      	adds	r1, r4, #0
    828c:	2400      	movs	r4, #0
    828e:	e7e6      	b.n	825e <__aeabi_f2d+0x66>
    8290:	800fffff 	.word	0x800fffff
    8294:	00000389 	.word	0x00000389
    8298:	000007ff 	.word	0x000007ff

0000829c <__clzsi2>:
    829c:	211c      	movs	r1, #28
    829e:	2301      	movs	r3, #1
    82a0:	041b      	lsls	r3, r3, #16
    82a2:	4298      	cmp	r0, r3
    82a4:	d301      	bcc.n	82aa <__clzsi2+0xe>
    82a6:	0c00      	lsrs	r0, r0, #16
    82a8:	3910      	subs	r1, #16
    82aa:	0a1b      	lsrs	r3, r3, #8
    82ac:	4298      	cmp	r0, r3
    82ae:	d301      	bcc.n	82b4 <__clzsi2+0x18>
    82b0:	0a00      	lsrs	r0, r0, #8
    82b2:	3908      	subs	r1, #8
    82b4:	091b      	lsrs	r3, r3, #4
    82b6:	4298      	cmp	r0, r3
    82b8:	d301      	bcc.n	82be <__clzsi2+0x22>
    82ba:	0900      	lsrs	r0, r0, #4
    82bc:	3904      	subs	r1, #4
    82be:	a202      	add	r2, pc, #8	; (adr r2, 82c8 <__clzsi2+0x2c>)
    82c0:	5c10      	ldrb	r0, [r2, r0]
    82c2:	1840      	adds	r0, r0, r1
    82c4:	4770      	bx	lr
    82c6:	46c0      	nop			; (mov r8, r8)
    82c8:	02020304 	.word	0x02020304
    82cc:	01010101 	.word	0x01010101
	...

000082d8 <__libc_init_array>:
    82d8:	b570      	push	{r4, r5, r6, lr}
    82da:	4b0e      	ldr	r3, [pc, #56]	; (8314 <__libc_init_array+0x3c>)
    82dc:	4d0e      	ldr	r5, [pc, #56]	; (8318 <__libc_init_array+0x40>)
    82de:	2400      	movs	r4, #0
    82e0:	1aed      	subs	r5, r5, r3
    82e2:	10ad      	asrs	r5, r5, #2
    82e4:	1c1e      	adds	r6, r3, #0
    82e6:	42ac      	cmp	r4, r5
    82e8:	d004      	beq.n	82f4 <__libc_init_array+0x1c>
    82ea:	00a3      	lsls	r3, r4, #2
    82ec:	58f3      	ldr	r3, [r6, r3]
    82ee:	4798      	blx	r3
    82f0:	3401      	adds	r4, #1
    82f2:	e7f8      	b.n	82e6 <__libc_init_array+0xe>
    82f4:	f000 f8ba 	bl	846c <_init>
    82f8:	4b08      	ldr	r3, [pc, #32]	; (831c <__libc_init_array+0x44>)
    82fa:	4d09      	ldr	r5, [pc, #36]	; (8320 <__libc_init_array+0x48>)
    82fc:	2400      	movs	r4, #0
    82fe:	1aed      	subs	r5, r5, r3
    8300:	10ad      	asrs	r5, r5, #2
    8302:	1c1e      	adds	r6, r3, #0
    8304:	42ac      	cmp	r4, r5
    8306:	d004      	beq.n	8312 <__libc_init_array+0x3a>
    8308:	00a3      	lsls	r3, r4, #2
    830a:	58f3      	ldr	r3, [r6, r3]
    830c:	4798      	blx	r3
    830e:	3401      	adds	r4, #1
    8310:	e7f8      	b.n	8304 <__libc_init_array+0x2c>
    8312:	bd70      	pop	{r4, r5, r6, pc}
    8314:	200000ec 	.word	0x200000ec
    8318:	200000ec 	.word	0x200000ec
    831c:	200000ec 	.word	0x200000ec
    8320:	20000108 	.word	0x20000108

00008324 <malloc>:
    8324:	b508      	push	{r3, lr}
    8326:	4b03      	ldr	r3, [pc, #12]	; (8334 <malloc+0x10>)
    8328:	1c01      	adds	r1, r0, #0
    832a:	6818      	ldr	r0, [r3, #0]
    832c:	f000 f816 	bl	835c <_malloc_r>
    8330:	bd08      	pop	{r3, pc}
    8332:	46c0      	nop			; (mov r8, r8)
    8334:	200000e8 	.word	0x200000e8

00008338 <memcpy>:
    8338:	b510      	push	{r4, lr}
    833a:	2300      	movs	r3, #0
    833c:	4293      	cmp	r3, r2
    833e:	d003      	beq.n	8348 <memcpy+0x10>
    8340:	5ccc      	ldrb	r4, [r1, r3]
    8342:	54c4      	strb	r4, [r0, r3]
    8344:	3301      	adds	r3, #1
    8346:	e7f9      	b.n	833c <memcpy+0x4>
    8348:	bd10      	pop	{r4, pc}

0000834a <memset>:
    834a:	1c03      	adds	r3, r0, #0
    834c:	1882      	adds	r2, r0, r2
    834e:	4293      	cmp	r3, r2
    8350:	d002      	beq.n	8358 <memset+0xe>
    8352:	7019      	strb	r1, [r3, #0]
    8354:	3301      	adds	r3, #1
    8356:	e7fa      	b.n	834e <memset+0x4>
    8358:	4770      	bx	lr
	...

0000835c <_malloc_r>:
    835c:	b570      	push	{r4, r5, r6, lr}
    835e:	2303      	movs	r3, #3
    8360:	1ccd      	adds	r5, r1, #3
    8362:	439d      	bics	r5, r3
    8364:	3508      	adds	r5, #8
    8366:	1c06      	adds	r6, r0, #0
    8368:	2d0c      	cmp	r5, #12
    836a:	d201      	bcs.n	8370 <_malloc_r+0x14>
    836c:	250c      	movs	r5, #12
    836e:	e001      	b.n	8374 <_malloc_r+0x18>
    8370:	2d00      	cmp	r5, #0
    8372:	db3f      	blt.n	83f4 <_malloc_r+0x98>
    8374:	428d      	cmp	r5, r1
    8376:	d33d      	bcc.n	83f4 <_malloc_r+0x98>
    8378:	4b20      	ldr	r3, [pc, #128]	; (83fc <_malloc_r+0xa0>)
    837a:	681c      	ldr	r4, [r3, #0]
    837c:	1c1a      	adds	r2, r3, #0
    837e:	1c21      	adds	r1, r4, #0
    8380:	2900      	cmp	r1, #0
    8382:	d013      	beq.n	83ac <_malloc_r+0x50>
    8384:	6808      	ldr	r0, [r1, #0]
    8386:	1b43      	subs	r3, r0, r5
    8388:	d40d      	bmi.n	83a6 <_malloc_r+0x4a>
    838a:	2b0b      	cmp	r3, #11
    838c:	d902      	bls.n	8394 <_malloc_r+0x38>
    838e:	600b      	str	r3, [r1, #0]
    8390:	18cc      	adds	r4, r1, r3
    8392:	e01e      	b.n	83d2 <_malloc_r+0x76>
    8394:	428c      	cmp	r4, r1
    8396:	d102      	bne.n	839e <_malloc_r+0x42>
    8398:	6863      	ldr	r3, [r4, #4]
    839a:	6013      	str	r3, [r2, #0]
    839c:	e01a      	b.n	83d4 <_malloc_r+0x78>
    839e:	6848      	ldr	r0, [r1, #4]
    83a0:	6060      	str	r0, [r4, #4]
    83a2:	1c0c      	adds	r4, r1, #0
    83a4:	e016      	b.n	83d4 <_malloc_r+0x78>
    83a6:	1c0c      	adds	r4, r1, #0
    83a8:	6849      	ldr	r1, [r1, #4]
    83aa:	e7e9      	b.n	8380 <_malloc_r+0x24>
    83ac:	4c14      	ldr	r4, [pc, #80]	; (8400 <_malloc_r+0xa4>)
    83ae:	6820      	ldr	r0, [r4, #0]
    83b0:	2800      	cmp	r0, #0
    83b2:	d103      	bne.n	83bc <_malloc_r+0x60>
    83b4:	1c30      	adds	r0, r6, #0
    83b6:	f000 f825 	bl	8404 <_sbrk_r>
    83ba:	6020      	str	r0, [r4, #0]
    83bc:	1c30      	adds	r0, r6, #0
    83be:	1c29      	adds	r1, r5, #0
    83c0:	f000 f820 	bl	8404 <_sbrk_r>
    83c4:	1c43      	adds	r3, r0, #1
    83c6:	d015      	beq.n	83f4 <_malloc_r+0x98>
    83c8:	1cc4      	adds	r4, r0, #3
    83ca:	2303      	movs	r3, #3
    83cc:	439c      	bics	r4, r3
    83ce:	4284      	cmp	r4, r0
    83d0:	d10a      	bne.n	83e8 <_malloc_r+0x8c>
    83d2:	6025      	str	r5, [r4, #0]
    83d4:	1c20      	adds	r0, r4, #0
    83d6:	300b      	adds	r0, #11
    83d8:	2207      	movs	r2, #7
    83da:	1d23      	adds	r3, r4, #4
    83dc:	4390      	bics	r0, r2
    83de:	1ac3      	subs	r3, r0, r3
    83e0:	d00b      	beq.n	83fa <_malloc_r+0x9e>
    83e2:	425a      	negs	r2, r3
    83e4:	50e2      	str	r2, [r4, r3]
    83e6:	e008      	b.n	83fa <_malloc_r+0x9e>
    83e8:	1a21      	subs	r1, r4, r0
    83ea:	1c30      	adds	r0, r6, #0
    83ec:	f000 f80a 	bl	8404 <_sbrk_r>
    83f0:	3001      	adds	r0, #1
    83f2:	d1ee      	bne.n	83d2 <_malloc_r+0x76>
    83f4:	230c      	movs	r3, #12
    83f6:	6033      	str	r3, [r6, #0]
    83f8:	2000      	movs	r0, #0
    83fa:	bd70      	pop	{r4, r5, r6, pc}
    83fc:	200008d4 	.word	0x200008d4
    8400:	200008d0 	.word	0x200008d0

00008404 <_sbrk_r>:
    8404:	b538      	push	{r3, r4, r5, lr}
    8406:	4c07      	ldr	r4, [pc, #28]	; (8424 <_sbrk_r+0x20>)
    8408:	2300      	movs	r3, #0
    840a:	1c05      	adds	r5, r0, #0
    840c:	1c08      	adds	r0, r1, #0
    840e:	6023      	str	r3, [r4, #0]
    8410:	f000 f812 	bl	8438 <_sbrk>
    8414:	1c43      	adds	r3, r0, #1
    8416:	d103      	bne.n	8420 <_sbrk_r+0x1c>
    8418:	6823      	ldr	r3, [r4, #0]
    841a:	2b00      	cmp	r3, #0
    841c:	d000      	beq.n	8420 <_sbrk_r+0x1c>
    841e:	602b      	str	r3, [r5, #0]
    8420:	bd38      	pop	{r3, r4, r5, pc}
    8422:	46c0      	nop			; (mov r8, r8)
    8424:	200008dc 	.word	0x200008dc

00008428 <strlen>:
    8428:	2300      	movs	r3, #0
    842a:	5cc2      	ldrb	r2, [r0, r3]
    842c:	3301      	adds	r3, #1
    842e:	2a00      	cmp	r2, #0
    8430:	d1fb      	bne.n	842a <strlen+0x2>
    8432:	1e58      	subs	r0, r3, #1
    8434:	4770      	bx	lr
	...

00008438 <_sbrk>:
    8438:	4a09      	ldr	r2, [pc, #36]	; (8460 <_sbrk+0x28>)
    843a:	6813      	ldr	r3, [r2, #0]
    843c:	2b00      	cmp	r3, #0
    843e:	d00c      	beq.n	845a <_sbrk+0x22>
    8440:	1818      	adds	r0, r3, r0
    8442:	4669      	mov	r1, sp
    8444:	4288      	cmp	r0, r1
    8446:	d802      	bhi.n	844e <_sbrk+0x16>
    8448:	6010      	str	r0, [r2, #0]
    844a:	1c18      	adds	r0, r3, #0
    844c:	4770      	bx	lr
    844e:	4b05      	ldr	r3, [pc, #20]	; (8464 <_sbrk+0x2c>)
    8450:	220c      	movs	r2, #12
    8452:	2001      	movs	r0, #1
    8454:	601a      	str	r2, [r3, #0]
    8456:	4240      	negs	r0, r0
    8458:	e7f8      	b.n	844c <_sbrk+0x14>
    845a:	4b03      	ldr	r3, [pc, #12]	; (8468 <_sbrk+0x30>)
    845c:	6013      	str	r3, [r2, #0]
    845e:	e7ef      	b.n	8440 <_sbrk+0x8>
    8460:	200008d8 	.word	0x200008d8
    8464:	200008dc 	.word	0x200008dc
    8468:	200008e0 	.word	0x200008e0

0000846c <_init>:
    846c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    846e:	46c0      	nop			; (mov r8, r8)
    8470:	bcf8      	pop	{r3, r4, r5, r6, r7}
    8472:	bc08      	pop	{r3}
    8474:	469e      	mov	lr, r3
    8476:	4770      	bx	lr

00008478 <_fini>:
    8478:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    847a:	46c0      	nop			; (mov r8, r8)
    847c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    847e:	bc08      	pop	{r3}
    8480:	469e      	mov	lr, r3
    8482:	4770      	bx	lr
    8484:	6c6c6548 	.word	0x6c6c6548
    8488:	6f57206f 	.word	0x6f57206f
    848c:	21646c72 	.word	0x21646c72
    8490:	61572000 	.word	0x61572000
    8494:	7020746e 	.word	0x7020746e
    8498:	20003f69 	.word	0x20003f69
    849c:	6e697250 	.word	0x6e697250
    84a0:	45482074 	.word	0x45482074
    84a4:	53002158 	.word	0x53002158
    84a8:	6374656b 	.word	0x6374656b
    84ac:	61682068 	.word	0x61682068
    84b0:	65622073 	.word	0x65622073
    84b4:	72006e65 	.word	0x72006e65
    84b8:	696e6e75 	.word	0x696e6e75
    84bc:	6620676e 	.word	0x6620676e
    84c0:	203a726f 	.word	0x203a726f
    84c4:	65732000 	.word	0x65732000
    84c8:	646e6f63 	.word	0x646e6f63
    84cc:	48002e73 	.word	0x48002e73
    84d0:	6f6c6c65 	.word	0x6f6c6c65
    84d4:	54532021 	.word	0x54532021
    84d8:	35333737 	.word	0x35333737
    84dc:	54465420 	.word	0x54465420
    84e0:	73655420 	.word	0x73655420
    84e4:	6e490074 	.word	0x6e490074
    84e8:	61697469 	.word	0x61697469
    84ec:	657a696c 	.word	0x657a696c
    84f0:	6f4c0064 	.word	0x6f4c0064
    84f4:	206d6572 	.word	0x206d6572
    84f8:	75737069 	.word	0x75737069
    84fc:	6f64206d 	.word	0x6f64206d
    8500:	20726f6c 	.word	0x20726f6c
    8504:	20746973 	.word	0x20746973
    8508:	74656d61 	.word	0x74656d61
    850c:	6f63202c 	.word	0x6f63202c
    8510:	6365736e 	.word	0x6365736e
    8514:	75746574 	.word	0x75746574
    8518:	64612072 	.word	0x64612072
    851c:	73697069 	.word	0x73697069
    8520:	676e6963 	.word	0x676e6963
    8524:	696c6520 	.word	0x696c6520
    8528:	43202e74 	.word	0x43202e74
    852c:	62617275 	.word	0x62617275
    8530:	72757469 	.word	0x72757469
    8534:	69646120 	.word	0x69646120
    8538:	63736970 	.word	0x63736970
    853c:	20676e69 	.word	0x20676e69
    8540:	65746e61 	.word	0x65746e61
    8544:	64657320 	.word	0x64657320
    8548:	62696e20 	.word	0x62696e20
    854c:	69742068 	.word	0x69742068
    8550:	6469636e 	.word	0x6469636e
    8554:	20746e75 	.word	0x20746e75
    8558:	67756566 	.word	0x67756566
    855c:	2e746169 	.word	0x2e746169
    8560:	65614d20 	.word	0x65614d20
    8564:	616e6563 	.word	0x616e6563
    8568:	6e652073 	.word	0x6e652073
    856c:	6d206d69 	.word	0x6d206d69
    8570:	61737361 	.word	0x61737361
    8574:	7266202c 	.word	0x7266202c
    8578:	69676e69 	.word	0x69676e69
    857c:	20616c6c 	.word	0x20616c6c
    8580:	20646573 	.word	0x20646573
    8584:	656c616d 	.word	0x656c616d
    8588:	64617573 	.word	0x64617573
    858c:	74652061 	.word	0x74652061
    8590:	616d202c 	.word	0x616d202c
    8594:	7573656c 	.word	0x7573656c
    8598:	20616461 	.word	0x20616461
    859c:	20746973 	.word	0x20746973
    85a0:	74656d61 	.word	0x74656d61
    85a4:	72757420 	.word	0x72757420
    85a8:	2e736970 	.word	0x2e736970
    85ac:	64655320 	.word	0x64655320
    85b0:	726f7020 	.word	0x726f7020
    85b4:	74697474 	.word	0x74697474
    85b8:	6e20726f 	.word	0x6e20726f
    85bc:	65757165 	.word	0x65757165
    85c0:	20747520 	.word	0x20747520
    85c4:	65746e61 	.word	0x65746e61
    85c8:	65727020 	.word	0x65727020
    85cc:	6d756974 	.word	0x6d756974
    85d0:	74697620 	.word	0x74697620
    85d4:	6d206561 	.word	0x6d206561
    85d8:	73656c61 	.word	0x73656c61
    85dc:	61646175 	.word	0x61646175
    85e0:	6e756e20 	.word	0x6e756e20
    85e4:	69622063 	.word	0x69622063
    85e8:	646e6562 	.word	0x646e6562
    85ec:	202e6d75 	.word	0x202e6d75
    85f0:	6c6c754e 	.word	0x6c6c754e
    85f4:	61206d61 	.word	0x61206d61
    85f8:	7571696c 	.word	0x7571696c
    85fc:	75207465 	.word	0x75207465
    8600:	6972746c 	.word	0x6972746c
    8604:	20736563 	.word	0x20736563
    8608:	7373616d 	.word	0x7373616d
    860c:	75652061 	.word	0x75652061
    8610:	6e656820 	.word	0x6e656820
    8614:	72657264 	.word	0x72657264
    8618:	202e7469 	.word	0x202e7469
    861c:	73207455 	.word	0x73207455
    8620:	6e206465 	.word	0x6e206465
    8624:	20697369 	.word	0x20697369
    8628:	65726f6c 	.word	0x65726f6c
    862c:	49202e6d 	.word	0x49202e6d
    8630:	6576206e 	.word	0x6576206e
    8634:	62697473 	.word	0x62697473
    8638:	6d756c75 	.word	0x6d756c75
    863c:	72757020 	.word	0x72757020
    8640:	61207375 	.word	0x61207375
    8644:	726f7420 	.word	0x726f7420
    8648:	20726f74 	.word	0x20726f74
    864c:	65706d69 	.word	0x65706d69
    8650:	65696472 	.word	0x65696472
    8654:	6f702074 	.word	0x6f702074
    8658:	72657573 	.word	0x72657573
    865c:	00202e65 	.word	0x00202e65
    8660:	656e6f64 	.word	0x656e6f64
    8664:	00000000 	.word	0x00000000

00008668 <_ZTV12Adafruit_GFX>:
	...
    8670:	00003915 000048fd 00002a4d 00002a51     .9...H..M*..Q*..
    8680:	00005181 00002b29 00002b2b 00002b55     .Q..)+..++..U+..
    8690:	00002b35 00002b45 00002a55 00002b6d     5+..E+..U*..m+..
    86a0:	00002d5b 00002d59 00002b6f 00002bad     [-..Y-..o+...+..
    86b0:	00002be9 00002c37 00002c51 00002cd5     .+..7,..Q,...,..

000086c0 <_ZL4font>:
    86c0:	00000000 4f5b3e00 6b3e3e5b 1c3e6b4f     .....>[O[>>kOk>.
    86d0:	1c3e7c3e 3c7e3c18 7d571c18 5e1c1c57     >|>..<~<..W}W..^
    86e0:	001c5e7f 00183c18 e7c3e7ff 241800ff     .^...<.........$
    86f0:	e7ff0018 30ffe7db 0e063a48 29792926     .......0H:..&)y)
    8700:	057f4026 7f400705 5a3f2505 5a3ce73c     &@....@..%?Z<.<Z
    8710:	1c1c3e7f 1c1c0808 22147f3e 5f14227f     .>......>.."."._
    8720:	5f5f005f 017f0906 8966007f 60606a95     _.__......f..j``
    8730:	94606060 94a2ffa2 047e0408 7e201008     ```.......~... ~
    8740:	08081020 08081c2a 08082a1c 1010101e      ...*....*......
    8750:	0c1e0c10 38300c1e 0630383e 060e3e0e     ......08>80..>..
    8760:	00000000 5f000000 07000000 14000700     ......._........
    8770:	147f147f 2a7f2a24 08132312 49366264     ....$*.*.#..db6I
    8780:	00502056 00030708 41221c00 22410000     V P......."A..A"
    8790:	1c2a001c 082a1c7f 08083e08 30708000     ..*...*..>....p0
    87a0:	08080800 00000808 20006060 02040810     ........``. ....
    87b0:	4549513e 7f42003e 49720040 21464949     >QIE>.B.@.rIIIF!
    87c0:	334d4941 7f121418 45452710 4a3c3945     AIM3.....'EEE9<J
    87d0:	41314949 07091121 49494936 49494636     II1A!...6III6FII
    87e0:	00001e29 00000014 00003440 22140800     ).......@4....."
    87f0:	14141441 41001414 02081422 06095901     A......A"....Y..
    8800:	595d413e 11127c4e 497f7c12 3e364949     >A]YN|...|.III6>
    8810:	22414141 4141417f 49497f3e 097f4149     AAA".AAA>.IIIA..
    8820:	3e010909 73514141 0808087f 7f41007f     ...>AAQs......A.
    8830:	40200041 7f013f41 41221408 4040407f     A. @A?...."A.@@@
    8840:	1c027f40 047f7f02 3e7f1008 3e414141     @..........>AAA>
    8850:	0909097f 51413e06 097f5e21 26462919     .....>AQ!^...)F&
    8860:	32494949 017f0103 40403f03 201f3f40     III2.....?@@@?. 
    8870:	3f1f2040 3f403840 14081463 78040363     @ .?@8@?c...c..x
    8880:	59610304 00434d49 4141417f 10080402     ..aYIMC..AAA....
    8890:	41410020 02047f41 40040201 40404040      .AAA......@@@@@
    88a0:	08070300 54542000 287f4078 38384444     ..... TTx@.(DD88
    88b0:	28444444 28444438 5454387f 08001854     DDD(8DD(.8TTT...
    88c0:	1802097e 789ca4a4 0404087f 7d440078     ~......x....x.D}
    88d0:	40200040 7f003d40 00442810 407f4100     @. @@=...(D..A.@
    88e0:	78047c00 087c7804 38780404 38444444     .|.x.x|...x8DDD8
    88f0:	242418fc 24241818 087cfc18 48080404     ..$$..$$..|....H
    8900:	24545454 443f0404 40403c24 201c7c20     TTT$..?D$<@@ |. 
    8910:	3c1c2040 3c403040 28102844 90904c44     @ .<@0@<D(.(DL..
    8920:	64447c90 00444c54 00413608 00770000     .|DdTLD..6A...w.
    8930:	36410000 01020008 3c020402 3c262326     ..A6.......<&#&<
    8940:	61a1a11e 40403a12 54387a20 21595554     ...a.:@@ z8TTUY!
    8950:	41795555 78545422 54552142 54204078     UUyA"TTxB!UTx@ T
    8960:	0c407955 1272521e 55555539 54543959     Uy@..Rr.9UUUY9TT
    8970:	55395954 00585454 417c4500 7d450200     TY9UTTX..E|A..E}
    8980:	45010042 127d407c f07d1211 f0282528     B..E|@}...}.(%(.
    8990:	4555547c 54542000 0a7c547c 32497f09     |TUE. TT|T|...I2
    89a0:	32494949 4444443a 484a323a 413a3048     III2:DDD:2JHH0:A
    89b0:	3a7a2141 78204042 a0a09d00 42423d7d     A!z:B@ x....}=BB
    89c0:	403d3d42 3c3d4040 2424ff24 43497e48     B==@@@=<$.$$H~IC
    89d0:	fc2f2b66 09ff2b2f c020f629 03097e88     f+/./+..). ..~..
    89e0:	79545420 44000041 4830417d 38324a48      TTyA..D}A0HHJ28
    89f0:	7a224040 0a0a7a00 190d7d72 29267d31     @@"z.z..r}..1}&)
    8a00:	26282f29 26292929 404d4830 08083820     )/(&)))&0HM@ 8..
    8a10:	08080808 2f380808 baacc810 3428102f     ......8/..../.(4
    8a20:	7b0000fa 14080000 2222142a 08142a14     ...{....*."".*..
    8a30:	00550055 aa55aa55 55ffaa55 00ff55ff     U.U.U.U.U..U.U..
    8a40:	00ff0000 ff101010 14141400 101000ff     ................
    8a50:	10ff00ff f010f010 fc141414 f7141400     ................
    8a60:	0000ff00 14ff00ff fc04f414 10171414     ................
    8a70:	1f10101f 14141f10 10001f14 00f01010     ................
    8a80:	1f000000 10101010 1010101f 0010f010     ................
    8a90:	10ff0000 10101010 10101010 000010ff     ................
    8aa0:	0014ff00 ff00ff00 101f0000 fc000017     ................
    8ab0:	1414f404 14171017 f404f414 00ff0000     ................
    8ac0:	141414f7 14141414 14f700f7 14171414     ................
    8ad0:	101f1010 1414141f 101014f4 00f010f0     ................
    8ae0:	1f101f00 1f000000 00000014 000014fc     ................
    8af0:	10f010f0 ff10ff10 ff141414 10101014     ................
    8b00:	0000001f ff10f000 ffffffff f0f0f0f0     ................
    8b10:	fffffff0 00000000 0fffff00 0f0f0f0f     ................
    8b20:	38444438 4a4afc44 027e344a 02060602     8DD8D.JJJ4~.....
    8b30:	027e027e 41495563 44443863 7e40043c     ~.~.cUIAc8DD<.@~
    8b40:	06201e20 02027e02 a5e7a599 492a1c99      . ..~........*I
    8b50:	724c1c2a 304c7201 304d4d4a 48784830     *.Lr.rL0JMM00HxH
    8b60:	5a62bc30 493e3d46 7e004949 7e010101     0.bZF=>III.~...~
    8b70:	2a2a2a2a 5f44442a 51404444 4040444a     *****DD_DD@QJD@@
    8b80:	40514a44 01ff0000 ff80e003 08080000     DJQ@............
    8b90:	36086b6b 36243612 0f090f06 18000006     kk.6.6$6........
    8ba0:	00000018 30001010 0101ff40 01011f00     .......0@.......
    8bb0:	1d19001e 3c001217 003c3c3c 00000000     .......<<<<.....

00008bc0 <_ZL13Rcmd2green144>:
    8bc0:	00042a02 2b7f0000 00000004 0000007f     .*.....+........

00008bd0 <_ZTV15Adafruit_ST7735>:
	...
    8bd8:	00003915 000048fd 00002a4d 00002a51     .9...H..M*..Q*..
    8be8:	00003ef1 00002b29 00002b2b 00002b55     .>..)+..++..U+..
    8bf8:	00002b35 00002b45 00002a55 00002b6d     5+..E+..U*..m+..
    8c08:	00003bad 00003b49 00003f79 0000401d     .;..I;..y?...@..
    8c18:	000040c5 00003a31 00002c51 00002cd5     .@..1:..Q,...,..

00008c28 <_ZL16Rcmd2green160x80>:
    8c28:	00042a02 2b7f0000 00000004 042a029f              .*.....+.....

00008c35 <_ZL8Rcmd2red>:
    8c35:	00042a02 2b7f0000 00000004 042a029f              .*.....+.....

00008c42 <_ZL10Rcmd2green>:
    8c42:	00042a02 2b810002 00010004 80010fa0              .*.....+.....

00008c4f <_ZL5Rcmd1>:
    8c4f:	9680010f b1ff8011 2d2c0103 2c0103b2     ..........,-...,
    8c5f:	0106b32d 2c012d2c 0701b42d 02a203c0     -...,-.,-.......
    8c6f:	c501c184 000a02c2 2a8a02c3 ee8a02c4     ...........*....
    8c7f:	200e01c5 c8013600 0405013a                       ... .6..:..

00008c8a <_ZL5Rcmd3>:
    8c8a:	0210e004 3712071c 292d2932 00392b25     .......72)-)%+9.
    8c9a:	e1100301 071d0310 292c2e06 372e2e2d     ..........,)-..7
    8caa:	0200003f 0a801310 00648029 00000000              ?.......).d...

00008cb8 <g_APinDescription>:
    8cb8:	00000000 0000000b 00000002 00000004     ................
    8cc8:	ffff00ff 000bffff 00000000 0000000a     ................
    8cd8:	00000002 00000004 ffff00ff 000affff     ................
    8ce8:	00000000 0000000e 00000008 00000004     ................
    8cf8:	ffff00ff 000effff 00000000 00000009     ................
    8d08:	00000004 0000001c 000100ff 00090001     ................
    8d18:	00000000 00000008 00000004 0000001c     ................
    8d28:	000000ff 00100000 00000000 0000000f     ................
    8d38:	00000004 0000001c 030100ff 000f0301     ................
    8d48:	00000000 00000014 00000005 0000002c     ............,...
    8d58:	000200ff 00040002 00000000 00000015     ................
    8d68:	00000005 0000002c 000300ff 00050003     ....,...........
    8d78:	00000000 00000006 00000004 0000001c     ................
    8d88:	010000ff 00060100 00000000 00000007     ................
    8d98:	00000004 0000001c 010100ff 00070101     ................
    8da8:	00000000 00000012 00000004 0000001c     ................
    8db8:	030000ff 00020300 00000000 00000010     ................
    8dc8:	00000004 0000001c 020000ff 00000200     ................
    8dd8:	00000000 00000013 00000005 0000002c     ............,...
    8de8:	000300ff 00030003 00000000 00000011     ................
    8df8:	00000004 0000001c 020100ff 00010201     ................
    8e08:	00000000 00000002 00000001 00000002     ................
    8e18:	ffff0000 0002ffff 00000001 00000008     ................
    8e28:	00000001 00000018 04000002 00080400     ................
    8e38:	00000001 00000009 00000001 00000018     ................
    8e48:	04010003 00090401 00000000 00000004     ................
    8e58:	00000001 00000000 ffff0004 0004ffff     ................
    8e68:	00000000 00000005 00000001 00000000     ................
    8e78:	ffff0005 0005ffff 00000001 00000002     ................
    8e88:	00000001 00000000 ffff000a 0002ffff     ................
    8e98:	00000000 00000016 00000002 00000004     ................
    8ea8:	ffff00ff 0006ffff 00000000 00000017     ................
    8eb8:	00000002 00000004 ffff00ff 0007ffff     ................
    8ec8:	00000000 0000000c 00000003 00000004     ................
    8ed8:	ffff00ff 000cffff 00000001 0000000a     ................
    8ee8:	00000003 00000004 ffff00ff 000affff     ................
    8ef8:	00000001 0000000b 00000003 00000004     ................
    8f08:	ffff00ff 000bffff 00000001 00000003     ................
    8f18:	0000000b 00000004 ffff00ff 00ffffff     ................
    8f28:	00000000 0000001b 0000000b 00000004     ................
    8f38:	ffff00ff 00ffffff 00000000 0000001c     ................
    8f48:	00000006 00000000 ffff00ff 00ffffff     ................
    8f58:	00000000 00000018 00000006 00000000     ................
    8f68:	ffff00ff 00ffffff 00000000 00000019     ................
    8f78:	00000006 00000000 ffff00ff 00ffffff     ................
    8f88:	00000001 00000016 00000003 00000000     ................
    8f98:	ffff00ff 00ffffff 00000001 00000017     ................
    8fa8:	00000003 00000000 ffff00ff 00ffffff     ................
    8fb8:	00000000 00000016 00000002 00000000     ................
    8fc8:	ffff00ff 00ffffff 00000000 00000017     ................
    8fd8:	00000002 00000000 ffff00ff 00ffffff     ................
    8fe8:	00000000 00000013 00000002 00000000     ................
    8ff8:	ffff00ff 00ffffff 00000000 00000010     ................
    9008:	00000002 00000000 ffff00ff 00ffffff     ................
    9018:	00000000 00000012 00000002 00000000     ................
    9028:	ffff00ff 00ffffff 00000000 00000011     ................
    9038:	00000002 00000000 ffff00ff 00ffffff     ................
    9048:	00000000 0000000d 00000004 0000000c     ................
    9058:	000100ff 000dffff 00000000 00000015     ................
    9068:	00000005 0000000c 000300ff 00ffffff     ................
    9078:	00000000 00000006 00000004 0000000c     ................
    9088:	010000ff 00ffffff 00000000 00000007     ................
    9098:	00000004 0000000c 010100ff 00ffffff     ................
    90a8:	00000000 00000003 00000001 00000002     ................
    90b8:	ffff00ff 00ffffff 00000000 00000002     ................
    90c8:	00000001 00000002 ffff0014 0002ffff     ................
    90d8:	6e000a0d 69006e61 6f00666e 00006676     ...nan.inf.ovf..

000090e8 <_ZTV4Uart>:
	...
    90f0:	00004fad 000048fd 00004f99 00004f77     .O...H...O..wO..
    9100:	00004f6d 00004f8f 00004fa3 00004f41     mO...O...O..AO..
    9110:	000050f9 00004f51 00004f3d 00000000     .P..QO..=O......

00009120 <_ZTV26DoubleBufferedEPOutHandler>:
	...
    9128:	000054d5 000053b9 00005301 00000000     .T...S...S......

00009138 <_ZL19STRING_MANUFACTURER>:
    9138:	75647241 206f6e69 00434c4c              Arduino LLC.

00009144 <_ZL15STRING_LANGUAGE>:
    9144:	04090304                                ....

00009148 <_ZL21USB_DeviceDescriptorB>:
    9148:	02000112 400102ef 804d2341 02010100     .......@A#M.....
    9158:	72410103                                         ..

0000915a <_ZL14STRING_PRODUCT>:
    915a:	75647241 206f6e69 6f72655a 00000000              Arduino Zero..

00009168 <_ZTV7Serial_>:
	...
    9170:	00006217 00006243 00006213 00006237     .b..Cb...b..7b..
    9180:	0000622b 0000627d 00006261 00000000     +b..}b..ab......
    9190:	00006ec8 00006e64 00006eac 00006d92     .n..dn...n...m..
    91a0:	00006eac 00006ea0 00006eac 00006d92     .n...n...n...m..
    91b0:	00006e64 00006e64 00006ea0 00006d92     dn..dn...n...m..
    91c0:	00006d88 00006d88 00006d88 000070ec     .m...m...m...p..
    91d0:	00007798 00007986 00007986 00007778     .w...y...y..xw..
    91e0:	00007662 00007662 0000776a 00007778     bv..bv..jw..xw..
    91f0:	00007662 0000776a 00007662 00007778     bv..jw..bv..xw..
    9200:	00007660 00007660 00007660 0000798e     `v..`v..`v...y..
    9210:	00000043                                C...

00009214 <__sf_fake_stdin>:
	...

00009234 <__sf_fake_stdout>:
	...

00009254 <__sf_fake_stderr>:
	...

00009274 <__EH_FRAME_BEGIN__>:
    9274:	00000000                                ....
