
meta-solitaire.ino.elf:     file format elf32-littlearm


Disassembly of section .text:

00004000 <__text_start__>:
    4000:	20007ffc 	.word	0x20007ffc
    4004:	0000f2b1 	.word	0x0000f2b1
    4008:	00007bb5 	.word	0x00007bb5
    400c:	00007bc5 	.word	0x00007bc5
	...
    402c:	0000f299 	.word	0x0000f299
	...
    4038:	0000f299 	.word	0x0000f299
    403c:	0000f305 	.word	0x0000f305
    4040:	0000f299 	.word	0x0000f299
    4044:	0000f299 	.word	0x0000f299
    4048:	0000f299 	.word	0x0000f299
    404c:	0000f299 	.word	0x0000f299
    4050:	0000f299 	.word	0x0000f299
    4054:	0000f299 	.word	0x0000f299
    4058:	00007805 	.word	0x00007805
    405c:	0000f29d 	.word	0x0000f29d
    4060:	0000f299 	.word	0x0000f299
    4064:	0000f1e5 	.word	0x0000f1e5
    4068:	0000f299 	.word	0x0000f299
    406c:	0000f299 	.word	0x0000f299
    4070:	0000f299 	.word	0x0000f299
    4074:	0000f299 	.word	0x0000f299
    4078:	0000f1f5 	.word	0x0000f1f5
    407c:	0000f299 	.word	0x0000f299
    4080:	0000f299 	.word	0x0000f299
    4084:	0000f299 	.word	0x0000f299
    4088:	0000f299 	.word	0x0000f299
    408c:	0000f299 	.word	0x0000f299
    4090:	0000ef1d 	.word	0x0000ef1d
    4094:	0000f299 	.word	0x0000f299
    4098:	0000f299 	.word	0x0000f299
    409c:	0000f299 	.word	0x0000f299
    40a0:	0000f299 	.word	0x0000f299
    40a4:	0000f299 	.word	0x0000f299
    40a8:	0000f299 	.word	0x0000f299
    40ac:	0000f299 	.word	0x0000f299
    40b0:	00000000 	.word	0x00000000

000040b4 <__do_global_dtors_aux>:
    40b4:	b510      	push	{r4, lr}
    40b6:	4c06      	ldr	r4, [pc, #24]	; (40d0 <__do_global_dtors_aux+0x1c>)
    40b8:	7823      	ldrb	r3, [r4, #0]
    40ba:	2b00      	cmp	r3, #0
    40bc:	d107      	bne.n	40ce <__do_global_dtors_aux+0x1a>
    40be:	4b05      	ldr	r3, [pc, #20]	; (40d4 <__do_global_dtors_aux+0x20>)
    40c0:	2b00      	cmp	r3, #0
    40c2:	d002      	beq.n	40ca <__do_global_dtors_aux+0x16>
    40c4:	4804      	ldr	r0, [pc, #16]	; (40d8 <__do_global_dtors_aux+0x24>)
    40c6:	e000      	b.n	40ca <__do_global_dtors_aux+0x16>
    40c8:	bf00      	nop
    40ca:	2301      	movs	r3, #1
    40cc:	7023      	strb	r3, [r4, #0]
    40ce:	bd10      	pop	{r4, pc}
    40d0:	200001d0 	.word	0x200001d0
    40d4:	00000000 	.word	0x00000000
    40d8:	00015be8 	.word	0x00015be8

000040dc <frame_dummy>:
    40dc:	b508      	push	{r3, lr}
    40de:	4b08      	ldr	r3, [pc, #32]	; (4100 <frame_dummy+0x24>)
    40e0:	2b00      	cmp	r3, #0
    40e2:	d003      	beq.n	40ec <frame_dummy+0x10>
    40e4:	4807      	ldr	r0, [pc, #28]	; (4104 <frame_dummy+0x28>)
    40e6:	4908      	ldr	r1, [pc, #32]	; (4108 <frame_dummy+0x2c>)
    40e8:	e000      	b.n	40ec <frame_dummy+0x10>
    40ea:	bf00      	nop
    40ec:	4807      	ldr	r0, [pc, #28]	; (410c <frame_dummy+0x30>)
    40ee:	6803      	ldr	r3, [r0, #0]
    40f0:	2b00      	cmp	r3, #0
    40f2:	d003      	beq.n	40fc <frame_dummy+0x20>
    40f4:	4b06      	ldr	r3, [pc, #24]	; (4110 <frame_dummy+0x34>)
    40f6:	2b00      	cmp	r3, #0
    40f8:	d000      	beq.n	40fc <frame_dummy+0x20>
    40fa:	4798      	blx	r3
    40fc:	bd08      	pop	{r3, pc}
    40fe:	46c0      	nop			; (mov r8, r8)
    4100:	00000000 	.word	0x00000000
    4104:	00015be8 	.word	0x00015be8
    4108:	200001d4 	.word	0x200001d4
    410c:	200001c0 	.word	0x200001c0
    4110:	00000000 	.word	0x00000000

00004114 <_ZN4CardC1E5Value4Suitb>:

Card::Card(Value value, Suit suit, bool faceDown) {
  // lowest 4 bits, value
  // bits 5 and 6, suite
  // highest bit, 1 if face down
  _value = value | (suit << 4) | (faceDown ? 0x80 : 0);
    4114:	0112      	lsls	r2, r2, #4
    4116:	4311      	orrs	r1, r2
    4118:	1e5a      	subs	r2, r3, #1
    411a:	4193      	sbcs	r3, r2
    411c:	01db      	lsls	r3, r3, #7
    411e:	4319      	orrs	r1, r3
    4120:	7001      	strb	r1, [r0, #0]
}
    4122:	4770      	bx	lr

00004124 <_ZNK4Card10isFaceDownEv>:

bool Card::isFaceDown() const {
  return 0x80 & _value;
    4124:	7800      	ldrb	r0, [r0, #0]
    4126:	09c0      	lsrs	r0, r0, #7
}
    4128:	4770      	bx	lr

0000412a <_ZNK4Card8getValueEv>:

Value Card::getValue() const {
  return static_cast<Value>(0x0f & _value);
    412a:	7800      	ldrb	r0, [r0, #0]
    412c:	230f      	movs	r3, #15
    412e:	4018      	ands	r0, r3
}
    4130:	4770      	bx	lr

00004132 <_ZNK4Card7getSuitEv>:

Suit Card::getSuit() const {
  return static_cast<Suit>((_value >> 4) & 0x03);
    4132:	7800      	ldrb	r0, [r0, #0]
    4134:	0680      	lsls	r0, r0, #26
    4136:	0f80      	lsrs	r0, r0, #30
}
    4138:	4770      	bx	lr

0000413a <_ZNK4Card5isRedEv>:
Value Card::getValue() const {
  return static_cast<Value>(0x0f & _value);
}

Suit Card::getSuit() const {
  return static_cast<Suit>((_value >> 4) & 0x03);
    413a:	7800      	ldrb	r0, [r0, #0]
    413c:	0680      	lsls	r0, r0, #26
    413e:	0f80      	lsrs	r0, r0, #30
}

bool Card::isRed() const {
  return getSuit() == heart || getSuit() == diamond;
    4140:	2802      	cmp	r0, #2
    4142:	d004      	beq.n	414e <_ZNK4Card5isRedEv+0x14>
    4144:	3803      	subs	r0, #3
    4146:	4243      	negs	r3, r0
    4148:	4158      	adcs	r0, r3
    414a:	b2c0      	uxtb	r0, r0
    414c:	e000      	b.n	4150 <_ZNK4Card5isRedEv+0x16>
    414e:	2001      	movs	r0, #1
}
    4150:	4770      	bx	lr

00004152 <_ZN4Card4flipEv>:
  // highest bit, 1 if face down
  _value = value | (suit << 4) | (faceDown ? 0x80 : 0);
}

bool Card::isFaceDown() const {
  return 0x80 & _value;
    4152:	7803      	ldrb	r3, [r0, #0]
bool Card::isRed() const {
  return getSuit() == heart || getSuit() == diamond;
}

void Card::flip() {
  if (isFaceDown()) _value = _value & 0x7f;
    4154:	b25a      	sxtb	r2, r3
    4156:	2a00      	cmp	r2, #0
    4158:	da02      	bge.n	4160 <_ZN4Card4flipEv+0xe>
    415a:	227f      	movs	r2, #127	; 0x7f
    415c:	4013      	ands	r3, r2
    415e:	e002      	b.n	4166 <_ZN4Card4flipEv+0x14>
  else _value = _value | 0x80;
    4160:	2280      	movs	r2, #128	; 0x80
    4162:	4252      	negs	r2, r2
    4164:	4313      	orrs	r3, r2
    4166:	7003      	strb	r3, [r0, #0]
}
    4168:	4770      	bx	lr
	...

0000416c <__tcf_1>:
// Keep track of source pile for returning invalid moves.
Pile *sourcePile;

Pile stockDeck = Pile(52), talonDeck = Pile(24);
Pile foundations[4] = { Pile(13), Pile(13), Pile(13), Pile(13) };
Pile tableau[7] = { Pile(20), Pile(20), Pile(20), Pile(20), Pile(20), Pile(20), Pile(20) };
    416c:	b538      	push	{r3, r4, r5, lr}
    416e:	4b06      	ldr	r3, [pc, #24]	; (4188 <__tcf_1+0x1c>)
    4170:	1c1c      	adds	r4, r3, #0
    4172:	1c1d      	adds	r5, r3, #0
    4174:	3460      	adds	r4, #96	; 0x60
    4176:	3d10      	subs	r5, #16
    4178:	1c20      	adds	r0, r4, #0
    417a:	3c10      	subs	r4, #16
    417c:	f001 fa11 	bl	55a2 <_ZN4PileD1Ev>
    4180:	42ac      	cmp	r4, r5
    4182:	d1f9      	bne.n	4178 <__tcf_1+0xc>
    4184:	bd38      	pop	{r3, r4, r5, pc}
    4186:	46c0      	nop			; (mov r8, r8)
    4188:	200002a8 	.word	0x200002a8

0000418c <__tcf_0>:

// Keep track of source pile for returning invalid moves.
Pile *sourcePile;

Pile stockDeck = Pile(52), talonDeck = Pile(24);
Pile foundations[4] = { Pile(13), Pile(13), Pile(13), Pile(13) };
    418c:	b510      	push	{r4, lr}
    418e:	4c08      	ldr	r4, [pc, #32]	; (41b0 <__tcf_0+0x24>)
    4190:	1c20      	adds	r0, r4, #0
    4192:	3030      	adds	r0, #48	; 0x30
    4194:	f001 fa05 	bl	55a2 <_ZN4PileD1Ev>
    4198:	1c20      	adds	r0, r4, #0
    419a:	3020      	adds	r0, #32
    419c:	f001 fa01 	bl	55a2 <_ZN4PileD1Ev>
    41a0:	1c20      	adds	r0, r4, #0
    41a2:	3010      	adds	r0, #16
    41a4:	f001 f9fd 	bl	55a2 <_ZN4PileD1Ev>
    41a8:	1c20      	adds	r0, r4, #0
    41aa:	f001 f9fa 	bl	55a2 <_ZN4PileD1Ev>
    41ae:	bd10      	pop	{r4, pc}
    41b0:	20000438 	.word	0x20000438

000041b4 <_ZN4CardC1Ev>:
enum Suit { spade = 0, club, heart, diamond };
enum Value { ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king };

class Card {
  public:
    Card() : Card(ace, spade, false) { }
    41b4:	b510      	push	{r4, lr}
    41b6:	2200      	movs	r2, #0
    41b8:	1c04      	adds	r4, r0, #0
    41ba:	2101      	movs	r1, #1
    41bc:	1c13      	adds	r3, r2, #0
    41be:	f7ff ffa9 	bl	4114 <_ZN4CardC1E5Value4Suitb>
    41c2:	1c20      	adds	r0, r4, #0
    41c4:	bd10      	pop	{r4, pc}
	...

000041c8 <_Z11revealCardsv>:
  bool unused;
  getCursorDestination(cursorX, cursorY, unused);
  return result;
}

bool revealCards() {
    41c8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    41ca:	2400      	movs	r4, #0
  bool revealed = false;
    41cc:	1c27      	adds	r7, r4, #0
    41ce:	4e0f      	ldr	r6, [pc, #60]	; (420c <_Z11revealCardsv+0x44>)
    41d0:	1936      	adds	r6, r6, r4
  // Check for cards to reveal.
  for (int i = 0; i < 7; i++) {
    if (tableau[i].getCardCount() == 0) continue;
    41d2:	1c30      	adds	r0, r6, #0
    41d4:	f001 f9f8 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    41d8:	2800      	cmp	r0, #0
    41da:	d011      	beq.n	4200 <_Z11revealCardsv+0x38>
    Card card = tableau[i].removeTopCard();
    41dc:	1c30      	adds	r0, r6, #0
    41de:	f001 fa16 	bl	560e <_ZN4Pile13removeTopCardEv>
    41e2:	ad01      	add	r5, sp, #4
    41e4:	7028      	strb	r0, [r5, #0]
    if (card.isFaceDown()) {
    41e6:	1c28      	adds	r0, r5, #0
    41e8:	f7ff ff9c 	bl	4124 <_ZNK4Card10isFaceDownEv>
    41ec:	2800      	cmp	r0, #0
    41ee:	d003      	beq.n	41f8 <_Z11revealCardsv+0x30>
      card.flip();
    41f0:	1c28      	adds	r0, r5, #0
    41f2:	f7ff ffae 	bl	4152 <_ZN4Card4flipEv>
      revealed = true;
    41f6:	2701      	movs	r7, #1
    }
    tableau[i].addCard(card);
    41f8:	7829      	ldrb	r1, [r5, #0]
    41fa:	1c30      	adds	r0, r6, #0
    41fc:	f001 f9da 	bl	55b4 <_ZN4Pile7addCardE4Card>
    4200:	3410      	adds	r4, #16
}

bool revealCards() {
  bool revealed = false;
  // Check for cards to reveal.
  for (int i = 0; i < 7; i++) {
    4202:	2c70      	cmp	r4, #112	; 0x70
    4204:	d1e3      	bne.n	41ce <_Z11revealCardsv+0x6>
      revealed = true;
    }
    tableau[i].addCard(card);
  }
  return revealed;
}
    4206:	1c38      	adds	r0, r7, #0
    4208:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    420a:	46c0      	nop			; (mov r8, r8)
    420c:	200002a8 	.word	0x200002a8

00004210 <_Z20initializeCardBouncev>:
      setupNewGame();
    }
  }
}

bool initializeCardBounce() {
    4210:	b570      	push	{r4, r5, r6, lr}
  // Return false if all the cards are done.
  if (foundations[bounceIndex].getCardCount() == 0) return false;
    4212:	4c1c      	ldr	r4, [pc, #112]	; (4284 <_Z20initializeCardBouncev+0x74>)
    4214:	4e1c      	ldr	r6, [pc, #112]	; (4288 <_Z20initializeCardBouncev+0x78>)
    4216:	7820      	ldrb	r0, [r4, #0]
    4218:	0100      	lsls	r0, r0, #4
    421a:	1830      	adds	r0, r6, r0
    421c:	f001 f9d4 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    4220:	2300      	movs	r3, #0
    4222:	4298      	cmp	r0, r3
    4224:	d02b      	beq.n	427e <_Z20initializeCardBouncev+0x6e>
  // Pick the next card to animate, with a random initial velocity.
  bounce.card = foundations[bounceIndex].removeTopCard();
    4226:	7820      	ldrb	r0, [r4, #0]
    4228:	4d18      	ldr	r5, [pc, #96]	; (428c <_Z20initializeCardBouncev+0x7c>)
    422a:	0100      	lsls	r0, r0, #4
    422c:	1830      	adds	r0, r6, r0
    422e:	f001 f9ee 	bl	560e <_ZN4Pile13removeTopCardEv>
  bounce.x = foundations[bounceIndex].x << 8;
    4232:	7823      	ldrb	r3, [r4, #0]

bool initializeCardBounce() {
  // Return false if all the cards are done.
  if (foundations[bounceIndex].getCardCount() == 0) return false;
  // Pick the next card to animate, with a random initial velocity.
  bounce.card = foundations[bounceIndex].removeTopCard();
    4234:	7028      	strb	r0, [r5, #0]
  bounce.x = foundations[bounceIndex].x << 8;
    4236:	011b      	lsls	r3, r3, #4
    4238:	5f9a      	ldrsh	r2, [r3, r6]
  bounce.y = foundations[bounceIndex].y << 8;
    423a:	18f6      	adds	r6, r6, r3
bool initializeCardBounce() {
  // Return false if all the cards are done.
  if (foundations[bounceIndex].getCardCount() == 0) return false;
  // Pick the next card to animate, with a random initial velocity.
  bounce.card = foundations[bounceIndex].removeTopCard();
  bounce.x = foundations[bounceIndex].x << 8;
    423c:	0212      	lsls	r2, r2, #8
    423e:	806a      	strh	r2, [r5, #2]
  bounce.y = foundations[bounceIndex].y << 8;
    4240:	2202      	movs	r2, #2
    4242:	5eb3      	ldrsh	r3, [r6, r2]
  bounce.xVelocity = (random(2) ? 1 : -1) * random(0x0100, 0x0200);
    4244:	2002      	movs	r0, #2
  // Return false if all the cards are done.
  if (foundations[bounceIndex].getCardCount() == 0) return false;
  // Pick the next card to animate, with a random initial velocity.
  bounce.card = foundations[bounceIndex].removeTopCard();
  bounce.x = foundations[bounceIndex].x << 8;
  bounce.y = foundations[bounceIndex].y << 8;
    4246:	021b      	lsls	r3, r3, #8
    4248:	80ab      	strh	r3, [r5, #4]
  bounce.xVelocity = (random(2) ? 1 : -1) * random(0x0100, 0x0200);
    424a:	f00b ffb9 	bl	101c0 <_Z6randoml>
    424e:	2601      	movs	r6, #1
    4250:	2800      	cmp	r0, #0
    4252:	d100      	bne.n	4256 <_Z20initializeCardBouncev+0x46>
    4254:	4e0e      	ldr	r6, [pc, #56]	; (4290 <_Z20initializeCardBouncev+0x80>)
    4256:	2080      	movs	r0, #128	; 0x80
    4258:	2180      	movs	r1, #128	; 0x80
    425a:	0089      	lsls	r1, r1, #2
    425c:	0040      	lsls	r0, r0, #1
    425e:	f00b ffbb 	bl	101d8 <_Z6randomll>
    4262:	4346      	muls	r6, r0
  bounce.yVelocity = -1 * random(0x0200);
    4264:	2080      	movs	r0, #128	; 0x80
    4266:	0080      	lsls	r0, r0, #2
  if (foundations[bounceIndex].getCardCount() == 0) return false;
  // Pick the next card to animate, with a random initial velocity.
  bounce.card = foundations[bounceIndex].removeTopCard();
  bounce.x = foundations[bounceIndex].x << 8;
  bounce.y = foundations[bounceIndex].y << 8;
  bounce.xVelocity = (random(2) ? 1 : -1) * random(0x0100, 0x0200);
    4268:	80ee      	strh	r6, [r5, #6]
  bounce.yVelocity = -1 * random(0x0200);
    426a:	f00b ffa9 	bl	101c0 <_Z6randoml>
  bounceIndex = (bounceIndex + 1) % 4;
    426e:	7823      	ldrb	r3, [r4, #0]
    4270:	2203      	movs	r2, #3
    4272:	3301      	adds	r3, #1
    4274:	4013      	ands	r3, r2
  // Pick the next card to animate, with a random initial velocity.
  bounce.card = foundations[bounceIndex].removeTopCard();
  bounce.x = foundations[bounceIndex].x << 8;
  bounce.y = foundations[bounceIndex].y << 8;
  bounce.xVelocity = (random(2) ? 1 : -1) * random(0x0100, 0x0200);
  bounce.yVelocity = -1 * random(0x0200);
    4276:	4240      	negs	r0, r0
  bounceIndex = (bounceIndex + 1) % 4;
    4278:	7023      	strb	r3, [r4, #0]
  // Pick the next card to animate, with a random initial velocity.
  bounce.card = foundations[bounceIndex].removeTopCard();
  bounce.x = foundations[bounceIndex].x << 8;
  bounce.y = foundations[bounceIndex].y << 8;
  bounce.xVelocity = (random(2) ? 1 : -1) * random(0x0100, 0x0200);
  bounce.yVelocity = -1 * random(0x0200);
    427a:	8128      	strh	r0, [r5, #8]
  bounceIndex = (bounceIndex + 1) % 4;
    427c:	2301      	movs	r3, #1
  return true;
}
    427e:	1c18      	adds	r0, r3, #0
    4280:	bd70      	pop	{r4, r5, r6, pc}
    4282:	46c0      	nop			; (mov r8, r8)
    4284:	200001ed 	.word	0x200001ed
    4288:	20000438 	.word	0x20000438
    428c:	20000478 	.word	0x20000478
    4290:	0000ffff 	.word	0x0000ffff

00004294 <_Z21getActiveLocationPilev>:
    }
  }
}

Pile* getActiveLocationPile() {
  switch (activeLocation) {
    4294:	4b0e      	ldr	r3, [pc, #56]	; (42d0 <_Z21getActiveLocationPilev+0x3c>)
      drawSuit(x + 12 + extraWidth, y + 1, card.getSuit());
    }
  }
}

Pile* getActiveLocationPile() {
    4296:	b500      	push	{lr}
  switch (activeLocation) {
    4298:	781b      	ldrb	r3, [r3, #0]
    429a:	2b0c      	cmp	r3, #12
    429c:	d813      	bhi.n	42c6 <_Z21getActiveLocationPilev+0x32>
    429e:	1c18      	adds	r0, r3, #0
    42a0:	f00d f866 	bl	11370 <__gnu_thumb1_case_uqi>
    42a4:	07071412 	.word	0x07071412
    42a8:	0c0c0707 	.word	0x0c0c0707
    42ac:	0c0c0c0c 	.word	0x0c0c0c0c
    42b0:	0c          	.byte	0x0c
    42b1:	00          	.byte	0x00
      return &talonDeck;
    case foundation1:
    case foundation2:
    case foundation3:
    case foundation4:
      return &foundations[activeLocation - foundation1];
    42b2:	3b02      	subs	r3, #2
    42b4:	4807      	ldr	r0, [pc, #28]	; (42d4 <_Z21getActiveLocationPilev+0x40>)
    42b6:	011b      	lsls	r3, r3, #4
    42b8:	18c0      	adds	r0, r0, r3
    42ba:	e008      	b.n	42ce <_Z21getActiveLocationPilev+0x3a>
    case tableau3:
    case tableau4:
    case tableau5:
    case tableau6:
    case tableau7:
      return &tableau[activeLocation - tableau1];
    42bc:	3b06      	subs	r3, #6
    42be:	4806      	ldr	r0, [pc, #24]	; (42d8 <_Z21getActiveLocationPilev+0x44>)
    42c0:	011b      	lsls	r3, r3, #4
    42c2:	18c0      	adds	r0, r0, r3
    42c4:	e003      	b.n	42ce <_Z21getActiveLocationPilev+0x3a>
    42c6:	e002      	b.n	42ce <_Z21getActiveLocationPilev+0x3a>
}

Pile* getActiveLocationPile() {
  switch (activeLocation) {
    case stock:
      return &stockDeck;
    42c8:	4804      	ldr	r0, [pc, #16]	; (42dc <_Z21getActiveLocationPilev+0x48>)
    42ca:	e000      	b.n	42ce <_Z21getActiveLocationPilev+0x3a>
    case talon:
      return &talonDeck;
    42cc:	4804      	ldr	r0, [pc, #16]	; (42e0 <_Z21getActiveLocationPilev+0x4c>)
    case tableau5:
    case tableau6:
    case tableau7:
      return &tableau[activeLocation - tableau1];
  }
}
    42ce:	bd00      	pop	{pc}
    42d0:	2000027c 	.word	0x2000027c
    42d4:	20000438 	.word	0x20000438
    42d8:	200002a8 	.word	0x200002a8
    42dc:	20000280 	.word	0x20000280
    42e0:	20000290 	.word	0x20000290

000042e4 <_Z14updatePositionhh>:

byte updatePosition(byte current, byte destination) {
    42e4:	b510      	push	{r4, lr}
  if (current == destination) return current;
    42e6:	4288      	cmp	r0, r1
    42e8:	d013      	beq.n	4312 <_Z14updatePositionhh+0x2e>

  byte delta = (destination - current) / 4;
    42ea:	1a0a      	subs	r2, r1, r0
    42ec:	17d3      	asrs	r3, r2, #31
    42ee:	0f9b      	lsrs	r3, r3, #30
    42f0:	189b      	adds	r3, r3, r2
    42f2:	109b      	asrs	r3, r3, #2
    42f4:	b2db      	uxtb	r3, r3
  if (delta == 0 && ((gb.frameCount % 2) == 0)) delta = destination > current ? 1 : -1;
    42f6:	2b00      	cmp	r3, #0
    42f8:	d109      	bne.n	430e <_Z14updatePositionhh+0x2a>
    42fa:	4a06      	ldr	r2, [pc, #24]	; (4314 <_Z14updatePositionhh+0x30>)
    42fc:	32fc      	adds	r2, #252	; 0xfc
    42fe:	6e14      	ldr	r4, [r2, #96]	; 0x60
    4300:	2201      	movs	r2, #1
    4302:	4214      	tst	r4, r2
    4304:	d103      	bne.n	430e <_Z14updatePositionhh+0x2a>
    4306:	23ff      	movs	r3, #255	; 0xff
    4308:	4281      	cmp	r1, r0
    430a:	d900      	bls.n	430e <_Z14updatePositionhh+0x2a>
    430c:	1c13      	adds	r3, r2, #0
  return current + delta;
    430e:	1818      	adds	r0, r3, r0
    4310:	b2c0      	uxtb	r0, r0
}
    4312:	bd10      	pop	{r4, pc}
    4314:	20000a3c 	.word	0x20000a3c

00004318 <_Z13cardYPositionP4Pileh>:
      gb.display.drawImage(pile->x, pile->y + 2 * i, cardTopSprite);
    }
  }
}

byte cardYPosition(Pile *pile, byte cardIndex) {
    4318:	b570      	push	{r4, r5, r6, lr}
  if (pile->isTableau) {
    431a:	7903      	ldrb	r3, [r0, #4]
      gb.display.drawImage(pile->x, pile->y + 2 * i, cardTopSprite);
    }
  }
}

byte cardYPosition(Pile *pile, byte cardIndex) {
    431c:	1c04      	adds	r4, r0, #0
    431e:	1c0d      	adds	r5, r1, #0
    4320:	8840      	ldrh	r0, [r0, #2]
  if (pile->isTableau) {
    4322:	2b00      	cmp	r3, #0
    4324:	d010      	beq.n	4348 <_Z13cardYPositionP4Pileh+0x30>
    if (cardIndex > MAX_CARDS_DRAWN_IN_PILE - 1) return pile->y;
    4326:	290e      	cmp	r1, #14
    4328:	d80e      	bhi.n	4348 <_Z13cardYPositionP4Pileh+0x30>
    return pile->y + 2 * (min(pile->getCardCount(), MAX_CARDS_DRAWN_IN_PILE) - cardIndex - 1);
    432a:	b2c6      	uxtb	r6, r0
    432c:	1c20      	adds	r0, r4, #0
    432e:	f001 f94b 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    4332:	230f      	movs	r3, #15
    4334:	280e      	cmp	r0, #14
    4336:	d803      	bhi.n	4340 <_Z13cardYPositionP4Pileh+0x28>
    4338:	1c20      	adds	r0, r4, #0
    433a:	f001 f945 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    433e:	1c03      	adds	r3, r0, #0
    4340:	1b58      	subs	r0, r3, r5
    4342:	3801      	subs	r0, #1
    4344:	0040      	lsls	r0, r0, #1
    4346:	1830      	adds	r0, r6, r0
    4348:	b2c0      	uxtb	r0, r0
  }

  return pile->y;
}
    434a:	bd70      	pop	{r4, r5, r6, pc}

0000434c <_Z20getCursorDestinationRhS_Rb>:
  cursorY = updatePosition(cursorY, y);

  drawCursor(cursorX, cursorY, flipped);
}

void getCursorDestination(byte& x, byte& y, bool& flipped) {
    434c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    434e:	1c07      	adds	r7, r0, #0
    4350:	1c0e      	adds	r6, r1, #0
    4352:	1c15      	adds	r5, r2, #0
  Pile* pile = getActiveLocationPile();
    4354:	f7ff ff9e 	bl	4294 <_Z21getActiveLocationPilev>

  switch (activeLocation) {
    4358:	4b2e      	ldr	r3, [pc, #184]	; (4414 <_Z20getCursorDestinationRhS_Rb+0xc8>)

  drawCursor(cursorX, cursorY, flipped);
}

void getCursorDestination(byte& x, byte& y, bool& flipped) {
  Pile* pile = getActiveLocationPile();
    435a:	1c04      	adds	r4, r0, #0

  switch (activeLocation) {
    435c:	7818      	ldrb	r0, [r3, #0]
    435e:	280c      	cmp	r0, #12
    4360:	d856      	bhi.n	4410 <_Z20getCursorDestinationRhS_Rb+0xc4>
    4362:	8823      	ldrh	r3, [r4, #0]
    4364:	f00d f804 	bl	11370 <__gnu_thumb1_case_uqi>
    4368:	2d2d0a07 	.word	0x2d2d0a07
    436c:	35352d2d 	.word	0x35352d2d
    4370:	45454535 	.word	0x45454535
    4374:	45          	.byte	0x45
    4375:	00          	.byte	0x00
    case stock:
      x = pile->x + 9;
    4376:	3309      	adds	r3, #9
    4378:	703b      	strb	r3, [r7, #0]
    437a:	e01c      	b.n	43b6 <_Z20getCursorDestinationRhS_Rb+0x6a>
      y = pile->y + 4;
      flipped = false;
      break;
    case talon:
      x = pile->x + 9 + 2 * min(2, max(0, pile->getCardCount() - 1));
    437c:	b2db      	uxtb	r3, r3
    437e:	1c20      	adds	r0, r4, #0
    4380:	9301      	str	r3, [sp, #4]
    4382:	f001 f921 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    4386:	2800      	cmp	r0, #0
    4388:	d10b      	bne.n	43a2 <_Z20getCursorDestinationRhS_Rb+0x56>
    438a:	1c20      	adds	r0, r4, #0
    438c:	f001 f91c 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    4390:	2800      	cmp	r0, #0
    4392:	d00c      	beq.n	43ae <_Z20getCursorDestinationRhS_Rb+0x62>
    4394:	1c20      	adds	r0, r4, #0
    4396:	f001 f917 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    439a:	3801      	subs	r0, #1
    439c:	0040      	lsls	r0, r0, #1
    439e:	b2c0      	uxtb	r0, r0
    43a0:	e005      	b.n	43ae <_Z20getCursorDestinationRhS_Rb+0x62>
    43a2:	1c20      	adds	r0, r4, #0
    43a4:	f001 f910 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    43a8:	2803      	cmp	r0, #3
    43aa:	ddee      	ble.n	438a <_Z20getCursorDestinationRhS_Rb+0x3e>
    43ac:	2004      	movs	r0, #4
    43ae:	9b01      	ldr	r3, [sp, #4]
    43b0:	3309      	adds	r3, #9
    43b2:	18c0      	adds	r0, r0, r3
    43b4:	7038      	strb	r0, [r7, #0]
      y = pile->y + 4;
    43b6:	8863      	ldrh	r3, [r4, #2]
    43b8:	3304      	adds	r3, #4
    43ba:	7033      	strb	r3, [r6, #0]
      flipped = false;
    43bc:	2300      	movs	r3, #0
    43be:	702b      	strb	r3, [r5, #0]
      break;
    43c0:	e026      	b.n	4410 <_Z20getCursorDestinationRhS_Rb+0xc4>
    case foundation1:
    case foundation2:
    case foundation3:
    case foundation4:
      x = pile->x - 7;
    43c2:	3b07      	subs	r3, #7
    43c4:	703b      	strb	r3, [r7, #0]
      y = pile->y + 4;
    43c6:	8863      	ldrh	r3, [r4, #2]
    43c8:	3304      	adds	r3, #4
    43ca:	7033      	strb	r3, [r6, #0]
      flipped = true;
    43cc:	2301      	movs	r3, #1
    43ce:	702b      	strb	r3, [r5, #0]
      break;
    43d0:	e01e      	b.n	4410 <_Z20getCursorDestinationRhS_Rb+0xc4>
    case tableau1:
    case tableau2:
    case tableau3:
      x = pile->x + 9;
    43d2:	3309      	adds	r3, #9
    43d4:	703b      	strb	r3, [r7, #0]
      y = (cardIndex == 0 ? 4 : -2) + cardYPosition(pile, cardIndex);
    43d6:	4b10      	ldr	r3, [pc, #64]	; (4418 <_Z20getCursorDestinationRhS_Rb+0xcc>)
    43d8:	27fe      	movs	r7, #254	; 0xfe
    43da:	7819      	ldrb	r1, [r3, #0]
    43dc:	2900      	cmp	r1, #0
    43de:	d100      	bne.n	43e2 <_Z20getCursorDestinationRhS_Rb+0x96>
    43e0:	2704      	movs	r7, #4
    43e2:	1c20      	adds	r0, r4, #0
    43e4:	f7ff ff98 	bl	4318 <_Z13cardYPositionP4Pileh>
      flipped = false;
    43e8:	2300      	movs	r3, #0
      break;
    case tableau1:
    case tableau2:
    case tableau3:
      x = pile->x + 9;
      y = (cardIndex == 0 ? 4 : -2) + cardYPosition(pile, cardIndex);
    43ea:	19c7      	adds	r7, r0, r7
    43ec:	7037      	strb	r7, [r6, #0]
      flipped = false;
    43ee:	702b      	strb	r3, [r5, #0]
      break;
    43f0:	e00e      	b.n	4410 <_Z20getCursorDestinationRhS_Rb+0xc4>
    case tableau4:
    case tableau5:
    case tableau6:
    case tableau7:
      x = pile->x - 7;
    43f2:	3b07      	subs	r3, #7
    43f4:	703b      	strb	r3, [r7, #0]
      y = (cardIndex == 0 ? 4 : -2) + cardYPosition(pile, cardIndex);
    43f6:	4b08      	ldr	r3, [pc, #32]	; (4418 <_Z20getCursorDestinationRhS_Rb+0xcc>)
    43f8:	27fe      	movs	r7, #254	; 0xfe
    43fa:	7819      	ldrb	r1, [r3, #0]
    43fc:	2900      	cmp	r1, #0
    43fe:	d100      	bne.n	4402 <_Z20getCursorDestinationRhS_Rb+0xb6>
    4400:	2704      	movs	r7, #4
    4402:	1c20      	adds	r0, r4, #0
    4404:	f7ff ff88 	bl	4318 <_Z13cardYPositionP4Pileh>
      flipped = true;
    4408:	2301      	movs	r3, #1
    case tableau4:
    case tableau5:
    case tableau6:
    case tableau7:
      x = pile->x - 7;
      y = (cardIndex == 0 ? 4 : -2) + cardYPosition(pile, cardIndex);
    440a:	19c7      	adds	r7, r0, r7
    440c:	7037      	strb	r7, [r6, #0]
      flipped = true;
    440e:	702b      	strb	r3, [r5, #0]
      break;
  }
}
    4410:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    4412:	46c0      	nop			; (mov r8, r8)
    4414:	2000027c 	.word	0x2000027c
    4418:	200002a4 	.word	0x200002a4

0000441c <_Z10playSoundAv>:
    valueSprite.setFrame(isRed ? 14 : 0);
    gb.display.drawImage(x - 4, y, valueSprite);
  }
}

void playSoundA() {
    441c:	b508      	push	{r3, lr}
  gb.sound.play(patternA);
    441e:	4803      	ldr	r0, [pc, #12]	; (442c <_Z10playSoundAv+0x10>)
    4420:	4903      	ldr	r1, [pc, #12]	; (4430 <_Z10playSoundAv+0x14>)
    4422:	2200      	movs	r2, #0
    4424:	f00a fce6 	bl	edf4 <_ZN14Gamebuino_Meta5Sound4playEPKtb>
}
    4428:	bd08      	pop	{r3, pc}
    442a:	46c0      	nop			; (mov r8, r8)
    442c:	20000a74 	.word	0x20000a74
    4430:	00011920 	.word	0x00011920

00004434 <_Z10playSoundBv>:

void playSoundB() {
    4434:	b508      	push	{r3, lr}
  gb.sound.play(patternB);
    4436:	4803      	ldr	r0, [pc, #12]	; (4444 <_Z10playSoundBv+0x10>)
    4438:	4903      	ldr	r1, [pc, #12]	; (4448 <_Z10playSoundBv+0x14>)
    443a:	2200      	movs	r2, #0
    443c:	f00a fcda 	bl	edf4 <_ZN14Gamebuino_Meta5Sound4playEPKtb>
}
    4440:	bd08      	pop	{r3, pc}
    4442:	46c0      	nop			; (mov r8, r8)
    4444:	20000a74 	.word	0x20000a74
    4448:	00011926 	.word	0x00011926

0000444c <_Z11drawAndFlipP4PileS0_>:

void drawAndFlip(Pile *source, Pile *destination) {
    444c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    444e:	1c0d      	adds	r5, r1, #0
  Card card = source->removeTopCard();
    4450:	f001 f8dd 	bl	560e <_ZN4Pile13removeTopCardEv>
    4454:	ac01      	add	r4, sp, #4
    4456:	7020      	strb	r0, [r4, #0]
  card.flip();
    4458:	1c20      	adds	r0, r4, #0
    445a:	f7ff fe7a 	bl	4152 <_ZN4Card4flipEv>
  destination->addCard(card);
    445e:	1c28      	adds	r0, r5, #0
    4460:	7821      	ldrb	r1, [r4, #0]
    4462:	f001 f8a7 	bl	55b4 <_ZN4Pile7addCardE4Card>
}
    4466:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

00004468 <_GLOBAL__sub_I_mode>:
      action.destination->removeCards(action.getCardCount(), &moving);
      action.source->addPile(&moving);
    }
    updateAfterPlay();
  }
}
    4468:	b570      	push	{r4, r5, r6, lr}
byte cardIndex;
// Position of the cursor for animation.
byte cursorX, cursorY;

// Animating moving stack of cards.
Pile moving = Pile(13);
    446a:	4e3a      	ldr	r6, [pc, #232]	; (4554 <_GLOBAL__sub_I_mode+0xec>)
    446c:	210d      	movs	r1, #13
    446e:	1c30      	adds	r0, r6, #0
    4470:	f001 f880 	bl	5574 <_ZN4PileC1Eh>
    4474:	4d38      	ldr	r5, [pc, #224]	; (4558 <_GLOBAL__sub_I_mode+0xf0>)
    4476:	4c39      	ldr	r4, [pc, #228]	; (455c <_GLOBAL__sub_I_mode+0xf4>)
    4478:	1c2a      	adds	r2, r5, #0
    447a:	1c21      	adds	r1, r4, #0
    447c:	1c30      	adds	r0, r6, #0
    447e:	f00d f83b 	bl	114f8 <__aeabi_atexit>
byte cardsToDraw = 1;

// Keep track of source pile for returning invalid moves.
Pile *sourcePile;

Pile stockDeck = Pile(52), talonDeck = Pile(24);
    4482:	4e37      	ldr	r6, [pc, #220]	; (4560 <_GLOBAL__sub_I_mode+0xf8>)
    4484:	2134      	movs	r1, #52	; 0x34
    4486:	1c30      	adds	r0, r6, #0
    4488:	f001 f874 	bl	5574 <_ZN4PileC1Eh>
    448c:	1c2a      	adds	r2, r5, #0
    448e:	1c21      	adds	r1, r4, #0
    4490:	1c30      	adds	r0, r6, #0
    4492:	f00d f831 	bl	114f8 <__aeabi_atexit>
    4496:	4e33      	ldr	r6, [pc, #204]	; (4564 <_GLOBAL__sub_I_mode+0xfc>)
    4498:	2118      	movs	r1, #24
    449a:	1c30      	adds	r0, r6, #0
    449c:	f001 f86a 	bl	5574 <_ZN4PileC1Eh>
    44a0:	1c2a      	adds	r2, r5, #0
    44a2:	1c21      	adds	r1, r4, #0
    44a4:	1c30      	adds	r0, r6, #0
    44a6:	f00d f827 	bl	114f8 <__aeabi_atexit>
Pile foundations[4] = { Pile(13), Pile(13), Pile(13), Pile(13) };
    44aa:	4c2f      	ldr	r4, [pc, #188]	; (4568 <_GLOBAL__sub_I_mode+0x100>)
    44ac:	210d      	movs	r1, #13
    44ae:	1c20      	adds	r0, r4, #0
    44b0:	f001 f860 	bl	5574 <_ZN4PileC1Eh>
    44b4:	1c20      	adds	r0, r4, #0
    44b6:	210d      	movs	r1, #13
    44b8:	3010      	adds	r0, #16
    44ba:	f001 f85b 	bl	5574 <_ZN4PileC1Eh>
    44be:	1c20      	adds	r0, r4, #0
    44c0:	210d      	movs	r1, #13
    44c2:	3020      	adds	r0, #32
    44c4:	f001 f856 	bl	5574 <_ZN4PileC1Eh>
    44c8:	1c20      	adds	r0, r4, #0
    44ca:	210d      	movs	r1, #13
    44cc:	3030      	adds	r0, #48	; 0x30
    44ce:	f001 f851 	bl	5574 <_ZN4PileC1Eh>
    44d2:	1c2a      	adds	r2, r5, #0
    44d4:	4925      	ldr	r1, [pc, #148]	; (456c <_GLOBAL__sub_I_mode+0x104>)
    44d6:	2000      	movs	r0, #0
    44d8:	f00d f80e 	bl	114f8 <__aeabi_atexit>
Pile tableau[7] = { Pile(20), Pile(20), Pile(20), Pile(20), Pile(20), Pile(20), Pile(20) };
    44dc:	4c24      	ldr	r4, [pc, #144]	; (4570 <_GLOBAL__sub_I_mode+0x108>)
    44de:	2114      	movs	r1, #20
    44e0:	1c20      	adds	r0, r4, #0
    44e2:	f001 f847 	bl	5574 <_ZN4PileC1Eh>
    44e6:	1c20      	adds	r0, r4, #0
    44e8:	2114      	movs	r1, #20
    44ea:	3010      	adds	r0, #16
    44ec:	f001 f842 	bl	5574 <_ZN4PileC1Eh>
    44f0:	1c20      	adds	r0, r4, #0
    44f2:	2114      	movs	r1, #20
    44f4:	3020      	adds	r0, #32
    44f6:	f001 f83d 	bl	5574 <_ZN4PileC1Eh>
    44fa:	1c20      	adds	r0, r4, #0
    44fc:	2114      	movs	r1, #20
    44fe:	3030      	adds	r0, #48	; 0x30
    4500:	f001 f838 	bl	5574 <_ZN4PileC1Eh>
    4504:	1c20      	adds	r0, r4, #0
    4506:	2114      	movs	r1, #20
    4508:	3040      	adds	r0, #64	; 0x40
    450a:	f001 f833 	bl	5574 <_ZN4PileC1Eh>
    450e:	1c20      	adds	r0, r4, #0
    4510:	2114      	movs	r1, #20
    4512:	3050      	adds	r0, #80	; 0x50
    4514:	f001 f82e 	bl	5574 <_ZN4PileC1Eh>
    4518:	1c20      	adds	r0, r4, #0
    451a:	2114      	movs	r1, #20
    451c:	3060      	adds	r0, #96	; 0x60
    451e:	f001 f829 	bl	5574 <_ZN4PileC1Eh>
    4522:	1c2a      	adds	r2, r5, #0
    4524:	4913      	ldr	r1, [pc, #76]	; (4574 <_GLOBAL__sub_I_mode+0x10c>)
    4526:	2000      	movs	r0, #0
    4528:	f00c ffe6 	bl	114f8 <__aeabi_atexit>

UndoStack undo;
    452c:	4812      	ldr	r0, [pc, #72]	; (4578 <_GLOBAL__sub_I_mode+0x110>)
    452e:	f001 f983 	bl	5838 <_ZN9UndoStackC1Ev>
    4532:	4b12      	ldr	r3, [pc, #72]	; (457c <_GLOBAL__sub_I_mode+0x114>)
    4534:	2291      	movs	r2, #145	; 0x91
    4536:	1c1c      	adds	r4, r3, #0
    4538:	0052      	lsls	r2, r2, #1
    453a:	340a      	adds	r4, #10
    453c:	189d      	adds	r5, r3, r2
    453e:	1c20      	adds	r0, r4, #0
    4540:	380a      	subs	r0, #10
    4542:	340a      	adds	r4, #10

struct CardAnimation {
    4544:	f7ff fe36 	bl	41b4 <_ZN4CardC1Ev>
  byte tableauIndex;
  int16_t x, y, destX, destY;
};

// Used to deal at the start of the game.
CardAnimation cardAnimations[28];
    4548:	42ac      	cmp	r4, r5
    454a:	d1f8      	bne.n	453e <_GLOBAL__sub_I_mode+0xd6>
byte cardAnimationCount = 0;

struct CardBounce {
    454c:	480c      	ldr	r0, [pc, #48]	; (4580 <_GLOBAL__sub_I_mode+0x118>)
    454e:	f7ff fe31 	bl	41b4 <_ZN4CardC1Ev>
      action.destination->removeCards(action.getCardCount(), &moving);
      action.source->addPile(&moving);
    }
    updateAfterPlay();
  }
}
    4552:	bd70      	pop	{r4, r5, r6, pc}
    4554:	200001f0 	.word	0x200001f0
    4558:	20000000 	.word	0x20000000
    455c:	000055a3 	.word	0x000055a3
    4560:	20000280 	.word	0x20000280
    4564:	20000290 	.word	0x20000290
    4568:	20000438 	.word	0x20000438
    456c:	0000418d 	.word	0x0000418d
    4570:	200002a8 	.word	0x200002a8
    4574:	0000416d 	.word	0x0000416d
    4578:	20000200 	.word	0x20000200
    457c:	20000318 	.word	0x20000318
    4580:	20000478 	.word	0x20000478

00004584 <_Z8drawSuitss4Suit>:

  drawSuit(x + 1, y + 2, card.getSuit());
  drawValue(x + 5, y + 7, card.getValue(), card.isRed());
}

void drawSuit(int16_t x, int16_t y, Suit suit) {
    4584:	b570      	push	{r4, r5, r6, lr}
  suitSprite.setFrame(suit);
    4586:	4c07      	ldr	r4, [pc, #28]	; (45a4 <_Z8drawSuitss4Suit+0x20>)

  drawSuit(x + 1, y + 2, card.getSuit());
  drawValue(x + 5, y + 7, card.getValue(), card.isRed());
}

void drawSuit(int16_t x, int16_t y, Suit suit) {
    4588:	1c06      	adds	r6, r0, #0
    458a:	1c0d      	adds	r5, r1, #0
  suitSprite.setFrame(suit);
    458c:	1c20      	adds	r0, r4, #0
    458e:	1c11      	adds	r1, r2, #0
    4590:	f006 fc90 	bl	aeb4 <_ZN14Gamebuino_Meta5Image8setFrameEt>
  gb.display.drawImage(x, y, suitSprite);
    4594:	1c31      	adds	r1, r6, #0
    4596:	1c2a      	adds	r2, r5, #0
    4598:	4803      	ldr	r0, [pc, #12]	; (45a8 <_Z8drawSuitss4Suit+0x24>)
    459a:	1c23      	adds	r3, r4, #0
    459c:	f006 fdb4 	bl	b108 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_>
}
    45a0:	bd70      	pop	{r4, r5, r6, pc}
    45a2:	46c0      	nop			; (mov r8, r8)
    45a4:	200004b0 	.word	0x200004b0
    45a8:	20000a4c 	.word	0x20000a4c

000045ac <_Z9drawValuess5Valueb>:

void drawValue(int16_t x, int16_t y, Value value, bool isRed) {
    45ac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    45ae:	1c0d      	adds	r5, r1, #0
  valueSprite.setFrame(value + (isRed ? 14 : 0));
    45b0:	2100      	movs	r1, #0
void drawSuit(int16_t x, int16_t y, Suit suit) {
  suitSprite.setFrame(suit);
  gb.display.drawImage(x, y, suitSprite);
}

void drawValue(int16_t x, int16_t y, Value value, bool isRed) {
    45b2:	9000      	str	r0, [sp, #0]
    45b4:	1c16      	adds	r6, r2, #0
    45b6:	9301      	str	r3, [sp, #4]
  valueSprite.setFrame(value + (isRed ? 14 : 0));
    45b8:	428b      	cmp	r3, r1
    45ba:	d000      	beq.n	45be <_Z9drawValuess5Valueb+0x12>
    45bc:	210e      	movs	r1, #14
    45be:	4c0f      	ldr	r4, [pc, #60]	; (45fc <_Z9drawValuess5Valueb+0x50>)
    45c0:	1989      	adds	r1, r1, r6
    45c2:	1c20      	adds	r0, r4, #0
    45c4:	f006 fc76 	bl	aeb4 <_ZN14Gamebuino_Meta5Image8setFrameEt>
  gb.display.drawImage(x, y, valueSprite);
    45c8:	4f0d      	ldr	r7, [pc, #52]	; (4600 <_Z9drawValuess5Valueb+0x54>)
    45ca:	9900      	ldr	r1, [sp, #0]
    45cc:	1c38      	adds	r0, r7, #0
    45ce:	1c2a      	adds	r2, r5, #0
    45d0:	1c23      	adds	r3, r4, #0
    45d2:	f006 fd99 	bl	b108 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_>
  
  if (value == ten) {
    45d6:	2e0a      	cmp	r6, #10
    45d8:	d10f      	bne.n	45fa <_Z9drawValuess5Valueb+0x4e>
    valueSprite.setFrame(isRed ? 14 : 0);
    45da:	9b01      	ldr	r3, [sp, #4]
    45dc:	2100      	movs	r1, #0
    45de:	428b      	cmp	r3, r1
    45e0:	d000      	beq.n	45e4 <_Z9drawValuess5Valueb+0x38>
    45e2:	210e      	movs	r1, #14
    45e4:	1c20      	adds	r0, r4, #0
    45e6:	f006 fc65 	bl	aeb4 <_ZN14Gamebuino_Meta5Image8setFrameEt>
    gb.display.drawImage(x - 4, y, valueSprite);
    45ea:	9900      	ldr	r1, [sp, #0]
    45ec:	1c38      	adds	r0, r7, #0
    45ee:	3904      	subs	r1, #4
    45f0:	b209      	sxth	r1, r1
    45f2:	1c2a      	adds	r2, r5, #0
    45f4:	1c23      	adds	r3, r4, #0
    45f6:	f006 fd87 	bl	b108 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_>
  }
}
    45fa:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    45fc:	200004d8 	.word	0x200004d8
    4600:	20000a4c 	.word	0x20000a4c

00004604 <_Z8drawCardss4Card>:
  }

  return pile->y;
}

void drawCard(int16_t x, int16_t y, Card card) {
    4604:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    4606:	ac01      	add	r4, sp, #4
    4608:	1c06      	adds	r6, r0, #0
  cardSprite.setFrame(card.isFaceDown() ? 1 : 0);
    460a:	1c20      	adds	r0, r4, #0
  }

  return pile->y;
}

void drawCard(int16_t x, int16_t y, Card card) {
    460c:	1c0d      	adds	r5, r1, #0
    460e:	7022      	strb	r2, [r4, #0]
  cardSprite.setFrame(card.isFaceDown() ? 1 : 0);
    4610:	f7ff fd88 	bl	4124 <_ZNK4Card10isFaceDownEv>
    4614:	4f15      	ldr	r7, [pc, #84]	; (466c <_Z8drawCardss4Card+0x68>)
    4616:	1c01      	adds	r1, r0, #0
    4618:	1c38      	adds	r0, r7, #0
    461a:	f006 fc4b 	bl	aeb4 <_ZN14Gamebuino_Meta5Image8setFrameEt>
  gb.display.drawImage(x, y, cardSprite);
    461e:	4814      	ldr	r0, [pc, #80]	; (4670 <_Z8drawCardss4Card+0x6c>)
    4620:	1c31      	adds	r1, r6, #0
    4622:	1c2a      	adds	r2, r5, #0
    4624:	1c3b      	adds	r3, r7, #0
    4626:	f006 fd6f 	bl	b108 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_>
  
  if (card.isFaceDown()) return;
    462a:	1c20      	adds	r0, r4, #0
    462c:	f7ff fd7a 	bl	4124 <_ZNK4Card10isFaceDownEv>
    4630:	2800      	cmp	r0, #0
    4632:	d11a      	bne.n	466a <_Z8drawCardss4Card+0x66>

  drawSuit(x + 1, y + 2, card.getSuit());
    4634:	1c20      	adds	r0, r4, #0
    4636:	f7ff fd7c 	bl	4132 <_ZNK4Card7getSuitEv>
    463a:	b2b6      	uxth	r6, r6
    463c:	b2ad      	uxth	r5, r5
    463e:	1c02      	adds	r2, r0, #0
    4640:	1ca9      	adds	r1, r5, #2
    4642:	1c70      	adds	r0, r6, #1
    4644:	b209      	sxth	r1, r1
    4646:	b200      	sxth	r0, r0
    4648:	f7ff ff9c 	bl	4584 <_Z8drawSuitss4Suit>
  drawValue(x + 5, y + 7, card.getValue(), card.isRed());
    464c:	1c20      	adds	r0, r4, #0
    464e:	f7ff fd6c 	bl	412a <_ZNK4Card8getValueEv>
    4652:	1c07      	adds	r7, r0, #0
    4654:	1c20      	adds	r0, r4, #0
    4656:	f7ff fd70 	bl	413a <_ZNK4Card5isRedEv>
    465a:	3605      	adds	r6, #5
    465c:	3507      	adds	r5, #7
    465e:	1c03      	adds	r3, r0, #0
    4660:	b229      	sxth	r1, r5
    4662:	b230      	sxth	r0, r6
    4664:	1c3a      	adds	r2, r7, #0
    4666:	f7ff ffa1 	bl	45ac <_Z9drawValuess5Valueb>
}
    466a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    466c:	20000528 	.word	0x20000528
    4670:	20000a4c 	.word	0x20000a4c

00004674 <_Z11drawDealingv>:
  for (int i = 0; i < 7; i++) {
    drawPile(&tableau[i]);
  }
}

void drawDealing() {
    4674:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (cardAnimationCount < 28 && gb.frameCount % 4 == 0) {
    4676:	4f2b      	ldr	r7, [pc, #172]	; (4724 <_Z11drawDealingv+0xb0>)
    4678:	783b      	ldrb	r3, [r7, #0]
    467a:	2b1b      	cmp	r3, #27
    467c:	d808      	bhi.n	4690 <_Z11drawDealingv+0x1c>
    467e:	4a2a      	ldr	r2, [pc, #168]	; (4728 <_Z11drawDealingv+0xb4>)
    4680:	32fc      	adds	r2, #252	; 0xfc
    4682:	6e12      	ldr	r2, [r2, #96]	; 0x60
    4684:	0791      	lsls	r1, r2, #30
    4686:	d103      	bne.n	4690 <_Z11drawDealingv+0x1c>
    cardAnimationCount++;
    4688:	3301      	adds	r3, #1
    468a:	703b      	strb	r3, [r7, #0]
    playSoundA();
    468c:	f7ff fec6 	bl	441c <_Z10playSoundAv>
  }
  bool doneDealing = cardAnimationCount == 28;
    4690:	783b      	ldrb	r3, [r7, #0]
    4692:	4c26      	ldr	r4, [pc, #152]	; (472c <_Z11drawDealingv+0xb8>)
    4694:	3b1c      	subs	r3, #28
    4696:	425a      	negs	r2, r3
    4698:	4153      	adcs	r3, r2
    469a:	b2db      	uxtb	r3, r3
    469c:	9300      	str	r3, [sp, #0]
    469e:	3404      	adds	r4, #4
  for (int i = 0; i < cardAnimationCount; i++) {
    46a0:	2500      	movs	r5, #0
    46a2:	783b      	ldrb	r3, [r7, #0]
    46a4:	429d      	cmp	r5, r3
    46a6:	da35      	bge.n	4714 <_Z11drawDealingv+0xa0>
    46a8:	1ea6      	subs	r6, r4, #2
    if (cardAnimations[i].x != cardAnimations[i].destX || cardAnimations[i].y != cardAnimations[i].destY) {
    46aa:	2100      	movs	r1, #0
    46ac:	5e70      	ldrsh	r0, [r6, r1]
    46ae:	2202      	movs	r2, #2
    46b0:	5ea3      	ldrsh	r3, [r4, r2]
    46b2:	2200      	movs	r2, #0
    46b4:	5ea1      	ldrsh	r1, [r4, r2]
    46b6:	4283      	cmp	r3, r0
    46b8:	d103      	bne.n	46c2 <_Z11drawDealingv+0x4e>
    46ba:	2204      	movs	r2, #4
    46bc:	5ea3      	ldrsh	r3, [r4, r2]
    46be:	4299      	cmp	r1, r3
    46c0:	d025      	beq.n	470e <_Z11drawDealingv+0x9a>
      doneDealing = false;
      drawCard(cardAnimations[i].x, cardAnimations[i].y, cardAnimations[i].card);
    46c2:	230a      	movs	r3, #10
    46c4:	436b      	muls	r3, r5
    46c6:	4a19      	ldr	r2, [pc, #100]	; (472c <_Z11drawDealingv+0xb8>)
    46c8:	9301      	str	r3, [sp, #4]
    46ca:	5c9a      	ldrb	r2, [r3, r2]
    46cc:	f7ff ff9a 	bl	4604 <_Z8drawCardss4Card>
      cardAnimations[i].x = updatePosition(cardAnimations[i].x, cardAnimations[i].destX);
    46d0:	7830      	ldrb	r0, [r6, #0]
    46d2:	78a1      	ldrb	r1, [r4, #2]
    46d4:	f7ff fe06 	bl	42e4 <_Z14updatePositionhh>
    46d8:	8030      	strh	r0, [r6, #0]
      cardAnimations[i].y = updatePosition(cardAnimations[i].y, cardAnimations[i].destY);
    46da:	7921      	ldrb	r1, [r4, #4]
    46dc:	7820      	ldrb	r0, [r4, #0]
    46de:	f7ff fe01 	bl	42e4 <_Z14updatePositionhh>
    46e2:	8020      	strh	r0, [r4, #0]
      if (cardAnimations[i].x == cardAnimations[i].destX && cardAnimations[i].y == cardAnimations[i].destY) {
    46e4:	2300      	movs	r3, #0
    46e6:	5ef2      	ldrsh	r2, [r6, r3]
    46e8:	2102      	movs	r1, #2
    46ea:	5e63      	ldrsh	r3, [r4, r1]
    playSoundA();
  }
  bool doneDealing = cardAnimationCount == 28;
  for (int i = 0; i < cardAnimationCount; i++) {
    if (cardAnimations[i].x != cardAnimations[i].destX || cardAnimations[i].y != cardAnimations[i].destY) {
      doneDealing = false;
    46ec:	2100      	movs	r1, #0
    46ee:	9100      	str	r1, [sp, #0]
      drawCard(cardAnimations[i].x, cardAnimations[i].y, cardAnimations[i].card);
      cardAnimations[i].x = updatePosition(cardAnimations[i].x, cardAnimations[i].destX);
      cardAnimations[i].y = updatePosition(cardAnimations[i].y, cardAnimations[i].destY);
      if (cardAnimations[i].x == cardAnimations[i].destX && cardAnimations[i].y == cardAnimations[i].destY) {
    46f0:	429a      	cmp	r2, r3
    46f2:	d10c      	bne.n	470e <_Z11drawDealingv+0x9a>
    46f4:	88a3      	ldrh	r3, [r4, #4]
    46f6:	4298      	cmp	r0, r3
    46f8:	d109      	bne.n	470e <_Z11drawDealingv+0x9a>
    46fa:	1ee3      	subs	r3, r4, #3
        tableau[cardAnimations[i].tableauIndex].addCard(cardAnimations[i].card);
    46fc:	7818      	ldrb	r0, [r3, #0]
    46fe:	4b0c      	ldr	r3, [pc, #48]	; (4730 <_Z11drawDealingv+0xbc>)
    4700:	0100      	lsls	r0, r0, #4
    4702:	1818      	adds	r0, r3, r0
    4704:	9a01      	ldr	r2, [sp, #4]
    4706:	4b09      	ldr	r3, [pc, #36]	; (472c <_Z11drawDealingv+0xb8>)
    4708:	5cd1      	ldrb	r1, [r2, r3]
    470a:	f000 ff53 	bl	55b4 <_ZN4Pile7addCardE4Card>
  if (cardAnimationCount < 28 && gb.frameCount % 4 == 0) {
    cardAnimationCount++;
    playSoundA();
  }
  bool doneDealing = cardAnimationCount == 28;
  for (int i = 0; i < cardAnimationCount; i++) {
    470e:	3501      	adds	r5, #1
    4710:	340a      	adds	r4, #10
    4712:	e7c6      	b.n	46a2 <_Z11drawDealingv+0x2e>
      if (cardAnimations[i].x == cardAnimations[i].destX && cardAnimations[i].y == cardAnimations[i].destY) {
        tableau[cardAnimations[i].tableauIndex].addCard(cardAnimations[i].card);
      }
    }
  }
  if (doneDealing) mode = selecting;
    4714:	9900      	ldr	r1, [sp, #0]
    4716:	2900      	cmp	r1, #0
    4718:	d002      	beq.n	4720 <_Z11drawDealingv+0xac>
    471a:	4b06      	ldr	r3, [pc, #24]	; (4734 <_Z11drawDealingv+0xc0>)
    471c:	2201      	movs	r2, #1
    471e:	701a      	strb	r2, [r3, #0]
}
    4720:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    4722:	46c0      	nop			; (mov r8, r8)
    4724:	200001ec 	.word	0x200001ec
    4728:	20000a3c 	.word	0x20000a3c
    472c:	20000318 	.word	0x20000318
    4730:	200002a8 	.word	0x200002a8
    4734:	200002a0 	.word	0x200002a0

00004738 <_Z8drawPileP4Pile>:
  byte delta = (destination - current) / 4;
  if (delta == 0 && ((gb.frameCount % 2) == 0)) delta = destination > current ? 1 : -1;
  return current + delta;
}

void drawPile(Pile* pile) {
    4738:	b5f0      	push	{r4, r5, r6, r7, lr}
    473a:	b085      	sub	sp, #20
    473c:	1c04      	adds	r4, r0, #0
  int baseIndex = max(0, pile->getCardCount() - MAX_CARDS_DRAWN_IN_PILE);
    473e:	f000 ff43 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    4742:	2300      	movs	r3, #0
    4744:	9301      	str	r3, [sp, #4]
    4746:	280e      	cmp	r0, #14
    4748:	dd04      	ble.n	4754 <_Z8drawPileP4Pile+0x1c>
    474a:	1c20      	adds	r0, r4, #0
    474c:	f000 ff3c 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    4750:	380f      	subs	r0, #15
    4752:	9001      	str	r0, [sp, #4]
  for (int i = 0; i < min(pile->getCardCount(), MAX_CARDS_DRAWN_IN_PILE); i++) {
    4754:	2500      	movs	r5, #0
    4756:	1c20      	adds	r0, r4, #0
    4758:	f000 ff36 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    475c:	230f      	movs	r3, #15
    475e:	280e      	cmp	r0, #14
    4760:	d803      	bhi.n	476a <_Z8drawPileP4Pile+0x32>
    4762:	1c20      	adds	r0, r4, #0
    4764:	f000 ff30 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    4768:	1c03      	adds	r3, r0, #0
    476a:	429d      	cmp	r5, r3
    476c:	da2f      	bge.n	47ce <_Z8drawPileP4Pile+0x96>
    byte cardIndex = pile->getCardCount() - i - 1 - baseIndex;
    476e:	1c20      	adds	r0, r4, #0
    4770:	f000 ff2a 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    4774:	9b01      	ldr	r3, [sp, #4]
    4776:	006f      	lsls	r7, r5, #1
    4778:	43d9      	mvns	r1, r3
    477a:	1b49      	subs	r1, r1, r5
    477c:	1841      	adds	r1, r0, r1
    477e:	b2c9      	uxtb	r1, r1
    if (cardIndex == 0) {
    4780:	2900      	cmp	r1, #0
    4782:	d10c      	bne.n	479e <_Z8drawPileP4Pile+0x66>
      drawCard(pile->x, pile->y + 2 * i, pile->getCard(cardIndex));
    4784:	8863      	ldrh	r3, [r4, #2]
    4786:	1c20      	adds	r0, r4, #0
    4788:	8826      	ldrh	r6, [r4, #0]
    478a:	18ff      	adds	r7, r7, r3
    478c:	f000 ff1e 	bl	55cc <_ZNK4Pile7getCardEi>
    4790:	b2bf      	uxth	r7, r7
    4792:	1c02      	adds	r2, r0, #0
    4794:	b239      	sxth	r1, r7
    4796:	b230      	sxth	r0, r6
    4798:	f7ff ff34 	bl	4604 <_Z8drawCardss4Card>
    479c:	e015      	b.n	47ca <_Z8drawPileP4Pile+0x92>
    }
    else {
      Card card = pile->getCard(cardIndex);
    479e:	1c20      	adds	r0, r4, #0
    47a0:	f000 ff14 	bl	55cc <_ZNK4Pile7getCardEi>
    47a4:	ab03      	add	r3, sp, #12
    47a6:	7018      	strb	r0, [r3, #0]
      cardTopSprite.setFrame(card.isFaceDown() ? 1 : 0);
    47a8:	1c18      	adds	r0, r3, #0
    47aa:	f7ff fcbb 	bl	4124 <_ZNK4Card10isFaceDownEv>
    47ae:	4e09      	ldr	r6, [pc, #36]	; (47d4 <_Z8drawPileP4Pile+0x9c>)
    47b0:	1c01      	adds	r1, r0, #0
    47b2:	1c30      	adds	r0, r6, #0
    47b4:	f006 fb7e 	bl	aeb4 <_ZN14Gamebuino_Meta5Image8setFrameEt>
      gb.display.drawImage(pile->x, pile->y + 2 * i, cardTopSprite);
    47b8:	8862      	ldrh	r2, [r4, #2]
    47ba:	2300      	movs	r3, #0
    47bc:	5ee1      	ldrsh	r1, [r4, r3]
    47be:	18bf      	adds	r7, r7, r2
    47c0:	b23a      	sxth	r2, r7
    47c2:	4805      	ldr	r0, [pc, #20]	; (47d8 <_Z8drawPileP4Pile+0xa0>)
    47c4:	1c33      	adds	r3, r6, #0
    47c6:	f006 fc9f 	bl	b108 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_>
  return current + delta;
}

void drawPile(Pile* pile) {
  int baseIndex = max(0, pile->getCardCount() - MAX_CARDS_DRAWN_IN_PILE);
  for (int i = 0; i < min(pile->getCardCount(), MAX_CARDS_DRAWN_IN_PILE); i++) {
    47ca:	3501      	adds	r5, #1
    47cc:	e7c3      	b.n	4756 <_Z8drawPileP4Pile+0x1e>
      Card card = pile->getCard(cardIndex);
      cardTopSprite.setFrame(card.isFaceDown() ? 1 : 0);
      gb.display.drawImage(pile->x, pile->y + 2 * i, cardTopSprite);
    }
  }
}
    47ce:	b005      	add	sp, #20
    47d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    47d2:	46c0      	nop			; (mov r8, r8)
    47d4:	20000550 	.word	0x20000550
    47d8:	20000a4c 	.word	0x20000a4c

000047dc <_Z16drawDrawingCardsv>:
    }
  }
  if (doneDealing) mode = selecting;
}

void drawDrawingCards() {
    47dc:	b5f0      	push	{r4, r5, r6, r7, lr}
  drawPile(&moving);
    47de:	4c23      	ldr	r4, [pc, #140]	; (486c <_Z16drawDrawingCardsv+0x90>)
    }
  }
  if (doneDealing) mode = selecting;
}

void drawDrawingCards() {
    47e0:	b087      	sub	sp, #28
  drawPile(&moving);
    47e2:	1c20      	adds	r0, r4, #0
    47e4:	f7ff ffa8 	bl	4738 <_Z8drawPileP4Pile>
  moving.x = updatePosition(moving.x, talonDeck.x + 2);
    47e8:	4d21      	ldr	r5, [pc, #132]	; (4870 <_Z16drawDrawingCardsv+0x94>)
    47ea:	7820      	ldrb	r0, [r4, #0]
    47ec:	882f      	ldrh	r7, [r5, #0]
    47ee:	1cb9      	adds	r1, r7, #2
    47f0:	b2c9      	uxtb	r1, r1
    47f2:	f7ff fd77 	bl	42e4 <_Z14updatePositionhh>
    47f6:	8020      	strh	r0, [r4, #0]
  moving.y = updatePosition(moving.y, talonDeck.y);
    47f8:	886b      	ldrh	r3, [r5, #2]
  if (doneDealing) mode = selecting;
}

void drawDrawingCards() {
  drawPile(&moving);
  moving.x = updatePosition(moving.x, talonDeck.x + 2);
    47fa:	1c06      	adds	r6, r0, #0
  moving.y = updatePosition(moving.y, talonDeck.y);
    47fc:	9301      	str	r3, [sp, #4]
    47fe:	78a0      	ldrb	r0, [r4, #2]
    4800:	b2d9      	uxtb	r1, r3
    4802:	f7ff fd6f 	bl	42e4 <_Z14updatePositionhh>
  if (moving.x == talonDeck.x + 2 && moving.y == talonDeck.y) {
    4806:	b23f      	sxth	r7, r7
    4808:	3702      	adds	r7, #2
}

void drawDrawingCards() {
  drawPile(&moving);
  moving.x = updatePosition(moving.x, talonDeck.x + 2);
  moving.y = updatePosition(moving.y, talonDeck.y);
    480a:	8060      	strh	r0, [r4, #2]
  if (moving.x == talonDeck.x + 2 && moving.y == talonDeck.y) {
    480c:	42be      	cmp	r6, r7
    480e:	d12b      	bne.n	4868 <_Z16drawDrawingCardsv+0x8c>
    4810:	9b01      	ldr	r3, [sp, #4]
    4812:	4283      	cmp	r3, r0
    4814:	d128      	bne.n	4868 <_Z16drawDrawingCardsv+0x8c>
    talonDeck.addCard(moving.getCard(0));
    4816:	2100      	movs	r1, #0
    4818:	1c20      	adds	r0, r4, #0
    481a:	f000 fed7 	bl	55cc <_ZNK4Pile7getCardEi>
    481e:	1c01      	adds	r1, r0, #0
    4820:	1c28      	adds	r0, r5, #0
    4822:	f000 fec7 	bl	55b4 <_ZN4Pile7addCardE4Card>
    if (remainingDraws) {
    4826:	4b13      	ldr	r3, [pc, #76]	; (4874 <_Z16drawDrawingCardsv+0x98>)
    4828:	781a      	ldrb	r2, [r3, #0]
    482a:	2a00      	cmp	r2, #0
    482c:	d010      	beq.n	4850 <_Z16drawDrawingCardsv+0x74>
      remainingDraws--;
    482e:	3a01      	subs	r2, #1
      moving.empty();
    4830:	1c20      	adds	r0, r4, #0
  moving.x = updatePosition(moving.x, talonDeck.x + 2);
  moving.y = updatePosition(moving.y, talonDeck.y);
  if (moving.x == talonDeck.x + 2 && moving.y == talonDeck.y) {
    talonDeck.addCard(moving.getCard(0));
    if (remainingDraws) {
      remainingDraws--;
    4832:	701a      	strb	r2, [r3, #0]
      moving.empty();
    4834:	f000 ff12 	bl	565c <_ZN4Pile5emptyEv>
      drawAndFlip(&stockDeck, &moving);
    4838:	4d0f      	ldr	r5, [pc, #60]	; (4878 <_Z16drawDrawingCardsv+0x9c>)
    483a:	1c21      	adds	r1, r4, #0
    483c:	1c28      	adds	r0, r5, #0
    483e:	f7ff fe05 	bl	444c <_Z11drawAndFlipP4PileS0_>
      moving.x = stockDeck.x;
    4842:	882b      	ldrh	r3, [r5, #0]
    4844:	8023      	strh	r3, [r4, #0]
      moving.y = stockDeck.y;
    4846:	886b      	ldrh	r3, [r5, #2]
    4848:	8063      	strh	r3, [r4, #2]
      playSoundA();
    484a:	f7ff fde7 	bl	441c <_Z10playSoundAv>
    484e:	e00b      	b.n	4868 <_Z16drawDrawingCardsv+0x8c>
    }
    else {
      UndoAction action;
      action.setDraw();
      undo.pushAction(action);
    4850:	ab03      	add	r3, sp, #12
    4852:	2240      	movs	r2, #64	; 0x40
    4854:	701a      	strb	r2, [r3, #0]
    4856:	4809      	ldr	r0, [pc, #36]	; (487c <_Z16drawDrawingCardsv+0xa0>)
    4858:	9a04      	ldr	r2, [sp, #16]
    485a:	9b05      	ldr	r3, [sp, #20]
    485c:	9903      	ldr	r1, [sp, #12]
    485e:	f000 fff8 	bl	5852 <_ZN9UndoStack10pushActionE10UndoAction>
      mode = selecting;
    4862:	4b07      	ldr	r3, [pc, #28]	; (4880 <_Z16drawDrawingCardsv+0xa4>)
    4864:	2201      	movs	r2, #1
    4866:	701a      	strb	r2, [r3, #0]
    }
  }
}
    4868:	b007      	add	sp, #28
    486a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    486c:	200001f0 	.word	0x200001f0
    4870:	20000290 	.word	0x20000290
    4874:	200002a3 	.word	0x200002a3
    4878:	20000280 	.word	0x20000280
    487c:	20000200 	.word	0x20000200
    4880:	200002a0 	.word	0x200002a0

00004884 <_Z14drawMovingPilev>:

void drawMovingPile() {
    4884:	b570      	push	{r4, r5, r6, lr}
  drawPile(&moving);
    4886:	4c0e      	ldr	r4, [pc, #56]	; (48c0 <_Z14drawMovingPilev+0x3c>)
  Pile* pile = getActiveLocationPile();
  byte yDelta = 2;
    4888:	2602      	movs	r6, #2
    }
  }
}

void drawMovingPile() {
  drawPile(&moving);
    488a:	1c20      	adds	r0, r4, #0
    488c:	f7ff ff54 	bl	4738 <_Z8drawPileP4Pile>
  Pile* pile = getActiveLocationPile();
    4890:	f7ff fd00 	bl	4294 <_Z21getActiveLocationPilev>
  byte yDelta = 2;
  if (pile->isTableau) yDelta += 2 * pile->getCardCount();
    4894:	7903      	ldrb	r3, [r0, #4]
  }
}

void drawMovingPile() {
  drawPile(&moving);
  Pile* pile = getActiveLocationPile();
    4896:	1c05      	adds	r5, r0, #0
  byte yDelta = 2;
  if (pile->isTableau) yDelta += 2 * pile->getCardCount();
    4898:	2b00      	cmp	r3, #0
    489a:	d004      	beq.n	48a6 <_Z14drawMovingPilev+0x22>
    489c:	f000 fe94 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    48a0:	0046      	lsls	r6, r0, #1
    48a2:	3602      	adds	r6, #2
    48a4:	b2f6      	uxtb	r6, r6
  moving.x = updatePosition(moving.x, pile->x);
    48a6:	7829      	ldrb	r1, [r5, #0]
    48a8:	7820      	ldrb	r0, [r4, #0]
    48aa:	f7ff fd1b 	bl	42e4 <_Z14updatePositionhh>
    48ae:	8020      	strh	r0, [r4, #0]
  moving.y = updatePosition(moving.y, pile->y + yDelta);  
    48b0:	8869      	ldrh	r1, [r5, #2]
    48b2:	78a0      	ldrb	r0, [r4, #2]
    48b4:	1876      	adds	r6, r6, r1
    48b6:	b2f1      	uxtb	r1, r6
    48b8:	f7ff fd14 	bl	42e4 <_Z14updatePositionhh>
    48bc:	8060      	strh	r0, [r4, #2]
}
    48be:	bd70      	pop	{r4, r5, r6, pc}
    48c0:	200001f0 	.word	0x200001f0

000048c4 <_Z9drawBoardv>:
        // writeEeprom(false);
      }
  }
}

void drawBoard() {
    48c4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  // Background
  gb.display.drawImage(0, 0, backgroundImage);
    48c6:	4d30      	ldr	r5, [pc, #192]	; (4988 <_Z9drawBoardv+0xc4>)
    48c8:	2100      	movs	r1, #0
    48ca:	1c28      	adds	r0, r5, #0
    48cc:	1c0a      	adds	r2, r1, #0
    48ce:	4b2f      	ldr	r3, [pc, #188]	; (498c <_Z9drawBoardv+0xc8>)
    48d0:	f006 fc1a 	bl	b108 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_>
  
  // Stock
  if (stockDeck.getCardCount() != 0) {
    48d4:	4c2e      	ldr	r4, [pc, #184]	; (4990 <_Z9drawBoardv+0xcc>)
    48d6:	1c20      	adds	r0, r4, #0
    48d8:	f000 fe76 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    48dc:	2800      	cmp	r0, #0
    48de:	d00d      	beq.n	48fc <_Z9drawBoardv+0x38>
    drawCard(stockDeck.x, stockDeck.y, Card(ace, spade, true));
    48e0:	8826      	ldrh	r6, [r4, #0]
    48e2:	8867      	ldrh	r7, [r4, #2]
    48e4:	2101      	movs	r1, #1
    48e6:	ac01      	add	r4, sp, #4
    48e8:	2200      	movs	r2, #0
    48ea:	1c0b      	adds	r3, r1, #0
    48ec:	1c20      	adds	r0, r4, #0
    48ee:	f7ff fc11 	bl	4114 <_ZN4CardC1E5Value4Suitb>
    48f2:	b230      	sxth	r0, r6
    48f4:	b239      	sxth	r1, r7
    48f6:	7822      	ldrb	r2, [r4, #0]
    48f8:	f7ff fe84 	bl	4604 <_Z8drawCardss4Card>
  }
  
  // Talon
  if (talonDeck.getCardCount() > 0) {
    48fc:	4c25      	ldr	r4, [pc, #148]	; (4994 <_Z9drawBoardv+0xd0>)
    48fe:	1c20      	adds	r0, r4, #0
    4900:	f000 fe62 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    4904:	2800      	cmp	r0, #0
    4906:	d01f      	beq.n	4948 <_Z9drawBoardv+0x84>
    gb.display.drawImage(talonDeck.x, talonDeck.y, talonBackgroundImage);
    4908:	2300      	movs	r3, #0
    490a:	5ee1      	ldrsh	r1, [r4, r3]
    490c:	2302      	movs	r3, #2
    490e:	5ee2      	ldrsh	r2, [r4, r3]
    4910:	1c28      	adds	r0, r5, #0
    4912:	4b21      	ldr	r3, [pc, #132]	; (4998 <_Z9drawBoardv+0xd4>)
    4914:	f006 fbf8 	bl	b108 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_>
    drawCard(talonDeck.x + (min(3, talonDeck.getCardCount()) - 1) * 2, talonDeck.y, talonDeck.getCard(0));
    4918:	1c20      	adds	r0, r4, #0
    491a:	8827      	ldrh	r7, [r4, #0]
    491c:	f000 fe54 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    4920:	2504      	movs	r5, #4
    4922:	2803      	cmp	r0, #3
    4924:	d805      	bhi.n	4932 <_Z9drawBoardv+0x6e>
    4926:	1c20      	adds	r0, r4, #0
    4928:	f000 fe4e 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    492c:	1e45      	subs	r5, r0, #1
    492e:	006d      	lsls	r5, r5, #1
    4930:	b2ad      	uxth	r5, r5
    4932:	2100      	movs	r1, #0
    4934:	1c20      	adds	r0, r4, #0
    4936:	8866      	ldrh	r6, [r4, #2]
    4938:	f000 fe48 	bl	55cc <_ZNK4Pile7getCardEi>
    493c:	19ed      	adds	r5, r5, r7
    493e:	1c02      	adds	r2, r0, #0
    4940:	b231      	sxth	r1, r6
    4942:	b228      	sxth	r0, r5
    4944:	f7ff fe5e 	bl	4604 <_Z8drawCardss4Card>
    4948:	4c14      	ldr	r4, [pc, #80]	; (499c <_Z9drawBoardv+0xd8>)
    494a:	1c25      	adds	r5, r4, #0
    494c:	3540      	adds	r5, #64	; 0x40
  }
  
  // Foundations
  for (int i = 0; i < 4; i++) {
    if (foundations[i].getCardCount() != 0) {
    494e:	1c20      	adds	r0, r4, #0
    4950:	f000 fe3a 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    4954:	2800      	cmp	r0, #0
    4956:	d00a      	beq.n	496e <_Z9drawBoardv+0xaa>
      drawCard(foundations[i].x, foundations[i].y, foundations[i].getCard(0));
    4958:	2100      	movs	r1, #0
    495a:	1c20      	adds	r0, r4, #0
    495c:	8827      	ldrh	r7, [r4, #0]
    495e:	8866      	ldrh	r6, [r4, #2]
    4960:	f000 fe34 	bl	55cc <_ZNK4Pile7getCardEi>
    4964:	b231      	sxth	r1, r6
    4966:	1c02      	adds	r2, r0, #0
    4968:	b238      	sxth	r0, r7
    496a:	f7ff fe4b 	bl	4604 <_Z8drawCardss4Card>
    496e:	3410      	adds	r4, #16
    gb.display.drawImage(talonDeck.x, talonDeck.y, talonBackgroundImage);
    drawCard(talonDeck.x + (min(3, talonDeck.getCardCount()) - 1) * 2, talonDeck.y, talonDeck.getCard(0));
  }
  
  // Foundations
  for (int i = 0; i < 4; i++) {
    4970:	42ac      	cmp	r4, r5
    4972:	d1ec      	bne.n	494e <_Z9drawBoardv+0x8a>
    4974:	4c0a      	ldr	r4, [pc, #40]	; (49a0 <_Z9drawBoardv+0xdc>)
    4976:	1c25      	adds	r5, r4, #0
    4978:	3570      	adds	r5, #112	; 0x70
    }
  }
  
  // Tableau
  for (int i = 0; i < 7; i++) {
    drawPile(&tableau[i]);
    497a:	1c20      	adds	r0, r4, #0
    497c:	3410      	adds	r4, #16
    497e:	f7ff fedb 	bl	4738 <_Z8drawPileP4Pile>
      drawCard(foundations[i].x, foundations[i].y, foundations[i].getCard(0));
    }
  }
  
  // Tableau
  for (int i = 0; i < 7; i++) {
    4982:	42ac      	cmp	r4, r5
    4984:	d1f9      	bne.n	497a <_Z9drawBoardv+0xb6>
    drawPile(&tableau[i]);
  }
}
    4986:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    4988:	20000a4c 	.word	0x20000a4c
    498c:	20000578 	.word	0x20000578
    4990:	20000280 	.word	0x20000280
    4994:	20000290 	.word	0x20000290
    4998:	20000500 	.word	0x20000500
    499c:	20000438 	.word	0x20000438
    49a0:	200002a8 	.word	0x200002a8

000049a4 <_Z12setupNewGamev>:
  setupNewGame();
  
  // testWinningAnimation();
}

void setupNewGame() {
    49a4:	b5f0      	push	{r4, r5, r6, r7, lr}
  gb.lights.fill(BLACK);
    49a6:	2100      	movs	r1, #0
  setupNewGame();
  
  // testWinningAnimation();
}

void setupNewGame() {
    49a8:	b087      	sub	sp, #28
  gb.lights.fill(BLACK);
    49aa:	4845      	ldr	r0, [pc, #276]	; (4ac0 <_Z12setupNewGamev+0x11c>)
    49ac:	f005 f9d6 	bl	9d5c <_ZN14Gamebuino_Meta8Graphics4fillENS_5ColorE>
  
  talonDeck.empty();
    49b0:	4844      	ldr	r0, [pc, #272]	; (4ac4 <_Z12setupNewGamev+0x120>)
    49b2:	f000 fe53 	bl	565c <_ZN4Pile5emptyEv>
  stockDeck.newDeck();
    49b6:	4c44      	ldr	r4, [pc, #272]	; (4ac8 <_Z12setupNewGamev+0x124>)
    49b8:	1c20      	adds	r0, r4, #0
    49ba:	f000 fe6d 	bl	5698 <_ZN4Pile7newDeckEv>
  stockDeck.shuffle();
    49be:	1c20      	adds	r0, r4, #0
    49c0:	f000 fe4f 	bl	5662 <_ZN4Pile7shuffleEv>
  for (int i = 0; i < 4; i++) {
    foundations[i].empty();
    49c4:	4c41      	ldr	r4, [pc, #260]	; (4acc <_Z12setupNewGamev+0x128>)
    49c6:	1c20      	adds	r0, r4, #0
    49c8:	f000 fe48 	bl	565c <_ZN4Pile5emptyEv>
    49cc:	1c20      	adds	r0, r4, #0
    49ce:	3010      	adds	r0, #16
    49d0:	f000 fe44 	bl	565c <_ZN4Pile5emptyEv>
    49d4:	1c20      	adds	r0, r4, #0
    49d6:	3020      	adds	r0, #32
    49d8:	f000 fe40 	bl	565c <_ZN4Pile5emptyEv>
    49dc:	1c20      	adds	r0, r4, #0
    49de:	3030      	adds	r0, #48	; 0x30
    49e0:	f000 fe3c 	bl	565c <_ZN4Pile5emptyEv>
    49e4:	4d3a      	ldr	r5, [pc, #232]	; (4ad0 <_Z12setupNewGamev+0x12c>)
    49e6:	4c3a      	ldr	r4, [pc, #232]	; (4ad0 <_Z12setupNewGamev+0x12c>)
    49e8:	3570      	adds	r5, #112	; 0x70
  }
  for (int i = 0; i < 7; i++) {
    tableau[i].empty();
    49ea:	1c20      	adds	r0, r4, #0
    49ec:	3410      	adds	r4, #16
    49ee:	f000 fe35 	bl	565c <_ZN4Pile5emptyEv>
  stockDeck.newDeck();
  stockDeck.shuffle();
  for (int i = 0; i < 4; i++) {
    foundations[i].empty();
  }
  for (int i = 0; i < 7; i++) {
    49f2:	42ac      	cmp	r4, r5
    49f4:	d1f9      	bne.n	49ea <_Z12setupNewGamev+0x46>
    tableau[i].empty();
  }

  // Put the cursor at the stock.
  activeLocation = stock;
    49f6:	4b37      	ldr	r3, [pc, #220]	; (4ad4 <_Z12setupNewGamev+0x130>)
  bool unused;
  getCursorDestination(cursorX, cursorY, unused);
    49f8:	466a      	mov	r2, sp
  for (int i = 0; i < 7; i++) {
    tableau[i].empty();
  }

  // Put the cursor at the stock.
  activeLocation = stock;
    49fa:	2400      	movs	r4, #0
  bool unused;
  getCursorDestination(cursorX, cursorY, unused);
    49fc:	4836      	ldr	r0, [pc, #216]	; (4ad8 <_Z12setupNewGamev+0x134>)
    49fe:	4937      	ldr	r1, [pc, #220]	; (4adc <_Z12setupNewGamev+0x138>)
    4a00:	320b      	adds	r2, #11
  for (int i = 0; i < 7; i++) {
    tableau[i].empty();
  }

  // Put the cursor at the stock.
  activeLocation = stock;
    4a02:	701c      	strb	r4, [r3, #0]
  bool unused;
  getCursorDestination(cursorX, cursorY, unused);
    4a04:	f7ff fca2 	bl	434c <_Z20getCursorDestinationRhS_Rb>

  // Initialize the data structure to deal out the initial board.
  cardAnimationCount = 0;
    4a08:	4b35      	ldr	r3, [pc, #212]	; (4ae0 <_Z12setupNewGamev+0x13c>)
    4a0a:	701c      	strb	r4, [r3, #0]
    4a0c:	0063      	lsls	r3, r4, #1
    4a0e:	b29b      	uxth	r3, r3
    4a10:	482f      	ldr	r0, [pc, #188]	; (4ad0 <_Z12setupNewGamev+0x12c>)
    4a12:	9301      	str	r3, [sp, #4]
    4a14:	0123      	lsls	r3, r4, #4
    4a16:	181b      	adds	r3, r3, r0
    4a18:	9300      	str	r3, [sp, #0]
  
  talonDeck.empty();
  stockDeck.newDeck();
  stockDeck.shuffle();
  for (int i = 0; i < 4; i++) {
    foundations[i].empty();
    4a1a:	1c25      	adds	r5, r4, #0

  // Initialize the data structure to deal out the initial board.
  cardAnimationCount = 0;
  for (int i = 0; i < 7; i++) {
    for (int j = i; j < 7; j++) {
      Card card = stockDeck.removeTopCard();
    4a1c:	482a      	ldr	r0, [pc, #168]	; (4ac8 <_Z12setupNewGamev+0x124>)
    4a1e:	f000 fdf6 	bl	560e <_ZN4Pile13removeTopCardEv>
    4a22:	4669      	mov	r1, sp
    4a24:	7208      	strb	r0, [r1, #8]
      if (i == j) card.flip();
    4a26:	42ac      	cmp	r4, r5
    4a28:	d102      	bne.n	4a30 <_Z12setupNewGamev+0x8c>
    4a2a:	a802      	add	r0, sp, #8
    4a2c:	f7ff fb91 	bl	4152 <_ZN4Card4flipEv>
      cardAnimations[cardAnimationCount] = CardAnimation();
    4a30:	4a2b      	ldr	r2, [pc, #172]	; (4ae0 <_Z12setupNewGamev+0x13c>)
    4a32:	260a      	movs	r6, #10
    4a34:	7817      	ldrb	r7, [r2, #0]
    4a36:	2100      	movs	r1, #0
    4a38:	1c32      	adds	r2, r6, #0
    4a3a:	4377      	muls	r7, r6
    4a3c:	a803      	add	r0, sp, #12
    4a3e:	f00c fdc5 	bl	115cc <memset>
Pile foundations[4] = { Pile(13), Pile(13), Pile(13), Pile(13) };
Pile tableau[7] = { Pile(20), Pile(20), Pile(20), Pile(20), Pile(20), Pile(20), Pile(20) };

UndoStack undo;

struct CardAnimation {
    4a42:	a803      	add	r0, sp, #12
    4a44:	f7ff fbb6 	bl	41b4 <_ZN4CardC1Ev>
  cardAnimationCount = 0;
  for (int i = 0; i < 7; i++) {
    for (int j = i; j < 7; j++) {
      Card card = stockDeck.removeTopCard();
      if (i == j) card.flip();
      cardAnimations[cardAnimationCount] = CardAnimation();
    4a48:	4b26      	ldr	r3, [pc, #152]	; (4ae4 <_Z12setupNewGamev+0x140>)
    4a4a:	1c32      	adds	r2, r6, #0
    4a4c:	19d8      	adds	r0, r3, r7
    4a4e:	a903      	add	r1, sp, #12
    4a50:	f00c fdb3 	bl	115ba <memcpy>
      cardAnimations[cardAnimationCount].x = 2;
    4a54:	4822      	ldr	r0, [pc, #136]	; (4ae0 <_Z12setupNewGamev+0x13c>)
    4a56:	4923      	ldr	r1, [pc, #140]	; (4ae4 <_Z12setupNewGamev+0x140>)
    4a58:	7802      	ldrb	r2, [r0, #0]
      cardAnimations[cardAnimationCount].y = 2;
      cardAnimations[cardAnimationCount].destX = tableau[j].x;
    4a5a:	9800      	ldr	r0, [sp, #0]
  for (int i = 0; i < 7; i++) {
    for (int j = i; j < 7; j++) {
      Card card = stockDeck.removeTopCard();
      if (i == j) card.flip();
      cardAnimations[cardAnimationCount] = CardAnimation();
      cardAnimations[cardAnimationCount].x = 2;
    4a5c:	4356      	muls	r6, r2
    4a5e:	198b      	adds	r3, r1, r6
      cardAnimations[cardAnimationCount].y = 2;
      cardAnimations[cardAnimationCount].destX = tableau[j].x;
    4a60:	8801      	ldrh	r1, [r0, #0]
  for (int i = 0; i < 7; i++) {
    for (int j = i; j < 7; j++) {
      Card card = stockDeck.removeTopCard();
      if (i == j) card.flip();
      cardAnimations[cardAnimationCount] = CardAnimation();
      cardAnimations[cardAnimationCount].x = 2;
    4a62:	2702      	movs	r7, #2
      cardAnimations[cardAnimationCount].y = 2;
      cardAnimations[cardAnimationCount].destX = tableau[j].x;
    4a64:	80d9      	strh	r1, [r3, #6]
      cardAnimations[cardAnimationCount].destY = tableau[j].y + 2 * i;
    4a66:	8841      	ldrh	r1, [r0, #2]
    4a68:	9801      	ldr	r0, [sp, #4]
      cardAnimations[cardAnimationCount].tableauIndex = j;
    4a6a:	705d      	strb	r5, [r3, #1]
      if (i == j) card.flip();
      cardAnimations[cardAnimationCount] = CardAnimation();
      cardAnimations[cardAnimationCount].x = 2;
      cardAnimations[cardAnimationCount].y = 2;
      cardAnimations[cardAnimationCount].destX = tableau[j].x;
      cardAnimations[cardAnimationCount].destY = tableau[j].y + 2 * i;
    4a6c:	1841      	adds	r1, r0, r1
    4a6e:	8119      	strh	r1, [r3, #8]
      cardAnimations[cardAnimationCount].tableauIndex = j;
      cardAnimations[cardAnimationCount].card = card;
    4a70:	4669      	mov	r1, sp
  for (int i = 0; i < 7; i++) {
    for (int j = i; j < 7; j++) {
      Card card = stockDeck.removeTopCard();
      if (i == j) card.flip();
      cardAnimations[cardAnimationCount] = CardAnimation();
      cardAnimations[cardAnimationCount].x = 2;
    4a72:	805f      	strh	r7, [r3, #2]
      cardAnimations[cardAnimationCount].y = 2;
    4a74:	809f      	strh	r7, [r3, #4]
      cardAnimations[cardAnimationCount].destX = tableau[j].x;
      cardAnimations[cardAnimationCount].destY = tableau[j].y + 2 * i;
      cardAnimations[cardAnimationCount].tableauIndex = j;
      cardAnimations[cardAnimationCount].card = card;
    4a76:	7a0b      	ldrb	r3, [r1, #8]
      cardAnimationCount++;
    4a78:	4919      	ldr	r1, [pc, #100]	; (4ae0 <_Z12setupNewGamev+0x13c>)
    4a7a:	3201      	adds	r2, #1
    4a7c:	700a      	strb	r2, [r1, #0]
    4a7e:	9a00      	ldr	r2, [sp, #0]
      cardAnimations[cardAnimationCount].x = 2;
      cardAnimations[cardAnimationCount].y = 2;
      cardAnimations[cardAnimationCount].destX = tableau[j].x;
      cardAnimations[cardAnimationCount].destY = tableau[j].y + 2 * i;
      cardAnimations[cardAnimationCount].tableauIndex = j;
      cardAnimations[cardAnimationCount].card = card;
    4a80:	4818      	ldr	r0, [pc, #96]	; (4ae4 <_Z12setupNewGamev+0x140>)
    4a82:	3210      	adds	r2, #16
  getCursorDestination(cursorX, cursorY, unused);

  // Initialize the data structure to deal out the initial board.
  cardAnimationCount = 0;
  for (int i = 0; i < 7; i++) {
    for (int j = i; j < 7; j++) {
    4a84:	3501      	adds	r5, #1
      cardAnimations[cardAnimationCount].x = 2;
      cardAnimations[cardAnimationCount].y = 2;
      cardAnimations[cardAnimationCount].destX = tableau[j].x;
      cardAnimations[cardAnimationCount].destY = tableau[j].y + 2 * i;
      cardAnimations[cardAnimationCount].tableauIndex = j;
      cardAnimations[cardAnimationCount].card = card;
    4a86:	5433      	strb	r3, [r6, r0]
    4a88:	9200      	str	r2, [sp, #0]
  getCursorDestination(cursorX, cursorY, unused);

  // Initialize the data structure to deal out the initial board.
  cardAnimationCount = 0;
  for (int i = 0; i < 7; i++) {
    for (int j = i; j < 7; j++) {
    4a8a:	2d07      	cmp	r5, #7
    4a8c:	d1c6      	bne.n	4a1c <_Z12setupNewGamev+0x78>
  bool unused;
  getCursorDestination(cursorX, cursorY, unused);

  // Initialize the data structure to deal out the initial board.
  cardAnimationCount = 0;
  for (int i = 0; i < 7; i++) {
    4a8e:	3401      	adds	r4, #1
    4a90:	2c07      	cmp	r4, #7
    4a92:	d1bb      	bne.n	4a0c <_Z12setupNewGamev+0x68>
      cardAnimations[cardAnimationCount].tableauIndex = j;
      cardAnimations[cardAnimationCount].card = card;
      cardAnimationCount++;
    }
  }
  cardAnimationCount = 0;
    4a94:	4912      	ldr	r1, [pc, #72]	; (4ae0 <_Z12setupNewGamev+0x13c>)
    4a96:	2400      	movs	r4, #0
    4a98:	700c      	strb	r4, [r1, #0]

  drawBoard();
    4a9a:	f7ff ff13 	bl	48c4 <_Z9drawBoardv>
  // Determine easy or hard game.
  cardsToDraw = menu(newGameMenu, 2, false) == 0 ? 1 : 3;
    4a9e:	4812      	ldr	r0, [pc, #72]	; (4ae8 <_Z12setupNewGamev+0x144>)
    4aa0:	1c39      	adds	r1, r7, #0
    4aa2:	1c22      	adds	r2, r4, #0
    4aa4:	f001 f818 	bl	5ad8 <_Z4menuPKPKcib>
    4aa8:	2303      	movs	r3, #3
    4aaa:	42a0      	cmp	r0, r4
    4aac:	d100      	bne.n	4ab0 <_Z12setupNewGamev+0x10c>
    4aae:	2301      	movs	r3, #1
    4ab0:	4a0e      	ldr	r2, [pc, #56]	; (4aec <_Z12setupNewGamev+0x148>)
    4ab2:	7013      	strb	r3, [r2, #0]
  mode = dealing; 
    4ab4:	4b0e      	ldr	r3, [pc, #56]	; (4af0 <_Z12setupNewGamev+0x14c>)
    4ab6:	2200      	movs	r2, #0
    4ab8:	701a      	strb	r2, [r3, #0]
}
    4aba:	b007      	add	sp, #28
    4abc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4abe:	46c0      	nop			; (mov r8, r8)
    4ac0:	20000acc 	.word	0x20000acc
    4ac4:	20000290 	.word	0x20000290
    4ac8:	20000280 	.word	0x20000280
    4acc:	20000438 	.word	0x20000438
    4ad0:	200002a8 	.word	0x200002a8
    4ad4:	2000027c 	.word	0x2000027c
    4ad8:	200002a1 	.word	0x200002a1
    4adc:	200002a2 	.word	0x200002a2
    4ae0:	200001ec 	.word	0x200001ec
    4ae4:	20000318 	.word	0x20000318
    4ae8:	00011914 	.word	0x00011914
    4aec:	20000004 	.word	0x20000004
    4af0:	200002a0 	.word	0x200002a0

00004af4 <setup>:
};

const uint16_t patternA[] = {0x0045, 0x0118, 0x0000};
const uint16_t patternB[] = {0x0045, 0x0108, 0x0000};

void setup() {
    4af4:	b510      	push	{r4, lr}
  gb.begin();
    4af6:	4c1d      	ldr	r4, [pc, #116]	; (4b6c <setup+0x78>)
    4af8:	1c20      	adds	r0, r4, #0
    4afa:	f002 facd 	bl	7098 <_ZN14Gamebuino_Meta9Gamebuino5beginEv>
  gb.setFrameRate(30);
    4afe:	1c20      	adds	r0, r4, #0
    4b00:	211e      	movs	r1, #30
    4b02:	f001 f94a 	bl	5d9a <_ZN14Gamebuino_Meta9Gamebuino12setFrameRateEh>

  initSprites();
    4b06:	f000 fddf 	bl	56c8 <_Z11initSpritesv>
  
  // Initialize positions of piles.
  for (int i = 0; i < 4; i++) {
    foundations[i].x = 35 + i * 11;
    4b0a:	4b19      	ldr	r3, [pc, #100]	; (4b70 <setup+0x7c>)
    4b0c:	202e      	movs	r0, #46	; 0x2e
    4b0e:	2223      	movs	r2, #35	; 0x23
    4b10:	8218      	strh	r0, [r3, #16]
    4b12:	2039      	movs	r0, #57	; 0x39
    4b14:	801a      	strh	r2, [r3, #0]
    4b16:	8418      	strh	r0, [r3, #32]
    foundations[i].y = 2;
    foundations[i].isTableau = false;
    4b18:	2200      	movs	r2, #0
    4b1a:	1d58      	adds	r0, r3, #5
  initSprites();
  
  // Initialize positions of piles.
  for (int i = 0; i < 4; i++) {
    foundations[i].x = 35 + i * 11;
    foundations[i].y = 2;
    4b1c:	2102      	movs	r1, #2
    foundations[i].isTableau = false;
    4b1e:	77c2      	strb	r2, [r0, #31]

  initSprites();
  
  // Initialize positions of piles.
  for (int i = 0; i < 4; i++) {
    foundations[i].x = 35 + i * 11;
    4b20:	2044      	movs	r0, #68	; 0x44
    foundations[i].y = 2;
    4b22:	8059      	strh	r1, [r3, #2]
    foundations[i].isTableau = false;
    4b24:	711a      	strb	r2, [r3, #4]
  initSprites();
  
  // Initialize positions of piles.
  for (int i = 0; i < 4; i++) {
    foundations[i].x = 35 + i * 11;
    foundations[i].y = 2;
    4b26:	8259      	strh	r1, [r3, #18]
    foundations[i].isTableau = false;
    4b28:	751a      	strb	r2, [r3, #20]
  initSprites();
  
  // Initialize positions of piles.
  for (int i = 0; i < 4; i++) {
    foundations[i].x = 35 + i * 11;
    foundations[i].y = 2;
    4b2a:	8459      	strh	r1, [r3, #34]	; 0x22

  initSprites();
  
  // Initialize positions of piles.
  for (int i = 0; i < 4; i++) {
    foundations[i].x = 35 + i * 11;
    4b2c:	8618      	strh	r0, [r3, #48]	; 0x30
    foundations[i].y = 2;
    4b2e:	8659      	strh	r1, [r3, #50]	; 0x32
    foundations[i].isTableau = false;
    4b30:	3334      	adds	r3, #52	; 0x34
    4b32:	701a      	strb	r2, [r3, #0]
    4b34:	1c13      	adds	r3, r2, #0
    4b36:	200b      	movs	r0, #11
    4b38:	4358      	muls	r0, r3
  }
  for (int i = 0; i < 7; i++) {
    tableau[i].x = i * 11 + 2;
    4b3a:	490e      	ldr	r1, [pc, #56]	; (4b74 <setup+0x80>)
    4b3c:	011a      	lsls	r2, r3, #4
    4b3e:	3002      	adds	r0, #2
    4b40:	5250      	strh	r0, [r2, r1]
    4b42:	188a      	adds	r2, r1, r2
    tableau[i].y = 18;
    4b44:	2112      	movs	r1, #18
    4b46:	8051      	strh	r1, [r2, #2]
    tableau[i].isTableau = true;
    4b48:	2101      	movs	r1, #1
  for (int i = 0; i < 4; i++) {
    foundations[i].x = 35 + i * 11;
    foundations[i].y = 2;
    foundations[i].isTableau = false;
  }
  for (int i = 0; i < 7; i++) {
    4b4a:	185b      	adds	r3, r3, r1
    tableau[i].x = i * 11 + 2;
    tableau[i].y = 18;
    tableau[i].isTableau = true;
    4b4c:	7111      	strb	r1, [r2, #4]
  for (int i = 0; i < 4; i++) {
    foundations[i].x = 35 + i * 11;
    foundations[i].y = 2;
    foundations[i].isTableau = false;
  }
  for (int i = 0; i < 7; i++) {
    4b4e:	2b07      	cmp	r3, #7
    4b50:	d1f1      	bne.n	4b36 <setup+0x42>
    tableau[i].x = i * 11 + 2;
    tableau[i].y = 18;
    tableau[i].isTableau = true;
  }
  stockDeck.x = 2;
    4b52:	4a09      	ldr	r2, [pc, #36]	; (4b78 <setup+0x84>)
    4b54:	2302      	movs	r3, #2
  stockDeck.y = 2;
  stockDeck.isTableau = false;
    4b56:	2100      	movs	r1, #0
  for (int i = 0; i < 7; i++) {
    tableau[i].x = i * 11 + 2;
    tableau[i].y = 18;
    tableau[i].isTableau = true;
  }
  stockDeck.x = 2;
    4b58:	8013      	strh	r3, [r2, #0]
  stockDeck.y = 2;
    4b5a:	8053      	strh	r3, [r2, #2]
  stockDeck.isTableau = false;
    4b5c:	7111      	strb	r1, [r2, #4]
  talonDeck.x = 13;
    4b5e:	4a07      	ldr	r2, [pc, #28]	; (4b7c <setup+0x88>)
    4b60:	210d      	movs	r1, #13
    4b62:	8011      	strh	r1, [r2, #0]
  talonDeck.y = 2;
    4b64:	8053      	strh	r3, [r2, #2]
  stockDeck.isTableau = false;

  setupNewGame();
    4b66:	f7ff ff1d 	bl	49a4 <_Z12setupNewGamev>
  
  // testWinningAnimation();
}
    4b6a:	bd10      	pop	{r4, pc}
    4b6c:	20000a3c 	.word	0x20000a3c
    4b70:	20000438 	.word	0x20000438
    4b74:	200002a8 	.word	0x200002a8
    4b78:	20000280 	.word	0x20000280
    4b7c:	20000290 	.word	0x20000290

00004b80 <_Z11drawWonGamev>:
    }
    if (mode != wonGame) mode = selecting;
  }
}

void drawWonGame() {
    4b80:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  // Bounce the cards from the foundations, one at a time.

  // Apply gravity
  bounce.yVelocity += 0x0080;
    4b82:	4c41      	ldr	r4, [pc, #260]	; (4c88 <_Z11drawWonGamev+0x108>)
  bounce.x += bounce.xVelocity;
  bounce.y += bounce.yVelocity;

  // If the card is at the bottom of the screen, reverse the y velocity and scale by 80%.
  if (bounce.y + (14 << 8) > gb.display.width() << 8) {
    4b84:	4d41      	ldr	r5, [pc, #260]	; (4c8c <_Z11drawWonGamev+0x10c>)
void drawWonGame() {
  // Bounce the cards from the foundations, one at a time.

  // Apply gravity
  bounce.yVelocity += 0x0080;
  bounce.x += bounce.xVelocity;
    4b86:	88e2      	ldrh	r2, [r4, #6]
    4b88:	8863      	ldrh	r3, [r4, #2]

void drawWonGame() {
  // Bounce the cards from the foundations, one at a time.

  // Apply gravity
  bounce.yVelocity += 0x0080;
    4b8a:	8926      	ldrh	r6, [r4, #8]
  bounce.x += bounce.xVelocity;
    4b8c:	18d3      	adds	r3, r2, r3
    4b8e:	8063      	strh	r3, [r4, #2]

void drawWonGame() {
  // Bounce the cards from the foundations, one at a time.

  // Apply gravity
  bounce.yVelocity += 0x0080;
    4b90:	3680      	adds	r6, #128	; 0x80
  bounce.x += bounce.xVelocity;
  bounce.y += bounce.yVelocity;
    4b92:	88a3      	ldrh	r3, [r4, #4]

void drawWonGame() {
  // Bounce the cards from the foundations, one at a time.

  // Apply gravity
  bounce.yVelocity += 0x0080;
    4b94:	b2b6      	uxth	r6, r6
    4b96:	8126      	strh	r6, [r4, #8]
  bounce.x += bounce.xVelocity;
  bounce.y += bounce.yVelocity;
    4b98:	18f6      	adds	r6, r6, r3
    4b9a:	b2b6      	uxth	r6, r6

  // If the card is at the bottom of the screen, reverse the y velocity and scale by 80%.
  if (bounce.y + (14 << 8) > gb.display.width() << 8) {
    4b9c:	1c28      	adds	r0, r5, #0
  // Bounce the cards from the foundations, one at a time.

  // Apply gravity
  bounce.yVelocity += 0x0080;
  bounce.x += bounce.xVelocity;
  bounce.y += bounce.yVelocity;
    4b9e:	80a6      	strh	r6, [r4, #4]

  // If the card is at the bottom of the screen, reverse the y velocity and scale by 80%.
  if (bounce.y + (14 << 8) > gb.display.width() << 8) {
    4ba0:	f005 fa32 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
    4ba4:	4a3a      	ldr	r2, [pc, #232]	; (4c90 <_Z11drawWonGamev+0x110>)
    4ba6:	b236      	sxth	r6, r6
    4ba8:	18b6      	adds	r6, r6, r2
    4baa:	0200      	lsls	r0, r0, #8
    4bac:	4286      	cmp	r6, r0
    4bae:	db0f      	blt.n	4bd0 <_Z11drawWonGamev+0x50>
    bounce.y = (gb.display.height() - 14) << 8;
    4bb0:	1c28      	adds	r0, r5, #0
    4bb2:	f005 fa39 	bl	a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>
    4bb6:	380e      	subs	r0, #14
    4bb8:	0200      	lsls	r0, r0, #8
    4bba:	80a0      	strh	r0, [r4, #4]
    bounce.yVelocity = -bounce.yVelocity * 4 / 5;
    4bbc:	2308      	movs	r3, #8
    4bbe:	5ee0      	ldrsh	r0, [r4, r3]
    4bc0:	2105      	movs	r1, #5
    4bc2:	0080      	lsls	r0, r0, #2
    4bc4:	4240      	negs	r0, r0
    4bc6:	f00c fc35 	bl	11434 <__aeabi_idiv>
    4bca:	8120      	strh	r0, [r4, #8]
    playSoundB();
    4bcc:	f7ff fc32 	bl	4434 <_Z10playSoundBv>
  }
  drawCard(bounce.x >> 8, bounce.y >> 8, bounce.card);
    4bd0:	2003      	movs	r0, #3
    4bd2:	2105      	movs	r1, #5
    4bd4:	5661      	ldrsb	r1, [r4, r1]
    4bd6:	7822      	ldrb	r2, [r4, #0]
    4bd8:	5620      	ldrsb	r0, [r4, r0]
    4bda:	f7ff fd13 	bl	4604 <_Z8drawCardss4Card>

  int val = (bounce.y * 255)* 3 / ((gb.display.height() - 14) << 8);
    4bde:	2204      	movs	r2, #4
    4be0:	5ea3      	ldrsh	r3, [r4, r2]
    4be2:	1c28      	adds	r0, r5, #0
    4be4:	005a      	lsls	r2, r3, #1
    4be6:	18d3      	adds	r3, r2, r3
    4be8:	021c      	lsls	r4, r3, #8
    4bea:	1ae4      	subs	r4, r4, r3
    4bec:	f005 fa1c 	bl	a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>
    4bf0:	1c01      	adds	r1, r0, #0
    4bf2:	390e      	subs	r1, #14
    4bf4:	1c20      	adds	r0, r4, #0
    4bf6:	0209      	lsls	r1, r1, #8
    4bf8:	f00c fc1c 	bl	11434 <__aeabi_idiv>
  for (int i = 0; i < 4; i++) {
    4bfc:	2500      	movs	r5, #0
    4bfe:	4246      	negs	r6, r0
    4c00:	1c04      	adds	r4, r0, #0
    Color c = hsvToRgb565(gb.frameCount % 256, 255, max(255 - abs(i * 255 - val), 0));
    4c02:	4b24      	ldr	r3, [pc, #144]	; (4c94 <_Z11drawWonGamev+0x114>)
    4c04:	33fc      	adds	r3, #252	; 0xfc
    4c06:	6e18      	ldr	r0, [r3, #96]	; 0x60
    4c08:	b2c0      	uxtb	r0, r0
    4c0a:	2e00      	cmp	r6, #0
    4c0c:	dd03      	ble.n	4c16 <_Z11drawWonGamev+0x96>
    4c0e:	1c23      	adds	r3, r4, #0
    4c10:	33fe      	adds	r3, #254	; 0xfe
    4c12:	da05      	bge.n	4c20 <_Z11drawWonGamev+0xa0>
    4c14:	e002      	b.n	4c1c <_Z11drawWonGamev+0x9c>
    4c16:	1c32      	adds	r2, r6, #0
    4c18:	32fe      	adds	r2, #254	; 0xfe
    4c1a:	da04      	bge.n	4c26 <_Z11drawWonGamev+0xa6>
    4c1c:	2200      	movs	r2, #0
    4c1e:	e004      	b.n	4c2a <_Z11drawWonGamev+0xaa>
    4c20:	1e62      	subs	r2, r4, #1
    4c22:	b2d2      	uxtb	r2, r2
    4c24:	e001      	b.n	4c2a <_Z11drawWonGamev+0xaa>
    4c26:	43e2      	mvns	r2, r4
    4c28:	b2d2      	uxtb	r2, r2
    4c2a:	21ff      	movs	r1, #255	; 0xff
    4c2c:	f000 fe53 	bl	58d6 <_Z11hsvToRgb565hhh>
    gb.lights.drawPixel(0, i, c);
    4c30:	4f19      	ldr	r7, [pc, #100]	; (4c98 <_Z11drawWonGamev+0x118>)
    4c32:	b22b      	sxth	r3, r5
  }
  drawCard(bounce.x >> 8, bounce.y >> 8, bounce.card);

  int val = (bounce.y * 255)* 3 / ((gb.display.height() - 14) << 8);
  for (int i = 0; i < 4; i++) {
    Color c = hsvToRgb565(gb.frameCount % 256, 255, max(255 - abs(i * 255 - val), 0));
    4c34:	9000      	str	r0, [sp, #0]
    gb.lights.drawPixel(0, i, c);
    4c36:	1c1a      	adds	r2, r3, #0
    4c38:	9301      	str	r3, [sp, #4]
    4c3a:	1c38      	adds	r0, r7, #0
    4c3c:	2100      	movs	r1, #0
    4c3e:	9b00      	ldr	r3, [sp, #0]
    4c40:	f005 f89a 	bl	9d78 <_ZN14Gamebuino_Meta8Graphics9drawPixelEssNS_5ColorE>
    playSoundB();
  }
  drawCard(bounce.x >> 8, bounce.y >> 8, bounce.card);

  int val = (bounce.y * 255)* 3 / ((gb.display.height() - 14) << 8);
  for (int i = 0; i < 4; i++) {
    4c44:	3501      	adds	r5, #1
    Color c = hsvToRgb565(gb.frameCount % 256, 255, max(255 - abs(i * 255 - val), 0));
    gb.lights.drawPixel(0, i, c);
    gb.lights.drawPixel(1, i, c);
    4c46:	1c38      	adds	r0, r7, #0
    4c48:	2101      	movs	r1, #1
    4c4a:	9a01      	ldr	r2, [sp, #4]
    4c4c:	9b00      	ldr	r3, [sp, #0]
    4c4e:	f005 f893 	bl	9d78 <_ZN14Gamebuino_Meta8Graphics9drawPixelEssNS_5ColorE>
    4c52:	36ff      	adds	r6, #255	; 0xff
    4c54:	3cff      	subs	r4, #255	; 0xff
    playSoundB();
  }
  drawCard(bounce.x >> 8, bounce.y >> 8, bounce.card);

  int val = (bounce.y * 255)* 3 / ((gb.display.height() - 14) << 8);
  for (int i = 0; i < 4; i++) {
    4c56:	2d04      	cmp	r5, #4
    4c58:	d1d3      	bne.n	4c02 <_Z11drawWonGamev+0x82>
    gb.lights.drawPixel(0, i, c);
    gb.lights.drawPixel(1, i, c);
  }
  
  // Check to see if the current card is off the screen.
  if (bounce.x + (10 << 8) < 0 || bounce.x > gb.display.width() << 8) {
    4c5a:	4b0b      	ldr	r3, [pc, #44]	; (4c88 <_Z11drawWonGamev+0x108>)
    4c5c:	2202      	movs	r2, #2
    4c5e:	5e9c      	ldrsh	r4, [r3, r2]
    4c60:	4b0e      	ldr	r3, [pc, #56]	; (4c9c <_Z11drawWonGamev+0x11c>)
    4c62:	429c      	cmp	r4, r3
    4c64:	db06      	blt.n	4c74 <_Z11drawWonGamev+0xf4>
    4c66:	1c38      	adds	r0, r7, #0
    4c68:	3880      	subs	r0, #128	; 0x80
    4c6a:	f005 f9cd 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
    4c6e:	0200      	lsls	r0, r0, #8
    4c70:	4284      	cmp	r4, r0
    4c72:	dd08      	ble.n	4c86 <_Z11drawWonGamev+0x106>
    if (!initializeCardBounce()) {
    4c74:	f7ff facc 	bl	4210 <_Z20initializeCardBouncev>
    4c78:	1e01      	subs	r1, r0, #0
    4c7a:	d104      	bne.n	4c86 <_Z11drawWonGamev+0x106>
      gb.lights.fill(BLACK);
    4c7c:	1c38      	adds	r0, r7, #0
    4c7e:	f005 f86d 	bl	9d5c <_ZN14Gamebuino_Meta8Graphics4fillENS_5ColorE>
      setupNewGame();
    4c82:	f7ff fe8f 	bl	49a4 <_Z12setupNewGamev>
    }
  }
}
    4c86:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    4c88:	20000478 	.word	0x20000478
    4c8c:	20000a4c 	.word	0x20000a4c
    4c90:	00000dff 	.word	0x00000dff
    4c94:	20000a3c 	.word	0x20000a3c
    4c98:	20000acc 	.word	0x20000acc
    4c9c:	fffff600 	.word	0xfffff600

00004ca0 <loop>:
  initializeCardBounce();
  drawBoard(); 
  mode = wonGame;
}

void loop() {
    4ca0:	b510      	push	{r4, lr}
  if (gb.update()) {
    4ca2:	480b      	ldr	r0, [pc, #44]	; (4cd0 <loop+0x30>)
    4ca4:	f001 fe76 	bl	6994 <_ZN14Gamebuino_Meta9Gamebuino6updateEv>
    4ca8:	2800      	cmp	r0, #0
    4caa:	d00f      	beq.n	4ccc <loop+0x2c>
    // Handle key presses for various modes.
    buttonJumpTable[mode]();
    4cac:	4c09      	ldr	r4, [pc, #36]	; (4cd4 <loop+0x34>)
    4cae:	4b0a      	ldr	r3, [pc, #40]	; (4cd8 <loop+0x38>)
    4cb0:	7822      	ldrb	r2, [r4, #0]
    4cb2:	0092      	lsls	r2, r2, #2
    4cb4:	58d3      	ldr	r3, [r2, r3]
    4cb6:	4798      	blx	r3
    
    // Draw the board.
    if (mode != wonGame) {
    4cb8:	7823      	ldrb	r3, [r4, #0]
    4cba:	2b06      	cmp	r3, #6
    4cbc:	d001      	beq.n	4cc2 <loop+0x22>
      drawBoard();      
    4cbe:	f7ff fe01 	bl	48c4 <_Z9drawBoardv>
    }
    
    // Draw other things based on the current state of the game.
    drawJumpTable[mode]();
    4cc2:	7822      	ldrb	r2, [r4, #0]
    4cc4:	4b05      	ldr	r3, [pc, #20]	; (4cdc <loop+0x3c>)
    4cc6:	0092      	lsls	r2, r2, #2
    4cc8:	58d3      	ldr	r3, [r2, r3]
    4cca:	4798      	blx	r3

    // displayCpuLoad();
  }
}
    4ccc:	bd10      	pop	{r4, pc}
    4cce:	46c0      	nop			; (mov r8, r8)
    4cd0:	20000a3c 	.word	0x20000a3c
    4cd4:	200002a0 	.word	0x200002a0
    4cd8:	20000008 	.word	0x20000008
    4cdc:	20000024 	.word	0x20000024

00004ce0 <_Z12checkWonGamev>:
    tableau[i].addCard(card);
  }
  return revealed;
}

void checkWonGame() {
    4ce0:	b510      	push	{r4, lr}
  // Check to see if all foundations are full
  if (foundations[0].getCardCount() == 13 && foundations[1].getCardCount() == 13 &&
    4ce2:	4c16      	ldr	r4, [pc, #88]	; (4d3c <_Z12checkWonGamev+0x5c>)
    4ce4:	1c20      	adds	r0, r4, #0
    4ce6:	f000 fc6f 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    foundations[2].getCardCount() == 13 && foundations[3].getCardCount() == 13) {
    4cea:	280d      	cmp	r0, #13
    4cec:	d125      	bne.n	4d3a <_Z12checkWonGamev+0x5a>
  return revealed;
}

void checkWonGame() {
  // Check to see if all foundations are full
  if (foundations[0].getCardCount() == 13 && foundations[1].getCardCount() == 13 &&
    4cee:	1c20      	adds	r0, r4, #0
    4cf0:	3010      	adds	r0, #16
    4cf2:	f000 fc69 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    4cf6:	280d      	cmp	r0, #13
    4cf8:	d11f      	bne.n	4d3a <_Z12checkWonGamev+0x5a>
    foundations[2].getCardCount() == 13 && foundations[3].getCardCount() == 13) {
    4cfa:	1c20      	adds	r0, r4, #0
    4cfc:	3020      	adds	r0, #32
    4cfe:	f000 fc63 	bl	55c8 <_ZNK4Pile12getCardCountEv>
  return revealed;
}

void checkWonGame() {
  // Check to see if all foundations are full
  if (foundations[0].getCardCount() == 13 && foundations[1].getCardCount() == 13 &&
    4d02:	280d      	cmp	r0, #13
    4d04:	d119      	bne.n	4d3a <_Z12checkWonGamev+0x5a>
    foundations[2].getCardCount() == 13 && foundations[3].getCardCount() == 13) {
    4d06:	1c20      	adds	r0, r4, #0
    4d08:	3030      	adds	r0, #48	; 0x30
    4d0a:	f000 fc5d 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    4d0e:	280d      	cmp	r0, #13
    4d10:	d113      	bne.n	4d3a <_Z12checkWonGamev+0x5a>
      initializeCardBounce();
    4d12:	f7ff fa7d 	bl	4210 <_Z20initializeCardBouncev>
      drawBoard(); 
    4d16:	f7ff fdd5 	bl	48c4 <_Z9drawBoardv>
      mode = wonGame;
    4d1a:	4b09      	ldr	r3, [pc, #36]	; (4d40 <_Z12checkWonGamev+0x60>)
    4d1c:	2206      	movs	r2, #6
    4d1e:	701a      	strb	r2, [r3, #0]
      if (cardsToDraw == 1) {
    4d20:	4b08      	ldr	r3, [pc, #32]	; (4d44 <_Z12checkWonGamev+0x64>)
    4d22:	781b      	ldrb	r3, [r3, #0]
    4d24:	2b01      	cmp	r3, #1
    4d26:	d104      	bne.n	4d32 <_Z12checkWonGamev+0x52>
        easyGamesWon++;
    4d28:	4b07      	ldr	r3, [pc, #28]	; (4d48 <_Z12checkWonGamev+0x68>)
    4d2a:	681a      	ldr	r2, [r3, #0]
    4d2c:	3201      	adds	r2, #1
    4d2e:	601a      	str	r2, [r3, #0]
    4d30:	e003      	b.n	4d3a <_Z12checkWonGamev+0x5a>
        // writeEeprom(false);
      }
      else {
        hardGamesWon++;
    4d32:	4b06      	ldr	r3, [pc, #24]	; (4d4c <_Z12checkWonGamev+0x6c>)
    4d34:	681a      	ldr	r2, [r3, #0]
    4d36:	3201      	adds	r2, #1
    4d38:	601a      	str	r2, [r3, #0]
        // writeEeprom(false);
      }
  }
}
    4d3a:	bd10      	pop	{r4, pc}
    4d3c:	20000438 	.word	0x20000438
    4d40:	200002a0 	.word	0x200002a0
    4d44:	20000004 	.word	0x20000004
    4d48:	20000434 	.word	0x20000434
    4d4c:	20000430 	.word	0x20000430

00004d50 <_Z15updateAfterPlayv>:
    action.setRevealed();
  }
  undo.pushAction(action);
}

bool updateAfterPlay() {
    4d50:	b513      	push	{r0, r1, r4, lr}
  bool result = revealCards();
    4d52:	f7ff fa39 	bl	41c8 <_Z11revealCardsv>
    4d56:	1c04      	adds	r4, r0, #0
  checkWonGame();
    4d58:	f7ff ffc2 	bl	4ce0 <_Z12checkWonGamev>
  cardIndex = 0;
    4d5c:	4b05      	ldr	r3, [pc, #20]	; (4d74 <_Z15updateAfterPlayv+0x24>)
    4d5e:	2200      	movs	r2, #0
    4d60:	701a      	strb	r2, [r3, #0]
  bool unused;
  getCursorDestination(cursorX, cursorY, unused);
    4d62:	466a      	mov	r2, sp
    4d64:	4804      	ldr	r0, [pc, #16]	; (4d78 <_Z15updateAfterPlayv+0x28>)
    4d66:	4905      	ldr	r1, [pc, #20]	; (4d7c <_Z15updateAfterPlayv+0x2c>)
    4d68:	3207      	adds	r2, #7
    4d6a:	f7ff faef 	bl	434c <_Z20getCursorDestinationRhS_Rb>
  return result;
}
    4d6e:	1c20      	adds	r0, r4, #0
    4d70:	bd16      	pop	{r1, r2, r4, pc}
    4d72:	46c0      	nop			; (mov r8, r8)
    4d74:	200002a4 	.word	0x200002a4
    4d78:	200002a1 	.word	0x200002a1
    4d7c:	200002a2 	.word	0x200002a2

00004d80 <_Z9moveCardsv>:
  }

  handleCommonButtons();
}

void moveCards() {
    4d80:	b5f0      	push	{r4, r5, r6, r7, lr}
    4d82:	b085      	sub	sp, #20
  Pile *pile = getActiveLocationPile();
    4d84:	f7ff fa86 	bl	4294 <_Z21getActiveLocationPilev>
  UndoAction action;
  action.source = sourcePile;
    4d88:	4b12      	ldr	r3, [pc, #72]	; (4dd4 <_Z9moveCardsv+0x54>)
  action.destination = pile;
  action.setCardCount(moving.getCardCount());
    4d8a:	4e13      	ldr	r6, [pc, #76]	; (4dd8 <_Z9moveCardsv+0x58>)
}

void moveCards() {
  Pile *pile = getActiveLocationPile();
  UndoAction action;
  action.source = sourcePile;
    4d8c:	ac01      	add	r4, sp, #4
    4d8e:	681b      	ldr	r3, [r3, #0]

  handleCommonButtons();
}

void moveCards() {
  Pile *pile = getActiveLocationPile();
    4d90:	1c07      	adds	r7, r0, #0
  UndoAction action;
  action.source = sourcePile;
  action.destination = pile;
    4d92:	60a0      	str	r0, [r4, #8]
  action.setCardCount(moving.getCardCount());
    4d94:	1c30      	adds	r0, r6, #0
}

void moveCards() {
  Pile *pile = getActiveLocationPile();
  UndoAction action;
  action.source = sourcePile;
    4d96:	6063      	str	r3, [r4, #4]
  action.destination = pile;
  action.setCardCount(moving.getCardCount());
    4d98:	f000 fc16 	bl	55c8 <_ZNK4Pile12getCardCountEv>

struct UndoAction {
    byte special = 0;
    Pile *source;
    Pile *destination;
    void setCardCount(byte cardCount) { special = (special & 0xf0) | (cardCount & 0x0f); }
    4d9c:	230f      	movs	r3, #15
    4d9e:	1c05      	adds	r5, r0, #0
    4da0:	401d      	ands	r5, r3
  pile->addPile(&moving);
    4da2:	1c38      	adds	r0, r7, #0
    4da4:	1c31      	adds	r1, r6, #0
    4da6:	7025      	strb	r5, [r4, #0]
    4da8:	f000 fc20 	bl	55ec <_ZN4Pile7addPileEPS_>
  mode = selecting;
    4dac:	4b0b      	ldr	r3, [pc, #44]	; (4ddc <_Z9moveCardsv+0x5c>)
    4dae:	2201      	movs	r2, #1
    4db0:	701a      	strb	r2, [r3, #0]
  if (updateAfterPlay()) {
    4db2:	f7ff ffcd 	bl	4d50 <_Z15updateAfterPlayv>
    4db6:	2800      	cmp	r0, #0
    4db8:	d003      	beq.n	4dc2 <_Z9moveCardsv+0x42>
    byte getCardCount() { return special & 0x0f; }
    void setRevealed() { special |= 0x80; }
    4dba:	2380      	movs	r3, #128	; 0x80
    4dbc:	425b      	negs	r3, r3
    4dbe:	431d      	orrs	r5, r3
    4dc0:	7025      	strb	r5, [r4, #0]
    action.setRevealed();
  }
  undo.pushAction(action);
    4dc2:	4807      	ldr	r0, [pc, #28]	; (4de0 <_Z9moveCardsv+0x60>)
    4dc4:	9901      	ldr	r1, [sp, #4]
    4dc6:	6862      	ldr	r2, [r4, #4]
    4dc8:	68a3      	ldr	r3, [r4, #8]
    4dca:	f000 fd42 	bl	5852 <_ZN9UndoStack10pushActionE10UndoAction>
}
    4dce:	b005      	add	sp, #20
    4dd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4dd2:	46c0      	nop			; (mov r8, r8)
    4dd4:	20000484 	.word	0x20000484
    4dd8:	200001f0 	.word	0x200001f0
    4ddc:	200002a0 	.word	0x200002a0
    4de0:	20000200 	.word	0x20000200

00004de4 <_Z11performUndov>:
  Card card = source->removeTopCard();
  card.flip();
  destination->addCard(card);
}

void performUndo() {
    4de4:	b5f0      	push	{r4, r5, r6, r7, lr}
  // Make sure there is something to undo.
  if (!undo.isEmpty() && mode == selecting) {
    4de6:	4c23      	ldr	r4, [pc, #140]	; (4e74 <_Z11performUndov+0x90>)
  Card card = source->removeTopCard();
  card.flip();
  destination->addCard(card);
}

void performUndo() {
    4de8:	b085      	sub	sp, #20
  // Make sure there is something to undo.
  if (!undo.isEmpty() && mode == selecting) {
    4dea:	1c20      	adds	r0, r4, #0
    4dec:	f000 fd6d 	bl	58ca <_ZNK9UndoStack7isEmptyEv>
    4df0:	1e07      	subs	r7, r0, #0
    4df2:	d13d      	bne.n	4e70 <_Z11performUndov+0x8c>
    4df4:	4b20      	ldr	r3, [pc, #128]	; (4e78 <_Z11performUndov+0x94>)
    4df6:	781b      	ldrb	r3, [r3, #0]
    4df8:	2b01      	cmp	r3, #1
    4dfa:	d139      	bne.n	4e70 <_Z11performUndov+0x8c>
    UndoAction action = undo.popAction();
    4dfc:	ae01      	add	r6, sp, #4
    4dfe:	1c21      	adds	r1, r4, #0
    4e00:	1c30      	adds	r0, r6, #0
    4e02:	f000 fd45 	bl	5890 <_ZN9UndoStack9popActionEv>
    4e06:	7834      	ldrb	r4, [r6, #0]
    4e08:	9d02      	ldr	r5, [sp, #8]
    // Handle draw from stock.
    if (action.wasDraw()) {
    4e0a:	0663      	lsls	r3, r4, #25
    4e0c:	d424      	bmi.n	4e58 <_Z11performUndov+0x74>
      for (byte i = 0; i < cardsToDraw; i++) {
        drawAndFlip(&talonDeck, &stockDeck);
      }
    }
    // Handle flipped talon.
    else if (action.wasFlippedTalon()) {
    4e0e:	06a3      	lsls	r3, r4, #26
    4e10:	d50a      	bpl.n	4e28 <_Z11performUndov+0x44>
      while (stockDeck.getCardCount() != 0) {
    4e12:	4c1a      	ldr	r4, [pc, #104]	; (4e7c <_Z11performUndov+0x98>)
    4e14:	1c20      	adds	r0, r4, #0
    4e16:	f000 fbd7 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    4e1a:	2800      	cmp	r0, #0
    4e1c:	d019      	beq.n	4e52 <_Z11performUndov+0x6e>
        drawAndFlip(&stockDeck, &talonDeck);
    4e1e:	1c20      	adds	r0, r4, #0
    4e20:	4917      	ldr	r1, [pc, #92]	; (4e80 <_Z11performUndov+0x9c>)
    4e22:	f7ff fb13 	bl	444c <_Z11drawAndFlipP4PileS0_>
    4e26:	e7f4      	b.n	4e12 <_Z11performUndov+0x2e>
      }
    }
    // Handle moving cards from one pile to another.
    else {
      // Handle moved cards resulted in revealing another card.
      if (action.wasRevealed()) {
    4e28:	b263      	sxtb	r3, r4
    4e2a:	2b00      	cmp	r3, #0
    4e2c:	da03      	bge.n	4e36 <_Z11performUndov+0x52>
        drawAndFlip(action.source, action.source);
    4e2e:	1c28      	adds	r0, r5, #0
    4e30:	1c29      	adds	r1, r5, #0
    4e32:	f7ff fb0b 	bl	444c <_Z11drawAndFlipP4PileS0_>
      }
      moving.empty();
    4e36:	4f13      	ldr	r7, [pc, #76]	; (4e84 <_Z11performUndov+0xa0>)
    4e38:	1c38      	adds	r0, r7, #0
    4e3a:	f000 fc0f 	bl	565c <_ZN4Pile5emptyEv>
      action.destination->removeCards(action.getCardCount(), &moving);
    4e3e:	210f      	movs	r1, #15
    4e40:	68b0      	ldr	r0, [r6, #8]
    4e42:	4021      	ands	r1, r4
    4e44:	1c3a      	adds	r2, r7, #0
    4e46:	f000 fbf2 	bl	562e <_ZN4Pile11removeCardsEiPS_>
      action.source->addPile(&moving);
    4e4a:	1c28      	adds	r0, r5, #0
    4e4c:	1c39      	adds	r1, r7, #0
    4e4e:	f000 fbcd 	bl	55ec <_ZN4Pile7addPileEPS_>
    }
    updateAfterPlay();
    4e52:	f7ff ff7d 	bl	4d50 <_Z15updateAfterPlayv>
    4e56:	e00b      	b.n	4e70 <_Z11performUndov+0x8c>
void performUndo() {
  // Make sure there is something to undo.
  if (!undo.isEmpty() && mode == selecting) {
    UndoAction action = undo.popAction();
    // Handle draw from stock.
    if (action.wasDraw()) {
    4e58:	1c3c      	adds	r4, r7, #0
      for (byte i = 0; i < cardsToDraw; i++) {
    4e5a:	4b0b      	ldr	r3, [pc, #44]	; (4e88 <_Z11performUndov+0xa4>)
    4e5c:	781b      	ldrb	r3, [r3, #0]
    4e5e:	42a3      	cmp	r3, r4
    4e60:	d9f7      	bls.n	4e52 <_Z11performUndov+0x6e>
        drawAndFlip(&talonDeck, &stockDeck);
    4e62:	4807      	ldr	r0, [pc, #28]	; (4e80 <_Z11performUndov+0x9c>)
    4e64:	4905      	ldr	r1, [pc, #20]	; (4e7c <_Z11performUndov+0x98>)
  // Make sure there is something to undo.
  if (!undo.isEmpty() && mode == selecting) {
    UndoAction action = undo.popAction();
    // Handle draw from stock.
    if (action.wasDraw()) {
      for (byte i = 0; i < cardsToDraw; i++) {
    4e66:	3401      	adds	r4, #1
        drawAndFlip(&talonDeck, &stockDeck);
    4e68:	f7ff faf0 	bl	444c <_Z11drawAndFlipP4PileS0_>
  // Make sure there is something to undo.
  if (!undo.isEmpty() && mode == selecting) {
    UndoAction action = undo.popAction();
    // Handle draw from stock.
    if (action.wasDraw()) {
      for (byte i = 0; i < cardsToDraw; i++) {
    4e6c:	b2e4      	uxtb	r4, r4
    4e6e:	e7f4      	b.n	4e5a <_Z11performUndov+0x76>
      action.destination->removeCards(action.getCardCount(), &moving);
      action.source->addPile(&moving);
    }
    updateAfterPlay();
  }
}
    4e70:	b005      	add	sp, #20
    4e72:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4e74:	20000200 	.word	0x20000200
    4e78:	200002a0 	.word	0x200002a0
    4e7c:	20000280 	.word	0x20000280
    4e80:	20000290 	.word	0x20000290
    4e84:	200001f0 	.word	0x200001f0
    4e88:	20000004 	.word	0x20000004

00004e8c <_Z19handleCommonButtonsv>:
  gb.display.setCursor(0, 0);
  gb.display.setColor(BLACK);
  gb.display.print(gb.getCpuLoad());
}

void handleCommonButtons() {
    4e8c:	b508      	push	{r3, lr}
  if (gb.buttons.pressed(BUTTON_MENU)) {
    4e8e:	4810      	ldr	r0, [pc, #64]	; (4ed0 <_Z19handleCommonButtonsv+0x44>)
    4e90:	2106      	movs	r1, #6
    4e92:	f002 fef3 	bl	7c7c <_ZN14Gamebuino_Meta7Buttons7pressedENS_6ButtonE>
    4e96:	2800      	cmp	r0, #0
    4e98:	d018      	beq.n	4ecc <_Z19handleCommonButtonsv+0x40>
    switch (menu(pauseMenu, (!undo.isEmpty() && mode == selecting) ? 3 : 2, true)) {
    4e9a:	480e      	ldr	r0, [pc, #56]	; (4ed4 <_Z19handleCommonButtonsv+0x48>)
    4e9c:	f000 fd15 	bl	58ca <_ZNK9UndoStack7isEmptyEv>
    4ea0:	2102      	movs	r1, #2
    4ea2:	2800      	cmp	r0, #0
    4ea4:	d105      	bne.n	4eb2 <_Z19handleCommonButtonsv+0x26>
    4ea6:	4b0c      	ldr	r3, [pc, #48]	; (4ed8 <_Z19handleCommonButtonsv+0x4c>)
    4ea8:	7819      	ldrb	r1, [r3, #0]
    4eaa:	3901      	subs	r1, #1
    4eac:	424b      	negs	r3, r1
    4eae:	4159      	adcs	r1, r3
    4eb0:	3102      	adds	r1, #2
    4eb2:	480a      	ldr	r0, [pc, #40]	; (4edc <_Z19handleCommonButtonsv+0x50>)
    4eb4:	2201      	movs	r2, #1
    4eb6:	f000 fe0f 	bl	5ad8 <_Z4menuPKPKcib>
    4eba:	2801      	cmp	r0, #1
    4ebc:	d004      	beq.n	4ec8 <_Z19handleCommonButtonsv+0x3c>
    4ebe:	2802      	cmp	r0, #2
    4ec0:	d104      	bne.n	4ecc <_Z19handleCommonButtonsv+0x40>
      case 1: 
        setupNewGame();
        return;
      case 2:
        performUndo();
    4ec2:	f7ff ff8f 	bl	4de4 <_Z11performUndov>
    4ec6:	e001      	b.n	4ecc <_Z19handleCommonButtonsv+0x40>

void handleCommonButtons() {
  if (gb.buttons.pressed(BUTTON_MENU)) {
    switch (menu(pauseMenu, (!undo.isEmpty() && mode == selecting) ? 3 : 2, true)) {
      case 1: 
        setupNewGame();
    4ec8:	f7ff fd6c 	bl	49a4 <_Z12setupNewGamev>
      case 2:
        performUndo();
        break;
    }
  }
}
    4ecc:	bd08      	pop	{r3, pc}
    4ece:	46c0      	nop			; (mov r8, r8)
    4ed0:	20000a3c 	.word	0x20000a3c
    4ed4:	20000200 	.word	0x20000200
    4ed8:	200002a0 	.word	0x200002a0
    4edc:	000118f8 	.word	0x000118f8

00004ee0 <_Z22handleSelectingButtonsv>:

void handleSelectingButtons() {
    4ee0:	b5f0      	push	{r4, r5, r6, r7, lr}
  // Handle buttons when user is using the arrow cursor to navigate.
  Location originalLocation = activeLocation;
    4ee2:	4ca1      	ldr	r4, [pc, #644]	; (5168 <_Z22handleSelectingButtonsv+0x288>)
  if (gb.buttons.repeat(BUTTON_RIGHT, 8)) {
    4ee4:	4da1      	ldr	r5, [pc, #644]	; (516c <_Z22handleSelectingButtonsv+0x28c>)
  }
}

void handleSelectingButtons() {
  // Handle buttons when user is using the arrow cursor to navigate.
  Location originalLocation = activeLocation;
    4ee6:	7822      	ldrb	r2, [r4, #0]
        break;
    }
  }
}

void handleSelectingButtons() {
    4ee8:	b08b      	sub	sp, #44	; 0x2c
  // Handle buttons when user is using the arrow cursor to navigate.
  Location originalLocation = activeLocation;
    4eea:	9202      	str	r2, [sp, #8]
  if (gb.buttons.repeat(BUTTON_RIGHT, 8)) {
    4eec:	1c28      	adds	r0, r5, #0
    4eee:	2102      	movs	r1, #2
    4ef0:	2208      	movs	r2, #8
    4ef2:	f002 fedd 	bl	7cb0 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt>
    4ef6:	2800      	cmp	r0, #0
    4ef8:	d006      	beq.n	4f08 <_Z22handleSelectingButtonsv+0x28>
    if (activeLocation != foundation4 && activeLocation != tableau7) {
    4efa:	7823      	ldrb	r3, [r4, #0]
    4efc:	2b05      	cmp	r3, #5
    4efe:	d003      	beq.n	4f08 <_Z22handleSelectingButtonsv+0x28>
    4f00:	2b0c      	cmp	r3, #12
    4f02:	d001      	beq.n	4f08 <_Z22handleSelectingButtonsv+0x28>
      activeLocation = (Location)(activeLocation + 1);
    4f04:	3301      	adds	r3, #1
    4f06:	7023      	strb	r3, [r4, #0]
    }
  }
  if (gb.buttons.repeat(BUTTON_LEFT, 8)) {
    4f08:	1c28      	adds	r0, r5, #0
    4f0a:	2101      	movs	r1, #1
    4f0c:	2208      	movs	r2, #8
    4f0e:	f002 fecf 	bl	7cb0 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt>
    4f12:	2800      	cmp	r0, #0
    4f14:	d006      	beq.n	4f24 <_Z22handleSelectingButtonsv+0x44>
    if (activeLocation != stock && activeLocation != tableau1) {
    4f16:	7823      	ldrb	r3, [r4, #0]
    4f18:	2b00      	cmp	r3, #0
    4f1a:	d003      	beq.n	4f24 <_Z22handleSelectingButtonsv+0x44>
    4f1c:	2b06      	cmp	r3, #6
    4f1e:	d001      	beq.n	4f24 <_Z22handleSelectingButtonsv+0x44>
      activeLocation = (Location)(activeLocation - 1);
    4f20:	3b01      	subs	r3, #1
    4f22:	7023      	strb	r3, [r4, #0]
    }
  }
  if (gb.buttons.repeat(BUTTON_DOWN, 8)) {
    4f24:	1c28      	adds	r0, r5, #0
    4f26:	2100      	movs	r1, #0
    4f28:	2208      	movs	r2, #8
    4f2a:	f002 fec1 	bl	7cb0 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt>
    4f2e:	2800      	cmp	r0, #0
    4f30:	d010      	beq.n	4f54 <_Z22handleSelectingButtonsv+0x74>
    if (cardIndex > 0) {
    4f32:	4b8f      	ldr	r3, [pc, #572]	; (5170 <_Z22handleSelectingButtonsv+0x290>)
    4f34:	781a      	ldrb	r2, [r3, #0]
    4f36:	2a00      	cmp	r2, #0
    4f38:	d002      	beq.n	4f40 <_Z22handleSelectingButtonsv+0x60>
      cardIndex--;
    4f3a:	3a01      	subs	r2, #1
    4f3c:	701a      	strb	r2, [r3, #0]
    4f3e:	e009      	b.n	4f54 <_Z22handleSelectingButtonsv+0x74>
    }
    else {
      if (activeLocation < foundation1) activeLocation = (Location)(activeLocation + 6);
    4f40:	7823      	ldrb	r3, [r4, #0]
    4f42:	2b01      	cmp	r3, #1
    4f44:	d802      	bhi.n	4f4c <_Z22handleSelectingButtonsv+0x6c>
    4f46:	3306      	adds	r3, #6
    4f48:	7023      	strb	r3, [r4, #0]
    4f4a:	e003      	b.n	4f54 <_Z22handleSelectingButtonsv+0x74>
      else if (activeLocation <= foundation4) activeLocation = (Location)(activeLocation + 7);
    4f4c:	2b05      	cmp	r3, #5
    4f4e:	d801      	bhi.n	4f54 <_Z22handleSelectingButtonsv+0x74>
    4f50:	3307      	adds	r3, #7
    4f52:	7023      	strb	r3, [r4, #0]
    }
  }
  if (gb.buttons.repeat(BUTTON_UP, 8)) {
    4f54:	1c28      	adds	r0, r5, #0
    4f56:	2103      	movs	r1, #3
    4f58:	2208      	movs	r2, #8
    4f5a:	f002 fea9 	bl	7cb0 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt>
    4f5e:	2800      	cmp	r0, #0
    4f60:	d021      	beq.n	4fa6 <_Z22handleSelectingButtonsv+0xc6>
    bool interPileNavigation = false;
    if (activeLocation >= tableau1 && activeLocation <= tableau7) {
    4f62:	7823      	ldrb	r3, [r4, #0]
    4f64:	3b06      	subs	r3, #6
    4f66:	2b06      	cmp	r3, #6
    4f68:	d817      	bhi.n	4f9a <_Z22handleSelectingButtonsv+0xba>
      Pile *pile = getActiveLocationPile();
    4f6a:	f7ff f993 	bl	4294 <_Z21getActiveLocationPilev>
    4f6e:	1c07      	adds	r7, r0, #0
      if (pile->getCardCount() > cardIndex + 1 && !pile->getCard(cardIndex + 1).isFaceDown()) {
    4f70:	f000 fb2a 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    4f74:	4e7e      	ldr	r6, [pc, #504]	; (5170 <_Z22handleSelectingButtonsv+0x290>)
    4f76:	7831      	ldrb	r1, [r6, #0]
    4f78:	3101      	adds	r1, #1
    4f7a:	4288      	cmp	r0, r1
    4f7c:	dd0d      	ble.n	4f9a <_Z22handleSelectingButtonsv+0xba>
    4f7e:	1c38      	adds	r0, r7, #0
    4f80:	f000 fb24 	bl	55cc <_ZNK4Pile7getCardEi>
    4f84:	ab07      	add	r3, sp, #28
    4f86:	7018      	strb	r0, [r3, #0]
    4f88:	1c18      	adds	r0, r3, #0
    4f8a:	f7ff f8cb 	bl	4124 <_ZNK4Card10isFaceDownEv>
    4f8e:	2800      	cmp	r0, #0
    4f90:	d103      	bne.n	4f9a <_Z22handleSelectingButtonsv+0xba>
        cardIndex++;
    4f92:	7833      	ldrb	r3, [r6, #0]
    4f94:	3301      	adds	r3, #1
    4f96:	7033      	strb	r3, [r6, #0]
    4f98:	e005      	b.n	4fa6 <_Z22handleSelectingButtonsv+0xc6>
        interPileNavigation = true;
      }
    }
    if (!interPileNavigation) {
      if (activeLocation > tableau2) activeLocation = (Location)(activeLocation - 7);
    4f9a:	7823      	ldrb	r3, [r4, #0]
    4f9c:	2b07      	cmp	r3, #7
    4f9e:	d800      	bhi.n	4fa2 <_Z22handleSelectingButtonsv+0xc2>
    4fa0:	e0dc      	b.n	515c <_Z22handleSelectingButtonsv+0x27c>
    4fa2:	3b07      	subs	r3, #7
    4fa4:	7023      	strb	r3, [r4, #0]
      else if (activeLocation >= tableau1) activeLocation = (Location)(activeLocation - 6);
    }
  }
  if (gb.buttons.pressed(BUTTON_B)) {
    4fa6:	1c28      	adds	r0, r5, #0
    4fa8:	2105      	movs	r1, #5
    4faa:	f002 fe67 	bl	7c7c <_ZN14Gamebuino_Meta7Buttons7pressedENS_6ButtonE>
    4fae:	1e06      	subs	r6, r0, #0
    4fb0:	d060      	beq.n	5074 <_Z22handleSelectingButtonsv+0x194>
    if (activeLocation >= tableau1 || activeLocation == talon) {
    4fb2:	7823      	ldrb	r3, [r4, #0]
    4fb4:	2b05      	cmp	r3, #5
    4fb6:	d802      	bhi.n	4fbe <_Z22handleSelectingButtonsv+0xde>
    4fb8:	2b01      	cmp	r3, #1
    4fba:	d000      	beq.n	4fbe <_Z22handleSelectingButtonsv+0xde>
    4fbc:	e0c3      	b.n	5146 <_Z22handleSelectingButtonsv+0x266>
      Pile *pile = getActiveLocationPile();
    4fbe:	f7ff f969 	bl	4294 <_Z21getActiveLocationPilev>
    4fc2:	1c05      	adds	r5, r0, #0
      if (pile->getCardCount() > 0) {
    4fc4:	f000 fb00 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    4fc8:	2800      	cmp	r0, #0
    4fca:	d100      	bne.n	4fce <_Z22handleSelectingButtonsv+0xee>
    4fcc:	e0bb      	b.n	5146 <_Z22handleSelectingButtonsv+0x266>
        Card card = pile->getCard(0);
    4fce:	1c28      	adds	r0, r5, #0
    4fd0:	2100      	movs	r1, #0
    4fd2:	f000 fafb 	bl	55cc <_ZNK4Pile7getCardEi>
    4fd6:	ab05      	add	r3, sp, #20
    4fd8:	7018      	strb	r0, [r3, #0]
    4fda:	2700      	movs	r7, #0
    4fdc:	4b65      	ldr	r3, [pc, #404]	; (5174 <_Z22handleSelectingButtonsv+0x294>)
    4fde:	19db      	adds	r3, r3, r7
        bool foundMatch = false;
        for (int i = 0; i < 4; i++) {
          if (foundations[i].getCardCount() == 0) {
    4fe0:	1c18      	adds	r0, r3, #0
    4fe2:	9301      	str	r3, [sp, #4]
    4fe4:	f000 faf0 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    4fe8:	2800      	cmp	r0, #0
    4fea:	d11f      	bne.n	502c <_Z22handleSelectingButtonsv+0x14c>
            if (card.getValue() == ace) {
    4fec:	a805      	add	r0, sp, #20
    4fee:	f7ff f89c 	bl	412a <_ZNK4Card8getValueEv>
    4ff2:	2801      	cmp	r0, #1
    4ff4:	d13a      	bne.n	506c <_Z22handleSelectingButtonsv+0x18c>
            if (card1.getSuit() == card2.getSuit() && card1.getValue() + 1 == card2.getValue()) {
              foundMatch = true;
            }
          }
          if (foundMatch) {
            moving.empty();
    4ff6:	4e60      	ldr	r6, [pc, #384]	; (5178 <_Z22handleSelectingButtonsv+0x298>)
    4ff8:	1c30      	adds	r0, r6, #0
    4ffa:	f000 fb2f 	bl	565c <_ZN4Pile5emptyEv>
            moving.x = pile->x;
    4ffe:	882b      	ldrh	r3, [r5, #0]
            moving.y = cardYPosition(pile, 0);
    5000:	2100      	movs	r1, #0
    5002:	1c28      	adds	r0, r5, #0
              foundMatch = true;
            }
          }
          if (foundMatch) {
            moving.empty();
            moving.x = pile->x;
    5004:	8033      	strh	r3, [r6, #0]
            moving.y = cardYPosition(pile, 0);
    5006:	f7ff f987 	bl	4318 <_Z13cardYPositionP4Pileh>
    500a:	8070      	strh	r0, [r6, #2]
            moving.addCard(pile->removeTopCard());
    500c:	1c28      	adds	r0, r5, #0
    500e:	f000 fafe 	bl	560e <_ZN4Pile13removeTopCardEv>
    5012:	1c01      	adds	r1, r0, #0
    5014:	1c30      	adds	r0, r6, #0
    5016:	f000 facd 	bl	55b4 <_ZN4Pile7addCardE4Card>
            sourcePile = &foundations[i];
    501a:	9a01      	ldr	r2, [sp, #4]
    501c:	4b57      	ldr	r3, [pc, #348]	; (517c <_Z22handleSelectingButtonsv+0x29c>)
    501e:	601a      	str	r2, [r3, #0]
            mode = fastFoundation;
    5020:	4b57      	ldr	r3, [pc, #348]	; (5180 <_Z22handleSelectingButtonsv+0x2a0>)
    5022:	2205      	movs	r2, #5
    5024:	701a      	strb	r2, [r3, #0]
            playSoundA();
    5026:	f7ff f9f9 	bl	441c <_Z10playSoundAv>
            break;
    502a:	e08c      	b.n	5146 <_Z22handleSelectingButtonsv+0x266>
            if (card.getValue() == ace) {
              foundMatch = true;
            }
          }
          else {
            Card card1 = foundations[i].getCard(0);
    502c:	2100      	movs	r1, #0
    502e:	9801      	ldr	r0, [sp, #4]
    5030:	f000 facc 	bl	55cc <_ZNK4Pile7getCardEi>
    5034:	ae06      	add	r6, sp, #24
            Card card2 = pile->getCard(0);
    5036:	2100      	movs	r1, #0
            if (card.getValue() == ace) {
              foundMatch = true;
            }
          }
          else {
            Card card1 = foundations[i].getCard(0);
    5038:	7030      	strb	r0, [r6, #0]
            Card card2 = pile->getCard(0);
    503a:	1c28      	adds	r0, r5, #0
    503c:	f000 fac6 	bl	55cc <_ZNK4Pile7getCardEi>
    5040:	466b      	mov	r3, sp
    5042:	7718      	strb	r0, [r3, #28]
            if (card1.getSuit() == card2.getSuit() && card1.getValue() + 1 == card2.getValue()) {
    5044:	1c30      	adds	r0, r6, #0
    5046:	f7ff f874 	bl	4132 <_ZNK4Card7getSuitEv>
    504a:	9003      	str	r0, [sp, #12]
    504c:	a807      	add	r0, sp, #28
    504e:	f7ff f870 	bl	4132 <_ZNK4Card7getSuitEv>
    5052:	9a03      	ldr	r2, [sp, #12]
    5054:	4282      	cmp	r2, r0
    5056:	d109      	bne.n	506c <_Z22handleSelectingButtonsv+0x18c>
    5058:	1c30      	adds	r0, r6, #0
    505a:	f7ff f866 	bl	412a <_ZNK4Card8getValueEv>
    505e:	1c06      	adds	r6, r0, #0
    5060:	a807      	add	r0, sp, #28
    5062:	f7ff f862 	bl	412a <_ZNK4Card8getValueEv>
    5066:	3601      	adds	r6, #1
    5068:	4286      	cmp	r6, r0
    506a:	d0c4      	beq.n	4ff6 <_Z22handleSelectingButtonsv+0x116>
    506c:	3710      	adds	r7, #16
    if (activeLocation >= tableau1 || activeLocation == talon) {
      Pile *pile = getActiveLocationPile();
      if (pile->getCardCount() > 0) {
        Card card = pile->getCard(0);
        bool foundMatch = false;
        for (int i = 0; i < 4; i++) {
    506e:	2f40      	cmp	r7, #64	; 0x40
    5070:	d1b4      	bne.n	4fdc <_Z22handleSelectingButtonsv+0xfc>
    5072:	e068      	b.n	5146 <_Z22handleSelectingButtonsv+0x266>
          }
        }
      }
    }
  }
  else if (gb.buttons.pressed(BUTTON_A)) {
    5074:	1c28      	adds	r0, r5, #0
    5076:	2104      	movs	r1, #4
    5078:	f002 fe00 	bl	7c7c <_ZN14Gamebuino_Meta7Buttons7pressedENS_6ButtonE>
    507c:	2800      	cmp	r0, #0
    507e:	d062      	beq.n	5146 <_Z22handleSelectingButtonsv+0x266>
    switch (activeLocation) {
    5080:	7823      	ldrb	r3, [r4, #0]
    5082:	2b00      	cmp	r3, #0
    5084:	d002      	beq.n	508c <_Z22handleSelectingButtonsv+0x1ac>
    5086:	2b0c      	cmp	r3, #12
    5088:	d85d      	bhi.n	5146 <_Z22handleSelectingButtonsv+0x266>
    508a:	e03d      	b.n	5108 <_Z22handleSelectingButtonsv+0x228>
      case stock:
        if (stockDeck.getCardCount() != 0) {
    508c:	4d3d      	ldr	r5, [pc, #244]	; (5184 <_Z22handleSelectingButtonsv+0x2a4>)
    508e:	1c28      	adds	r0, r5, #0
    5090:	f000 fa9a 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    5094:	1c2e      	adds	r6, r5, #0
    5096:	2800      	cmp	r0, #0
    5098:	d021      	beq.n	50de <_Z22handleSelectingButtonsv+0x1fe>
          moving.empty();
    509a:	4e37      	ldr	r6, [pc, #220]	; (5178 <_Z22handleSelectingButtonsv+0x298>)
    509c:	1c30      	adds	r0, r6, #0
    509e:	f000 fadd 	bl	565c <_ZN4Pile5emptyEv>
          drawAndFlip(&stockDeck, &moving);
    50a2:	1c28      	adds	r0, r5, #0
    50a4:	1c31      	adds	r1, r6, #0
    50a6:	f7ff f9d1 	bl	444c <_Z11drawAndFlipP4PileS0_>
          moving.x = stockDeck.x;
    50aa:	882b      	ldrh	r3, [r5, #0]
          moving.y = stockDeck.y;
          remainingDraws = min(cardsToDraw - 1, stockDeck.getCardCount()); 
    50ac:	1c28      	adds	r0, r5, #0
    switch (activeLocation) {
      case stock:
        if (stockDeck.getCardCount() != 0) {
          moving.empty();
          drawAndFlip(&stockDeck, &moving);
          moving.x = stockDeck.x;
    50ae:	8033      	strh	r3, [r6, #0]
          moving.y = stockDeck.y;
    50b0:	886b      	ldrh	r3, [r5, #2]
    50b2:	8073      	strh	r3, [r6, #2]
          remainingDraws = min(cardsToDraw - 1, stockDeck.getCardCount()); 
    50b4:	4e34      	ldr	r6, [pc, #208]	; (5188 <_Z22handleSelectingButtonsv+0x2a8>)
    50b6:	7837      	ldrb	r7, [r6, #0]
    50b8:	f000 fa86 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    50bc:	4287      	cmp	r7, r0
    50be:	dc03      	bgt.n	50c8 <_Z22handleSelectingButtonsv+0x1e8>
    50c0:	7830      	ldrb	r0, [r6, #0]
    50c2:	3801      	subs	r0, #1
    50c4:	b2c0      	uxtb	r0, r0
    50c6:	e002      	b.n	50ce <_Z22handleSelectingButtonsv+0x1ee>
    50c8:	1c28      	adds	r0, r5, #0
    50ca:	f000 fa7d 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    50ce:	4b2f      	ldr	r3, [pc, #188]	; (518c <_Z22handleSelectingButtonsv+0x2ac>)
          mode = drawingCards;
    50d0:	2202      	movs	r2, #2
        if (stockDeck.getCardCount() != 0) {
          moving.empty();
          drawAndFlip(&stockDeck, &moving);
          moving.x = stockDeck.x;
          moving.y = stockDeck.y;
          remainingDraws = min(cardsToDraw - 1, stockDeck.getCardCount()); 
    50d2:	7018      	strb	r0, [r3, #0]
          mode = drawingCards;
    50d4:	4b2a      	ldr	r3, [pc, #168]	; (5180 <_Z22handleSelectingButtonsv+0x2a0>)
    50d6:	701a      	strb	r2, [r3, #0]
          playSoundA();
    50d8:	f7ff f9a0 	bl	441c <_Z10playSoundAv>
    50dc:	e033      	b.n	5146 <_Z22handleSelectingButtonsv+0x266>
        }
        else {
          while (talonDeck.getCardCount() != 0) {
    50de:	4d2c      	ldr	r5, [pc, #176]	; (5190 <_Z22handleSelectingButtonsv+0x2b0>)
    50e0:	1c28      	adds	r0, r5, #0
    50e2:	f000 fa71 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    50e6:	2800      	cmp	r0, #0
    50e8:	d004      	beq.n	50f4 <_Z22handleSelectingButtonsv+0x214>
            drawAndFlip(&talonDeck, &stockDeck);
    50ea:	1c28      	adds	r0, r5, #0
    50ec:	1c31      	adds	r1, r6, #0
    50ee:	f7ff f9ad 	bl	444c <_Z11drawAndFlipP4PileS0_>
    50f2:	e7f4      	b.n	50de <_Z22handleSelectingButtonsv+0x1fe>
          }
          UndoAction action;
          action.setFlippedTalon();
          undo.pushAction(action);
    50f4:	ab07      	add	r3, sp, #28
    50f6:	2220      	movs	r2, #32
    50f8:	701a      	strb	r2, [r3, #0]
    50fa:	4826      	ldr	r0, [pc, #152]	; (5194 <_Z22handleSelectingButtonsv+0x2b4>)
    50fc:	9907      	ldr	r1, [sp, #28]
    50fe:	9a08      	ldr	r2, [sp, #32]
    5100:	9b09      	ldr	r3, [sp, #36]	; 0x24
    5102:	f000 fba6 	bl	5852 <_ZN9UndoStack10pushActionE10UndoAction>
    5106:	e01e      	b.n	5146 <_Z22handleSelectingButtonsv+0x266>
      case tableau3:
      case tableau4:
      case tableau5:
      case tableau6:
      case tableau7:
        sourcePile = getActiveLocationPile();
    5108:	f7ff f8c4 	bl	4294 <_Z21getActiveLocationPilev>
    510c:	4f1b      	ldr	r7, [pc, #108]	; (517c <_Z22handleSelectingButtonsv+0x29c>)
    510e:	6038      	str	r0, [r7, #0]
        if (sourcePile->getCardCount() == 0) break;
    5110:	f000 fa5a 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    5114:	2800      	cmp	r0, #0
    5116:	d016      	beq.n	5146 <_Z22handleSelectingButtonsv+0x266>
        moving.empty();
    5118:	4d17      	ldr	r5, [pc, #92]	; (5178 <_Z22handleSelectingButtonsv+0x298>)
    511a:	1c28      	adds	r0, r5, #0
    511c:	f000 fa9e 	bl	565c <_ZN4Pile5emptyEv>
        moving.x = sourcePile->x;
    5120:	6838      	ldr	r0, [r7, #0]
        moving.y = cardYPosition(sourcePile, 0);
    5122:	1c31      	adds	r1, r6, #0
      case tableau6:
      case tableau7:
        sourcePile = getActiveLocationPile();
        if (sourcePile->getCardCount() == 0) break;
        moving.empty();
        moving.x = sourcePile->x;
    5124:	8803      	ldrh	r3, [r0, #0]
    5126:	802b      	strh	r3, [r5, #0]
        moving.y = cardYPosition(sourcePile, 0);
    5128:	f7ff f8f6 	bl	4318 <_Z13cardYPositionP4Pileh>
        sourcePile->removeCards(cardIndex + 1, &moving);
    512c:	4b10      	ldr	r3, [pc, #64]	; (5170 <_Z22handleSelectingButtonsv+0x290>)
      case tableau7:
        sourcePile = getActiveLocationPile();
        if (sourcePile->getCardCount() == 0) break;
        moving.empty();
        moving.x = sourcePile->x;
        moving.y = cardYPosition(sourcePile, 0);
    512e:	8068      	strh	r0, [r5, #2]
        sourcePile->removeCards(cardIndex + 1, &moving);
    5130:	7819      	ldrb	r1, [r3, #0]
    5132:	1c2a      	adds	r2, r5, #0
    5134:	6838      	ldr	r0, [r7, #0]
    5136:	3101      	adds	r1, #1
    5138:	f000 fa79 	bl	562e <_ZN4Pile11removeCardsEiPS_>
        mode = movingPile;
    513c:	4b10      	ldr	r3, [pc, #64]	; (5180 <_Z22handleSelectingButtonsv+0x2a0>)
    513e:	2203      	movs	r2, #3
    5140:	701a      	strb	r2, [r3, #0]
        playSoundA();
    5142:	f7ff f96b 	bl	441c <_Z10playSoundAv>
        break;
    }
  }
  if (originalLocation != activeLocation) cardIndex = 0;
    5146:	7823      	ldrb	r3, [r4, #0]
    5148:	9a02      	ldr	r2, [sp, #8]
    514a:	4293      	cmp	r3, r2
    514c:	d002      	beq.n	5154 <_Z22handleSelectingButtonsv+0x274>
    514e:	4b08      	ldr	r3, [pc, #32]	; (5170 <_Z22handleSelectingButtonsv+0x290>)
    5150:	2200      	movs	r2, #0
    5152:	701a      	strb	r2, [r3, #0]

  handleCommonButtons();
    5154:	f7ff fe9a 	bl	4e8c <_Z19handleCommonButtonsv>
}
    5158:	b00b      	add	sp, #44	; 0x2c
    515a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        interPileNavigation = true;
      }
    }
    if (!interPileNavigation) {
      if (activeLocation > tableau2) activeLocation = (Location)(activeLocation - 7);
      else if (activeLocation >= tableau1) activeLocation = (Location)(activeLocation - 6);
    515c:	2b05      	cmp	r3, #5
    515e:	d800      	bhi.n	5162 <_Z22handleSelectingButtonsv+0x282>
    5160:	e721      	b.n	4fa6 <_Z22handleSelectingButtonsv+0xc6>
    5162:	3b06      	subs	r3, #6
    5164:	7023      	strb	r3, [r4, #0]
    5166:	e71e      	b.n	4fa6 <_Z22handleSelectingButtonsv+0xc6>
    5168:	2000027c 	.word	0x2000027c
    516c:	20000a3c 	.word	0x20000a3c
    5170:	200002a4 	.word	0x200002a4
    5174:	20000438 	.word	0x20000438
    5178:	200001f0 	.word	0x200001f0
    517c:	20000484 	.word	0x20000484
    5180:	200002a0 	.word	0x200002a0
    5184:	20000280 	.word	0x20000280
    5188:	20000004 	.word	0x20000004
    518c:	200002a3 	.word	0x200002a3
    5190:	20000290 	.word	0x20000290
    5194:	20000200 	.word	0x20000200

00005198 <_Z15drawIllegalMovev>:
  if (pile->isTableau) yDelta += 2 * pile->getCardCount();
  moving.x = updatePosition(moving.x, pile->x);
  moving.y = updatePosition(moving.y, pile->y + yDelta);  
}

void drawIllegalMove() {
    5198:	b5f0      	push	{r4, r5, r6, r7, lr}
  // Move the cards back to the source pile.
  byte yDelta = 0;
  if (sourcePile->isTableau) yDelta += 2 * sourcePile->getCardCount();
    519a:	4d27      	ldr	r5, [pc, #156]	; (5238 <_Z15drawIllegalMovev+0xa0>)
  moving.y = updatePosition(moving.y, pile->y + yDelta);  
}

void drawIllegalMove() {
  // Move the cards back to the source pile.
  byte yDelta = 0;
    519c:	2600      	movs	r6, #0
  if (sourcePile->isTableau) yDelta += 2 * sourcePile->getCardCount();
    519e:	6828      	ldr	r0, [r5, #0]
  if (pile->isTableau) yDelta += 2 * pile->getCardCount();
  moving.x = updatePosition(moving.x, pile->x);
  moving.y = updatePosition(moving.y, pile->y + yDelta);  
}

void drawIllegalMove() {
    51a0:	b085      	sub	sp, #20
  // Move the cards back to the source pile.
  byte yDelta = 0;
  if (sourcePile->isTableau) yDelta += 2 * sourcePile->getCardCount();
    51a2:	7903      	ldrb	r3, [r0, #4]
    51a4:	42b3      	cmp	r3, r6
    51a6:	d003      	beq.n	51b0 <_Z15drawIllegalMovev+0x18>
    51a8:	f000 fa0e 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    51ac:	0046      	lsls	r6, r0, #1
    51ae:	b2f6      	uxtb	r6, r6
  moving.x = updatePosition(moving.x, sourcePile->x);
    51b0:	4c22      	ldr	r4, [pc, #136]	; (523c <_Z15drawIllegalMovev+0xa4>)
    51b2:	682f      	ldr	r7, [r5, #0]
    51b4:	7820      	ldrb	r0, [r4, #0]
    51b6:	7839      	ldrb	r1, [r7, #0]
    51b8:	f7ff f894 	bl	42e4 <_Z14updatePositionhh>
    51bc:	8020      	strh	r0, [r4, #0]
  moving.y = updatePosition(moving.y, sourcePile->y + yDelta); 
    51be:	8879      	ldrh	r1, [r7, #2]
    51c0:	78a0      	ldrb	r0, [r4, #2]
    51c2:	1871      	adds	r1, r6, r1
    51c4:	b2c9      	uxtb	r1, r1
    51c6:	f7ff f88d 	bl	42e4 <_Z14updatePositionhh>
    51ca:	8060      	strh	r0, [r4, #2]
  drawPile(&moving);
    51cc:	1c20      	adds	r0, r4, #0
    51ce:	f7ff fab3 	bl	4738 <_Z8drawPileP4Pile>
  // Check to see if the animation is done
  if (moving.x == sourcePile->x && moving.y == sourcePile->y + yDelta) {
    51d2:	6828      	ldr	r0, [r5, #0]
    51d4:	2100      	movs	r1, #0
    51d6:	5e62      	ldrsh	r2, [r4, r1]
    51d8:	2100      	movs	r1, #0
    51da:	5e43      	ldrsh	r3, [r0, r1]
    51dc:	429a      	cmp	r2, r3
    51de:	d128      	bne.n	5232 <_Z15drawIllegalMovev+0x9a>
    51e0:	2202      	movs	r2, #2
    51e2:	5ea3      	ldrsh	r3, [r4, r2]
    51e4:	2102      	movs	r1, #2
    51e6:	5e42      	ldrsh	r2, [r0, r1]
    51e8:	1996      	adds	r6, r2, r6
    51ea:	42b3      	cmp	r3, r6
    51ec:	d121      	bne.n	5232 <_Z15drawIllegalMovev+0x9a>
    sourcePile->addPile(&moving);
    51ee:	1c21      	adds	r1, r4, #0
    51f0:	f000 f9fc 	bl	55ec <_ZN4Pile7addPileEPS_>
    bool revealed = updateAfterPlay();
    51f4:	f7ff fdac 	bl	4d50 <_Z15updateAfterPlayv>
    
    // Update undo stack if this was a fast move to the foundation.
    if (mode == fastFoundation) {
    51f8:	4c11      	ldr	r4, [pc, #68]	; (5240 <_Z15drawIllegalMovev+0xa8>)
  moving.y = updatePosition(moving.y, sourcePile->y + yDelta); 
  drawPile(&moving);
  // Check to see if the animation is done
  if (moving.x == sourcePile->x && moving.y == sourcePile->y + yDelta) {
    sourcePile->addPile(&moving);
    bool revealed = updateAfterPlay();
    51fa:	1c06      	adds	r6, r0, #0
    
    // Update undo stack if this was a fast move to the foundation.
    if (mode == fastFoundation) {
    51fc:	7823      	ldrb	r3, [r4, #0]
    51fe:	2b05      	cmp	r3, #5
    5200:	d112      	bne.n	5228 <_Z15drawIllegalMovev+0x90>
      UndoAction action;
      action.source = getActiveLocationPile();
    5202:	f7ff f847 	bl	4294 <_Z21getActiveLocationPilev>
      action.destination = sourcePile;
    5206:	682d      	ldr	r5, [r5, #0]
    bool revealed = updateAfterPlay();
    
    // Update undo stack if this was a fast move to the foundation.
    if (mode == fastFoundation) {
      UndoAction action;
      action.source = getActiveLocationPile();
    5208:	ab01      	add	r3, sp, #4
    520a:	6058      	str	r0, [r3, #4]
      action.destination = sourcePile;
    520c:	609d      	str	r5, [r3, #8]
      action.setCardCount(1);
      if (revealed) action.setRevealed();
    520e:	2e00      	cmp	r6, #0
    5210:	d102      	bne.n	5218 <_Z15drawIllegalMovev+0x80>

struct UndoAction {
    byte special = 0;
    Pile *source;
    Pile *destination;
    void setCardCount(byte cardCount) { special = (special & 0xf0) | (cardCount & 0x0f); }
    5212:	2201      	movs	r2, #1
    5214:	701a      	strb	r2, [r3, #0]
    5216:	e001      	b.n	521c <_Z15drawIllegalMovev+0x84>
    byte getCardCount() { return special & 0x0f; }
    void setRevealed() { special |= 0x80; }
    5218:	2281      	movs	r2, #129	; 0x81
    521a:	701a      	strb	r2, [r3, #0]
      undo.pushAction(action);
    521c:	685a      	ldr	r2, [r3, #4]
    521e:	4809      	ldr	r0, [pc, #36]	; (5244 <_Z15drawIllegalMovev+0xac>)
    5220:	9901      	ldr	r1, [sp, #4]
    5222:	689b      	ldr	r3, [r3, #8]
    5224:	f000 fb15 	bl	5852 <_ZN9UndoStack10pushActionE10UndoAction>
    }
    if (mode != wonGame) mode = selecting;
    5228:	7823      	ldrb	r3, [r4, #0]
    522a:	2b06      	cmp	r3, #6
    522c:	d001      	beq.n	5232 <_Z15drawIllegalMovev+0x9a>
    522e:	2301      	movs	r3, #1
    5230:	7023      	strb	r3, [r4, #0]
  }
}
    5232:	b005      	add	sp, #20
    5234:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5236:	46c0      	nop			; (mov r8, r8)
    5238:	20000484 	.word	0x20000484
    523c:	200001f0 	.word	0x200001f0
    5240:	200002a0 	.word	0x200002a0
    5244:	20000200 	.word	0x20000200

00005248 <_Z23handleMovingPileButtonsv>:
  if (originalLocation != activeLocation) cardIndex = 0;

  handleCommonButtons();
}

void handleMovingPileButtons() {
    5248:	b573      	push	{r0, r1, r4, r5, r6, lr}
  // Handle buttons when user is moving a pile of cards.
  if (gb.buttons.repeat(BUTTON_RIGHT, 8)) {
    524a:	4c6b      	ldr	r4, [pc, #428]	; (53f8 <_Z23handleMovingPileButtonsv+0x1b0>)
    524c:	2102      	movs	r1, #2
    524e:	1c20      	adds	r0, r4, #0
    5250:	2208      	movs	r2, #8
    5252:	f002 fd2d 	bl	7cb0 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt>
    5256:	2800      	cmp	r0, #0
    5258:	d007      	beq.n	526a <_Z23handleMovingPileButtonsv+0x22>
    if (activeLocation != foundation4 && activeLocation != tableau7) {
    525a:	4a68      	ldr	r2, [pc, #416]	; (53fc <_Z23handleMovingPileButtonsv+0x1b4>)
    525c:	7813      	ldrb	r3, [r2, #0]
    525e:	2b05      	cmp	r3, #5
    5260:	d003      	beq.n	526a <_Z23handleMovingPileButtonsv+0x22>
    5262:	2b0c      	cmp	r3, #12
    5264:	d001      	beq.n	526a <_Z23handleMovingPileButtonsv+0x22>
      activeLocation = (Location)(activeLocation + 1);
    5266:	3301      	adds	r3, #1
    5268:	7013      	strb	r3, [r2, #0]
    }
  }
  if (gb.buttons.repeat(BUTTON_LEFT, 8)) {
    526a:	1c20      	adds	r0, r4, #0
    526c:	2101      	movs	r1, #1
    526e:	2208      	movs	r2, #8
    5270:	f002 fd1e 	bl	7cb0 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt>
    5274:	2800      	cmp	r0, #0
    5276:	d007      	beq.n	5288 <_Z23handleMovingPileButtonsv+0x40>
    if (activeLocation != talon && activeLocation != tableau1) {
    5278:	4a60      	ldr	r2, [pc, #384]	; (53fc <_Z23handleMovingPileButtonsv+0x1b4>)
    527a:	7813      	ldrb	r3, [r2, #0]
    527c:	2b01      	cmp	r3, #1
    527e:	d003      	beq.n	5288 <_Z23handleMovingPileButtonsv+0x40>
    5280:	2b06      	cmp	r3, #6
    5282:	d001      	beq.n	5288 <_Z23handleMovingPileButtonsv+0x40>
      activeLocation = (Location)(activeLocation - 1);
    5284:	3b01      	subs	r3, #1
    5286:	7013      	strb	r3, [r2, #0]
    }
  }
  if (gb.buttons.repeat(BUTTON_DOWN, 8)) {
    5288:	1c20      	adds	r0, r4, #0
    528a:	2100      	movs	r1, #0
    528c:	2208      	movs	r2, #8
    528e:	f002 fd0f 	bl	7cb0 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt>
    5292:	2800      	cmp	r0, #0
    5294:	d00a      	beq.n	52ac <_Z23handleMovingPileButtonsv+0x64>
    if (activeLocation == talon) activeLocation = tableau2;
    5296:	4b59      	ldr	r3, [pc, #356]	; (53fc <_Z23handleMovingPileButtonsv+0x1b4>)
    5298:	781a      	ldrb	r2, [r3, #0]
    529a:	2a01      	cmp	r2, #1
    529c:	d102      	bne.n	52a4 <_Z23handleMovingPileButtonsv+0x5c>
    529e:	2207      	movs	r2, #7
    52a0:	701a      	strb	r2, [r3, #0]
    52a2:	e003      	b.n	52ac <_Z23handleMovingPileButtonsv+0x64>
    else if (activeLocation <= foundation4) activeLocation = (Location)(activeLocation + 7);
    52a4:	2a05      	cmp	r2, #5
    52a6:	d801      	bhi.n	52ac <_Z23handleMovingPileButtonsv+0x64>
    52a8:	3207      	adds	r2, #7
    52aa:	701a      	strb	r2, [r3, #0]
  }
  if (gb.buttons.repeat(BUTTON_UP, 8)) {
    52ac:	1c20      	adds	r0, r4, #0
    52ae:	2103      	movs	r1, #3
    52b0:	2208      	movs	r2, #8
    52b2:	f002 fcfd 	bl	7cb0 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt>
    52b6:	2800      	cmp	r0, #0
    52b8:	d00a      	beq.n	52d0 <_Z23handleMovingPileButtonsv+0x88>
    if (activeLocation >= tableau4) activeLocation = (Location)(activeLocation - 7);
    52ba:	4b50      	ldr	r3, [pc, #320]	; (53fc <_Z23handleMovingPileButtonsv+0x1b4>)
    52bc:	781a      	ldrb	r2, [r3, #0]
    52be:	2a08      	cmp	r2, #8
    52c0:	d902      	bls.n	52c8 <_Z23handleMovingPileButtonsv+0x80>
    52c2:	3a07      	subs	r2, #7
    52c4:	701a      	strb	r2, [r3, #0]
    52c6:	e003      	b.n	52d0 <_Z23handleMovingPileButtonsv+0x88>
    else if (activeLocation >= tableau1) activeLocation = talon;
    52c8:	2a05      	cmp	r2, #5
    52ca:	d901      	bls.n	52d0 <_Z23handleMovingPileButtonsv+0x88>
    52cc:	2201      	movs	r2, #1
    52ce:	701a      	strb	r2, [r3, #0]
  }
  if (gb.buttons.pressed(BUTTON_A)) {
    52d0:	1c20      	adds	r0, r4, #0
    52d2:	2104      	movs	r1, #4
    52d4:	f002 fcd2 	bl	7c7c <_ZN14Gamebuino_Meta7Buttons7pressedENS_6ButtonE>
    52d8:	2800      	cmp	r0, #0
    52da:	d100      	bne.n	52de <_Z23handleMovingPileButtonsv+0x96>
    52dc:	e084      	b.n	53e8 <_Z23handleMovingPileButtonsv+0x1a0>
    playSoundB();
    52de:	f7ff f8a9 	bl	4434 <_Z10playSoundBv>
    switch (activeLocation) {
    52e2:	4b46      	ldr	r3, [pc, #280]	; (53fc <_Z23handleMovingPileButtonsv+0x1b4>)
    52e4:	7818      	ldrb	r0, [r3, #0]
    52e6:	3801      	subs	r0, #1
    52e8:	280b      	cmp	r0, #11
    52ea:	d87d      	bhi.n	53e8 <_Z23handleMovingPileButtonsv+0x1a0>
    52ec:	f00c f840 	bl	11370 <__gnu_thumb1_case_uqi>
    52f0:	0606067f 	.word	0x0606067f
    52f4:	42424206 	.word	0x42424206
    52f8:	42424242 	.word	0x42424242
      case foundation1:
      case foundation2:
      case foundation3:
      case foundation4:
        {
          if (moving.getCardCount() != 1) {
    52fc:	4d40      	ldr	r5, [pc, #256]	; (5400 <_Z23handleMovingPileButtonsv+0x1b8>)
    52fe:	1c28      	adds	r0, r5, #0
    5300:	f000 f962 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    5304:	2801      	cmp	r0, #1
    5306:	d000      	beq.n	530a <_Z23handleMovingPileButtonsv+0xc2>
    5308:	e071      	b.n	53ee <_Z23handleMovingPileButtonsv+0x1a6>
            mode = illegalMove;
            break;
          }
          Pile *destinationFoundation = getActiveLocationPile();
    530a:	f7fe ffc3 	bl	4294 <_Z21getActiveLocationPilev>
    530e:	1c06      	adds	r6, r0, #0
          if (destinationFoundation->getCardCount() == 0) {
    5310:	f000 f95a 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    5314:	ac01      	add	r4, sp, #4
    5316:	1e01      	subs	r1, r0, #0
    5318:	d109      	bne.n	532e <_Z23handleMovingPileButtonsv+0xe6>
            if (moving.getCard(0).getValue() != ace) {
    531a:	1c28      	adds	r0, r5, #0
    531c:	f000 f956 	bl	55cc <_ZNK4Pile7getCardEi>
    5320:	7020      	strb	r0, [r4, #0]
    5322:	1c20      	adds	r0, r4, #0
    5324:	f7fe ff01 	bl	412a <_ZNK4Card8getValueEv>
    5328:	2801      	cmp	r0, #1
    532a:	d160      	bne.n	53ee <_Z23handleMovingPileButtonsv+0x1a6>
    532c:	e01d      	b.n	536a <_Z23handleMovingPileButtonsv+0x122>
              mode = illegalMove;
              break;
            }
          }
          else {
            Card card1 = destinationFoundation->getCard(0);
    532e:	2100      	movs	r1, #0
    5330:	1c30      	adds	r0, r6, #0
    5332:	f000 f94b 	bl	55cc <_ZNK4Pile7getCardEi>
    5336:	466b      	mov	r3, sp
    5338:	7018      	strb	r0, [r3, #0]
            Card card2 = moving.getCard(0);
    533a:	2100      	movs	r1, #0
    533c:	1c28      	adds	r0, r5, #0
    533e:	f000 f945 	bl	55cc <_ZNK4Pile7getCardEi>
    5342:	7020      	strb	r0, [r4, #0]
            if (card1.getSuit() != card2.getSuit() || card1.getValue() + 1 != card2.getValue()) {
    5344:	4668      	mov	r0, sp
    5346:	f7fe fef4 	bl	4132 <_ZNK4Card7getSuitEv>
    534a:	1c05      	adds	r5, r0, #0
    534c:	1c20      	adds	r0, r4, #0
    534e:	f7fe fef0 	bl	4132 <_ZNK4Card7getSuitEv>
    5352:	4285      	cmp	r5, r0
    5354:	d14b      	bne.n	53ee <_Z23handleMovingPileButtonsv+0x1a6>
    5356:	4668      	mov	r0, sp
    5358:	f7fe fee7 	bl	412a <_ZNK4Card8getValueEv>
    535c:	1c05      	adds	r5, r0, #0
    535e:	1c20      	adds	r0, r4, #0
    5360:	f7fe fee3 	bl	412a <_ZNK4Card8getValueEv>
    5364:	3501      	adds	r5, #1
    5366:	4285      	cmp	r5, r0
    5368:	d141      	bne.n	53ee <_Z23handleMovingPileButtonsv+0x1a6>
              mode = illegalMove;
              break;
            }
          }
          moveCards();
    536a:	f7ff fd09 	bl	4d80 <_Z9moveCardsv>
          checkWonGame();
    536e:	f7ff fcb7 	bl	4ce0 <_Z12checkWonGamev>
        }
        break;
    5372:	e039      	b.n	53e8 <_Z23handleMovingPileButtonsv+0x1a0>
      case tableau4:
      case tableau5:
      case tableau6:
      case tableau7:
        {
          Pile *destinationTableau = getActiveLocationPile();
    5374:	f7fe ff8e 	bl	4294 <_Z21getActiveLocationPilev>
    5378:	1c06      	adds	r6, r0, #0
          if (destinationTableau->getCardCount() > 0) {
    537a:	f000 f925 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    537e:	ac01      	add	r4, sp, #4
    5380:	4d1f      	ldr	r5, [pc, #124]	; (5400 <_Z23handleMovingPileButtonsv+0x1b8>)
    5382:	2800      	cmp	r0, #0
    5384:	d021      	beq.n	53ca <_Z23handleMovingPileButtonsv+0x182>
            // Make sure that it is a decending value, alternating color.
            Card card1 = destinationTableau->getCard(0);
    5386:	2100      	movs	r1, #0
    5388:	1c30      	adds	r0, r6, #0
    538a:	f000 f91f 	bl	55cc <_ZNK4Pile7getCardEi>
    538e:	466b      	mov	r3, sp
    5390:	7018      	strb	r0, [r3, #0]
            Card card2 = moving.getCard(moving.getCardCount() - 1);
    5392:	1c28      	adds	r0, r5, #0
    5394:	f000 f918 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    5398:	1e41      	subs	r1, r0, #1
    539a:	1c28      	adds	r0, r5, #0
    539c:	f000 f916 	bl	55cc <_ZNK4Pile7getCardEi>
    53a0:	7020      	strb	r0, [r4, #0]
            if (card1.isRed() == card2.isRed() || card1.getValue() != card2.getValue() + 1) {
    53a2:	4668      	mov	r0, sp
    53a4:	f7fe fec9 	bl	413a <_ZNK4Card5isRedEv>
    53a8:	1c05      	adds	r5, r0, #0
    53aa:	1c20      	adds	r0, r4, #0
    53ac:	f7fe fec5 	bl	413a <_ZNK4Card5isRedEv>
    53b0:	4285      	cmp	r5, r0
    53b2:	d01c      	beq.n	53ee <_Z23handleMovingPileButtonsv+0x1a6>
    53b4:	4668      	mov	r0, sp
    53b6:	f7fe feb8 	bl	412a <_ZNK4Card8getValueEv>
    53ba:	1c05      	adds	r5, r0, #0
    53bc:	1c20      	adds	r0, r4, #0
    53be:	f7fe feb4 	bl	412a <_ZNK4Card8getValueEv>
    53c2:	3001      	adds	r0, #1
    53c4:	4285      	cmp	r5, r0
    53c6:	d112      	bne.n	53ee <_Z23handleMovingPileButtonsv+0x1a6>
    53c8:	e00c      	b.n	53e4 <_Z23handleMovingPileButtonsv+0x19c>
              break;
            }
          }
          else {
            // You can only place kings in an empty tableau.
            Card card = moving.getCard(moving.getCardCount() - 1);
    53ca:	1c28      	adds	r0, r5, #0
    53cc:	f000 f8fc 	bl	55c8 <_ZNK4Pile12getCardCountEv>
    53d0:	1e41      	subs	r1, r0, #1
    53d2:	1c28      	adds	r0, r5, #0
    53d4:	f000 f8fa 	bl	55cc <_ZNK4Pile7getCardEi>
    53d8:	7020      	strb	r0, [r4, #0]
            if (card.getValue() != king) {
    53da:	1c20      	adds	r0, r4, #0
    53dc:	f7fe fea5 	bl	412a <_ZNK4Card8getValueEv>
    53e0:	280d      	cmp	r0, #13
    53e2:	d104      	bne.n	53ee <_Z23handleMovingPileButtonsv+0x1a6>
              mode = illegalMove;
              break;
            }
          }
        }
        moveCards();
    53e4:	f7ff fccc 	bl	4d80 <_Z9moveCardsv>
        break;
    }
  }

  handleCommonButtons();
    53e8:	f7ff fd50 	bl	4e8c <_Z19handleCommonButtonsv>
}
    53ec:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
          if (destinationTableau->getCardCount() > 0) {
            // Make sure that it is a decending value, alternating color.
            Card card1 = destinationTableau->getCard(0);
            Card card2 = moving.getCard(moving.getCardCount() - 1);
            if (card1.isRed() == card2.isRed() || card1.getValue() != card2.getValue() + 1) {
              mode = illegalMove;
    53ee:	4b05      	ldr	r3, [pc, #20]	; (5404 <_Z23handleMovingPileButtonsv+0x1bc>)
    53f0:	2204      	movs	r2, #4
    53f2:	701a      	strb	r2, [r3, #0]
    53f4:	e7f8      	b.n	53e8 <_Z23handleMovingPileButtonsv+0x1a0>
    53f6:	46c0      	nop			; (mov r8, r8)
    53f8:	20000a3c 	.word	0x20000a3c
    53fc:	2000027c 	.word	0x2000027c
    5400:	200001f0 	.word	0x200001f0
    5404:	200002a0 	.word	0x200002a0

00005408 <_Z10drawCursorhhb>:
      flipped = true;
      break;
  }
}

void drawCursor(byte x, byte y, bool flipped) {
    5408:	b5f0      	push	{r4, r5, r6, r7, lr}
    540a:	4d44      	ldr	r5, [pc, #272]	; (551c <_Z10drawCursorhhb+0x114>)
    540c:	1c06      	adds	r6, r0, #0
    540e:	b085      	sub	sp, #20
    5410:	1c0c      	adds	r4, r1, #0
    5412:	4843      	ldr	r0, [pc, #268]	; (5520 <_Z10drawCursorhhb+0x118>)
  if (flipped) {
    if (cardIndex == 0) {
    5414:	782b      	ldrb	r3, [r5, #0]
      break;
  }
}

void drawCursor(byte x, byte y, bool flipped) {
  if (flipped) {
    5416:	2a00      	cmp	r2, #0
    5418:	d045      	beq.n	54a6 <_Z10drawCursorhhb+0x9e>
    if (cardIndex == 0) {
    541a:	2b00      	cmp	r3, #0
    541c:	d10a      	bne.n	5434 <_Z10drawCursorhhb+0x2c>
      gb.display.drawImage(x, y, cursorImage, -7, 7);
    541e:	2307      	movs	r3, #7
    5420:	425b      	negs	r3, r3
    5422:	9300      	str	r3, [sp, #0]
    5424:	2307      	movs	r3, #7
    5426:	9301      	str	r3, [sp, #4]
    5428:	b231      	sxth	r1, r6
    542a:	b222      	sxth	r2, r4
    542c:	4b3d      	ldr	r3, [pc, #244]	; (5524 <_Z10drawCursorhhb+0x11c>)
    542e:	f005 ff13 	bl	b258 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_ss>
    5432:	e070      	b.n	5516 <_Z10drawCursorhhb+0x10e>
    }
    else {
      gb.display.drawImage(x - 14, y - 1, cursorDetailsImage, -21, 9);
    5434:	2315      	movs	r3, #21
    5436:	1c31      	adds	r1, r6, #0
    5438:	425b      	negs	r3, r3
    543a:	9300      	str	r3, [sp, #0]
    543c:	1e62      	subs	r2, r4, #1
    543e:	2309      	movs	r3, #9
    5440:	390e      	subs	r1, #14
    5442:	b212      	sxth	r2, r2
    5444:	b209      	sxth	r1, r1
    5446:	9301      	str	r3, [sp, #4]
    5448:	4b37      	ldr	r3, [pc, #220]	; (5528 <_Z10drawCursorhhb+0x120>)
    544a:	f005 ff05 	bl	b258 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_ss>
      Card card = getActiveLocationPile()->getCard(cardIndex);
    544e:	f7fe ff21 	bl	4294 <_Z21getActiveLocationPilev>
    5452:	7829      	ldrb	r1, [r5, #0]
    5454:	f000 f8ba 	bl	55cc <_ZNK4Pile7getCardEi>
    5458:	ad03      	add	r5, sp, #12
    545a:	7028      	strb	r0, [r5, #0]
      byte extraWidth = card.getValue() == ten ? 2 : 1;
    545c:	1c28      	adds	r0, r5, #0
    545e:	f7fe fe64 	bl	412a <_ZNK4Card8getValueEv>
    5462:	1c03      	adds	r3, r0, #0
    5464:	3b0a      	subs	r3, #10
    5466:	1e5a      	subs	r2, r3, #1
    5468:	4193      	sbcs	r3, r2
      drawValue(x - 12 + extraWidth, y + 1, card.getValue(), card.isRed());
    546a:	1c28      	adds	r0, r5, #0
      gb.display.drawImage(x, y, cursorImage, -7, 7);
    }
    else {
      gb.display.drawImage(x - 14, y - 1, cursorDetailsImage, -21, 9);
      Card card = getActiveLocationPile()->getCard(cardIndex);
      byte extraWidth = card.getValue() == ten ? 2 : 1;
    546c:	1af6      	subs	r6, r6, r3
      drawValue(x - 12 + extraWidth, y + 1, card.getValue(), card.isRed());
    546e:	f7fe fe5c 	bl	412a <_ZNK4Card8getValueEv>
    5472:	1c07      	adds	r7, r0, #0
    5474:	1c28      	adds	r0, r5, #0
    5476:	f7fe fe60 	bl	413a <_ZNK4Card5isRedEv>
    547a:	3602      	adds	r6, #2
    547c:	b2b6      	uxth	r6, r6
    547e:	1c03      	adds	r3, r0, #0
    5480:	3401      	adds	r4, #1
    5482:	1c30      	adds	r0, r6, #0
    5484:	b224      	sxth	r4, r4
    5486:	380c      	subs	r0, #12
    5488:	1c21      	adds	r1, r4, #0
    548a:	1c3a      	adds	r2, r7, #0
    548c:	b200      	sxth	r0, r0
    548e:	f7ff f88d 	bl	45ac <_Z9drawValuess5Valueb>
      drawSuit(x - 8 + extraWidth, y + 1, card.getSuit());
    5492:	1c28      	adds	r0, r5, #0
    5494:	f7fe fe4d 	bl	4132 <_ZNK4Card7getSuitEv>
    5498:	3e08      	subs	r6, #8
    549a:	1c02      	adds	r2, r0, #0
    549c:	1c21      	adds	r1, r4, #0
    549e:	b230      	sxth	r0, r6
    54a0:	f7ff f870 	bl	4584 <_Z8drawSuitss4Suit>
    54a4:	e037      	b.n	5516 <_Z10drawCursorhhb+0x10e>
    54a6:	b231      	sxth	r1, r6
    }
  }
  else {
    if (cardIndex == 0) {
    54a8:	2b00      	cmp	r3, #0
    54aa:	d104      	bne.n	54b6 <_Z10drawCursorhhb+0xae>
      gb.display.drawImage(x, y, cursorImage);
    54ac:	b222      	sxth	r2, r4
    54ae:	4b1d      	ldr	r3, [pc, #116]	; (5524 <_Z10drawCursorhhb+0x11c>)
    54b0:	f005 fe2a 	bl	b108 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_>
    54b4:	e02f      	b.n	5516 <_Z10drawCursorhhb+0x10e>
    }
    else {
      gb.display.drawImage(x, y - 1, cursorDetailsImage);
    54b6:	1e62      	subs	r2, r4, #1
    54b8:	b212      	sxth	r2, r2
    54ba:	4b1b      	ldr	r3, [pc, #108]	; (5528 <_Z10drawCursorhhb+0x120>)
    54bc:	f005 fe24 	bl	b108 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_>
      Card card = getActiveLocationPile()->getCard(cardIndex);
    54c0:	f7fe fee8 	bl	4294 <_Z21getActiveLocationPilev>
    54c4:	7829      	ldrb	r1, [r5, #0]
    54c6:	f000 f881 	bl	55cc <_ZNK4Pile7getCardEi>
    54ca:	ad03      	add	r5, sp, #12
    54cc:	7028      	strb	r0, [r5, #0]
      byte extraWidth = card.getValue() == ten ? 2 : 1;
    54ce:	1c28      	adds	r0, r5, #0
    54d0:	f7fe fe2b 	bl	412a <_ZNK4Card8getValueEv>
    54d4:	1c03      	adds	r3, r0, #0
    54d6:	3b0a      	subs	r3, #10
    54d8:	1e5a      	subs	r2, r3, #1
    54da:	4193      	sbcs	r3, r2
      drawValue(x + 8 + extraWidth, y + 1, card.getValue(), card.isRed());
    54dc:	1c28      	adds	r0, r5, #0
      gb.display.drawImage(x, y, cursorImage);
    }
    else {
      gb.display.drawImage(x, y - 1, cursorDetailsImage);
      Card card = getActiveLocationPile()->getCard(cardIndex);
      byte extraWidth = card.getValue() == ten ? 2 : 1;
    54de:	1af6      	subs	r6, r6, r3
      drawValue(x + 8 + extraWidth, y + 1, card.getValue(), card.isRed());
    54e0:	f7fe fe23 	bl	412a <_ZNK4Card8getValueEv>
    54e4:	1c07      	adds	r7, r0, #0
    54e6:	1c28      	adds	r0, r5, #0
    54e8:	f7fe fe27 	bl	413a <_ZNK4Card5isRedEv>
    54ec:	3602      	adds	r6, #2
    54ee:	b2b6      	uxth	r6, r6
    54f0:	1c03      	adds	r3, r0, #0
    54f2:	3401      	adds	r4, #1
    54f4:	1c30      	adds	r0, r6, #0
    54f6:	b224      	sxth	r4, r4
    54f8:	3008      	adds	r0, #8
    54fa:	1c21      	adds	r1, r4, #0
    54fc:	1c3a      	adds	r2, r7, #0
    54fe:	b200      	sxth	r0, r0
    5500:	f7ff f854 	bl	45ac <_Z9drawValuess5Valueb>
      drawSuit(x + 12 + extraWidth, y + 1, card.getSuit());
    5504:	1c28      	adds	r0, r5, #0
    5506:	f7fe fe14 	bl	4132 <_ZNK4Card7getSuitEv>
    550a:	360c      	adds	r6, #12
    550c:	1c02      	adds	r2, r0, #0
    550e:	1c21      	adds	r1, r4, #0
    5510:	b230      	sxth	r0, r6
    5512:	f7ff f837 	bl	4584 <_Z8drawSuitss4Suit>
    }
  }
}
    5516:	b005      	add	sp, #20
    5518:	bdf0      	pop	{r4, r5, r6, r7, pc}
    551a:	46c0      	nop			; (mov r8, r8)
    551c:	200002a4 	.word	0x200002a4
    5520:	20000a4c 	.word	0x20000a4c
    5524:	20000488 	.word	0x20000488
    5528:	200005a0 	.word	0x200005a0

0000552c <_Z10drawCursorv>:
  bounce.yVelocity = -1 * random(0x0200);
  bounceIndex = (bounceIndex + 1) % 4;
  return true;
}

void drawCursor() {
    552c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  bool flipped;
  byte x, y;
  getCursorDestination(x, y, flipped);
    552e:	466c      	mov	r4, sp
    5530:	466f      	mov	r7, sp
    5532:	466d      	mov	r5, sp
    5534:	3707      	adds	r7, #7
    5536:	3505      	adds	r5, #5
    5538:	3406      	adds	r4, #6
    553a:	1c2a      	adds	r2, r5, #0
    553c:	1c39      	adds	r1, r7, #0
    553e:	1c20      	adds	r0, r4, #0
    5540:	f7fe ff04 	bl	434c <_Z20getCursorDestinationRhS_Rb>
  
  cursorX = updatePosition(cursorX, x);
    5544:	4e09      	ldr	r6, [pc, #36]	; (556c <_Z10drawCursorv+0x40>)
    5546:	7821      	ldrb	r1, [r4, #0]
    5548:	7830      	ldrb	r0, [r6, #0]
    554a:	f7fe fecb 	bl	42e4 <_Z14updatePositionhh>
    554e:	7030      	strb	r0, [r6, #0]
  cursorY = updatePosition(cursorY, y);
    5550:	4e07      	ldr	r6, [pc, #28]	; (5570 <_Z10drawCursorv+0x44>)
    5552:	7839      	ldrb	r1, [r7, #0]
void drawCursor() {
  bool flipped;
  byte x, y;
  getCursorDestination(x, y, flipped);
  
  cursorX = updatePosition(cursorX, x);
    5554:	1c04      	adds	r4, r0, #0
  cursorY = updatePosition(cursorY, y);
    5556:	7830      	ldrb	r0, [r6, #0]
    5558:	f7fe fec4 	bl	42e4 <_Z14updatePositionhh>

  drawCursor(cursorX, cursorY, flipped);
    555c:	782a      	ldrb	r2, [r5, #0]
  bool flipped;
  byte x, y;
  getCursorDestination(x, y, flipped);
  
  cursorX = updatePosition(cursorX, x);
  cursorY = updatePosition(cursorY, y);
    555e:	7030      	strb	r0, [r6, #0]
    5560:	1c01      	adds	r1, r0, #0

  drawCursor(cursorX, cursorY, flipped);
    5562:	1c20      	adds	r0, r4, #0
    5564:	f7ff ff50 	bl	5408 <_Z10drawCursorhhb>
}
    5568:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    556a:	46c0      	nop			; (mov r8, r8)
    556c:	200002a1 	.word	0x200002a1
    5570:	200002a2 	.word	0x200002a2

00005574 <_ZN4PileC1Eh>:
#include "pile.h"
 
Pile::Pile(byte maxCards) {
    5574:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5576:	1c04      	adds	r4, r0, #0
  _count = 0;
    5578:	2300      	movs	r3, #0
    557a:	7343      	strb	r3, [r0, #13]
  _maxCards = maxCards;
    557c:	7321      	strb	r1, [r4, #12]
  _cards = new Card[_maxCards];
    557e:	1c08      	adds	r0, r1, #0
#include "pile.h"
 
Pile::Pile(byte maxCards) {
    5580:	1c0f      	adds	r7, r1, #0
  _count = 0;
  _maxCards = maxCards;
  _cards = new Card[_maxCards];
    5582:	f00a fe59 	bl	10238 <_Znaj>
    5586:	1c06      	adds	r6, r0, #0
    5588:	1c05      	adds	r5, r0, #0
    558a:	1c28      	adds	r0, r5, #0
    558c:	19f3      	adds	r3, r6, r7
    558e:	3501      	adds	r5, #1
    5590:	1b5b      	subs	r3, r3, r5
    5592:	3301      	adds	r3, #1
    5594:	d002      	beq.n	559c <_ZN4PileC1Eh+0x28>
    5596:	f7fe fe0d 	bl	41b4 <_ZN4CardC1Ev>
    559a:	e7f6      	b.n	558a <_ZN4PileC1Eh+0x16>
    559c:	60a6      	str	r6, [r4, #8]
}
    559e:	1c20      	adds	r0, r4, #0
    55a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000055a2 <_ZN4PileD1Ev>:

Pile::~Pile() {
    55a2:	b510      	push	{r4, lr}
    55a4:	1c04      	adds	r4, r0, #0
  delete[] _cards;
    55a6:	6880      	ldr	r0, [r0, #8]
    55a8:	2800      	cmp	r0, #0
    55aa:	d001      	beq.n	55b0 <_ZN4PileD1Ev+0xe>
    55ac:	f00a fe4c 	bl	10248 <_ZdaPv>
}
    55b0:	1c20      	adds	r0, r4, #0
    55b2:	bd10      	pop	{r4, pc}

000055b4 <_ZN4Pile7addCardE4Card>:

void Pile::addCard(Card card) {
  if (_count < _maxCards) _cards[_count++] = card;
    55b4:	7b43      	ldrb	r3, [r0, #13]
    55b6:	7b02      	ldrb	r2, [r0, #12]

Pile::~Pile() {
  delete[] _cards;
}

void Pile::addCard(Card card) {
    55b8:	b510      	push	{r4, lr}
  if (_count < _maxCards) _cards[_count++] = card;
    55ba:	429a      	cmp	r2, r3
    55bc:	d903      	bls.n	55c6 <_ZN4Pile7addCardE4Card+0x12>
    55be:	6882      	ldr	r2, [r0, #8]
    55c0:	1c5c      	adds	r4, r3, #1
    55c2:	7344      	strb	r4, [r0, #13]
    55c4:	54d1      	strb	r1, [r2, r3]
}
    55c6:	bd10      	pop	{r4, pc}

000055c8 <_ZNK4Pile12getCardCountEv>:
    addCard(pile->getCard(i));  
  }
}

byte Pile::getCardCount() const {
  return _count;
    55c8:	7b40      	ldrb	r0, [r0, #13]
}
    55ca:	4770      	bx	lr

000055cc <_ZNK4Pile7getCardEi>:

Card Pile::getCard(int indexFromTop) const {
    55cc:	b513      	push	{r0, r1, r4, lr}
  if (indexFromTop < _count) {
    55ce:	7b43      	ldrb	r3, [r0, #13]
    55d0:	4299      	cmp	r1, r3
    55d2:	da05      	bge.n	55e0 <_ZNK4Pile7getCardEi+0x14>
    return _cards[_count - indexFromTop - 1];
    55d4:	1a59      	subs	r1, r3, r1
    55d6:	6883      	ldr	r3, [r0, #8]
    55d8:	185b      	adds	r3, r3, r1
    55da:	3b01      	subs	r3, #1
    55dc:	7818      	ldrb	r0, [r3, #0]
    55de:	e004      	b.n	55ea <_ZNK4Pile7getCardEi+0x1e>
  }
  return Card();
    55e0:	ac01      	add	r4, sp, #4
    55e2:	1c20      	adds	r0, r4, #0
    55e4:	f7fe fde6 	bl	41b4 <_ZN4CardC1Ev>
    55e8:	7820      	ldrb	r0, [r4, #0]
}
    55ea:	bd16      	pop	{r1, r2, r4, pc}

000055ec <_ZN4Pile7addPileEPS_>:

void Pile::addCard(Card card) {
  if (_count < _maxCards) _cards[_count++] = card;
}

void Pile::addPile(Pile *pile) {
    55ec:	b570      	push	{r4, r5, r6, lr}
  for (int i = pile->getCardCount() - 1; i >= 0; i--) {
    55ee:	7b4c      	ldrb	r4, [r1, #13]

void Pile::addCard(Card card) {
  if (_count < _maxCards) _cards[_count++] = card;
}

void Pile::addPile(Pile *pile) {
    55f0:	1c06      	adds	r6, r0, #0
    55f2:	1c0d      	adds	r5, r1, #0
  for (int i = pile->getCardCount() - 1; i >= 0; i--) {
    55f4:	3c01      	subs	r4, #1
    55f6:	1c63      	adds	r3, r4, #1
    55f8:	d008      	beq.n	560c <_ZN4Pile7addPileEPS_+0x20>
    addCard(pile->getCard(i));  
    55fa:	1c21      	adds	r1, r4, #0
    55fc:	1c28      	adds	r0, r5, #0
    55fe:	f7ff ffe5 	bl	55cc <_ZNK4Pile7getCardEi>
    5602:	1c01      	adds	r1, r0, #0
    5604:	1c30      	adds	r0, r6, #0
    5606:	f7ff ffd5 	bl	55b4 <_ZN4Pile7addCardE4Card>
    560a:	e7f3      	b.n	55f4 <_ZN4Pile7addPileEPS_+0x8>
  }
}
    560c:	bd70      	pop	{r4, r5, r6, pc}

0000560e <_ZN4Pile13removeTopCardEv>:
    return _cards[_count - indexFromTop - 1];
  }
  return Card();
}

Card Pile::removeTopCard() {
    560e:	b513      	push	{r0, r1, r4, lr}
  if (_count > 0) return _cards[--_count];
    5610:	7b43      	ldrb	r3, [r0, #13]
    5612:	2b00      	cmp	r3, #0
    5614:	d005      	beq.n	5622 <_ZN4Pile13removeTopCardEv+0x14>
    5616:	3b01      	subs	r3, #1
    5618:	b2db      	uxtb	r3, r3
    561a:	6882      	ldr	r2, [r0, #8]
    561c:	7343      	strb	r3, [r0, #13]
    561e:	5cd0      	ldrb	r0, [r2, r3]
    5620:	e004      	b.n	562c <_ZN4Pile13removeTopCardEv+0x1e>
  return Card();
    5622:	ac01      	add	r4, sp, #4
    5624:	1c20      	adds	r0, r4, #0
    5626:	f7fe fdc5 	bl	41b4 <_ZN4CardC1Ev>
    562a:	7820      	ldrb	r0, [r4, #0]
}
    562c:	bd16      	pop	{r1, r2, r4, pc}

0000562e <_ZN4Pile11removeCardsEiPS_>:

void Pile::removeCards(int count, Pile* destination) {
    562e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  count = min(count, _count);
    5630:	7b43      	ldrb	r3, [r0, #13]
Card Pile::removeTopCard() {
  if (_count > 0) return _cards[--_count];
  return Card();
}

void Pile::removeCards(int count, Pile* destination) {
    5632:	1c06      	adds	r6, r0, #0
    5634:	1c17      	adds	r7, r2, #0
  count = min(count, _count);
    5636:	1e0c      	subs	r4, r1, #0
    5638:	429c      	cmp	r4, r3
    563a:	dd00      	ble.n	563e <_ZN4Pile11removeCardsEiPS_+0x10>
    563c:	1c1c      	adds	r4, r3, #0
  _count -= count;
    563e:	1b1b      	subs	r3, r3, r4
    5640:	7373      	strb	r3, [r6, #13]
  for (int i = 0; i < count; i++) destination->addCard(_cards[_count + i]);
    5642:	2500      	movs	r5, #0
    5644:	42a5      	cmp	r5, r4
    5646:	da08      	bge.n	565a <_ZN4Pile11removeCardsEiPS_+0x2c>
    5648:	68b1      	ldr	r1, [r6, #8]
    564a:	7b73      	ldrb	r3, [r6, #13]
    564c:	194a      	adds	r2, r1, r5
    564e:	5cd1      	ldrb	r1, [r2, r3]
    5650:	1c38      	adds	r0, r7, #0
    5652:	f7ff ffaf 	bl	55b4 <_ZN4Pile7addCardE4Card>
    5656:	3501      	adds	r5, #1
    5658:	e7f4      	b.n	5644 <_ZN4Pile11removeCardsEiPS_+0x16>
}
    565a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000565c <_ZN4Pile5emptyEv>:

void Pile::empty() {
  _count = 0;
    565c:	2300      	movs	r3, #0
    565e:	7343      	strb	r3, [r0, #13]
}
    5660:	4770      	bx	lr

00005662 <_ZN4Pile7shuffleEv>:

void Pile::shuffle() {
    5662:	b538      	push	{r3, r4, r5, lr}
    5664:	1c05      	adds	r5, r0, #0
  for (int i = 0; i < _count; i++) {
    5666:	2400      	movs	r4, #0
    5668:	7b68      	ldrb	r0, [r5, #13]
    566a:	4284      	cmp	r4, r0
    566c:	da13      	bge.n	5696 <_ZN4Pile7shuffleEv+0x34>
    int randomIndex = random(_count - i);
    566e:	1b00      	subs	r0, r0, r4
    5670:	f00a fda6 	bl	101c0 <_Z6randoml>
    Card tmp = _cards[randomIndex];
    _cards[randomIndex] = _cards[_count - i - 1];
    5674:	7b69      	ldrb	r1, [r5, #13]
}

void Pile::shuffle() {
  for (int i = 0; i < _count; i++) {
    int randomIndex = random(_count - i);
    Card tmp = _cards[randomIndex];
    5676:	68ab      	ldr	r3, [r5, #8]
    _cards[randomIndex] = _cards[_count - i - 1];
    5678:	1b09      	subs	r1, r1, r4
}

void Pile::shuffle() {
  for (int i = 0; i < _count; i++) {
    int randomIndex = random(_count - i);
    Card tmp = _cards[randomIndex];
    567a:	1818      	adds	r0, r3, r0
    _cards[randomIndex] = _cards[_count - i - 1];
    567c:	185b      	adds	r3, r3, r1
    567e:	3b01      	subs	r3, #1
    5680:	781b      	ldrb	r3, [r3, #0]
}

void Pile::shuffle() {
  for (int i = 0; i < _count; i++) {
    int randomIndex = random(_count - i);
    Card tmp = _cards[randomIndex];
    5682:	7802      	ldrb	r2, [r0, #0]
    _cards[randomIndex] = _cards[_count - i - 1];
    5684:	7003      	strb	r3, [r0, #0]
    _cards[_count - i - 1] = tmp;
    5686:	7b6b      	ldrb	r3, [r5, #13]
    5688:	68a9      	ldr	r1, [r5, #8]
    568a:	1b1b      	subs	r3, r3, r4
    568c:	18cb      	adds	r3, r1, r3
    568e:	3b01      	subs	r3, #1
    5690:	701a      	strb	r2, [r3, #0]
void Pile::empty() {
  _count = 0;
}

void Pile::shuffle() {
  for (int i = 0; i < _count; i++) {
    5692:	3401      	adds	r4, #1
    5694:	e7e8      	b.n	5668 <_ZN4Pile7shuffleEv+0x6>
    int randomIndex = random(_count - i);
    Card tmp = _cards[randomIndex];
    _cards[randomIndex] = _cards[_count - i - 1];
    _cards[_count - i - 1] = tmp;
  }
}
    5696:	bd38      	pop	{r3, r4, r5, pc}

00005698 <_ZN4Pile7newDeckEv>:

void Pile::newDeck() {
    5698:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  _count -= count;
  for (int i = 0; i < count; i++) destination->addCard(_cards[_count + i]);
}

void Pile::empty() {
  _count = 0;
    569a:	2500      	movs	r5, #0
    _cards[randomIndex] = _cards[_count - i - 1];
    _cards[_count - i - 1] = tmp;
  }
}

void Pile::newDeck() {
    569c:	1c06      	adds	r6, r0, #0
  _count -= count;
  for (int i = 0; i < count; i++) destination->addCard(_cards[_count + i]);
}

void Pile::empty() {
  _count = 0;
    569e:	7345      	strb	r5, [r0, #13]
    _cards[randomIndex] = _cards[_count - i - 1];
    _cards[_count - i - 1] = tmp;
  }
}

void Pile::newDeck() {
    56a0:	2401      	movs	r4, #1
  empty();
  for (int suit = spade; suit <= diamond; suit++) {
    for (int value = ace; value <= king; value++) {
      addCard(Card(static_cast<Value>(value), static_cast<Suit>(suit), true));
    56a2:	af01      	add	r7, sp, #4
    56a4:	b2e1      	uxtb	r1, r4
    56a6:	b2ea      	uxtb	r2, r5
    56a8:	2301      	movs	r3, #1
    56aa:	1c38      	adds	r0, r7, #0
    56ac:	f7fe fd32 	bl	4114 <_ZN4CardC1E5Value4Suitb>
}

void Pile::newDeck() {
  empty();
  for (int suit = spade; suit <= diamond; suit++) {
    for (int value = ace; value <= king; value++) {
    56b0:	3401      	adds	r4, #1
      addCard(Card(static_cast<Value>(value), static_cast<Suit>(suit), true));
    56b2:	7839      	ldrb	r1, [r7, #0]
    56b4:	1c30      	adds	r0, r6, #0
    56b6:	f7ff ff7d 	bl	55b4 <_ZN4Pile7addCardE4Card>
}

void Pile::newDeck() {
  empty();
  for (int suit = spade; suit <= diamond; suit++) {
    for (int value = ace; value <= king; value++) {
    56ba:	2c0e      	cmp	r4, #14
    56bc:	d1f1      	bne.n	56a2 <_ZN4Pile7newDeckEv+0xa>
  }
}

void Pile::newDeck() {
  empty();
  for (int suit = spade; suit <= diamond; suit++) {
    56be:	3501      	adds	r5, #1
    56c0:	2d04      	cmp	r5, #4
    56c2:	d1ed      	bne.n	56a0 <_ZN4Pile7newDeckEv+0x8>
    for (int value = ace; value <= king; value++) {
      addCard(Card(static_cast<Value>(value), static_cast<Suit>(suit), true));
    }
  }
}
    56c4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
	...

000056c8 <_Z11initSpritesv>:
Image cursorDetailsImage(cursorDetailsData, ColorMode::rgb565);

const uint16_t talonBackgroundData[] = {5,14,0x1f,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0x1f,0xffff,0xacd0,0xffff,0xacd0};
Image talonBackgroundImage(talonBackgroundData, ColorMode::rgb565);

void initSprites() {
    56c8:	b508      	push	{r3, lr}
  cardSprite.setTransparentColor((Color)0x1f);
    56ca:	480e      	ldr	r0, [pc, #56]	; (5704 <_Z11initSpritesv+0x3c>)
    56cc:	211f      	movs	r1, #31
    56ce:	f004 fbd3 	bl	9e78 <_ZN14Gamebuino_Meta8Graphics19setTransparentColorENS_5ColorE>
  cardTopSprite.setTransparentColor((Color)0x1f);
    56d2:	480d      	ldr	r0, [pc, #52]	; (5708 <_Z11initSpritesv+0x40>)
    56d4:	211f      	movs	r1, #31
    56d6:	f004 fbcf 	bl	9e78 <_ZN14Gamebuino_Meta8Graphics19setTransparentColorENS_5ColorE>
  valueSprite.setTransparentColor((Color)0x1f);
    56da:	480c      	ldr	r0, [pc, #48]	; (570c <_Z11initSpritesv+0x44>)
    56dc:	211f      	movs	r1, #31
    56de:	f004 fbcb 	bl	9e78 <_ZN14Gamebuino_Meta8Graphics19setTransparentColorENS_5ColorE>
  suitSprite.setTransparentColor((Color)0x1f);
    56e2:	480b      	ldr	r0, [pc, #44]	; (5710 <_Z11initSpritesv+0x48>)
    56e4:	211f      	movs	r1, #31
    56e6:	f004 fbc7 	bl	9e78 <_ZN14Gamebuino_Meta8Graphics19setTransparentColorENS_5ColorE>
  cursorImage.setTransparentColor((Color)0x1f);
    56ea:	480a      	ldr	r0, [pc, #40]	; (5714 <_Z11initSpritesv+0x4c>)
    56ec:	211f      	movs	r1, #31
    56ee:	f004 fbc3 	bl	9e78 <_ZN14Gamebuino_Meta8Graphics19setTransparentColorENS_5ColorE>
  cursorDetailsImage.setTransparentColor((Color)0x1f);
    56f2:	4809      	ldr	r0, [pc, #36]	; (5718 <_Z11initSpritesv+0x50>)
    56f4:	211f      	movs	r1, #31
    56f6:	f004 fbbf 	bl	9e78 <_ZN14Gamebuino_Meta8Graphics19setTransparentColorENS_5ColorE>
  talonBackgroundImage.setTransparentColor((Color)0x1f);
    56fa:	4808      	ldr	r0, [pc, #32]	; (571c <_Z11initSpritesv+0x54>)
    56fc:	211f      	movs	r1, #31
    56fe:	f004 fbbb 	bl	9e78 <_ZN14Gamebuino_Meta8Graphics19setTransparentColorENS_5ColorE>
}
    5702:	bd08      	pop	{r3, pc}
    5704:	20000528 	.word	0x20000528
    5708:	20000550 	.word	0x20000550
    570c:	200004d8 	.word	0x200004d8
    5710:	200004b0 	.word	0x200004b0
    5714:	20000488 	.word	0x20000488
    5718:	200005a0 	.word	0x200005a0
    571c:	20000500 	.word	0x20000500

00005720 <_GLOBAL__sub_I_backgroundImage>:
    5720:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#include "sprites.h"

const uint16_t backgroundData[] = {80,64,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x44a,0x409,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x409,0x409,0x409,0x44a,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x44a,0x409,0x409,0x409,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x409,0x409,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x409,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x409,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x44a,0x44a,0x409,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x409,0x409,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x409,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x409,0x409,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x409,0x409,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x409,0x409,0x409,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x409,0x409,0x409,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x409,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x409,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x44a,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x52b,0x4eb,0x44a,0x409,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x52b,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x409,0x52b,0x4eb,0x52b,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x44a,0x44a,0x409,0x44a,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x409,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x52b,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x44a,0x44a,0x44a,0x409,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x52b,0x4eb,0x44a,0x409,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x52b,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x409,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x409,0x52b,0x4eb,0x52b,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x409,0x44a,0x44a,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x44a,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x409,0x409,0x409,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x52b,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x52b,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x52b,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x409,0x409,0x409,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x409,0x409,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x409,0x409,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x409,0x409,0x409,0x44a,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x409,0x409,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x409,0x409,0x409,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x44a,0x409,0x409,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x44a,0x44a,0x409,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x44a,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x44a,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x44a,0x44a,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x409,0x44a,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x409,0x409,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x409,0x409,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x409,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x44a,0x409,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x52b,0x409,0x44a,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x409,0x44a,0x4eb,0x52b,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x4eb,0x52b,0x4eb,0x52b,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x409,0x44a,0x44a,0x409,0x44a,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x409,0x409,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x409,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x52b,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x44a,0x44a,0x44a,0x409,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x52b,0x409,0x44a,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x409,0x409,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x409,0x44a,0x4eb,0x52b,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x4eb,0x52b,0x4eb,0x52b,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x409,0x44a,0x44a,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x409,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x44a,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x409,0x409,0x409,0x4eb,0x52b,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x52b,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x44a,0x409,0x409,0x409,0x409,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x409,0x409,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x409,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x409,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x409,0x409,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x409,0x409,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x44a,0x44a,0x409,0x409,0x409,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x409,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x409,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x44a,0x44a,0x409,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x409,0x409,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x409,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x409,0x409,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x409,0x409,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x409,0x409,0x409,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x409,0x409,0x409,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x409,0x44a,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x409,0x409,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x409,0x409,0x409,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x44a,0x409,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x44a,0x409,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x44a,0x44a,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409};
Image backgroundImage(backgroundData, ColorMode::rgb565);
    5722:	4c33      	ldr	r4, [pc, #204]	; (57f0 <_GLOBAL__sub_I_backgroundImage+0xd0>)
    5724:	2701      	movs	r7, #1
    5726:	1c3b      	adds	r3, r7, #0
    5728:	9700      	str	r7, [sp, #0]
    572a:	1c20      	adds	r0, r4, #0
    572c:	4931      	ldr	r1, [pc, #196]	; (57f4 <_GLOBAL__sub_I_backgroundImage+0xd4>)
    572e:	2200      	movs	r2, #0
    5730:	f005 fc86 	bl	b040 <_ZN14Gamebuino_Meta5ImageC1EPKtNS_9ColorModeEth>
    5734:	4e30      	ldr	r6, [pc, #192]	; (57f8 <_GLOBAL__sub_I_backgroundImage+0xd8>)
    5736:	4d31      	ldr	r5, [pc, #196]	; (57fc <_GLOBAL__sub_I_backgroundImage+0xdc>)
    5738:	1c31      	adds	r1, r6, #0
    573a:	1c2a      	adds	r2, r5, #0
    573c:	1c20      	adds	r0, r4, #0

const uint16_t cardSpriteData[] = {9,14,0x1f,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0x1f,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0x1f,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0x1f,0x1f,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0x1f,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xcc68,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xcc68,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xcc68,0xcc68,0xcc68,0xcc68,0xcc68,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xcc68,0xcc68,0xcc68,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xcc68,0xfeb2,0xcc68,0xfeb2,0xcc68,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfd42,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0x1f,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0x1f};
Image cardSprite(cardSpriteData, ColorMode::rgb565, 2, 0);
    573e:	2400      	movs	r4, #0
#include "sprites.h"

const uint16_t backgroundData[] = {80,64,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x44a,0x409,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x409,0x409,0x409,0x44a,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x44a,0x409,0x409,0x409,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x409,0x409,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x409,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x409,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x44a,0x44a,0x409,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x409,0x409,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x409,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x409,0x409,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x409,0x409,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x409,0x409,0x409,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x409,0x409,0x409,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x409,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x409,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x44a,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x52b,0x4eb,0x44a,0x409,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x52b,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x409,0x52b,0x4eb,0x52b,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x44a,0x44a,0x409,0x44a,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x409,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x52b,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x44a,0x44a,0x44a,0x409,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x52b,0x4eb,0x44a,0x409,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x52b,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x409,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x409,0x52b,0x4eb,0x52b,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x409,0x44a,0x44a,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x44a,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x409,0x409,0x409,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x52b,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x52b,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x52b,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x409,0x409,0x409,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x409,0x409,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x409,0x409,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x409,0x409,0x409,0x44a,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x409,0x409,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x409,0x409,0x409,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x44a,0x409,0x409,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x44a,0x44a,0x409,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x44a,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x44a,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x44a,0x44a,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x409,0x44a,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x409,0x409,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x409,0x409,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x409,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x44a,0x409,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x52b,0x409,0x44a,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x409,0x44a,0x4eb,0x52b,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x4eb,0x52b,0x4eb,0x52b,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x409,0x44a,0x44a,0x409,0x44a,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x409,0x409,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x409,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x52b,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x44a,0x44a,0x44a,0x409,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x52b,0x409,0x44a,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x409,0x409,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x409,0x44a,0x4eb,0x52b,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x4eb,0x52b,0x4eb,0x52b,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x409,0x44a,0x44a,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x409,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x44a,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x409,0x409,0x409,0x4eb,0x52b,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x52b,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x44a,0x409,0x409,0x409,0x409,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x409,0x409,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x409,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x409,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x409,0x409,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x409,0x409,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x44a,0x44a,0x409,0x409,0x409,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x409,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x52b,0x409,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x44a,0x44a,0x409,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x409,0x409,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x409,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x409,0x409,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x409,0x409,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x409,0x409,0x409,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x4eb,0x409,0x409,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x409,0x409,0x409,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x52b,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x44a,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x52b,0x52b,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x409,0x409,0x44a,0x44a,0x409,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x409,0x409,0x44a,0x44a,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x52b,0x44a,0x409,0x44a,0x44a,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x52b,0x44a,0x409,0x409,0x409,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x4eb,0x44a,0x44a,0x44a,0x409,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x4eb,0x409,0x44a,0x44a,0x409,0x4eb,0x4eb,0x52b,0x52b,0x4eb,0x4eb,0x4eb,0x409,0x409,0x44a,0x44a,0x52b,0x4eb,0x52b,0x52b,0x52b,0x4eb,0x4eb,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x44a,0x409,0x44a,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409,0x409,0x409,0x409,0x409,0x409,0x409,0x44a,0x44a,0x44a,0x44a,0x44a,0x409};
Image backgroundImage(backgroundData, ColorMode::rgb565);
    5740:	f00b feda 	bl	114f8 <__aeabi_atexit>

const uint16_t cardSpriteData[] = {9,14,0x1f,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0x1f,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0x1f,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0x1f,0x1f,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0x1f,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xcc68,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xcc68,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xcc68,0xcc68,0xcc68,0xcc68,0xcc68,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xcc68,0xcc68,0xcc68,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xcc68,0xfeb2,0xcc68,0xfeb2,0xcc68,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfd42,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0x1f,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0x1f};
Image cardSprite(cardSpriteData, ColorMode::rgb565, 2, 0);
    5744:	1c22      	adds	r2, r4, #0
    5746:	2302      	movs	r3, #2
    5748:	9400      	str	r4, [sp, #0]
    574a:	492d      	ldr	r1, [pc, #180]	; (5800 <_GLOBAL__sub_I_backgroundImage+0xe0>)
    574c:	482d      	ldr	r0, [pc, #180]	; (5804 <_GLOBAL__sub_I_backgroundImage+0xe4>)
    574e:	f005 fc77 	bl	b040 <_ZN14Gamebuino_Meta5ImageC1EPKtNS_9ColorModeEth>
    5752:	1c31      	adds	r1, r6, #0
    5754:	1c2a      	adds	r2, r5, #0
    5756:	482b      	ldr	r0, [pc, #172]	; (5804 <_GLOBAL__sub_I_backgroundImage+0xe4>)
    5758:	f00b fece 	bl	114f8 <__aeabi_atexit>

const uint16_t cardTopSpriteData[] = {9,3,0x1f,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0x1f,0xffff,0xacd0,0xacd0,0xacd0,0xacd0,0xacd0,0xacd0,0xacd0,0xffff,0xacd0,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0xacd0,0x1f,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0xfeb2,0x1f,0xfeb2,0xcc68,0xcc68,0xcc68,0xcc68,0xcc68,0xcc68,0xcc68,0xfeb2,0xcc68,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0xcc68};
Image cardTopSprite(cardTopSpriteData, ColorMode::rgb565, 2, 0);
    575c:	1c22      	adds	r2, r4, #0
    575e:	2302      	movs	r3, #2
    5760:	9400      	str	r4, [sp, #0]
    5762:	4929      	ldr	r1, [pc, #164]	; (5808 <_GLOBAL__sub_I_backgroundImage+0xe8>)
    5764:	4829      	ldr	r0, [pc, #164]	; (580c <_GLOBAL__sub_I_backgroundImage+0xec>)
    5766:	f005 fc6b 	bl	b040 <_ZN14Gamebuino_Meta5ImageC1EPKtNS_9ColorModeEth>
    576a:	1c31      	adds	r1, r6, #0
    576c:	1c2a      	adds	r2, r5, #0
    576e:	4827      	ldr	r0, [pc, #156]	; (580c <_GLOBAL__sub_I_backgroundImage+0xec>)
    5770:	f00b fec2 	bl	114f8 <__aeabi_atexit>

const uint16_t valueSpriteData[] = {3,5,0x1f,0x1f,0x1f,0x1f,0x1f,0x0,0x1f,0x1f,0x0,0x1f,0x1f,0x0,0x1f,0x1f,0x0,0x1f,0x0,0x1f,0x0,0x1f,0x0,0x0,0x0,0x0,0x0,0x1f,0x0,0x0,0x1f,0x0,0x0,0x0,0x0,0x1f,0x1f,0x0,0x0,0x0,0x0,0x0,0x1f,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x1f,0x0,0x1f,0x0,0x0,0x1f,0x1f,0x0,0x0,0x0,0x0,0x0,0x1f,0x1f,0x0,0x1f,0x0,0x0,0x0,0x0,0x1f,0x1f,0x0,0x1f,0x1f,0x0,0x0,0x0,0x0,0x0,0x1f,0x1f,0x0,0x0,0x0,0x1f,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x1f,0x0,0x0,0x0,0x0,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x1f,0x0,0x1f,0x1f,0x0,0x1f,0x1f,0x0,0x1f,0x1f,0x0,0x0,0x0,0x0,0x0,0x1f,0x0,0x0,0x0,0x0,0x0,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x0,0x0,0x0,0x0,0x1f,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x0,0x0,0x1f,0x0,0x0,0x1f,0x0,0x0,0x0,0x0,0x1f,0x1f,0x0,0x1f,0x1f,0x0,0x1f,0x1f,0x0,0x0,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x0,0x0,0x1f,0x0,0x0,0x0,0x0,0x1f,0x0,0x1f,0x0,0x1f,0x0,0x0,0x1f,0x0,0x0,0x0,0x1f,0x0,0x1f,0x0,0x0,0x1f,0x0,0x1f,0x1f,0x1f,0x1f,0x1f,0xb8a2,0x1f,0x1f,0xb8a2,0x1f,0x1f,0xb8a2,0x1f,0x1f,0xb8a2,0x1f,0xb8a2,0x1f,0xb8a2,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0xb8a2,0xb8a2,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0x1f,0xb8a2,0x1f,0xb8a2,0xb8a2,0x1f,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0x1f,0xb8a2,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0x1f,0xb8a2,0x1f,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0x1f,0xb8a2,0xb8a2,0xb8a2,0x1f,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0x1f,0xb8a2,0x1f,0x1f,0xb8a2,0x1f,0x1f,0xb8a2,0x1f,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0xb8a2,0xb8a2,0x1f,0xb8a2,0xb8a2,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0x1f,0xb8a2,0x1f,0x1f,0xb8a2,0x1f,0x1f,0xb8a2,0xb8a2,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0xb8a2,0xb8a2,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0xb8a2,0x1f,0xb8a2,0x1f,0xb8a2,0xb8a2,0x1f,0xb8a2,0xb8a2,0xb8a2,0x1f,0xb8a2,0x1f,0xb8a2,0xb8a2,0x1f,0xb8a2};
Image valueSprite(valueSpriteData, ColorMode::rgb565, 28, 0);
    5774:	1c22      	adds	r2, r4, #0
    5776:	231c      	movs	r3, #28
    5778:	9400      	str	r4, [sp, #0]
    577a:	4925      	ldr	r1, [pc, #148]	; (5810 <_GLOBAL__sub_I_backgroundImage+0xf0>)
    577c:	4825      	ldr	r0, [pc, #148]	; (5814 <_GLOBAL__sub_I_backgroundImage+0xf4>)
    577e:	f005 fc5f 	bl	b040 <_ZN14Gamebuino_Meta5ImageC1EPKtNS_9ColorModeEth>
    5782:	1c31      	adds	r1, r6, #0
    5784:	1c2a      	adds	r2, r5, #0
    5786:	4823      	ldr	r0, [pc, #140]	; (5814 <_GLOBAL__sub_I_backgroundImage+0xf4>)
    5788:	f00b feb6 	bl	114f8 <__aeabi_atexit>

const uint16_t suitSpriteData[] = {5,5,0x1f,0x1f,0x0,0x1f,0x1f,0x1f,0x0,0x0,0x0,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x1f,0x0,0x1f,0x1f,0x1f,0x0,0x0,0x0,0x1f,0x0,0x1f,0x0,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x0,0x1f,0x0,0x1f,0x1f,0x0,0x1f,0x1f,0x1f,0xb8a2,0x1f,0xb8a2,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0xb8a2,0xb8a2,0xb8a2,0x1f,0x1f,0x1f,0xb8a2,0x1f,0x1f,0x1f,0x1f,0xb8a2,0x1f,0x1f,0x1f,0xb8a2,0xb8a2,0xb8a2,0x1f,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0xb8a2,0x1f,0xb8a2,0xb8a2,0xb8a2,0x1f,0x1f,0x1f,0xb8a2,0x1f,0x1f};
Image suitSprite(suitSpriteData, ColorMode::rgb565, 4, 0);
    578c:	1c22      	adds	r2, r4, #0
    578e:	2304      	movs	r3, #4
    5790:	9400      	str	r4, [sp, #0]
    5792:	4921      	ldr	r1, [pc, #132]	; (5818 <_GLOBAL__sub_I_backgroundImage+0xf8>)
    5794:	4821      	ldr	r0, [pc, #132]	; (581c <_GLOBAL__sub_I_backgroundImage+0xfc>)
    5796:	f005 fc53 	bl	b040 <_ZN14Gamebuino_Meta5ImageC1EPKtNS_9ColorModeEth>
    579a:	1c31      	adds	r1, r6, #0
    579c:	1c2a      	adds	r2, r5, #0
    579e:	481f      	ldr	r0, [pc, #124]	; (581c <_GLOBAL__sub_I_backgroundImage+0xfc>)
    57a0:	f00b feaa 	bl	114f8 <__aeabi_atexit>

const uint16_t cursorData[] = {7,7,0x1f,0x1f,0x1f,0x0,0x0,0x1f,0x1f,0x1f,0x1f,0x0,0xffff,0x0,0x1f,0x1f,0x1f,0x0,0xffff,0xffff,0x0,0x0,0x0,0x0,0xffff,0xffff,0xffff,0xffff,0xffff,0x0,0x1f,0x0,0xffff,0xffff,0x0,0x0,0x0,0x1f,0x1f,0x0,0xffff,0x0,0x1f,0x1f,0x1f,0x1f,0x1f,0x0,0x0,0x1f,0x1f};
Image cursorImage(cursorData, ColorMode::rgb565);
    57a4:	1c3b      	adds	r3, r7, #0
    57a6:	9700      	str	r7, [sp, #0]
    57a8:	1c22      	adds	r2, r4, #0
    57aa:	491d      	ldr	r1, [pc, #116]	; (5820 <_GLOBAL__sub_I_backgroundImage+0x100>)
    57ac:	481d      	ldr	r0, [pc, #116]	; (5824 <_GLOBAL__sub_I_backgroundImage+0x104>)
    57ae:	f005 fc47 	bl	b040 <_ZN14Gamebuino_Meta5ImageC1EPKtNS_9ColorModeEth>
    57b2:	1c31      	adds	r1, r6, #0
    57b4:	1c2a      	adds	r2, r5, #0
    57b6:	481b      	ldr	r0, [pc, #108]	; (5824 <_GLOBAL__sub_I_backgroundImage+0x104>)
    57b8:	f00b fe9e 	bl	114f8 <__aeabi_atexit>

const uint16_t cursorDetailsData[] = {21,9,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x1f,0x1f,0x1f,0x0,0x0,0x1f,0x0,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0x0,0x1f,0x1f,0x0,0xffff,0x0,0x1f,0x0,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0x0,0x1f,0x0,0xffff,0xffff,0x0,0x0,0x0,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0x0,0x0,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0x0,0x1f,0x0,0xffff,0xffff,0x0,0x0,0x0,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0x0,0x1f,0x1f,0x0,0xffff,0x0,0x1f,0x0,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0x0,0x1f,0x1f,0x1f,0x0,0x0,0x1f,0x0,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0x0,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f};
Image cursorDetailsImage(cursorDetailsData, ColorMode::rgb565);
    57bc:	1c3b      	adds	r3, r7, #0
    57be:	9700      	str	r7, [sp, #0]
    57c0:	1c22      	adds	r2, r4, #0
    57c2:	4919      	ldr	r1, [pc, #100]	; (5828 <_GLOBAL__sub_I_backgroundImage+0x108>)
    57c4:	4819      	ldr	r0, [pc, #100]	; (582c <_GLOBAL__sub_I_backgroundImage+0x10c>)
    57c6:	f005 fc3b 	bl	b040 <_ZN14Gamebuino_Meta5ImageC1EPKtNS_9ColorModeEth>
    57ca:	1c31      	adds	r1, r6, #0
    57cc:	1c2a      	adds	r2, r5, #0
    57ce:	4817      	ldr	r0, [pc, #92]	; (582c <_GLOBAL__sub_I_backgroundImage+0x10c>)
    57d0:	f00b fe92 	bl	114f8 <__aeabi_atexit>

const uint16_t talonBackgroundData[] = {5,14,0x1f,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0xffff,0xacd0,0xffff,0xacd0,0xffff,0x1f,0xffff,0xacd0,0xffff,0xacd0};
Image talonBackgroundImage(talonBackgroundData, ColorMode::rgb565);
    57d4:	1c3b      	adds	r3, r7, #0
    57d6:	9700      	str	r7, [sp, #0]
    57d8:	1c22      	adds	r2, r4, #0
    57da:	4915      	ldr	r1, [pc, #84]	; (5830 <_GLOBAL__sub_I_backgroundImage+0x110>)
    57dc:	4815      	ldr	r0, [pc, #84]	; (5834 <_GLOBAL__sub_I_backgroundImage+0x114>)
    57de:	f005 fc2f 	bl	b040 <_ZN14Gamebuino_Meta5ImageC1EPKtNS_9ColorModeEth>
    57e2:	1c31      	adds	r1, r6, #0
    57e4:	1c2a      	adds	r2, r5, #0
    57e6:	4813      	ldr	r0, [pc, #76]	; (5834 <_GLOBAL__sub_I_backgroundImage+0x114>)
    57e8:	f00b fe86 	bl	114f8 <__aeabi_atexit>
  valueSprite.setTransparentColor((Color)0x1f);
  suitSprite.setTransparentColor((Color)0x1f);
  cursorImage.setTransparentColor((Color)0x1f);
  cursorDetailsImage.setTransparentColor((Color)0x1f);
  talonBackgroundImage.setTransparentColor((Color)0x1f);
}
    57ec:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    57ee:	46c0      	nop			; (mov r8, r8)
    57f0:	20000578 	.word	0x20000578
    57f4:	00012234 	.word	0x00012234
    57f8:	0000a221 	.word	0x0000a221
    57fc:	20000000 	.word	0x20000000
    5800:	00011c5c 	.word	0x00011c5c
    5804:	20000528 	.word	0x20000528
    5808:	00011b86 	.word	0x00011b86
    580c:	20000550 	.word	0x20000550
    5810:	00011ee8 	.word	0x00011ee8
    5814:	200004d8 	.word	0x200004d8
    5818:	00011aba 	.word	0x00011aba
    581c:	200004b0 	.word	0x200004b0
    5820:	00011bf6 	.word	0x00011bf6
    5824:	20000488 	.word	0x20000488
    5828:	0001193c 	.word	0x0001193c
    582c:	200005a0 	.word	0x200005a0
    5830:	00011e58 	.word	0x00011e58
    5834:	20000500 	.word	0x20000500

00005838 <_ZN9UndoStackC1Ev>:
#include "undo.h"

UndoStack::UndoStack() {
    5838:	1c01      	adds	r1, r0, #0
    583a:	1c03      	adds	r3, r0, #0
    583c:	3178      	adds	r1, #120	; 0x78
#include "pile.h"

#define UNDO_STACK_SIZE 10

struct UndoAction {
    583e:	2200      	movs	r2, #0
    5840:	701a      	strb	r2, [r3, #0]
    5842:	330c      	adds	r3, #12
    5844:	428b      	cmp	r3, r1
    5846:	d1fa      	bne.n	583e <_ZN9UndoStackC1Ev+0x6>
    index = count = 0;
    5848:	1c01      	adds	r1, r0, #0
    584a:	3179      	adds	r1, #121	; 0x79
    584c:	700a      	strb	r2, [r1, #0]
    584e:	701a      	strb	r2, [r3, #0]
}
    5850:	4770      	bx	lr

00005852 <_ZN9UndoStack10pushActionE10UndoAction>:

void UndoStack::pushAction(UndoAction action) {
    5852:	b5f0      	push	{r4, r5, r6, r7, lr}
    5854:	b085      	sub	sp, #20
    5856:	9202      	str	r2, [sp, #8]
    actions[index++] = action;
    5858:	1c02      	adds	r2, r0, #0

UndoStack::UndoStack() {
    index = count = 0;
}

void UndoStack::pushAction(UndoAction action) {
    585a:	9101      	str	r1, [sp, #4]
    585c:	9303      	str	r3, [sp, #12]
    actions[index++] = action;
    585e:	3278      	adds	r2, #120	; 0x78
    5860:	7813      	ldrb	r3, [r2, #0]
    5862:	250c      	movs	r5, #12
    5864:	1c59      	adds	r1, r3, #1
    5866:	436b      	muls	r3, r5
    5868:	b2c9      	uxtb	r1, r1

UndoStack::UndoStack() {
    index = count = 0;
}

void UndoStack::pushAction(UndoAction action) {
    586a:	ac01      	add	r4, sp, #4
    actions[index++] = action;
    586c:	7011      	strb	r1, [r2, #0]
    586e:	18c3      	adds	r3, r0, r3
    5870:	cce0      	ldmia	r4!, {r5, r6, r7}
    5872:	c3e0      	stmia	r3!, {r5, r6, r7}
    if (index >= UNDO_STACK_SIZE) index = 0;
    5874:	2909      	cmp	r1, #9
    5876:	d901      	bls.n	587c <_ZN9UndoStack10pushActionE10UndoAction+0x2a>
    5878:	2300      	movs	r3, #0
    587a:	7013      	strb	r3, [r2, #0]
    count++;
    587c:	3079      	adds	r0, #121	; 0x79
    587e:	7803      	ldrb	r3, [r0, #0]
    5880:	3301      	adds	r3, #1
    5882:	b2db      	uxtb	r3, r3
    if (count > UNDO_STACK_SIZE) count = UNDO_STACK_SIZE;
    5884:	2b0a      	cmp	r3, #10
    5886:	d900      	bls.n	588a <_ZN9UndoStack10pushActionE10UndoAction+0x38>
    5888:	230a      	movs	r3, #10
    588a:	7003      	strb	r3, [r0, #0]
}
    588c:	b005      	add	sp, #20
    588e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00005890 <_ZN9UndoStack9popActionEv>:

UndoAction UndoStack::popAction() {
    5890:	b530      	push	{r4, r5, lr}
    // Invalid
    return UndoAction();
}

bool UndoStack::isEmpty() const {
    return count == 0;
    5892:	1c0c      	adds	r4, r1, #0
    5894:	3479      	adds	r4, #121	; 0x79
    5896:	7823      	ldrb	r3, [r4, #0]
    count++;
    if (count > UNDO_STACK_SIZE) count = UNDO_STACK_SIZE;
}

UndoAction UndoStack::popAction() {
    if (!isEmpty()) {
    5898:	2b00      	cmp	r3, #0
    589a:	d012      	beq.n	58c2 <_ZN9UndoStack9popActionEv+0x32>
        if (index == 0) index = UNDO_STACK_SIZE - 1;
    589c:	1c0a      	adds	r2, r1, #0
    589e:	3278      	adds	r2, #120	; 0x78
    58a0:	7815      	ldrb	r5, [r2, #0]
    58a2:	2d00      	cmp	r5, #0
    58a4:	d101      	bne.n	58aa <_ZN9UndoStack9popActionEv+0x1a>
    58a6:	2509      	movs	r5, #9
    58a8:	e000      	b.n	58ac <_ZN9UndoStack9popActionEv+0x1c>
        else index--;
    58aa:	3d01      	subs	r5, #1
        count--;
    58ac:	3b01      	subs	r3, #1
}

UndoAction UndoStack::popAction() {
    if (!isEmpty()) {
        if (index == 0) index = UNDO_STACK_SIZE - 1;
        else index--;
    58ae:	7015      	strb	r5, [r2, #0]
        count--;
    58b0:	7023      	strb	r3, [r4, #0]
        return actions[index];
    58b2:	7813      	ldrb	r3, [r2, #0]
    58b4:	220c      	movs	r2, #12
    58b6:	4353      	muls	r3, r2
    58b8:	18c9      	adds	r1, r1, r3
    58ba:	1c03      	adds	r3, r0, #0
    58bc:	c934      	ldmia	r1!, {r2, r4, r5}
    58be:	c334      	stmia	r3!, {r2, r4, r5}
    58c0:	e002      	b.n	58c8 <_ZN9UndoStack9popActionEv+0x38>
    }
    // Invalid
    return UndoAction();
    58c2:	7003      	strb	r3, [r0, #0]
    58c4:	6043      	str	r3, [r0, #4]
    58c6:	6083      	str	r3, [r0, #8]
}
    58c8:	bd30      	pop	{r4, r5, pc}

000058ca <_ZNK9UndoStack7isEmptyEv>:

bool UndoStack::isEmpty() const {
    return count == 0;
    58ca:	3079      	adds	r0, #121	; 0x79
    58cc:	7800      	ldrb	r0, [r0, #0]
    58ce:	4243      	negs	r3, r0
    58d0:	4158      	adcs	r0, r3
    58d2:	b2c0      	uxtb	r0, r0
    58d4:	4770      	bx	lr

000058d6 <_Z11hsvToRgb565hhh>:
#include <Gamebuino-Meta.h>
#include "utils.h"

// https://stackoverflow.com/questions/3018313/algorithm-to-convert-rgb-to-hsv-and-hsv-to-rgb-in-range-0-255-for-both#14733008
Color hsvToRgb565(unsigned char h, unsigned char s, unsigned char v)
{
    58d6:	b570      	push	{r4, r5, r6, lr}
    58d8:	1c06      	adds	r6, r0, #0
    58da:	1c0d      	adds	r5, r1, #0
    58dc:	1c14      	adds	r4, r2, #0
    unsigned char r, g, b;
    unsigned char region, remainder, p, q, t;

    if (s == 0)
    58de:	2900      	cmp	r1, #0
    58e0:	d10a      	bne.n	58f8 <_Z11hsvToRgb565hhh+0x22>
    {
        r = v;
        g = v;
        b = v;
        return (Color)(((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));
    58e2:	2307      	movs	r3, #7
    58e4:	1c10      	adds	r0, r2, #0
    58e6:	4398      	bics	r0, r3
    58e8:	2303      	movs	r3, #3
    58ea:	439a      	bics	r2, r3
    58ec:	0200      	lsls	r0, r0, #8
    58ee:	00d3      	lsls	r3, r2, #3
    58f0:	4318      	orrs	r0, r3
    58f2:	10e4      	asrs	r4, r4, #3
    58f4:	4320      	orrs	r0, r4
    58f6:	e042      	b.n	597e <_Z11hsvToRgb565hhh+0xa8>
    }

    region = h / 43;
    58f8:	212b      	movs	r1, #43	; 0x2b
    58fa:	f00b fd4d 	bl	11398 <__aeabi_uidiv>
    remainder = (h - (region * 43)) * 6; 
    58fe:	222b      	movs	r2, #43	; 0x2b
        g = v;
        b = v;
        return (Color)(((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));
    }

    region = h / 43;
    5900:	b2c0      	uxtb	r0, r0
    remainder = (h - (region * 43)) * 6; 
    5902:	4252      	negs	r2, r2
    5904:	4342      	muls	r2, r0
    5906:	18b6      	adds	r6, r6, r2
    5908:	2206      	movs	r2, #6
    590a:	4356      	muls	r6, r2

    p = (v * (255 - s)) >> 8;
    590c:	21ff      	movs	r1, #255	; 0xff
    q = (v * (255 - ((s * remainder) >> 8))) >> 8;
    590e:	b2f6      	uxtb	r6, r6
    5910:	1c32      	adds	r2, r6, #0
    t = (v * (255 - ((s * (255 - remainder)) >> 8))) >> 8;
    5912:	1b8e      	subs	r6, r1, r6
    }

    region = h / 43;
    remainder = (h - (region * 43)) * 6; 

    p = (v * (255 - s)) >> 8;
    5914:	1b4b      	subs	r3, r1, r5
    q = (v * (255 - ((s * remainder) >> 8))) >> 8;
    5916:	436a      	muls	r2, r5
    t = (v * (255 - ((s * (255 - remainder)) >> 8))) >> 8;
    5918:	4375      	muls	r5, r6

    region = h / 43;
    remainder = (h - (region * 43)) * 6; 

    p = (v * (255 - s)) >> 8;
    q = (v * (255 - ((s * remainder) >> 8))) >> 8;
    591a:	1212      	asrs	r2, r2, #8
    t = (v * (255 - ((s * (255 - remainder)) >> 8))) >> 8;
    591c:	122d      	asrs	r5, r5, #8

    region = h / 43;
    remainder = (h - (region * 43)) * 6; 

    p = (v * (255 - s)) >> 8;
    q = (v * (255 - ((s * remainder) >> 8))) >> 8;
    591e:	1a8a      	subs	r2, r1, r2
    t = (v * (255 - ((s * (255 - remainder)) >> 8))) >> 8;
    5920:	1b49      	subs	r1, r1, r5
    }

    region = h / 43;
    remainder = (h - (region * 43)) * 6; 

    p = (v * (255 - s)) >> 8;
    5922:	4363      	muls	r3, r4
    q = (v * (255 - ((s * remainder) >> 8))) >> 8;
    5924:	4362      	muls	r2, r4
    t = (v * (255 - ((s * (255 - remainder)) >> 8))) >> 8;
    5926:	4361      	muls	r1, r4
    }

    region = h / 43;
    remainder = (h - (region * 43)) * 6; 

    p = (v * (255 - s)) >> 8;
    5928:	121b      	asrs	r3, r3, #8
    q = (v * (255 - ((s * remainder) >> 8))) >> 8;
    592a:	1212      	asrs	r2, r2, #8
    t = (v * (255 - ((s * (255 - remainder)) >> 8))) >> 8;
    592c:	1209      	asrs	r1, r1, #8
    }

    region = h / 43;
    remainder = (h - (region * 43)) * 6; 

    p = (v * (255 - s)) >> 8;
    592e:	b2db      	uxtb	r3, r3
    q = (v * (255 - ((s * remainder) >> 8))) >> 8;
    5930:	b2d2      	uxtb	r2, r2
    t = (v * (255 - ((s * (255 - remainder)) >> 8))) >> 8;
    5932:	b2c9      	uxtb	r1, r1

    switch (region)
    5934:	2804      	cmp	r0, #4
    5936:	d814      	bhi.n	5962 <_Z11hsvToRgb565hhh+0x8c>
    5938:	f00b fd1a 	bl	11370 <__gnu_thumb1_case_uqi>
    593c:	09061703 	.word	0x09061703
    5940:	0e          	.byte	0x0e
    5941:	00          	.byte	0x00
    {
        case 0:
            r = v; g = t; b = p;
    5942:	1c22      	adds	r2, r4, #0
    5944:	1c0c      	adds	r4, r1, #0
    5946:	e010      	b.n	596a <_Z11hsvToRgb565hhh+0x94>
            break;
        case 1:
            r = q; g = v; b = p;
            break;
        case 2:
            r = p; g = v; b = t;
    5948:	1c1a      	adds	r2, r3, #0
    594a:	1c0b      	adds	r3, r1, #0
            break;
    594c:	e00d      	b.n	596a <_Z11hsvToRgb565hhh+0x94>
        case 3:
            r = p; g = q; b = v;
            break;
    594e:	1c11      	adds	r1, r2, #0
            break;
        case 2:
            r = p; g = v; b = t;
            break;
        case 3:
            r = p; g = q; b = v;
    5950:	1c1a      	adds	r2, r3, #0
    5952:	1c23      	adds	r3, r4, #0
    5954:	1c0c      	adds	r4, r1, #0
            break;
    5956:	e008      	b.n	596a <_Z11hsvToRgb565hhh+0x94>
        case 4:
            r = t; g = p; b = v;
            break;
    5958:	1c22      	adds	r2, r4, #0
            break;
        case 3:
            r = p; g = q; b = v;
            break;
        case 4:
            r = t; g = p; b = v;
    595a:	1c1c      	adds	r4, r3, #0
    595c:	1c13      	adds	r3, r2, #0
    595e:	1c0a      	adds	r2, r1, #0
            break;
    5960:	e003      	b.n	596a <_Z11hsvToRgb565hhh+0x94>
        default:
            r = v; g = p; b = q;
            break;
    5962:	1c11      	adds	r1, r2, #0
            break;
        case 4:
            r = t; g = p; b = v;
            break;
        default:
            r = v; g = p; b = q;
    5964:	1c22      	adds	r2, r4, #0
    5966:	1c1c      	adds	r4, r3, #0
    5968:	1c0b      	adds	r3, r1, #0
            break;
    }

    return (Color)(((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));
    596a:	20f8      	movs	r0, #248	; 0xf8
    596c:	4002      	ands	r2, r0
    596e:	0210      	lsls	r0, r2, #8
    5970:	22fc      	movs	r2, #252	; 0xfc
    5972:	4014      	ands	r4, r2
    5974:	00e4      	lsls	r4, r4, #3
    5976:	4320      	orrs	r0, r4
    5978:	10db      	asrs	r3, r3, #3
    597a:	4318      	orrs	r0, r3
    597c:	b280      	uxth	r0, r0
}
    597e:	bd70      	pop	{r4, r5, r6, pc}

00005980 <_Z11drawMenuBoxii>:

void drawMenuBox(int width, int height) {
    5980:	b5f0      	push	{r4, r5, r6, r7, lr}
  int top = (gb.display.height() - height) / 2;
    5982:	4d51      	ldr	r5, [pc, #324]	; (5ac8 <_Z11drawMenuBoxii+0x148>)
    }

    return (Color)(((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));
}

void drawMenuBox(int width, int height) {
    5984:	b091      	sub	sp, #68	; 0x44
    5986:	9003      	str	r0, [sp, #12]
  int top = (gb.display.height() - height) / 2;
    5988:	1c28      	adds	r0, r5, #0
    }

    return (Color)(((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));
}

void drawMenuBox(int width, int height) {
    598a:	1c0c      	adds	r4, r1, #0
  int top = (gb.display.height() - height) / 2;
    598c:	f004 fb4c 	bl	a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>
    5990:	1b00      	subs	r0, r0, r4
    5992:	0fc6      	lsrs	r6, r0, #31
    5994:	1836      	adds	r6, r6, r0
  int left = (gb.display.width() - width) / 2;
    5996:	1c28      	adds	r0, r5, #0
    5998:	f004 fb36 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
    599c:	9903      	ldr	r1, [sp, #12]

    return (Color)(((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));
}

void drawMenuBox(int width, int height) {
  int top = (gb.display.height() - height) / 2;
    599e:	1076      	asrs	r6, r6, #1
  int left = (gb.display.width() - width) / 2;
    59a0:	1a40      	subs	r0, r0, r1
    59a2:	0fc7      	lsrs	r7, r0, #31
    59a4:	183f      	adds	r7, r7, r0

  gb.display.setColor(WHITE);
    59a6:	4949      	ldr	r1, [pc, #292]	; (5acc <_Z11drawMenuBoxii+0x14c>)
    59a8:	1c28      	adds	r0, r5, #0
    59aa:	f004 fa13 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
  gb.display.drawFastHLine(left, top, width - 1);
    59ae:	9a03      	ldr	r2, [sp, #12]
    return (Color)(((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));
}

void drawMenuBox(int width, int height) {
  int top = (gb.display.height() - height) / 2;
  int left = (gb.display.width() - width) / 2;
    59b0:	107f      	asrs	r7, r7, #1

  gb.display.setColor(WHITE);
  gb.display.drawFastHLine(left, top, width - 1);
    59b2:	b292      	uxth	r2, r2
    59b4:	1c13      	adds	r3, r2, #0
    59b6:	b2bf      	uxth	r7, r7
    59b8:	b2b6      	uxth	r6, r6
    59ba:	3b01      	subs	r3, #1
    59bc:	9203      	str	r2, [sp, #12]
    59be:	b238      	sxth	r0, r7
    59c0:	b231      	sxth	r1, r6
    59c2:	b21a      	sxth	r2, r3
    59c4:	9006      	str	r0, [sp, #24]
    59c6:	9109      	str	r1, [sp, #36]	; 0x24
    59c8:	920a      	str	r2, [sp, #40]	; 0x28
    59ca:	1c28      	adds	r0, r5, #0
    59cc:	9906      	ldr	r1, [sp, #24]
    59ce:	9a09      	ldr	r2, [sp, #36]	; 0x24
    59d0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  gb.display.drawFastVLine(left, top + 1, height - 2);
    59d2:	b2a4      	uxth	r4, r4
void drawMenuBox(int width, int height) {
  int top = (gb.display.height() - height) / 2;
  int left = (gb.display.width() - width) / 2;

  gb.display.setColor(WHITE);
  gb.display.drawFastHLine(left, top, width - 1);
    59d4:	f004 fb74 	bl	a0c0 <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss>
  gb.display.drawFastVLine(left, top + 1, height - 2);
    59d8:	1c72      	adds	r2, r6, #1
    59da:	1ea3      	subs	r3, r4, #2
    59dc:	b210      	sxth	r0, r2
    59de:	b219      	sxth	r1, r3
    59e0:	9005      	str	r0, [sp, #20]
    59e2:	910b      	str	r1, [sp, #44]	; 0x2c
    59e4:	1c28      	adds	r0, r5, #0
    59e6:	9906      	ldr	r1, [sp, #24]
    59e8:	9a05      	ldr	r2, [sp, #20]
    59ea:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    59ec:	f003 f861 	bl	8ab2 <_ZN14Gamebuino_Meta8Graphics13drawFastVLineEsss>
  gb.display.drawFastHLine(left + 2, top + height - 2, width - 3);
    59f0:	1cba      	adds	r2, r7, #2
    59f2:	1933      	adds	r3, r6, r4
    59f4:	9903      	ldr	r1, [sp, #12]
    59f6:	b210      	sxth	r0, r2
    59f8:	b29b      	uxth	r3, r3
    59fa:	900c      	str	r0, [sp, #48]	; 0x30
    59fc:	9304      	str	r3, [sp, #16]
    59fe:	3903      	subs	r1, #3
    5a00:	3b02      	subs	r3, #2
    5a02:	b21a      	sxth	r2, r3
    5a04:	1c28      	adds	r0, r5, #0
    5a06:	b20b      	sxth	r3, r1
    5a08:	990c      	ldr	r1, [sp, #48]	; 0x30
    5a0a:	920d      	str	r2, [sp, #52]	; 0x34
    5a0c:	930e      	str	r3, [sp, #56]	; 0x38
    5a0e:	f004 fb57 	bl	a0c0 <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss>
  gb.display.drawFastVLine(left + width - 2, top + 2, height - 4);
    5a12:	9803      	ldr	r0, [sp, #12]
    5a14:	3c04      	subs	r4, #4
    5a16:	183b      	adds	r3, r7, r0
    5a18:	b222      	sxth	r2, r4
    5a1a:	b29b      	uxth	r3, r3
    5a1c:	3602      	adds	r6, #2
    5a1e:	b236      	sxth	r6, r6
    5a20:	9207      	str	r2, [sp, #28]
    5a22:	9308      	str	r3, [sp, #32]
    5a24:	3b02      	subs	r3, #2
    5a26:	b219      	sxth	r1, r3
    5a28:	1c32      	adds	r2, r6, #0
    5a2a:	9b07      	ldr	r3, [sp, #28]
    5a2c:	1c28      	adds	r0, r5, #0

  gb.display.setColor(BROWN);
  gb.display.drawFastHLine(left + 1, top + 1, width - 3);
    5a2e:	3701      	adds	r7, #1
    5a30:	b23f      	sxth	r7, r7

  gb.display.setColor(WHITE);
  gb.display.drawFastHLine(left, top, width - 1);
  gb.display.drawFastVLine(left, top + 1, height - 2);
  gb.display.drawFastHLine(left + 2, top + height - 2, width - 3);
  gb.display.drawFastVLine(left + width - 2, top + 2, height - 4);
    5a32:	910f      	str	r1, [sp, #60]	; 0x3c
    5a34:	f003 f83d 	bl	8ab2 <_ZN14Gamebuino_Meta8Graphics13drawFastVLineEsss>

  gb.display.setColor(BROWN);
    5a38:	1c28      	adds	r0, r5, #0
    5a3a:	4925      	ldr	r1, [pc, #148]	; (5ad0 <_Z11drawMenuBoxii+0x150>)
    5a3c:	f004 f9ca 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
  gb.display.drawFastHLine(left + 1, top + 1, width - 3);
    5a40:	1c28      	adds	r0, r5, #0
    5a42:	1c39      	adds	r1, r7, #0
    5a44:	9a05      	ldr	r2, [sp, #20]
    5a46:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    5a48:	f004 fb3a 	bl	a0c0 <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss>
  gb.display.drawFastVLine(left + 1, top + 2, height - 4);
    5a4c:	1c28      	adds	r0, r5, #0
    5a4e:	1c39      	adds	r1, r7, #0
    5a50:	1c32      	adds	r2, r6, #0
    5a52:	9b07      	ldr	r3, [sp, #28]
    5a54:	f003 f82d 	bl	8ab2 <_ZN14Gamebuino_Meta8Graphics13drawFastVLineEsss>
  gb.display.drawFastHLine(left + 1, top + height - 1, width - 1);
    5a58:	9c04      	ldr	r4, [sp, #16]
    5a5a:	1c28      	adds	r0, r5, #0
    5a5c:	3c01      	subs	r4, #1
    5a5e:	b224      	sxth	r4, r4
    5a60:	1c39      	adds	r1, r7, #0
    5a62:	1c22      	adds	r2, r4, #0
    5a64:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5a66:	f004 fb2b 	bl	a0c0 <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss>
  gb.display.drawFastVLine(left + width - 1, top + 1, height - 2);
    5a6a:	9b08      	ldr	r3, [sp, #32]
    5a6c:	9a05      	ldr	r2, [sp, #20]
    5a6e:	3b01      	subs	r3, #1
    5a70:	b218      	sxth	r0, r3
    5a72:	9004      	str	r0, [sp, #16]
    5a74:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5a76:	1c28      	adds	r0, r5, #0
    5a78:	9904      	ldr	r1, [sp, #16]
    5a7a:	f003 f81a 	bl	8ab2 <_ZN14Gamebuino_Meta8Graphics13drawFastVLineEsss>

  gb.display.setColor(BEIGE);
    5a7e:	1c28      	adds	r0, r5, #0
    5a80:	4914      	ldr	r1, [pc, #80]	; (5ad4 <_Z11drawMenuBoxii+0x154>)
    5a82:	f004 f9a7 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
  gb.display.drawPixel(left + width - 1, top);
    5a86:	1c28      	adds	r0, r5, #0
    5a88:	9904      	ldr	r1, [sp, #16]
    5a8a:	9a09      	ldr	r2, [sp, #36]	; 0x24
    5a8c:	f003 fdaa 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
  gb.display.drawPixel(left + width - 2, top + 1);
    5a90:	1c28      	adds	r0, r5, #0
    5a92:	990f      	ldr	r1, [sp, #60]	; 0x3c
    5a94:	9a05      	ldr	r2, [sp, #20]
    5a96:	f003 fda5 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
  gb.display.drawPixel(left, top + height - 1);
    5a9a:	1c28      	adds	r0, r5, #0
    5a9c:	9906      	ldr	r1, [sp, #24]
    5a9e:	1c22      	adds	r2, r4, #0
    5aa0:	f003 fda0 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
  gb.display.drawPixel(left + 1, top + height - 2);
    5aa4:	1c28      	adds	r0, r5, #0
    5aa6:	1c39      	adds	r1, r7, #0
    5aa8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    5aaa:	f003 fd9b 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
  gb.display.fillRect(left + 2, top + 2, width - 4, height - 4);
    5aae:	9b03      	ldr	r3, [sp, #12]
    5ab0:	9907      	ldr	r1, [sp, #28]
    5ab2:	3b04      	subs	r3, #4
    5ab4:	9100      	str	r1, [sp, #0]
    5ab6:	b21b      	sxth	r3, r3
    5ab8:	1c28      	adds	r0, r5, #0
    5aba:	990c      	ldr	r1, [sp, #48]	; 0x30
    5abc:	1c32      	adds	r2, r6, #0
    5abe:	f003 f80d 	bl	8adc <_ZN14Gamebuino_Meta8Graphics8fillRectEssss>
}
    5ac2:	b011      	add	sp, #68	; 0x44
    5ac4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5ac6:	46c0      	nop			; (mov r8, r8)
    5ac8:	20000a4c 	.word	0x20000a4c
    5acc:	0000ffff 	.word	0x0000ffff
    5ad0:	0000cc68 	.word	0x0000cc68
    5ad4:	0000feb2 	.word	0x0000feb2

00005ad8 <_Z4menuPKPKcib>:

int menu(const char* const* items, int length, bool allowExit) {
    5ad8:	b5f0      	push	{r4, r5, r6, r7, lr}
    5ada:	b087      	sub	sp, #28
    5adc:	9004      	str	r0, [sp, #16]
    5ade:	9101      	str	r1, [sp, #4]
    5ae0:	9205      	str	r2, [sp, #20]
  int width = 0, height = 0;
    5ae2:	2500      	movs	r5, #0
  int activeItem = 0;

  // Animate menu opening.
  while (width < gb.display.height() - 10) {
    5ae4:	4c4e      	ldr	r4, [pc, #312]	; (5c20 <_Z4menuPKPKcib+0x148>)
    5ae6:	1c20      	adds	r0, r4, #0
    5ae8:	f004 fa9e 	bl	a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>
    5aec:	380a      	subs	r0, #10
    5aee:	4285      	cmp	r5, r0
    5af0:	da0b      	bge.n	5b0a <_Z4menuPKPKcib+0x32>
    if (gb.update()) {
    5af2:	1c20      	adds	r0, r4, #0
    5af4:	3810      	subs	r0, #16
    5af6:	f000 ff4d 	bl	6994 <_ZN14Gamebuino_Meta9Gamebuino6updateEv>
    5afa:	2800      	cmp	r0, #0
    5afc:	d0f2      	beq.n	5ae4 <_Z4menuPKPKcib+0xc>
      width += 6;
    5afe:	3506      	adds	r5, #6
      height += 6;
      drawMenuBox(width, height);
    5b00:	1c28      	adds	r0, r5, #0
    5b02:	1c29      	adds	r1, r5, #0
    5b04:	f7ff ff3c 	bl	5980 <_Z11drawMenuBoxii>
    5b08:	e7ec      	b.n	5ae4 <_Z4menuPKPKcib+0xc>
int menu(const char* const* items, int length, bool allowExit) {
  int width = 0, height = 0;
  int activeItem = 0;

  // Animate menu opening.
  while (width < gb.display.height() - 10) {
    5b0a:	2400      	movs	r4, #0
      drawMenuBox(width, height);
    }
  }

  while (true) {
    if (gb.update()) {
    5b0c:	4f45      	ldr	r7, [pc, #276]	; (5c24 <_Z4menuPKPKcib+0x14c>)
    5b0e:	1c38      	adds	r0, r7, #0
    5b10:	f000 ff40 	bl	6994 <_ZN14Gamebuino_Meta9Gamebuino6updateEv>
    5b14:	1c3e      	adds	r6, r7, #0
    5b16:	2800      	cmp	r0, #0
    5b18:	d0f8      	beq.n	5b0c <_Z4menuPKPKcib+0x34>
      if (gb.buttons.pressed(BUTTON_A)) {
    5b1a:	1c38      	adds	r0, r7, #0
    5b1c:	2104      	movs	r1, #4
    5b1e:	f002 f8ad 	bl	7c7c <_ZN14Gamebuino_Meta7Buttons7pressedENS_6ButtonE>
    5b22:	2800      	cmp	r0, #0
    5b24:	d005      	beq.n	5b32 <_Z4menuPKPKcib+0x5a>
        gb.sound.playOK();
    5b26:	1c38      	adds	r0, r7, #0
    5b28:	3038      	adds	r0, #56	; 0x38
    5b2a:	f009 f985 	bl	ee38 <_ZN14Gamebuino_Meta5Sound6playOKEv>
        return activeItem;
    5b2e:	1c20      	adds	r0, r4, #0
    5b30:	e073      	b.n	5c1a <_Z4menuPKPKcib+0x142>
      }
      if (allowExit && (gb.buttons.pressed(BUTTON_MENU) || gb.buttons.pressed(BUTTON_B))) {
    5b32:	9a05      	ldr	r2, [sp, #20]
    5b34:	2a00      	cmp	r2, #0
    5b36:	d011      	beq.n	5b5c <_Z4menuPKPKcib+0x84>
    5b38:	1c38      	adds	r0, r7, #0
    5b3a:	2106      	movs	r1, #6
    5b3c:	f002 f89e 	bl	7c7c <_ZN14Gamebuino_Meta7Buttons7pressedENS_6ButtonE>
    5b40:	2800      	cmp	r0, #0
    5b42:	d105      	bne.n	5b50 <_Z4menuPKPKcib+0x78>
    5b44:	1c38      	adds	r0, r7, #0
    5b46:	2105      	movs	r1, #5
    5b48:	f002 f898 	bl	7c7c <_ZN14Gamebuino_Meta7Buttons7pressedENS_6ButtonE>
    5b4c:	2800      	cmp	r0, #0
    5b4e:	d005      	beq.n	5b5c <_Z4menuPKPKcib+0x84>
        gb.sound.playCancel();
    5b50:	4835      	ldr	r0, [pc, #212]	; (5c28 <_Z4menuPKPKcib+0x150>)
    5b52:	f009 f979 	bl	ee48 <_ZN14Gamebuino_Meta5Sound10playCancelEv>
        return -1;
    5b56:	2001      	movs	r0, #1
    5b58:	4240      	negs	r0, r0
    5b5a:	e05e      	b.n	5c1a <_Z4menuPKPKcib+0x142>
      }

      if (gb.buttons.repeat(BUTTON_DOWN, 8)) {
    5b5c:	1c30      	adds	r0, r6, #0
    5b5e:	2100      	movs	r1, #0
    5b60:	2208      	movs	r2, #8
    5b62:	f002 f8a5 	bl	7cb0 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt>
    5b66:	2800      	cmp	r0, #0
    5b68:	d004      	beq.n	5b74 <_Z4menuPKPKcib+0x9c>
        activeItem++;
        gb.sound.playTick();
    5b6a:	1c30      	adds	r0, r6, #0
    5b6c:	3038      	adds	r0, #56	; 0x38
        gb.sound.playCancel();
        return -1;
      }

      if (gb.buttons.repeat(BUTTON_DOWN, 8)) {
        activeItem++;
    5b6e:	3401      	adds	r4, #1
        gb.sound.playTick();
    5b70:	f009 f972 	bl	ee58 <_ZN14Gamebuino_Meta5Sound8playTickEv>
      }
      if (gb.buttons.repeat(BUTTON_UP, 8)) {
    5b74:	1c30      	adds	r0, r6, #0
    5b76:	2103      	movs	r1, #3
    5b78:	2208      	movs	r2, #8
    5b7a:	f002 f899 	bl	7cb0 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt>
    5b7e:	2800      	cmp	r0, #0
    5b80:	d004      	beq.n	5b8c <_Z4menuPKPKcib+0xb4>
        activeItem--;
        gb.sound.playTick();
    5b82:	1c30      	adds	r0, r6, #0
    5b84:	3038      	adds	r0, #56	; 0x38
      if (gb.buttons.repeat(BUTTON_DOWN, 8)) {
        activeItem++;
        gb.sound.playTick();
      }
      if (gb.buttons.repeat(BUTTON_UP, 8)) {
        activeItem--;
    5b86:	3c01      	subs	r4, #1
        gb.sound.playTick();
    5b88:	f009 f966 	bl	ee58 <_ZN14Gamebuino_Meta5Sound8playTickEv>
      }
      //don't go out of the menu
      if (activeItem == length) activeItem = 0;
    5b8c:	9b01      	ldr	r3, [sp, #4]
    5b8e:	429c      	cmp	r4, r3
    5b90:	d004      	beq.n	5b9c <_Z4menuPKPKcib+0xc4>
      if (activeItem < 0) activeItem = length - 1;
    5b92:	2c00      	cmp	r4, #0
    5b94:	da03      	bge.n	5b9e <_Z4menuPKPKcib+0xc6>
    5b96:	1c1c      	adds	r4, r3, #0
    5b98:	3c01      	subs	r4, #1
    5b9a:	e000      	b.n	5b9e <_Z4menuPKPKcib+0xc6>
      if (gb.buttons.repeat(BUTTON_UP, 8)) {
        activeItem--;
        gb.sound.playTick();
      }
      //don't go out of the menu
      if (activeItem == length) activeItem = 0;
    5b9c:	2400      	movs	r4, #0
      if (activeItem < 0) activeItem = length - 1;

      drawMenuBox(width, height);
    5b9e:	1c29      	adds	r1, r5, #0
    5ba0:	1c28      	adds	r0, r5, #0
    5ba2:	f7ff feed 	bl	5980 <_Z11drawMenuBoxii>
      int top = (gb.display.height() - height) / 2;
    5ba6:	4e1e      	ldr	r6, [pc, #120]	; (5c20 <_Z4menuPKPKcib+0x148>)
    5ba8:	1c30      	adds	r0, r6, #0
    5baa:	f004 fa3d 	bl	a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>
    5bae:	1c07      	adds	r7, r0, #0
      int left = (gb.display.width() - width) / 2;
    5bb0:	1c30      	adds	r0, r6, #0
    5bb2:	f004 fa29 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
    5bb6:	1b40      	subs	r0, r0, r5
    5bb8:	0fc3      	lsrs	r3, r0, #31
    5bba:	1818      	adds	r0, r3, r0
      //don't go out of the menu
      if (activeItem == length) activeItem = 0;
      if (activeItem < 0) activeItem = length - 1;

      drawMenuBox(width, height);
      int top = (gb.display.height() - height) / 2;
    5bbc:	1b7f      	subs	r7, r7, r5
      int left = (gb.display.width() - width) / 2;
    5bbe:	1040      	asrs	r0, r0, #1

      gb.display.setCursor(left + 7, top + 5);
    5bc0:	b280      	uxth	r0, r0
      //don't go out of the menu
      if (activeItem == length) activeItem = 0;
      if (activeItem < 0) activeItem = length - 1;

      drawMenuBox(width, height);
      int top = (gb.display.height() - height) / 2;
    5bc2:	0ffa      	lsrs	r2, r7, #31
      int left = (gb.display.width() - width) / 2;

      gb.display.setCursor(left + 7, top + 5);
    5bc4:	1c03      	adds	r3, r0, #0
      //don't go out of the menu
      if (activeItem == length) activeItem = 0;
      if (activeItem < 0) activeItem = length - 1;

      drawMenuBox(width, height);
      int top = (gb.display.height() - height) / 2;
    5bc6:	19d7      	adds	r7, r2, r7
      int left = (gb.display.width() - width) / 2;

      gb.display.setCursor(left + 7, top + 5);
    5bc8:	3307      	adds	r3, #7
      //don't go out of the menu
      if (activeItem == length) activeItem = 0;
      if (activeItem < 0) activeItem = length - 1;

      drawMenuBox(width, height);
      int top = (gb.display.height() - height) / 2;
    5bca:	107a      	asrs	r2, r7, #1
      int left = (gb.display.width() - width) / 2;

      gb.display.setCursor(left + 7, top + 5);
    5bcc:	b29b      	uxth	r3, r3
    5bce:	3205      	adds	r2, #5
    5bd0:	9002      	str	r0, [sp, #8]
    5bd2:	b219      	sxth	r1, r3
    5bd4:	1c30      	adds	r0, r6, #0
    5bd6:	b212      	sxth	r2, r2
    5bd8:	9303      	str	r3, [sp, #12]
    5bda:	f004 f95b 	bl	9e94 <_ZN14Gamebuino_Meta8Graphics9setCursorEss>
      for (int i = 0; i < length; i++) {
    5bde:	2600      	movs	r6, #0
    5be0:	9b01      	ldr	r3, [sp, #4]
    5be2:	429e      	cmp	r6, r3
    5be4:	da92      	bge.n	5b0c <_Z4menuPKPKcib+0x34>
        gb.display.cursorX = left + 7;
        gb.display.setColor(BROWN);
    5be6:	4f0e      	ldr	r7, [pc, #56]	; (5c20 <_Z4menuPKPKcib+0x148>)
      int top = (gb.display.height() - height) / 2;
      int left = (gb.display.width() - width) / 2;

      gb.display.setCursor(left + 7, top + 5);
      for (int i = 0; i < length; i++) {
        gb.display.cursorX = left + 7;
    5be8:	9b03      	ldr	r3, [sp, #12]
    5bea:	4a10      	ldr	r2, [pc, #64]	; (5c2c <_Z4menuPKPKcib+0x154>)
        gb.display.setColor(BROWN);
    5bec:	1c38      	adds	r0, r7, #0
    5bee:	4910      	ldr	r1, [pc, #64]	; (5c30 <_Z4menuPKPKcib+0x158>)
      int top = (gb.display.height() - height) / 2;
      int left = (gb.display.width() - width) / 2;

      gb.display.setCursor(left + 7, top + 5);
      for (int i = 0; i < length; i++) {
        gb.display.cursorX = left + 7;
    5bf0:	8013      	strh	r3, [r2, #0]
        gb.display.setColor(BROWN);
    5bf2:	f004 f8ef 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
        if (i == activeItem){
    5bf6:	42a6      	cmp	r6, r4
    5bf8:	d107      	bne.n	5c0a <_Z4menuPKPKcib+0x132>
          gb.display.setColor(BLACK);
    5bfa:	1c38      	adds	r0, r7, #0
    5bfc:	2100      	movs	r1, #0
    5bfe:	f004 f8e9 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
          gb.display.cursorX = left + 5;
    5c02:	9b02      	ldr	r3, [sp, #8]
    5c04:	4a09      	ldr	r2, [pc, #36]	; (5c2c <_Z4menuPKPKcib+0x154>)
    5c06:	3305      	adds	r3, #5
    5c08:	8013      	strh	r3, [r2, #0]
        }
        gb.display.println((const char*)items[i]);
    5c0a:	9a04      	ldr	r2, [sp, #16]
    5c0c:	00b3      	lsls	r3, r6, #2
    5c0e:	58d1      	ldr	r1, [r2, r3]
    5c10:	1c38      	adds	r0, r7, #0
    5c12:	f009 ffc1 	bl	fb98 <_ZN5Print7printlnEPKc>
      drawMenuBox(width, height);
      int top = (gb.display.height() - height) / 2;
      int left = (gb.display.width() - width) / 2;

      gb.display.setCursor(left + 7, top + 5);
      for (int i = 0; i < length; i++) {
    5c16:	3601      	adds	r6, #1
    5c18:	e7e2      	b.n	5be0 <_Z4menuPKPKcib+0x108>
        }
        gb.display.println((const char*)items[i]);
      }
    }
  }
}
    5c1a:	b007      	add	sp, #28
    5c1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5c1e:	46c0      	nop			; (mov r8, r8)
    5c20:	20000a4c 	.word	0x20000a4c
    5c24:	20000a3c 	.word	0x20000a3c
    5c28:	20000a74 	.word	0x20000a74
    5c2c:	20000cdc 	.word	0x20000cdc
    5c30:	0000cc68 	.word	0x0000cc68

00005c34 <_ZN4File9availableEv>:
    return isOpen();
  }
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
    5c34:	1c03      	adds	r3, r0, #0
  bool isDir() const {
    return m_attr & FILE_ATTR_DIR;
  }
  /** \return True if this is a normal file else false. */
  bool isFile() const {
    return m_attr & FILE_ATTR_FILE;
    5c36:	7c00      	ldrb	r0, [r0, #16]
  void setpos(FatPos_t* pos);
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available() {
    return isFile() ? fileSize() - curPosition() : 0;
    5c38:	2208      	movs	r2, #8
    5c3a:	4010      	ands	r0, r2
    5c3c:	d004      	beq.n	5c48 <_ZN4File9availableEv+0x14>
    5c3e:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    5c40:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    5c42:	1ac0      	subs	r0, r0, r3
    uint32_t n = FatFile::available();
    return n > INT_MAX ? INT_MAX : n;
    5c44:	d500      	bpl.n	5c48 <_ZN4File9availableEv+0x14>
    5c46:	4801      	ldr	r0, [pc, #4]	; (5c4c <_ZN4File9availableEv+0x18>)
  }
    5c48:	4770      	bx	lr
    5c4a:	46c0      	nop			; (mov r8, r8)
    5c4c:	7fffffff 	.word	0x7fffffff

00005c50 <_ZN4File5writeEPKhj>:
   * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
   * include write() is called before a file has been opened, write is called
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const uint8_t *buf, size_t size) {
    5c50:	b508      	push	{r3, lr}
    return FatFile::write(buf, size);
    5c52:	3010      	adds	r0, #16
    5c54:	f007 fd44 	bl	d6e0 <_ZN7FatFile5writeEPKvj>
  }
    5c58:	bd08      	pop	{r3, pc}

00005c5a <_ZN4File5flushEv>:
  int available() {
    uint32_t n = FatFile::available();
    return n > INT_MAX ? INT_MAX : n;
  }
  /** Ensure that any bytes written to the file are saved to the SD card. */
  void flush() {
    5c5a:	b508      	push	{r3, lr}
    FatFile::sync();
    5c5c:	3010      	adds	r0, #16
    5c5e:	f007 fb83 	bl	d368 <_ZN7FatFile4syncEv>
  }
    5c62:	bd08      	pop	{r3, pc}

00005c64 <_ZN4File4peekEv>:
  }
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    5c64:	b508      	push	{r3, lr}
    return FatFile::peek();
    5c66:	3010      	adds	r0, #16
    5c68:	f007 fa60 	bl	d12c <_ZN7FatFile4peekEv>
  }
    5c6c:	bd08      	pop	{r3, pc}

00005c6e <_ZN4File4readEv>:
  /** Read the next byte from a file.
   *
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
    5c6e:	b513      	push	{r0, r1, r4, lr}
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    5c70:	466c      	mov	r4, sp
    5c72:	3407      	adds	r4, #7
    return FatFile::read();
    5c74:	3010      	adds	r0, #16
    5c76:	1c21      	adds	r1, r4, #0
    5c78:	2201      	movs	r2, #1
    5c7a:	f007 f995 	bl	cfa8 <_ZN7FatFile4readEPvj>
    5c7e:	2801      	cmp	r0, #1
    5c80:	d101      	bne.n	5c86 <_ZN4File4readEv+0x18>
    5c82:	7820      	ldrb	r0, [r4, #0]
    5c84:	e001      	b.n	5c8a <_ZN4File4readEv+0x1c>
    5c86:	2001      	movs	r0, #1
    5c88:	4240      	negs	r0, r0
  }
    5c8a:	bd16      	pop	{r1, r2, r4, pc}

00005c8c <_ZN9SdFatBase9readBlockEmPh>:
    return m_sdCard.errorCode();
  }
  uint8_t cardErrorData() {
    return m_sdCard.errorData();
  }
  bool readBlock(uint32_t block, uint8_t* dst) {
    5c8c:	b508      	push	{r3, lr}
    return m_sdCard.readBlock(block, dst);
    5c8e:	238c      	movs	r3, #140	; 0x8c
    5c90:	00db      	lsls	r3, r3, #3
    5c92:	18c0      	adds	r0, r0, r3
    5c94:	f008 fd43 	bl	e71e <_ZN9SdSpiCard9readBlockEmPh>
  }
    5c98:	bd08      	pop	{r3, pc}

00005c9a <_ZN9SdFatBase10writeBlockEmPKh>:
  bool writeBlock(uint32_t block, const uint8_t* src) {
    5c9a:	b508      	push	{r3, lr}
    return m_sdCard.writeBlock(block, src);
    5c9c:	238c      	movs	r3, #140	; 0x8c
    5c9e:	00db      	lsls	r3, r3, #3
    5ca0:	18c0      	adds	r0, r0, r3
    5ca2:	f008 fdcb 	bl	e83c <_ZN9SdSpiCard10writeBlockEmPKh>
  }
    5ca6:	bd08      	pop	{r3, pc}

00005ca8 <_ZN9SdFatBase10readBlocksEmPhj>:
  bool readBlocks(uint32_t block, uint8_t* dst, size_t n) {
    5ca8:	b510      	push	{r4, lr}
    return m_sdCard.readBlocks(block, dst, n);
    5caa:	248c      	movs	r4, #140	; 0x8c
    5cac:	00e4      	lsls	r4, r4, #3
    5cae:	1900      	adds	r0, r0, r4
    5cb0:	f008 fd83 	bl	e7ba <_ZN9SdSpiCard10readBlocksEmPhj>
  }
    5cb4:	bd10      	pop	{r4, pc}

00005cb6 <_ZN9SdFatBase11writeBlocksEmPKhj>:
  bool writeBlocks(uint32_t block, const uint8_t* src, size_t n) {
    5cb6:	b510      	push	{r4, lr}
    return m_sdCard.writeBlocks(block, src, n);
    5cb8:	248c      	movs	r4, #140	; 0x8c
    5cba:	00e4      	lsls	r4, r4, #3
    5cbc:	1900      	adds	r0, r0, r4
    5cbe:	f008 fe3b 	bl	e938 <_ZN9SdSpiCard11writeBlocksEmPKhj>
  }
    5cc2:	bd10      	pop	{r4, pc}

00005cc4 <_ZN14Gamebuino_Meta14Display_ST7735D1Ev>:
#define ST7735_MAGENTA 0xF81F
#define ST7735_YELLOW  0xFFE0
#define ST7735_WHITE   0xFFFF


class Display_ST7735 : public Graphics {
    5cc4:	b510      	push	{r4, lr}
    5cc6:	4b03      	ldr	r3, [pc, #12]	; (5cd4 <_ZN14Gamebuino_Meta14Display_ST7735D1Ev+0x10>)
    5cc8:	1c04      	adds	r4, r0, #0
    5cca:	6003      	str	r3, [r0, #0]
    5ccc:	f002 febe 	bl	8a4c <_ZN14Gamebuino_Meta8GraphicsD1Ev>
    5cd0:	1c20      	adds	r0, r4, #0
    5cd2:	bd10      	pop	{r4, pc}
    5cd4:	00015080 	.word	0x00015080

00005cd8 <_ZN14Gamebuino_Meta14Display_ST7735D0Ev>:
#define ST7735_MAGENTA 0xF81F
#define ST7735_YELLOW  0xFFE0
#define ST7735_WHITE   0xFFFF


class Display_ST7735 : public Graphics {
    5cd8:	b510      	push	{r4, lr}
    5cda:	1c04      	adds	r4, r0, #0
    5cdc:	f7ff fff2 	bl	5cc4 <_ZN14Gamebuino_Meta14Display_ST7735D1Ev>
    5ce0:	1c20      	adds	r0, r4, #0
    5ce2:	f00a faad 	bl	10240 <_ZdlPv>
    5ce6:	1c20      	adds	r0, r4, #0
    5ce8:	bd10      	pop	{r4, pc}

00005cea <_ZN4File5writeEh>:
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {
    5cea:	b507      	push	{r0, r1, r2, lr}
    5cec:	466b      	mov	r3, sp
    5cee:	71d9      	strb	r1, [r3, #7]
    5cf0:	3307      	adds	r3, #7
    return FatFile::write(b);
    5cf2:	3010      	adds	r0, #16
  /** Write a single byte.
   * \param[in] b The byte to be written.
   * \return +1 for success or -1 for failure.
   */
  int write(uint8_t b) {
    return write(&b, 1);
    5cf4:	1c19      	adds	r1, r3, #0
    5cf6:	2201      	movs	r2, #1
    5cf8:	f007 fcf2 	bl	d6e0 <_ZN7FatFile5writeEPKvj>
  }
    5cfc:	bd0e      	pop	{r1, r2, r3, pc}

00005cfe <_ZN7FatFile6existsEPKc>:
   * dirFile.exists("TOFIND.TXT") searches for "TOFIND.TXT" in  the directory
   * dirFile.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    5cfe:	b530      	push	{r4, r5, lr}
    5d00:	1c05      	adds	r5, r0, #0
    5d02:	b08b      	sub	sp, #44	; 0x2c
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
    5d04:	a801      	add	r0, sp, #4
   * dirFile.exists("TOFIND.TXT") searches for "TOFIND.TXT" in  the directory
   * dirFile.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    5d06:	1c0a      	adds	r2, r1, #0
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
    5d08:	2400      	movs	r4, #0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile file;
    return file.open(this, path, O_READ);
    5d0a:	1c29      	adds	r1, r5, #0
    5d0c:	2301      	movs	r3, #1
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
    5d0e:	7004      	strb	r4, [r0, #0]
    5d10:	7044      	strb	r4, [r0, #1]
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile file;
    return file.open(this, path, O_READ);
    5d12:	f007 fb78 	bl	d406 <_ZN7FatFile4openEPS_PKch>
  }
    5d16:	b00b      	add	sp, #44	; 0x2c
    5d18:	bd30      	pop	{r4, r5, pc}
	...

00005d1c <_ZN7FatFile6setCwdEPS_>:
   * the value false, is returned for failure.
   */  
  bool getSFN(char* name);
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_attr & FILE_ATTR_DIR;
    5d1c:	7801      	ldrb	r1, [r0, #0]
   * \param[in] dir New current working directory.
   *
   * \return true for success else false.
   */
  static bool setCwd(FatFile* dir) {
    if (!dir->isDir()) {
    5d1e:	2270      	movs	r2, #112	; 0x70
      return false;
    5d20:	2300      	movs	r3, #0
   * \param[in] dir New current working directory.
   *
   * \return true for success else false.
   */
  static bool setCwd(FatFile* dir) {
    if (!dir->isDir()) {
    5d22:	4211      	tst	r1, r2
    5d24:	d002      	beq.n	5d2c <_ZN7FatFile6setCwdEPS_+0x10>
      return false;
    }
    m_cwd = dir;
    5d26:	4b02      	ldr	r3, [pc, #8]	; (5d30 <_ZN7FatFile6setCwdEPS_+0x14>)
    5d28:	6018      	str	r0, [r3, #0]
    return true;
    5d2a:	2301      	movs	r3, #1
  }
    5d2c:	1c18      	adds	r0, r3, #0
    5d2e:	4770      	bx	lr
    5d30:	20000cec 	.word	0x20000cec

00005d34 <_ZN4FileC1Ev>:
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
    5d34:	2300      	movs	r3, #0
    5d36:	7403      	strb	r3, [r0, #16]
    5d38:	7443      	strb	r3, [r0, #17]
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    5d3a:	6043      	str	r3, [r0, #4]
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
    5d3c:	23fa      	movs	r3, #250	; 0xfa
    5d3e:	009b      	lsls	r3, r3, #2
    5d40:	6083      	str	r3, [r0, #8]
class File : public FatFile, public Stream {
#else  // ARDUINO_FILE_USES_STREAM
class File : public FatFile, public Print {
#endif  // ARDUINO_FILE_USES_STREAM
 public:
  File() {}
    5d42:	4b01      	ldr	r3, [pc, #4]	; (5d48 <_ZN4FileC1Ev+0x14>)
    5d44:	6003      	str	r3, [r0, #0]
    5d46:	4770      	bx	lr
    5d48:	00014a40 	.word	0x00014a40

00005d4c <_ZN4FileaSEOS_>:
/**
 * \class File
 * \brief Arduino SD.h style File API
 */
#if ARDUINO_FILE_USES_STREAM
class File : public FatFile, public Stream {
    5d4c:	b570      	push	{r4, r5, r6, lr}
    5d4e:	1c03      	adds	r3, r0, #0
    5d50:	1c0a      	adds	r2, r1, #0
    5d52:	3310      	adds	r3, #16
    5d54:	3210      	adds	r2, #16
    5d56:	ca70      	ldmia	r2!, {r4, r5, r6}
    5d58:	c370      	stmia	r3!, {r4, r5, r6}
    5d5a:	ca70      	ldmia	r2!, {r4, r5, r6}
    5d5c:	c370      	stmia	r3!, {r4, r5, r6}
    5d5e:	ca70      	ldmia	r2!, {r4, r5, r6}
    5d60:	c370      	stmia	r3!, {r4, r5, r6}
#define DEC 10
#define HEX 16
#define OCT 8
#define BIN 2

class Print
    5d62:	684b      	ldr	r3, [r1, #4]
    SKIP_WHITESPACE // Only tabs, spaces, line feeds & carriage returns are skipped.
};

#define NO_IGNORE_CHAR  '\x01' // a char not found in a valid ASCII numeric field

class Stream : public Print
    5d64:	688c      	ldr	r4, [r1, #8]
    5d66:	68c9      	ldr	r1, [r1, #12]
    5d68:	6043      	str	r3, [r0, #4]
    5d6a:	6084      	str	r4, [r0, #8]
    5d6c:	60c1      	str	r1, [r0, #12]
    5d6e:	bd70      	pop	{r4, r5, r6, pc}

00005d70 <_ZN14Gamebuino_Meta9Gamebuino13updateDisplayEv>:
	frameEndMicros = micros(); //measure the frame's end time
	frameDurationMicros = frameEndMicros - frameStartMicros;
	return false;
}

void Gamebuino::updateDisplay() {
    5d70:	b573      	push	{r0, r1, r4, r5, r6, lr}
	tft.drawImage(0, 0, display, tft.width(), tft.height()); //send the buffer to the screen
    5d72:	1c04      	adds	r4, r0, #0
    5d74:	343c      	adds	r4, #60	; 0x3c
	frameEndMicros = micros(); //measure the frame's end time
	frameDurationMicros = frameEndMicros - frameStartMicros;
	return false;
}

void Gamebuino::updateDisplay() {
    5d76:	1c05      	adds	r5, r0, #0
	tft.drawImage(0, 0, display, tft.width(), tft.height()); //send the buffer to the screen
    5d78:	1c20      	adds	r0, r4, #0
    5d7a:	f004 f945 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
    5d7e:	1c06      	adds	r6, r0, #0
    5d80:	1c20      	adds	r0, r4, #0
    5d82:	f004 f951 	bl	a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>
    5d86:	1c2b      	adds	r3, r5, #0
    5d88:	2100      	movs	r1, #0
    5d8a:	9600      	str	r6, [sp, #0]
    5d8c:	9001      	str	r0, [sp, #4]
    5d8e:	3310      	adds	r3, #16
    5d90:	1c20      	adds	r0, r4, #0
    5d92:	1c0a      	adds	r2, r1, #0
    5d94:	f002 fce6 	bl	8764 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss>
}
    5d98:	bd73      	pop	{r0, r1, r4, r5, r6, pc}

00005d9a <_ZN14Gamebuino_Meta9Gamebuino12setFrameRateEh>:

void Gamebuino::setFrameRate(uint8_t fps) {
    5d9a:	b510      	push	{r4, lr}
    5d9c:	1c04      	adds	r4, r0, #0
	timePerFrame = 1000 / fps;
    5d9e:	20fa      	movs	r0, #250	; 0xfa
    5da0:	0080      	lsls	r0, r0, #2
    5da2:	f00b fb47 	bl	11434 <__aeabi_idiv>
    5da6:	23c2      	movs	r3, #194	; 0xc2
    5da8:	005b      	lsls	r3, r3, #1
    5daa:	54e0      	strb	r0, [r4, r3]
}
    5dac:	bd10      	pop	{r4, pc}

00005dae <_ZN14Gamebuino_Meta9Gamebuino14pickRandomSeedEv>:

void Gamebuino::pickRandomSeed(){
    5dae:	b538      	push	{r3, r4, r5, lr}
	randomSeed(micros() * micros() ^ analogRead(1)*analogRead(2)); // can't use analogRad(0) as we have a speaker attached there
    5db0:	f009 fabc 	bl	f32c <micros>
    5db4:	1c04      	adds	r4, r0, #0
    5db6:	f009 fab9 	bl	f32c <micros>
    5dba:	4344      	muls	r4, r0
    5dbc:	2001      	movs	r0, #1
    5dbe:	f009 fc6f 	bl	f6a0 <analogRead>
    5dc2:	1c05      	adds	r5, r0, #0
    5dc4:	2002      	movs	r0, #2
    5dc6:	f009 fc6b 	bl	f6a0 <analogRead>
    5dca:	4368      	muls	r0, r5
    5dcc:	4060      	eors	r0, r4
    5dce:	f00a f9f1 	bl	101b4 <_Z10randomSeedm>
}
    5dd2:	bd38      	pop	{r3, r4, r5, pc}

00005dd4 <_ZN14Gamebuino_Meta17Hook_ExitHomeMenuEv>:
}

void Hook_ExitHomeMenu() __attribute__((weak));
void Hook_ExitHomeMenu() {
	
}
    5dd4:	4770      	bx	lr
	...

00005dd8 <_ZN14Gamebuino_Meta21homeMenuGetUniquePathEPchh>:

bool homeMenuGetUniquePath(char* name, uint8_t offset, uint8_t len) {
    5dd8:	b5f0      	push	{r4, r5, r6, r7, lr}
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return vwd()->exists(path);
    5dda:	4b3c      	ldr	r3, [pc, #240]	; (5ecc <_ZN14Gamebuino_Meta21homeMenuGetUniquePathEPchh+0xf4>)
    5ddc:	4f3c      	ldr	r7, [pc, #240]	; (5ed0 <_ZN14Gamebuino_Meta21homeMenuGetUniquePathEPchh+0xf8>)
    5dde:	b09d      	sub	sp, #116	; 0x74
    5de0:	18fc      	adds	r4, r7, r3
    5de2:	1c06      	adds	r6, r0, #0
    5de4:	1c0d      	adds	r5, r1, #0
    5de6:	1c20      	adds	r0, r4, #0
    5de8:	493a      	ldr	r1, [pc, #232]	; (5ed4 <_ZN14Gamebuino_Meta21homeMenuGetUniquePathEPchh+0xfc>)
    5dea:	9201      	str	r2, [sp, #4]
    5dec:	f7ff ff87 	bl	5cfe <_ZN7FatFile6existsEPKc>
	if(!SD.exists("REC")) {
    5df0:	2800      	cmp	r0, #0
    5df2:	d108      	bne.n	5e06 <_ZN14Gamebuino_Meta21homeMenuGetUniquePathEPchh+0x2e>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
    5df4:	ab0f      	add	r3, sp, #60	; 0x3c
    5df6:	7018      	strb	r0, [r3, #0]
    5df8:	7058      	strb	r0, [r3, #1]
   * \return The value true is returned for success and
   * the value false is returned for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    5dfa:	1c21      	adds	r1, r4, #0
    5dfc:	1c18      	adds	r0, r3, #0
    5dfe:	4a35      	ldr	r2, [pc, #212]	; (5ed4 <_ZN14Gamebuino_Meta21homeMenuGetUniquePathEPchh+0xfc>)
    5e00:	2301      	movs	r3, #1
    5e02:	f007 fbcd 	bl	d5a0 <_ZN7FatFile5mkdirEPS_PKcb>
		SD.mkdir("REC");
	}
	uint32_t start;
	File cache;
    5e06:	a802      	add	r0, sp, #8
    5e08:	f7ff ff94 	bl	5d34 <_ZN4FileC1Ev>
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return vwd()->exists(path);
    5e0c:	4b2f      	ldr	r3, [pc, #188]	; (5ecc <_ZN14Gamebuino_Meta21homeMenuGetUniquePathEPchh+0xf4>)
    5e0e:	4932      	ldr	r1, [pc, #200]	; (5ed8 <_ZN14Gamebuino_Meta21homeMenuGetUniquePathEPchh+0x100>)
    5e10:	18ff      	adds	r7, r7, r3
    5e12:	1c38      	adds	r0, r7, #0
    5e14:	f7ff ff73 	bl	5cfe <_ZN7FatFile6existsEPKc>
    5e18:	1e04      	subs	r4, r0, #0
	if (!SD.exists("REC/REC.CACHE")) {
    5e1a:	d117      	bne.n	5e4c <_ZN14Gamebuino_Meta21homeMenuGetUniquePathEPchh+0x74>
   * \param[in] path location of file to be opened.
   * \param[in] mode open mode flags.
   * \return a File object.
   */
  File open(const char *path, uint8_t mode = FILE_READ) {
    File tmpFile;
    5e1c:	a80f      	add	r0, sp, #60	; 0x3c
    5e1e:	f7ff ff89 	bl	5d34 <_ZN4FileC1Ev>
    tmpFile.open(vwd(), path, mode);
    5e22:	4a2d      	ldr	r2, [pc, #180]	; (5ed8 <_ZN14Gamebuino_Meta21homeMenuGetUniquePathEPchh+0x100>)
    5e24:	2363      	movs	r3, #99	; 0x63
    5e26:	1c39      	adds	r1, r7, #0
    5e28:	a813      	add	r0, sp, #76	; 0x4c
    5e2a:	f007 faec 	bl	d406 <_ZN7FatFile4openEPS_PKch>
		cache = SD.open("REC/REC.CACHE", FILE_WRITE);
    5e2e:	a90f      	add	r1, sp, #60	; 0x3c
    5e30:	a802      	add	r0, sp, #8
    5e32:	f7ff ff8b 	bl	5d4c <_ZN4FileaSEOS_>
   * the value false is returned for failure.
   */
  static bool remove(FatFile* dirFile, const char* path);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    5e36:	1c21      	adds	r1, r4, #0
    5e38:	a806      	add	r0, sp, #24
    5e3a:	f007 f9a9 	bl	d190 <_ZN7FatFile7seekSetEm>
		cache.rewind();
		f_write32(0, &cache); // images
    5e3e:	1c20      	adds	r0, r4, #0
    5e40:	a902      	add	r1, sp, #8
    5e42:	f006 fcdd 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
		cache.close();
    5e46:	a806      	add	r0, sp, #24
    5e48:	f007 fad6 	bl	d3f8 <_ZN7FatFile5closeEv>
   * \param[in] path location of file to be opened.
   * \param[in] mode open mode flags.
   * \return a File object.
   */
  File open(const char *path, uint8_t mode = FILE_READ) {
    File tmpFile;
    5e4c:	a80f      	add	r0, sp, #60	; 0x3c
    5e4e:	f7ff ff71 	bl	5d34 <_ZN4FileC1Ev>
    tmpFile.open(vwd(), path, mode);
    5e52:	491f      	ldr	r1, [pc, #124]	; (5ed0 <_ZN14Gamebuino_Meta21homeMenuGetUniquePathEPchh+0xf8>)
    5e54:	4b1d      	ldr	r3, [pc, #116]	; (5ecc <_ZN14Gamebuino_Meta21homeMenuGetUniquePathEPchh+0xf4>)
    5e56:	4a20      	ldr	r2, [pc, #128]	; (5ed8 <_ZN14Gamebuino_Meta21homeMenuGetUniquePathEPchh+0x100>)
    5e58:	18c9      	adds	r1, r1, r3
    5e5a:	a813      	add	r0, sp, #76	; 0x4c
    5e5c:	2363      	movs	r3, #99	; 0x63
    5e5e:	f007 fad2 	bl	d406 <_ZN7FatFile4openEPS_PKch>
	}
	cache = SD.open("REC/REC.CACHE", FILE_WRITE);
    5e62:	a90f      	add	r1, sp, #60	; 0x3c
    5e64:	a802      	add	r0, sp, #8
    5e66:	f7ff ff71 	bl	5d4c <_ZN4FileaSEOS_>
    5e6a:	2100      	movs	r1, #0
    5e6c:	a806      	add	r0, sp, #24
    5e6e:	f007 f98f 	bl	d190 <_ZN7FatFile7seekSetEm>
	cache.rewind();
	start = f_read32(&cache);
    5e72:	a802      	add	r0, sp, #8
    5e74:	f006 fcbc 	bl	c7f0 <_ZN14Gamebuino_Meta8f_read32EP4File>
	start = sdPathNoDuplicate(name, offset, len, start + 1);
    5e78:	1c29      	adds	r1, r5, #0
    5e7a:	1c43      	adds	r3, r0, #1
    5e7c:	9a01      	ldr	r2, [sp, #4]
    5e7e:	1c30      	adds	r0, r6, #0
    5e80:	f006 fc5a 	bl	c738 <_ZN14Gamebuino_Meta17sdPathNoDuplicateEPchhl>
    5e84:	2100      	movs	r1, #0
    5e86:	1c04      	adds	r4, r0, #0
    5e88:	a806      	add	r0, sp, #24
    5e8a:	f007 f981 	bl	d190 <_ZN7FatFile7seekSetEm>
	cache.rewind();
	if (start == -1) {
    5e8e:	1c63      	adds	r3, r4, #1
    5e90:	d111      	bne.n	5eb6 <_ZN14Gamebuino_Meta21homeMenuGetUniquePathEPchh+0xde>
		f_write32(0, &cache);
    5e92:	2000      	movs	r0, #0
    5e94:	a902      	add	r1, sp, #8
    5e96:	f006 fcb3 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
		start = sdPathNoDuplicate(name, offset, len);
    5e9a:	1c30      	adds	r0, r6, #0
    5e9c:	1c29      	adds	r1, r5, #0
    5e9e:	9a01      	ldr	r2, [sp, #4]
    5ea0:	2300      	movs	r3, #0
    5ea2:	f006 fc49 	bl	c738 <_ZN14Gamebuino_Meta17sdPathNoDuplicateEPchhl>
    5ea6:	1c04      	adds	r4, r0, #0
	}
	if (start == -1) {
    5ea8:	1c43      	adds	r3, r0, #1
    5eaa:	d104      	bne.n	5eb6 <_ZN14Gamebuino_Meta21homeMenuGetUniquePathEPchh+0xde>
		cache.close();
    5eac:	a806      	add	r0, sp, #24
    5eae:	f007 faa3 	bl	d3f8 <_ZN7FatFile5closeEv>
		return false;
    5eb2:	2000      	movs	r0, #0
    5eb4:	e007      	b.n	5ec6 <_ZN14Gamebuino_Meta21homeMenuGetUniquePathEPchh+0xee>
	}
	f_write32(start, &cache);
    5eb6:	1c20      	adds	r0, r4, #0
    5eb8:	a902      	add	r1, sp, #8
    5eba:	f006 fca1 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
	cache.close();
    5ebe:	a806      	add	r0, sp, #24
    5ec0:	f007 fa9a 	bl	d3f8 <_ZN7FatFile5closeEv>
	return true;
    5ec4:	2001      	movs	r0, #1
}
    5ec6:	b01d      	add	sp, #116	; 0x74
    5ec8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5eca:	46c0      	nop			; (mov r8, r8)
    5ecc:	0000043c 	.word	0x0000043c
    5ed0:	200005c8 	.word	0x200005c8
    5ed4:	00014d0c 	.word	0x00014d0c
    5ed8:	00014d10 	.word	0x00014d10

00005edc <_ZN14Gamebuino_Meta9Gamebuino11updatePopupEv>:
void Gamebuino::popup(const char* text, uint8_t duration){
	popupText = text;
	popupTimeLeft = duration+12;
}

void Gamebuino::updatePopup(){
    5edc:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (popupTimeLeft){
    5ede:	23c8      	movs	r3, #200	; 0xc8
    5ee0:	005b      	lsls	r3, r3, #1
    5ee2:	5cc3      	ldrb	r3, [r0, r3]
void Gamebuino::popup(const char* text, uint8_t duration){
	popupText = text;
	popupTimeLeft = duration+12;
}

void Gamebuino::updatePopup(){
    5ee4:	b087      	sub	sp, #28
    5ee6:	1c05      	adds	r5, r0, #0
	if (popupTimeLeft){
    5ee8:	2b00      	cmp	r3, #0
    5eea:	d069      	beq.n	5fc0 <_ZN14Gamebuino_Meta9Gamebuino11updatePopupEv+0xe4>
		uint8_t yOffset = 0;
    5eec:	2600      	movs	r6, #0
		if(popupTimeLeft<12){
    5eee:	2b0b      	cmp	r3, #11
    5ef0:	d802      	bhi.n	5ef8 <_ZN14Gamebuino_Meta9Gamebuino11updatePopupEv+0x1c>
			yOffset = 12-popupTimeLeft;
    5ef2:	260c      	movs	r6, #12
    5ef4:	1af6      	subs	r6, r6, r3
    5ef6:	b2f6      	uxtb	r6, r6
		}
		display.setFontSize(1);
    5ef8:	1c2c      	adds	r4, r5, #0
    5efa:	3410      	adds	r4, #16
    5efc:	1c20      	adds	r0, r4, #0
    5efe:	2101      	movs	r1, #1
    5f00:	f003 fb68 	bl	95d4 <_ZN14Gamebuino_Meta8Graphics11setFontSizeEh>
		display.setColor(DISPLAY_DEFAULT_BACKGROUND_COLOR);
    5f04:	2100      	movs	r1, #0
    5f06:	1c20      	adds	r0, r4, #0
    5f08:	f003 ff64 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
		display.fillRoundRect(0,display.height()-display.getFontHeight()+yOffset-3,display.width(),display.getFontHeight()+3,3);
    5f0c:	1c20      	adds	r0, r4, #0
    5f0e:	f004 f88b 	bl	a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>
    5f12:	1c07      	adds	r7, r0, #0
    5f14:	1c20      	adds	r0, r4, #0
    5f16:	f003 fb57 	bl	95c8 <_ZNK14Gamebuino_Meta8Graphics13getFontHeightEv>
    5f1a:	9003      	str	r0, [sp, #12]
    5f1c:	1c20      	adds	r0, r4, #0
    5f1e:	f004 f873 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
    5f22:	9004      	str	r0, [sp, #16]
    5f24:	1c20      	adds	r0, r4, #0
    5f26:	f003 fb4f 	bl	95c8 <_ZNK14Gamebuino_Meta8Graphics13getFontHeightEv>
    5f2a:	9b03      	ldr	r3, [sp, #12]
    5f2c:	19f2      	adds	r2, r6, r7
    5f2e:	3a03      	subs	r2, #3
    5f30:	3003      	adds	r0, #3
    5f32:	2703      	movs	r7, #3
    5f34:	1ad2      	subs	r2, r2, r3
    5f36:	b200      	sxth	r0, r0
    5f38:	b212      	sxth	r2, r2
    5f3a:	9b04      	ldr	r3, [sp, #16]
    5f3c:	9000      	str	r0, [sp, #0]
    5f3e:	9701      	str	r7, [sp, #4]
    5f40:	1c20      	adds	r0, r4, #0
    5f42:	2100      	movs	r1, #0
    5f44:	f003 fafc 	bl	9540 <_ZN14Gamebuino_Meta8Graphics13fillRoundRectEsssss>
		display.setColor(DISPLAY_DEFAULT_COLOR);
    5f48:	491e      	ldr	r1, [pc, #120]	; (5fc4 <_ZN14Gamebuino_Meta9Gamebuino11updatePopupEv+0xe8>)
    5f4a:	1c20      	adds	r0, r4, #0
    5f4c:	f003 ff42 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
		display.drawRoundRect(0,display.height()-display.getFontHeight()+yOffset-3,display.width(),display.getFontHeight()+3,3);
    5f50:	1c20      	adds	r0, r4, #0
    5f52:	f004 f869 	bl	a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>
    5f56:	9003      	str	r0, [sp, #12]
    5f58:	1c20      	adds	r0, r4, #0
    5f5a:	f003 fb35 	bl	95c8 <_ZNK14Gamebuino_Meta8Graphics13getFontHeightEv>
    5f5e:	9004      	str	r0, [sp, #16]
    5f60:	1c20      	adds	r0, r4, #0
    5f62:	f004 f851 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
    5f66:	9005      	str	r0, [sp, #20]
    5f68:	1c20      	adds	r0, r4, #0
    5f6a:	f003 fb2d 	bl	95c8 <_ZNK14Gamebuino_Meta8Graphics13getFontHeightEv>
    5f6e:	9b03      	ldr	r3, [sp, #12]
    5f70:	19c0      	adds	r0, r0, r7
    5f72:	18f2      	adds	r2, r6, r3
    5f74:	9b04      	ldr	r3, [sp, #16]
    5f76:	3a03      	subs	r2, #3
    5f78:	1ad2      	subs	r2, r2, r3
    5f7a:	b200      	sxth	r0, r0
    5f7c:	9b05      	ldr	r3, [sp, #20]
    5f7e:	b212      	sxth	r2, r2
    5f80:	2100      	movs	r1, #0
    5f82:	9000      	str	r0, [sp, #0]
    5f84:	9701      	str	r7, [sp, #4]
    5f86:	1c20      	adds	r0, r4, #0
    5f88:	f003 fbcf 	bl	972a <_ZN14Gamebuino_Meta8Graphics13drawRoundRectEsssss>
		display.setCursor(
			4,
			display.height()-display.getFontHeight()+yOffset-1
    5f8c:	1c20      	adds	r0, r4, #0
    5f8e:	f004 f84b 	bl	a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>
    5f92:	1c07      	adds	r7, r0, #0
    5f94:	1c20      	adds	r0, r4, #0
    5f96:	f003 fb17 	bl	95c8 <_ZNK14Gamebuino_Meta8Graphics13getFontHeightEv>
		);
    5f9a:	19f2      	adds	r2, r6, r7
    5f9c:	3a01      	subs	r2, #1
    5f9e:	1a12      	subs	r2, r2, r0
    5fa0:	b212      	sxth	r2, r2
    5fa2:	1c20      	adds	r0, r4, #0
    5fa4:	2104      	movs	r1, #4
    5fa6:	f003 ff75 	bl	9e94 <_ZN14Gamebuino_Meta8Graphics9setCursorEss>
		display.print(popupText);
    5faa:	23c6      	movs	r3, #198	; 0xc6
    5fac:	005b      	lsls	r3, r3, #1
    5fae:	58e9      	ldr	r1, [r5, r3]
    5fb0:	1c20      	adds	r0, r4, #0
    5fb2:	f009 fddf 	bl	fb74 <_ZN5Print5printEPKc>
		popupTimeLeft--;
    5fb6:	23c8      	movs	r3, #200	; 0xc8
    5fb8:	005b      	lsls	r3, r3, #1
    5fba:	5cea      	ldrb	r2, [r5, r3]
    5fbc:	3a01      	subs	r2, #1
    5fbe:	54ea      	strb	r2, [r5, r3]
	}
}
    5fc0:	b007      	add	sp, #28
    5fc2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5fc4:	0000ffff 	.word	0x0000ffff

00005fc8 <_ZN14Gamebuino_Meta9Gamebuino10changeGameEv>:

void Gamebuino::changeGame(){
    5fc8:	b510      	push	{r4, lr}
	//clear the screen
	tft.fill(Color::black);
    5fca:	2100      	movs	r1, #0
		display.print(popupText);
		popupTimeLeft--;
	}
}

void Gamebuino::changeGame(){
    5fcc:	1c04      	adds	r4, r0, #0
	//clear the screen
	tft.fill(Color::black);
    5fce:	303c      	adds	r0, #60	; 0x3c
    5fd0:	f003 fec4 	bl	9d5c <_ZN14Gamebuino_Meta8Graphics4fillENS_5ColorE>
	//flash loader.bin
	bootloader.loader();
    5fd4:	235a      	movs	r3, #90	; 0x5a
    5fd6:	33ff      	adds	r3, #255	; 0xff
    5fd8:	18e0      	adds	r0, r4, r3
    5fda:	f001 fdcf 	bl	7b7c <_ZN14Gamebuino_Meta10Bootloader6loaderEv>
}
    5fde:	bd10      	pop	{r4, pc}

00005fe0 <_ZN14Gamebuino_Meta8Language4_getILh3EEEPKcRAT__KNS_9MultiLangE>:
	template<uint8_t N>
	static const char* get(const MultiLang (&l) [N]) {
		return get(l, N);
	};
	template<uint8_t N>
	static const char* _get(const MultiLang (&l) [N]) {
    5fe0:	b508      	push	{r3, lr}
		return get(l, N);
    5fe2:	2103      	movs	r1, #3
    5fe4:	f006 fb7a 	bl	c6dc <_ZN14Gamebuino_Meta8Language3getEPKNS_9MultiLangEh>
	};
    5fe8:	bd08      	pop	{r3, pc}
	...

00005fec <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv>:
	name[N-4] = 'B';
	//name[N-3] = 'M'; // no need as GMV and BMP have same second letter
	name[N-2] = 'P';
}

void Gamebuino::homeMenu(){
    5fec:	b5f0      	push	{r4, r5, r6, r7, lr}
	//here we don't use gb.update and display.not to interfere with the game
	//the only things we use are gb.tft and gb.buttons
	sound.startEfxOnly();
    5fee:	1c06      	adds	r6, r0, #0
    5ff0:	3638      	adds	r6, #56	; 0x38
	name[N-4] = 'B';
	//name[N-3] = 'M'; // no need as GMV and BMP have same second letter
	name[N-2] = 'P';
}

void Gamebuino::homeMenu(){
    5ff2:	b09f      	sub	sp, #124	; 0x7c
    5ff4:	1c07      	adds	r7, r0, #0
	//here we don't use gb.update and display.not to interfere with the game
	//the only things we use are gb.tft and gb.buttons
	sound.startEfxOnly();
    5ff6:	1c30      	adds	r0, r6, #0
    5ff8:	f008 ff74 	bl	eee4 <_ZN14Gamebuino_Meta5Sound12startEfxOnlyEv>
	
	HOME_MENU_SAVE_STATE;
    5ffc:	4bc6      	ldr	r3, [pc, #792]	; (6318 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x32c>)
		lang_homeMenu_exit,
		lang_homeMenu_volume,
		lang_homeMenu_save_image,
		lang_homeMenu_save_video,
		lang_homeMenu_light,
	};
    5ffe:	a919      	add	r1, sp, #100	; 0x64
void Gamebuino::homeMenu(){
	//here we don't use gb.update and display.not to interfere with the game
	//the only things we use are gb.tft and gb.buttons
	sound.startEfxOnly();
	
	HOME_MENU_SAVE_STATE;
    6000:	881b      	ldrh	r3, [r3, #0]
		lang_homeMenu_exit,
		lang_homeMenu_volume,
		lang_homeMenu_save_image,
		lang_homeMenu_save_video,
		lang_homeMenu_light,
	};
    6002:	4ac6      	ldr	r2, [pc, #792]	; (631c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x330>)
void Gamebuino::homeMenu(){
	//here we don't use gb.update and display.not to interfere with the game
	//the only things we use are gb.tft and gb.buttons
	sound.startEfxOnly();
	
	HOME_MENU_SAVE_STATE;
    6004:	930a      	str	r3, [sp, #40]	; 0x28
    6006:	4bc6      	ldr	r3, [pc, #792]	; (6320 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x334>)
    6008:	881b      	ldrh	r3, [r3, #0]
    600a:	930b      	str	r3, [sp, #44]	; 0x2c
    600c:	4bc5      	ldr	r3, [pc, #788]	; (6324 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x338>)
    600e:	881b      	ldrh	r3, [r3, #0]
    6010:	930c      	str	r3, [sp, #48]	; 0x30
    6012:	4bc5      	ldr	r3, [pc, #788]	; (6328 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x33c>)
    6014:	881b      	ldrh	r3, [r3, #0]
    6016:	930d      	str	r3, [sp, #52]	; 0x34
    6018:	4bc4      	ldr	r3, [pc, #784]	; (632c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x340>)
    601a:	781b      	ldrb	r3, [r3, #0]
    601c:	930e      	str	r3, [sp, #56]	; 0x38
    601e:	4bc4      	ldr	r3, [pc, #784]	; (6330 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x344>)
    6020:	781b      	ldrb	r3, [r3, #0]
    6022:	930f      	str	r3, [sp, #60]	; 0x3c
    6024:	4bc3      	ldr	r3, [pc, #780]	; (6334 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x348>)
    6026:	681b      	ldr	r3, [r3, #0]
    6028:	9310      	str	r3, [sp, #64]	; 0x40
    602a:	4bc3      	ldr	r3, [pc, #780]	; (6338 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x34c>)
    602c:	781b      	ldrb	r3, [r3, #0]
    602e:	9311      	str	r3, [sp, #68]	; 0x44
    6030:	4bc2      	ldr	r3, [pc, #776]	; (633c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x350>)
    6032:	781b      	ldrb	r3, [r3, #0]
    6034:	9312      	str	r3, [sp, #72]	; 0x48
		lang_homeMenu_exit,
		lang_homeMenu_volume,
		lang_homeMenu_save_image,
		lang_homeMenu_save_video,
		lang_homeMenu_light,
	};
    6036:	1c0b      	adds	r3, r1, #0
    6038:	ca31      	ldmia	r2!, {r0, r4, r5}
    603a:	c331      	stmia	r3!, {r0, r4, r5}
	
	
	neoPixels.clear();
    603c:	24b8      	movs	r4, #184	; 0xb8
    603e:	0064      	lsls	r4, r4, #1
    6040:	193c      	adds	r4, r7, r4
		lang_homeMenu_exit,
		lang_homeMenu_volume,
		lang_homeMenu_save_image,
		lang_homeMenu_save_video,
		lang_homeMenu_light,
	};
    6042:	ca03      	ldmia	r2!, {r0, r1}
    6044:	c303      	stmia	r3!, {r0, r1}
	
	
	neoPixels.clear();
    6046:	1c20      	adds	r0, r4, #0
    6048:	9406      	str	r4, [sp, #24]
    604a:	f001 fb69 	bl	7720 <_ZN17Adafruit_NeoPixel5clearEv>
	neoPixels.show();
    604e:	9806      	ldr	r0, [sp, #24]
    6050:	f001 fa6e 	bl	7530 <_ZN17Adafruit_NeoPixel4showEv>
    6054:	2400      	movs	r4, #0
    6056:	b2e5      	uxtb	r5, r4
	// determin the neoPixel color index
	uint8_t neoPixelsIntensity = 0;
	for (;(neoPixelsIntensity < 5) && (neoPixels.getBrightness() > neoPixelsIntensities[neoPixelsIntensity]);neoPixelsIntensity++);
    6058:	9806      	ldr	r0, [sp, #24]
    605a:	9503      	str	r5, [sp, #12]
    605c:	f001 fb5c 	bl	7718 <_ZNK17Adafruit_NeoPixel13getBrightnessEv>
    6060:	4bb7      	ldr	r3, [pc, #732]	; (6340 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x354>)
    6062:	5ce3      	ldrb	r3, [r4, r3]
    6064:	4283      	cmp	r3, r0
    6066:	d206      	bcs.n	6076 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x8a>
    6068:	9b03      	ldr	r3, [sp, #12]
    606a:	3401      	adds	r4, #1
    606c:	3301      	adds	r3, #1
    606e:	b2db      	uxtb	r3, r3
    6070:	9303      	str	r3, [sp, #12]
    6072:	2c05      	cmp	r4, #5
    6074:	d1ef      	bne.n	6056 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x6a>
	
	
	//static screen content
	//logo
	tft.setColor(BLACK);
    6076:	1c3c      	adds	r4, r7, #0
    6078:	343c      	adds	r4, #60	; 0x3c
    607a:	1c20      	adds	r0, r4, #0
    607c:	2100      	movs	r1, #0
    607e:	f003 fea9 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
	tft.fillRect(0,0,160,12);
    6082:	250c      	movs	r5, #12
    6084:	2100      	movs	r1, #0
    6086:	1c0a      	adds	r2, r1, #0
    6088:	23a0      	movs	r3, #160	; 0xa0
    608a:	1c20      	adds	r0, r4, #0
    608c:	9500      	str	r5, [sp, #0]
    608e:	f002 f98d 	bl	83ac <_ZN14Gamebuino_Meta14Display_ST77358fillRectEssss>
	tft.setColor(WHITE);
    6092:	1c20      	adds	r0, r4, #0
    6094:	49ab      	ldr	r1, [pc, #684]	; (6344 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x358>)
    6096:	f003 fe9d 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
	tft.drawBitmap(40,0,gamebuinoLogo);
    609a:	2200      	movs	r2, #0
    609c:	4baa      	ldr	r3, [pc, #680]	; (6348 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x35c>)
    609e:	1c20      	adds	r0, r4, #0
    60a0:	2128      	movs	r1, #40	; 0x28
    60a2:	f003 fc1d 	bl	98e0 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKh>
	//text settings
	display.setFont(font3x5);
    60a6:	1c38      	adds	r0, r7, #0
    60a8:	3010      	adds	r0, #16
    60aa:	49a8      	ldr	r1, [pc, #672]	; (634c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x360>)
    60ac:	9008      	str	r0, [sp, #32]
    60ae:	f003 fefb 	bl	9ea8 <_ZN14Gamebuino_Meta8Graphics7setFontEPKh>
	tft.fontSize = 2;
    60b2:	4b9e      	ldr	r3, [pc, #632]	; (632c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x340>)
    60b4:	2202      	movs	r2, #2
    60b6:	701a      	strb	r2, [r3, #0]
	tft.textWrap = false;
    60b8:	4b9d      	ldr	r3, [pc, #628]	; (6330 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x344>)
    60ba:	2200      	movs	r2, #0
	//horizontal stripes
	tft.setColor(DARKGRAY);
    60bc:	1c20      	adds	r0, r4, #0
    60be:	49a4      	ldr	r1, [pc, #656]	; (6350 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x364>)
	tft.setColor(WHITE);
	tft.drawBitmap(40,0,gamebuinoLogo);
	//text settings
	display.setFont(font3x5);
	tft.fontSize = 2;
	tft.textWrap = false;
    60c0:	701a      	strb	r2, [r3, #0]
	//horizontal stripes
	tft.setColor(DARKGRAY);
    60c2:	f003 fe87 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
	for (int i = 12; i < tft.height(); i+=4){
    60c6:	1c20      	adds	r0, r4, #0
    60c8:	f003 ffae 	bl	a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>
    60cc:	4285      	cmp	r5, r0
    60ce:	da0c      	bge.n	60ea <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0xfe>
		tft.fillRect(0, i, tft.width(), 2);
    60d0:	1c20      	adds	r0, r4, #0
    60d2:	f003 ff99 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
    60d6:	2102      	movs	r1, #2
    60d8:	1c03      	adds	r3, r0, #0
    60da:	b22a      	sxth	r2, r5
    60dc:	9100      	str	r1, [sp, #0]
    60de:	1c20      	adds	r0, r4, #0
    60e0:	2100      	movs	r1, #0
    60e2:	f002 f963 	bl	83ac <_ZN14Gamebuino_Meta14Display_ST77358fillRectEssss>
	display.setFont(font3x5);
	tft.fontSize = 2;
	tft.textWrap = false;
	//horizontal stripes
	tft.setColor(DARKGRAY);
	for (int i = 12; i < tft.height(); i+=4){
    60e6:	3504      	adds	r5, #4
    60e8:	e7ed      	b.n	60c6 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0xda>
		tft.fillRect(0, i, tft.width(), 2);
	}
	
	tft.setColor(DARKGRAY);
    60ea:	4999      	ldr	r1, [pc, #612]	; (6350 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x364>)
    60ec:	1c20      	adds	r0, r4, #0
    60ee:	f003 fe71 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
	//first row
	tft.fillRect(xOffset-8, yOffset1 - 2, tft.width() - 2*(xOffset-8), 14);
    60f2:	1c20      	adds	r0, r4, #0
    60f4:	f003 ff88 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
    60f8:	1c03      	adds	r3, r0, #0
    60fa:	250e      	movs	r5, #14
    60fc:	3b40      	subs	r3, #64	; 0x40
    60fe:	b21b      	sxth	r3, r3
    6100:	2120      	movs	r1, #32
    6102:	2228      	movs	r2, #40	; 0x28
    6104:	9500      	str	r5, [sp, #0]
    6106:	1c20      	adds	r0, r4, #0
    6108:	f002 f950 	bl	83ac <_ZN14Gamebuino_Meta14Display_ST77358fillRectEssss>
	//main text
	tft.fillRect(xOffset-18, yOffset2 - 4, tft.width()- 2*(xOffset-18), 18);
    610c:	1c20      	adds	r0, r4, #0
    610e:	f003 ff7b 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
    6112:	1c03      	adds	r3, r0, #0
    6114:	3b2c      	subs	r3, #44	; 0x2c
    6116:	2012      	movs	r0, #18
    6118:	b21b      	sxth	r3, r3
    611a:	2236      	movs	r2, #54	; 0x36
    611c:	9000      	str	r0, [sp, #0]
    611e:	2116      	movs	r1, #22
    6120:	1c20      	adds	r0, r4, #0
    6122:	f002 f943 	bl	83ac <_ZN14Gamebuino_Meta14Display_ST77358fillRectEssss>
	tft.setColor(BROWN);
    6126:	498b      	ldr	r1, [pc, #556]	; (6354 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x368>)
    6128:	1c20      	adds	r0, r4, #0
    612a:	f003 fe53 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
	tft.fillRect(xOffset-16, yOffset2 - 4, tft.width()- 2*(xOffset-16), 18);
    612e:	1c20      	adds	r0, r4, #0
    6130:	f003 ff6a 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
    6134:	1c03      	adds	r3, r0, #0
    6136:	2112      	movs	r1, #18
    6138:	3b30      	subs	r3, #48	; 0x30
    613a:	b21b      	sxth	r3, r3
    613c:	2236      	movs	r2, #54	; 0x36
    613e:	9100      	str	r1, [sp, #0]
    6140:	1c20      	adds	r0, r4, #0
    6142:	2118      	movs	r1, #24
    6144:	f002 f932 	bl	83ac <_ZN14Gamebuino_Meta14Display_ST77358fillRectEssss>
	//last row
	tft.setColor(DARKGRAY);
    6148:	4981      	ldr	r1, [pc, #516]	; (6350 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x364>)
    614a:	1c20      	adds	r0, r4, #0
    614c:	f003 fe42 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
	tft.fillRect(xOffset-8, yOffset3 - 2, tft.width() - 2*(xOffset-8), 14);
    6150:	1c20      	adds	r0, r4, #0
    6152:	f003 ff59 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
    6156:	1c03      	adds	r3, r0, #0
    6158:	3b40      	subs	r3, #64	; 0x40
    615a:	9500      	str	r5, [sp, #0]
    615c:	b21b      	sxth	r3, r3
	const int yOffset2 = 42+16;
	const int yOffset3 = 42+16+16;
	//main text offset
	const int xOffset = 40;
	boolean changed = true;
	int frameCounter = 0;
    615e:	2500      	movs	r5, #0
	tft.fillRect(xOffset-18, yOffset2 - 4, tft.width()- 2*(xOffset-18), 18);
	tft.setColor(BROWN);
	tft.fillRect(xOffset-16, yOffset2 - 4, tft.width()- 2*(xOffset-16), 18);
	//last row
	tft.setColor(DARKGRAY);
	tft.fillRect(xOffset-8, yOffset3 - 2, tft.width() - 2*(xOffset-8), 14);
    6160:	1c20      	adds	r0, r4, #0
    6162:	2120      	movs	r1, #32
    6164:	2248      	movs	r2, #72	; 0x48
    6166:	f002 f921 	bl	83ac <_ZN14Gamebuino_Meta14Display_ST77358fillRectEssss>
	const int yOffset2 = 42+16;
	const int yOffset3 = 42+16+16;
	//main text offset
	const int xOffset = 40;
	boolean changed = true;
	int frameCounter = 0;
    616a:	9507      	str	r5, [sp, #28]
	const int yOffset1 = 42;
	const int yOffset2 = 42+16;
	const int yOffset3 = 42+16+16;
	//main text offset
	const int xOffset = 40;
	boolean changed = true;
    616c:	2501      	movs	r5, #1
    616e:	9505      	str	r5, [sp, #20]
	
	HOME_MENU_SAVE_STATE;
	
	int currentItem = 0;
	const int numItems = 5;
	unsigned long lastMillis = 0;
    6170:	2500      	movs	r5, #0
    6172:	9509      	str	r5, [sp, #36]	; 0x24
	//the only things we use are gb.tft and gb.buttons
	sound.startEfxOnly();
	
	HOME_MENU_SAVE_STATE;
	
	int currentItem = 0;
    6174:	9504      	str	r5, [sp, #16]
	tft.setColor(DARKGRAY);
	tft.fillRect(xOffset-8, yOffset3 - 2, tft.width() - 2*(xOffset-8), 14);
		
	while(1){
		//Ensure constant framerate using millis (40ms = 25FPS)
		if((millis() - lastMillis) > 40){
    6176:	f009 f8d3 	bl	f320 <millis>
    617a:	9d09      	ldr	r5, [sp, #36]	; 0x24
    617c:	1b40      	subs	r0, r0, r5
    617e:	2828      	cmp	r0, #40	; 0x28
    6180:	d9f9      	bls.n	6176 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x18a>
			sound.update(); // we still need sound...
    6182:	1c30      	adds	r0, r6, #0
    6184:	f008 fe70 	bl	ee68 <_ZN14Gamebuino_Meta5Sound6updateEv>
			lastMillis = millis();
    6188:	f009 f8ca 	bl	f320 <millis>
    618c:	9009      	str	r0, [sp, #36]	; 0x24
			buttons.update();
    618e:	1c38      	adds	r0, r7, #0
    6190:	f001 fd30 	bl	7bf4 <_ZN14Gamebuino_Meta7Buttons6updateEv>
			frameCounter++;
    6194:	9d07      	ldr	r5, [sp, #28]
			
			//clear noPixels
			neoPixels.clear();
    6196:	9806      	ldr	r0, [sp, #24]
		//Ensure constant framerate using millis (40ms = 25FPS)
		if((millis() - lastMillis) > 40){
			sound.update(); // we still need sound...
			lastMillis = millis();
			buttons.update();
			frameCounter++;
    6198:	3501      	adds	r5, #1
    619a:	9507      	str	r5, [sp, #28]
			
			//clear noPixels
			neoPixels.clear();
    619c:	f001 fac0 	bl	7720 <_ZN17Adafruit_NeoPixel5clearEv>
			
			if(buttons.released(Button::d) || buttons.released(Button::b) || buttons.released(Button::c)){
    61a0:	1c38      	adds	r0, r7, #0
    61a2:	2107      	movs	r1, #7
    61a4:	f001 fd72 	bl	7c8c <_ZN14Gamebuino_Meta7Buttons8releasedENS_6ButtonE>
    61a8:	2800      	cmp	r0, #0
    61aa:	d10b      	bne.n	61c4 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x1d8>
    61ac:	1c38      	adds	r0, r7, #0
    61ae:	2105      	movs	r1, #5
    61b0:	f001 fd6c 	bl	7c8c <_ZN14Gamebuino_Meta7Buttons8releasedENS_6ButtonE>
    61b4:	2800      	cmp	r0, #0
    61b6:	d105      	bne.n	61c4 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x1d8>
    61b8:	1c38      	adds	r0, r7, #0
    61ba:	2106      	movs	r1, #6
    61bc:	f001 fd66 	bl	7c8c <_ZN14Gamebuino_Meta7Buttons8releasedENS_6ButtonE>
    61c0:	2800      	cmp	r0, #0
    61c2:	d021      	beq.n	6208 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x21c>
				sound.stopEfxOnly();
    61c4:	1c30      	adds	r0, r6, #0
    61c6:	f008 fe93 	bl	eef0 <_ZN14Gamebuino_Meta5Sound11stopEfxOnlyEv>
				HOME_MENU_RESTORE_STATE;
    61ca:	4b53      	ldr	r3, [pc, #332]	; (6318 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x32c>)
    61cc:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    61ce:	801c      	strh	r4, [r3, #0]
    61d0:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    61d2:	4b53      	ldr	r3, [pc, #332]	; (6320 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x334>)
    61d4:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    61d6:	801d      	strh	r5, [r3, #0]
    61d8:	4b52      	ldr	r3, [pc, #328]	; (6324 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x338>)
    61da:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    61dc:	801c      	strh	r4, [r3, #0]
    61de:	4b52      	ldr	r3, [pc, #328]	; (6328 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x33c>)
    61e0:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    61e2:	801d      	strh	r5, [r3, #0]
    61e4:	4b51      	ldr	r3, [pc, #324]	; (632c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x340>)
    61e6:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    61e8:	701c      	strb	r4, [r3, #0]
    61ea:	4b51      	ldr	r3, [pc, #324]	; (6330 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x344>)
    61ec:	9c10      	ldr	r4, [sp, #64]	; 0x40
    61ee:	701d      	strb	r5, [r3, #0]
    61f0:	4b50      	ldr	r3, [pc, #320]	; (6334 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x348>)
    61f2:	9d11      	ldr	r5, [sp, #68]	; 0x44
    61f4:	601c      	str	r4, [r3, #0]
    61f6:	4b50      	ldr	r3, [pc, #320]	; (6338 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x34c>)
    61f8:	9c12      	ldr	r4, [sp, #72]	; 0x48
    61fa:	701d      	strb	r5, [r3, #0]
    61fc:	4b4f      	ldr	r3, [pc, #316]	; (633c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x350>)
    61fe:	701c      	strb	r4, [r3, #0]
				Hook_ExitHomeMenu();
    6200:	f7ff fde8 	bl	5dd4 <_ZN14Gamebuino_Meta17Hook_ExitHomeMenuEv>
			neoPixels.show();
			
			changed = false;
		}
	}
}
    6204:	b01f      	add	sp, #124	; 0x7c
    6206:	bdf0      	pop	{r4, r5, r6, r7, pc}
				sound.stopEfxOnly();
				HOME_MENU_RESTORE_STATE;
				Hook_ExitHomeMenu();
				return;
			}
			if(buttons.held(Button::d, 25)){
    6208:	1c38      	adds	r0, r7, #0
    620a:	2107      	movs	r1, #7
    620c:	2219      	movs	r2, #25
    620e:	f001 fd47 	bl	7ca0 <_ZN14Gamebuino_Meta7Buttons4heldENS_6ButtonEt>
    6212:	2800      	cmp	r0, #0
    6214:	d002      	beq.n	621c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x230>
				changeGame();
    6216:	1c38      	adds	r0, r7, #0
    6218:	f7ff fed6 	bl	5fc8 <_ZN14Gamebuino_Meta9Gamebuino10changeGameEv>
			}
			
			if(buttons.repeat(Button::down, 8)){
    621c:	1c38      	adds	r0, r7, #0
    621e:	2100      	movs	r1, #0
    6220:	2208      	movs	r2, #8
    6222:	f001 fd45 	bl	7cb0 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt>
    6226:	2800      	cmp	r0, #0
    6228:	d00b      	beq.n	6242 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x256>
				currentItem++;
    622a:	9d04      	ldr	r5, [sp, #16]
    622c:	3501      	adds	r5, #1
    622e:	9504      	str	r5, [sp, #16]
				if(currentItem >= numItems){
    6230:	2d04      	cmp	r5, #4
    6232:	dc02      	bgt.n	623a <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x24e>
					currentItem = 0;
				}
				changed = true;
    6234:	2501      	movs	r5, #1
    6236:	9505      	str	r5, [sp, #20]
    6238:	e003      	b.n	6242 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x256>
    623a:	2501      	movs	r5, #1
    623c:	9505      	str	r5, [sp, #20]
			}
			
			if(buttons.repeat(Button::down, 8)){
				currentItem++;
				if(currentItem >= numItems){
					currentItem = 0;
    623e:	2500      	movs	r5, #0
    6240:	9504      	str	r5, [sp, #16]
				}
				changed = true;
			}
			
			if(buttons.repeat(Button::up, 8)){
    6242:	1c38      	adds	r0, r7, #0
    6244:	2103      	movs	r1, #3
    6246:	2208      	movs	r2, #8
    6248:	f001 fd32 	bl	7cb0 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt>
    624c:	2800      	cmp	r0, #0
    624e:	d00a      	beq.n	6266 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x27a>
				currentItem--;
				if(currentItem < 0){
    6250:	9d04      	ldr	r5, [sp, #16]
    6252:	3d01      	subs	r5, #1
    6254:	9504      	str	r5, [sp, #16]
    6256:	d302      	bcc.n	625e <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x272>
					currentItem = numItems - 1;
				}
				changed = true;
    6258:	2501      	movs	r5, #1
    625a:	9505      	str	r5, [sp, #20]
    625c:	e003      	b.n	6266 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x27a>
    625e:	2501      	movs	r5, #1
    6260:	9505      	str	r5, [sp, #20]
			}
			
			if(buttons.repeat(Button::up, 8)){
				currentItem--;
				if(currentItem < 0){
					currentItem = numItems - 1;
    6262:	2504      	movs	r5, #4
    6264:	9504      	str	r5, [sp, #16]
				changed = true;
			}
			
			
			//blinking arrow
			if((frameCounter%10) < 5){
    6266:	9807      	ldr	r0, [sp, #28]
    6268:	210a      	movs	r1, #10
    626a:	f00b f939 	bl	114e0 <__aeabi_idivmod>
				tft.setColor(BROWN);
    626e:	1c20      	adds	r0, r4, #0
				changed = true;
			}
			
			
			//blinking arrow
			if((frameCounter%10) < 5){
    6270:	2904      	cmp	r1, #4
    6272:	dc03      	bgt.n	627c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x290>
				tft.setColor(BROWN);
    6274:	4937      	ldr	r1, [pc, #220]	; (6354 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x368>)
    6276:	f003 fdad 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
    627a:	e003      	b.n	6284 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x298>
			} else {
				tft.setColor(WHITE, BROWN);
    627c:	4931      	ldr	r1, [pc, #196]	; (6344 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x358>)
    627e:	4a35      	ldr	r2, [pc, #212]	; (6354 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x368>)
    6280:	f003 fdde 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
			}
			tft.cursorX = xOffset - 12;
    6284:	4d24      	ldr	r5, [pc, #144]	; (6318 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x32c>)
    6286:	231c      	movs	r3, #28
    6288:	802b      	strh	r3, [r5, #0]
			tft.cursorY = yOffset2;
    628a:	4d25      	ldr	r5, [pc, #148]	; (6320 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x334>)
    628c:	203a      	movs	r0, #58	; 0x3a
    628e:	8028      	strh	r0, [r5, #0]
			tft.print(">");
    6290:	4931      	ldr	r1, [pc, #196]	; (6358 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x36c>)
    6292:	1c20      	adds	r0, r4, #0
    6294:	f009 fc6e 	bl	fb74 <_ZN5Print5printEPKc>
			
			tft.cursorX = xOffset;
    6298:	491f      	ldr	r1, [pc, #124]	; (6318 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x32c>)
    629a:	2328      	movs	r3, #40	; 0x28
			tft.cursorY = yOffset2;
    629c:	223a      	movs	r2, #58	; 0x3a
			}
			tft.cursorX = xOffset - 12;
			tft.cursorY = yOffset2;
			tft.print(">");
			
			tft.cursorX = xOffset;
    629e:	800b      	strh	r3, [r1, #0]
			tft.cursorY = yOffset2;
    62a0:	802a      	strh	r2, [r5, #0]
			tft.setColor(WHITE, BROWN);
    62a2:	1c20      	adds	r0, r4, #0
    62a4:	4927      	ldr	r1, [pc, #156]	; (6344 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x358>)
    62a6:	4a2b      	ldr	r2, [pc, #172]	; (6354 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x368>)
    62a8:	f003 fdca 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
			
			tft.setColor(WHITE, BROWN);
    62ac:	1c20      	adds	r0, r4, #0
    62ae:	4925      	ldr	r1, [pc, #148]	; (6344 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x358>)
    62b0:	4a28      	ldr	r2, [pc, #160]	; (6354 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x368>)
    62b2:	f003 fdc5 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
			switch(currentItem){
    62b6:	9d04      	ldr	r5, [sp, #16]
    62b8:	2d04      	cmp	r5, #4
    62ba:	d900      	bls.n	62be <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x2d2>
    62bc:	e114      	b.n	64e8 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x4fc>
    62be:	1c28      	adds	r0, r5, #0
    62c0:	f00b f856 	bl	11370 <__gnu_thumb1_case_uqi>
    62c4:	c37a0e03 	.word	0xc37a0e03
    62c8:	d3          	.byte	0xd3
    62c9:	00          	.byte	0x00
				////EXIT
				case 0:
					if (buttons.pressed(Button::a)){
    62ca:	1c38      	adds	r0, r7, #0
    62cc:	2104      	movs	r1, #4
    62ce:	f001 fcd5 	bl	7c7c <_ZN14Gamebuino_Meta7Buttons7pressedENS_6ButtonE>
    62d2:	2800      	cmp	r0, #0
    62d4:	d100      	bne.n	62d8 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x2ec>
    62d6:	e107      	b.n	64e8 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x4fc>
						changeGame();
    62d8:	1c38      	adds	r0, r7, #0
    62da:	f7ff fe75 	bl	5fc8 <_ZN14Gamebuino_Meta9Gamebuino10changeGameEv>
    62de:	e103      	b.n	64e8 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x4fc>
					}
				break;
				////VOLUME
				case 1:
					if (buttons.released(Button::a)) {
    62e0:	1c38      	adds	r0, r7, #0
    62e2:	2104      	movs	r1, #4
    62e4:	f001 fcd2 	bl	7c8c <_ZN14Gamebuino_Meta7Buttons8releasedENS_6ButtonE>
    62e8:	2800      	cmp	r0, #0
    62ea:	d043      	beq.n	6374 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x388>
						if (sound.isMute()) {
    62ec:	1c30      	adds	r0, r6, #0
    62ee:	f008 fdf3 	bl	eed8 <_ZN14Gamebuino_Meta5Sound6isMuteEv>
    62f2:	2800      	cmp	r0, #0
    62f4:	d032      	beq.n	635c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x370>
							sound.unmute();
    62f6:	1c30      	adds	r0, r6, #0
    62f8:	f008 fde8 	bl	eecc <_ZN14Gamebuino_Meta5Sound6unmuteEv>
							sound.playTick();
    62fc:	1c30      	adds	r0, r6, #0
    62fe:	f008 fdab 	bl	ee58 <_ZN14Gamebuino_Meta5Sound8playTickEv>
							settings.set(SETTING_VOLUME_MUTE, (int32_t)0);
    6302:	2184      	movs	r1, #132	; 0x84
    6304:	0049      	lsls	r1, r1, #1
    6306:	1878      	adds	r0, r7, r1
    6308:	2200      	movs	r2, #0
    630a:	2101      	movs	r1, #1
						} else {
							sound.mute();
							settings.set(SETTING_VOLUME_MUTE, 1);
						}
						changed = true;
    630c:	2501      	movs	r5, #1
				case 1:
					if (buttons.released(Button::a)) {
						if (sound.isMute()) {
							sound.unmute();
							sound.playTick();
							settings.set(SETTING_VOLUME_MUTE, (int32_t)0);
    630e:	f006 fd63 	bl	cdd8 <_ZN14Gamebuino_Meta4Save3setEtl>
						} else {
							sound.mute();
							settings.set(SETTING_VOLUME_MUTE, 1);
						}
						changed = true;
    6312:	9505      	str	r5, [sp, #20]
    6314:	e02e      	b.n	6374 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x388>
    6316:	46c0      	nop			; (mov r8, r8)
    6318:	20000cdc 	.word	0x20000cdc
    631c:	00014a70 	.word	0x00014a70
    6320:	20000cc4 	.word	0x20000cc4
    6324:	20000cd8 	.word	0x20000cd8
    6328:	20000cc2 	.word	0x20000cc2
    632c:	20000cd4 	.word	0x20000cd4
    6330:	20000077 	.word	0x20000077
    6334:	20000cc8 	.word	0x20000cc8
    6338:	20000cc0 	.word	0x20000cc0
    633c:	20000cd5 	.word	0x20000cd5
    6340:	00014cec 	.word	0x00014cec
    6344:	0000ffff 	.word	0x0000ffff
    6348:	00014f64 	.word	0x00014f64
    634c:	00015110 	.word	0x00015110
    6350:	000072c7 	.word	0x000072c7
    6354:	0000cc68 	.word	0x0000cc68
    6358:	00014d1e 	.word	0x00014d1e
						if (sound.isMute()) {
							sound.unmute();
							sound.playTick();
							settings.set(SETTING_VOLUME_MUTE, (int32_t)0);
						} else {
							sound.mute();
    635c:	1c30      	adds	r0, r6, #0
    635e:	f008 fdaf 	bl	eec0 <_ZN14Gamebuino_Meta5Sound4muteEv>
							settings.set(SETTING_VOLUME_MUTE, 1);
    6362:	2184      	movs	r1, #132	; 0x84
    6364:	0049      	lsls	r1, r1, #1
    6366:	1878      	adds	r0, r7, r1
    6368:	2101      	movs	r1, #1
    636a:	1c0a      	adds	r2, r1, #0
						}
						changed = true;
    636c:	2501      	movs	r5, #1
							sound.unmute();
							sound.playTick();
							settings.set(SETTING_VOLUME_MUTE, (int32_t)0);
						} else {
							sound.mute();
							settings.set(SETTING_VOLUME_MUTE, 1);
    636e:	f006 fd33 	bl	cdd8 <_ZN14Gamebuino_Meta4Save3setEtl>
						}
						changed = true;
    6372:	9505      	str	r5, [sp, #20]
					}
					if ((buttons.repeat(Button::right, 4) && (sound.getVolume() < 8))){
    6374:	1c38      	adds	r0, r7, #0
    6376:	2102      	movs	r1, #2
    6378:	2204      	movs	r2, #4
    637a:	f001 fc99 	bl	7cb0 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt>
    637e:	2800      	cmp	r0, #0
    6380:	d005      	beq.n	638e <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x3a2>
    6382:	1c30      	adds	r0, r6, #0
    6384:	f008 fdc4 	bl	ef10 <_ZN14Gamebuino_Meta5Sound9getVolumeEv>
    6388:	2807      	cmp	r0, #7
    638a:	d800      	bhi.n	638e <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x3a2>
    638c:	e155      	b.n	663a <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x64e>
						sound.setVolume(sound.getVolume() + 1);
						settings.set(SETTING_VOLUME, sound.getVolume());
						sound.playTick();
						changed = true;
					}
					if (buttons.repeat(Button::left, 4) && sound.getVolume() && !sound.isMute()){
    638e:	1c38      	adds	r0, r7, #0
    6390:	2101      	movs	r1, #1
    6392:	2204      	movs	r2, #4
    6394:	f001 fc8c 	bl	7cb0 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt>
    6398:	2800      	cmp	r0, #0
    639a:	d100      	bne.n	639e <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x3b2>
    639c:	e0a4      	b.n	64e8 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x4fc>
    639e:	1c30      	adds	r0, r6, #0
    63a0:	f008 fdb6 	bl	ef10 <_ZN14Gamebuino_Meta5Sound9getVolumeEv>
    63a4:	2800      	cmp	r0, #0
    63a6:	d100      	bne.n	63aa <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x3be>
    63a8:	e09e      	b.n	64e8 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x4fc>
    63aa:	1c30      	adds	r0, r6, #0
    63ac:	f008 fd94 	bl	eed8 <_ZN14Gamebuino_Meta5Sound6isMuteEv>
    63b0:	1e05      	subs	r5, r0, #0
    63b2:	d000      	beq.n	63b6 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x3ca>
    63b4:	e098      	b.n	64e8 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x4fc>
    63b6:	e158      	b.n	666a <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x67e>
						changed = true;
					}
				break;
				////SCREENSHOT
				case 2:
					if (buttons.released(Button::a)){
    63b8:	1c38      	adds	r0, r7, #0
    63ba:	2104      	movs	r1, #4
    63bc:	f001 fc66 	bl	7c8c <_ZN14Gamebuino_Meta7Buttons8releasedENS_6ButtonE>
    63c0:	2800      	cmp	r0, #0
    63c2:	d100      	bne.n	63c6 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x3da>
    63c4:	e090      	b.n	64e8 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x4fc>
						tft.print(language._get(lang_homeMenu_SAVING));
    63c6:	48e4      	ldr	r0, [pc, #912]	; (6758 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x76c>)
    63c8:	f7ff fe0a 	bl	5fe0 <_ZN14Gamebuino_Meta8Language4_getILh3EEEPKcRAT__KNS_9MultiLangE>
						char name[] = "REC/00000.GMV";
    63cc:	ad15      	add	r5, sp, #84	; 0x54
					}
				break;
				////SCREENSHOT
				case 2:
					if (buttons.released(Button::a)){
						tft.print(language._get(lang_homeMenu_SAVING));
    63ce:	1c01      	adds	r1, r0, #0
    63d0:	1c20      	adds	r0, r4, #0
    63d2:	f009 fbcf 	bl	fb74 <_ZN5Print5printEPKc>
						char name[] = "REC/00000.GMV";
    63d6:	49e1      	ldr	r1, [pc, #900]	; (675c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x770>)
    63d8:	220e      	movs	r2, #14
    63da:	1c28      	adds	r0, r5, #0
    63dc:	f00b f8ed 	bl	115ba <memcpy>
						// now `name` will be a unique thing
						// 9 because "REC/" is 4 long, 5 because "00000" is 4 chars
						bool success = homeMenuGetUniquePath(name, 4, 5);
    63e0:	1c28      	adds	r0, r5, #0
    63e2:	2104      	movs	r1, #4
    63e4:	2205      	movs	r2, #5
    63e6:	f7ff fcf7 	bl	5dd8 <_ZN14Gamebuino_Meta21homeMenuGetUniquePathEPchh>
						if (success) {
    63ea:	2800      	cmp	r0, #0
    63ec:	d007      	beq.n	63fe <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x412>
	return true;
}

template<uint8_t N>
void fileEndingGmvToBmp(char (&name)[N]) {
	name[N-4] = 'B';
    63ee:	2342      	movs	r3, #66	; 0x42
    63f0:	72ab      	strb	r3, [r5, #10]
						// now `name` will be a unique thing
						// 9 because "REC/" is 4 long, 5 because "00000" is 4 chars
						bool success = homeMenuGetUniquePath(name, 4, 5);
						if (success) {
							fileEndingGmvToBmp(name);
							success = display.save(name);
    63f2:	9808      	ldr	r0, [sp, #32]

template<uint8_t N>
void fileEndingGmvToBmp(char (&name)[N]) {
	name[N-4] = 'B';
	//name[N-3] = 'M'; // no need as GMV and BMP have same second letter
	name[N-2] = 'P';
    63f4:	2350      	movs	r3, #80	; 0x50
						// now `name` will be a unique thing
						// 9 because "REC/" is 4 long, 5 because "00000" is 4 chars
						bool success = homeMenuGetUniquePath(name, 4, 5);
						if (success) {
							fileEndingGmvToBmp(name);
							success = display.save(name);
    63f6:	1c29      	adds	r1, r5, #0

template<uint8_t N>
void fileEndingGmvToBmp(char (&name)[N]) {
	name[N-4] = 'B';
	//name[N-3] = 'M'; // no need as GMV and BMP have same second letter
	name[N-2] = 'P';
    63f8:	732b      	strb	r3, [r5, #12]
						// now `name` will be a unique thing
						// 9 because "REC/" is 4 long, 5 because "00000" is 4 chars
						bool success = homeMenuGetUniquePath(name, 4, 5);
						if (success) {
							fileEndingGmvToBmp(name);
							success = display.save(name);
    63fa:	f004 fced 	bl	add8 <_ZN14Gamebuino_Meta5Image4saveEPc>
						}
						// we temp. set inited to false so that delay() won't re-draw the screen
						inited = false;
    63fe:	23b6      	movs	r3, #182	; 0xb6
    6400:	2200      	movs	r2, #0
    6402:	005b      	lsls	r3, r3, #1
    6404:	54fa      	strb	r2, [r7, r3]
    6406:	4dd6      	ldr	r5, [pc, #856]	; (6760 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x774>)
						if (success){
    6408:	4290      	cmp	r0, r2
    640a:	d008      	beq.n	641e <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x432>
							tft.setColor(LIGHTGREEN, BROWN);
    640c:	1c20      	adds	r0, r4, #0
    640e:	49d5      	ldr	r1, [pc, #852]	; (6764 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x778>)
    6410:	4ad5      	ldr	r2, [pc, #852]	; (6768 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x77c>)
    6412:	f003 fd15 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
							tft.cursorX = xOffset;
    6416:	2328      	movs	r3, #40	; 0x28
    6418:	802b      	strh	r3, [r5, #0]
							tft.print(language._get(lang_homeMenu_SAVED));
    641a:	48d4      	ldr	r0, [pc, #848]	; (676c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x780>)
    641c:	e007      	b.n	642e <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x442>
							delay(250);
							changed = true;
						} else {
							tft.setColor(RED, BROWN);
    641e:	1c20      	adds	r0, r4, #0
    6420:	49d3      	ldr	r1, [pc, #844]	; (6770 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x784>)
    6422:	4ad1      	ldr	r2, [pc, #836]	; (6768 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x77c>)
    6424:	f003 fd0c 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
							tft.cursorX = xOffset;
    6428:	2328      	movs	r3, #40	; 0x28
							tft.print(language._get(lang_homeMenu_ERROR));
    642a:	48d2      	ldr	r0, [pc, #840]	; (6774 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x788>)
							tft.print(language._get(lang_homeMenu_SAVED));
							delay(250);
							changed = true;
						} else {
							tft.setColor(RED, BROWN);
							tft.cursorX = xOffset;
    642c:	802b      	strh	r3, [r5, #0]
							tft.print(language._get(lang_homeMenu_ERROR));
    642e:	f7ff fdd7 	bl	5fe0 <_ZN14Gamebuino_Meta8Language4_getILh3EEEPKcRAT__KNS_9MultiLangE>
    6432:	1c01      	adds	r1, r0, #0
    6434:	1c20      	adds	r0, r4, #0
    6436:	f009 fb9d 	bl	fb74 <_ZN5Print5printEPKc>
							delay(250);
    643a:	20fa      	movs	r0, #250	; 0xfa
    643c:	f008 ffa8 	bl	f390 <delay>
							changed = true;
						}
						inited = true;
    6440:	2201      	movs	r2, #1
    6442:	23b6      	movs	r3, #182	; 0xb6
    6444:	4093      	lsls	r3, r2
    6446:	54fa      	strb	r2, [r7, r3]
    6448:	e052      	b.n	64f0 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x504>
					}
				break;
				////RECORD SCREEN
				case 3:
					if (buttons.released(Button::a) || buttons.held(Button::a, 25)){
    644a:	1c38      	adds	r0, r7, #0
    644c:	2104      	movs	r1, #4
    644e:	f001 fc1d 	bl	7c8c <_ZN14Gamebuino_Meta7Buttons8releasedENS_6ButtonE>
    6452:	2800      	cmp	r0, #0
    6454:	d000      	beq.n	6458 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x46c>
    6456:	e11e      	b.n	6696 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x6aa>
    6458:	1c38      	adds	r0, r7, #0
    645a:	2104      	movs	r1, #4
    645c:	2219      	movs	r2, #25
    645e:	f001 fc1f 	bl	7ca0 <_ZN14Gamebuino_Meta7Buttons4heldENS_6ButtonEt>
    6462:	2800      	cmp	r0, #0
    6464:	d000      	beq.n	6468 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x47c>
    6466:	e116      	b.n	6696 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x6aa>
    6468:	e03e      	b.n	64e8 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x4fc>
						inited = true;
					}
				break;
				//// NEOPIXELS
				case 4:
					if (buttons.released(Button::a) || buttons.repeat(Button::right, 4)){
    646a:	1c38      	adds	r0, r7, #0
    646c:	2104      	movs	r1, #4
    646e:	f001 fc0d 	bl	7c8c <_ZN14Gamebuino_Meta7Buttons8releasedENS_6ButtonE>
    6472:	2800      	cmp	r0, #0
    6474:	d000      	beq.n	6478 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x48c>
    6476:	e1b5      	b.n	67e4 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x7f8>
    6478:	1c38      	adds	r0, r7, #0
    647a:	2102      	movs	r1, #2
    647c:	2204      	movs	r2, #4
    647e:	f001 fc17 	bl	7cb0 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt>
    6482:	2800      	cmp	r0, #0
    6484:	d000      	beq.n	6488 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x49c>
    6486:	e1ad      	b.n	67e4 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x7f8>
						}
						changed = true;
						neoPixels.setBrightness(neoPixelsIntensities[neoPixelsIntensity]);
						settings.set(SETTING_NEOPIXELS_INTENSITY, neoPixelsIntensity);
					}
					if (buttons.repeat(Button::left, 4)){
    6488:	1c38      	adds	r0, r7, #0
    648a:	2101      	movs	r1, #1
    648c:	2204      	movs	r2, #4
    648e:	f001 fc0f 	bl	7cb0 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt>
    6492:	2800      	cmp	r0, #0
    6494:	d018      	beq.n	64c8 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x4dc>
						if(neoPixelsIntensity == 0){
    6496:	9d03      	ldr	r5, [sp, #12]
    6498:	2d00      	cmp	r5, #0
    649a:	d004      	beq.n	64a6 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x4ba>
							neoPixelsIntensity = 4;
						} else {
							neoPixelsIntensity--;
    649c:	1c2b      	adds	r3, r5, #0
    649e:	3b01      	subs	r3, #1
    64a0:	b2db      	uxtb	r3, r3
    64a2:	9303      	str	r3, [sp, #12]
    64a4:	e001      	b.n	64aa <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x4be>
						neoPixels.setBrightness(neoPixelsIntensities[neoPixelsIntensity]);
						settings.set(SETTING_NEOPIXELS_INTENSITY, neoPixelsIntensity);
					}
					if (buttons.repeat(Button::left, 4)){
						if(neoPixelsIntensity == 0){
							neoPixelsIntensity = 4;
    64a6:	2504      	movs	r5, #4
    64a8:	9503      	str	r5, [sp, #12]
						} else {
							neoPixelsIntensity--;
						}
						changed = true;
						neoPixels.setBrightness(neoPixelsIntensities[neoPixelsIntensity]);
    64aa:	4bb3      	ldr	r3, [pc, #716]	; (6778 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x78c>)
    64ac:	9d03      	ldr	r5, [sp, #12]
    64ae:	9806      	ldr	r0, [sp, #24]
    64b0:	5d59      	ldrb	r1, [r3, r5]
    64b2:	f001 f909 	bl	76c8 <_ZN17Adafruit_NeoPixel13setBrightnessEh>
						settings.set(SETTING_NEOPIXELS_INTENSITY, neoPixelsIntensity);
    64b6:	2184      	movs	r1, #132	; 0x84
    64b8:	0049      	lsls	r1, r1, #1
    64ba:	1878      	adds	r0, r7, r1
	bool set(uint16_t i, const char* buf);
	bool set(uint16_t i, void* buf, uint32_t bufsize);
	bool set(uint16_t i, const void* buf, uint32_t bufsize);
	template< typename T > bool set(uint16_t i, T& obj) {
		if (std::is_arithmetic<T>::value) {
			return set(i, (int32_t)obj);
    64bc:	9a03      	ldr	r2, [sp, #12]
    64be:	2104      	movs	r1, #4
						if(neoPixelsIntensity == 0){
							neoPixelsIntensity = 4;
						} else {
							neoPixelsIntensity--;
						}
						changed = true;
    64c0:	2501      	movs	r5, #1
    64c2:	f006 fc89 	bl	cdd8 <_ZN14Gamebuino_Meta4Save3setEtl>
    64c6:	9505      	str	r5, [sp, #20]
						neoPixels.setBrightness(neoPixelsIntensities[neoPixelsIntensity]);
						settings.set(SETTING_NEOPIXELS_INTENSITY, neoPixelsIntensity);
					}
					//light up neopixels according to intensity
					for(uint8_t i = 0; i < neoPixels.numPixels(); i++){
    64c8:	2500      	movs	r5, #0
    64ca:	9806      	ldr	r0, [sp, #24]
    64cc:	f001 f8fa 	bl	76c4 <_ZNK17Adafruit_NeoPixel9numPixelsEv>
    64d0:	4285      	cmp	r5, r0
    64d2:	d209      	bcs.n	64e8 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x4fc>
						neoPixels.setPixelColor(i, 0xFF, 0xFF, 0xFF);
    64d4:	23ff      	movs	r3, #255	; 0xff
    64d6:	1c29      	adds	r1, r5, #0
    64d8:	9300      	str	r3, [sp, #0]
    64da:	9806      	ldr	r0, [sp, #24]
    64dc:	1c1a      	adds	r2, r3, #0
						changed = true;
						neoPixels.setBrightness(neoPixelsIntensities[neoPixelsIntensity]);
						settings.set(SETTING_NEOPIXELS_INTENSITY, neoPixelsIntensity);
					}
					//light up neopixels according to intensity
					for(uint8_t i = 0; i < neoPixels.numPixels(); i++){
    64de:	3501      	adds	r5, #1
						neoPixels.setPixelColor(i, 0xFF, 0xFF, 0xFF);
    64e0:	f001 f8cd 	bl	767e <_ZN17Adafruit_NeoPixel13setPixelColorEthhh>
						changed = true;
						neoPixels.setBrightness(neoPixelsIntensities[neoPixelsIntensity]);
						settings.set(SETTING_NEOPIXELS_INTENSITY, neoPixelsIntensity);
					}
					//light up neopixels according to intensity
					for(uint8_t i = 0; i < neoPixels.numPixels(); i++){
    64e4:	b2ed      	uxtb	r5, r5
    64e6:	e7f0      	b.n	64ca <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x4de>
						neoPixels.setPixelColor(i, 0xFF, 0xFF, 0xFF);
					}
				break;
			}
			
			if(changed == true){
    64e8:	9d05      	ldr	r5, [sp, #20]
    64ea:	2d00      	cmp	r5, #0
    64ec:	d100      	bne.n	64f0 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x504>
    64ee:	e09e      	b.n	662e <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x642>
				//bottom text first to feel snappy when you are seeking down
				tft.cursorX = xOffset;
    64f0:	4d9b      	ldr	r5, [pc, #620]	; (6760 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x774>)
				tft.cursorY = yOffset3;
    64f2:	49a2      	ldr	r1, [pc, #648]	; (677c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x790>)
    64f4:	234a      	movs	r3, #74	; 0x4a
				break;
			}
			
			if(changed == true){
				//bottom text first to feel snappy when you are seeking down
				tft.cursorX = xOffset;
    64f6:	2028      	movs	r0, #40	; 0x28
				tft.cursorY = yOffset3;
    64f8:	800b      	strh	r3, [r1, #0]
				tft.setColor(BROWN, DARKGRAY);
    64fa:	4aa1      	ldr	r2, [pc, #644]	; (6780 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x794>)
				break;
			}
			
			if(changed == true){
				//bottom text first to feel snappy when you are seeking down
				tft.cursorX = xOffset;
    64fc:	8028      	strh	r0, [r5, #0]
				tft.cursorY = yOffset3;
				tft.setColor(BROWN, DARKGRAY);
    64fe:	499a      	ldr	r1, [pc, #616]	; (6768 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x77c>)
    6500:	1c20      	adds	r0, r4, #0
    6502:	f003 fc9d 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
				tft.print(language.get(menuText[wrap(currentItem+1, numItems)], NUMBER_SYSTEM_LANGUAGES));
    6506:	9804      	ldr	r0, [sp, #16]
    6508:	2105      	movs	r1, #5
    650a:	3006      	adds	r0, #6
    650c:	f00a ffe8 	bl	114e0 <__aeabi_idivmod>
    6510:	0089      	lsls	r1, r1, #2
    6512:	466a      	mov	r2, sp
    6514:	3164      	adds	r1, #100	; 0x64
    6516:	5888      	ldr	r0, [r1, r2]
    6518:	2103      	movs	r1, #3
    651a:	f006 f8df 	bl	c6dc <_ZN14Gamebuino_Meta8Language3getEPKNS_9MultiLangEh>
    651e:	1c01      	adds	r1, r0, #0
    6520:	1c20      	adds	r0, r4, #0
    6522:	f009 fb27 	bl	fb74 <_ZN5Print5printEPKc>
				//primary text
				tft.cursorX = xOffset;
				tft.cursorY = yOffset2;
    6526:	4895      	ldr	r0, [pc, #596]	; (677c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x790>)
    6528:	213a      	movs	r1, #58	; 0x3a
				tft.cursorX = xOffset;
				tft.cursorY = yOffset3;
				tft.setColor(BROWN, DARKGRAY);
				tft.print(language.get(menuText[wrap(currentItem+1, numItems)], NUMBER_SYSTEM_LANGUAGES));
				//primary text
				tft.cursorX = xOffset;
    652a:	2328      	movs	r3, #40	; 0x28
				tft.cursorY = yOffset2;
    652c:	8001      	strh	r1, [r0, #0]
				tft.setColor(WHITE, BROWN);
    652e:	4a8e      	ldr	r2, [pc, #568]	; (6768 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x77c>)
    6530:	1c20      	adds	r0, r4, #0
    6532:	4994      	ldr	r1, [pc, #592]	; (6784 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x798>)
				tft.cursorX = xOffset;
				tft.cursorY = yOffset3;
				tft.setColor(BROWN, DARKGRAY);
				tft.print(language.get(menuText[wrap(currentItem+1, numItems)], NUMBER_SYSTEM_LANGUAGES));
				//primary text
				tft.cursorX = xOffset;
    6534:	802b      	strh	r3, [r5, #0]
				tft.cursorY = yOffset2;
				tft.setColor(WHITE, BROWN);
    6536:	f003 fc83 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
				tft.print(language.get(menuText[currentItem], NUMBER_SYSTEM_LANGUAGES));
    653a:	9a04      	ldr	r2, [sp, #16]
    653c:	4669      	mov	r1, sp
    653e:	0093      	lsls	r3, r2, #2
    6540:	3364      	adds	r3, #100	; 0x64
    6542:	5858      	ldr	r0, [r3, r1]
    6544:	2103      	movs	r1, #3
    6546:	f006 f8c9 	bl	c6dc <_ZN14Gamebuino_Meta8Language3getEPKNS_9MultiLangEh>
    654a:	1c01      	adds	r1, r0, #0
    654c:	1c20      	adds	r0, r4, #0
    654e:	f009 fb11 	bl	fb74 <_ZN5Print5printEPKc>
				tft.print("  ");
    6552:	498d      	ldr	r1, [pc, #564]	; (6788 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x79c>)
    6554:	1c20      	adds	r0, r4, #0
    6556:	f009 fb0d 	bl	fb74 <_ZN5Print5printEPKc>
				//complementary text if needed
				tft.setColor(WHITE, BROWN);
    655a:	1c20      	adds	r0, r4, #0
    655c:	4a82      	ldr	r2, [pc, #520]	; (6768 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x77c>)
    655e:	4989      	ldr	r1, [pc, #548]	; (6784 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x798>)
    6560:	f003 fc6e 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
				tft.cursorY = yOffset2;
    6564:	4a85      	ldr	r2, [pc, #532]	; (677c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x790>)
				switch(currentItem){
    6566:	9804      	ldr	r0, [sp, #16]
				tft.setColor(WHITE, BROWN);
				tft.print(language.get(menuText[currentItem], NUMBER_SYSTEM_LANGUAGES));
				tft.print("  ");
				//complementary text if needed
				tft.setColor(WHITE, BROWN);
				tft.cursorY = yOffset2;
    6568:	233a      	movs	r3, #58	; 0x3a
    656a:	8013      	strh	r3, [r2, #0]
				switch(currentItem){
    656c:	2801      	cmp	r0, #1
    656e:	d006      	beq.n	657e <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x592>
    6570:	2804      	cmp	r0, #4
    6572:	d142      	bne.n	65fa <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x60e>
							tft.print("\23x");
						}
					break;
					////NEOPIXELS
					case 4:
						tft.cursorX -= 4*2*6;
    6574:	882b      	ldrh	r3, [r5, #0]
    6576:	3b30      	subs	r3, #48	; 0x30
    6578:	802b      	strh	r3, [r5, #0]
						for(int i = 0; i < 4; i++){
    657a:	2500      	movs	r5, #0
    657c:	e019      	b.n	65b2 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x5c6>
				tft.setColor(WHITE, BROWN);
				tft.cursorY = yOffset2;
				switch(currentItem){
					////VOLUME
					case 1:
						tft.cursorX -= 4*2*4;
    657e:	882b      	ldrh	r3, [r5, #0]
						if(!sound.isMute() && sound.getVolume()) {
    6580:	1c30      	adds	r0, r6, #0
				tft.setColor(WHITE, BROWN);
				tft.cursorY = yOffset2;
				switch(currentItem){
					////VOLUME
					case 1:
						tft.cursorX -= 4*2*4;
    6582:	3b20      	subs	r3, #32
    6584:	802b      	strh	r3, [r5, #0]
						if(!sound.isMute() && sound.getVolume()) {
    6586:	f008 fca7 	bl	eed8 <_ZN14Gamebuino_Meta5Sound6isMuteEv>
    658a:	2800      	cmp	r0, #0
    658c:	d000      	beq.n	6590 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x5a4>
    658e:	e144      	b.n	681a <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x82e>
    6590:	1c30      	adds	r0, r6, #0
    6592:	f008 fcbd 	bl	ef10 <_ZN14Gamebuino_Meta5Sound9getVolumeEv>
    6596:	2800      	cmp	r0, #0
    6598:	d114      	bne.n	65c4 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x5d8>
    659a:	e13e      	b.n	681a <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x82e>
						tft.cursorX -= 4*2*6;
						for(int i = 0; i < 4; i++){
							if(neoPixelsIntensity <= i){
								tft.setColor(DARKGRAY, BROWN);
							} else {
								tft.setColor(WHITE, BROWN);
    659c:	4979      	ldr	r1, [pc, #484]	; (6784 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x798>)
    659e:	4a72      	ldr	r2, [pc, #456]	; (6768 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x77c>)
    65a0:	f003 fc4e 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
							}
							tft.print("*");
    65a4:	1c20      	adds	r0, r4, #0
    65a6:	4979      	ldr	r1, [pc, #484]	; (678c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x7a0>)
						}
					break;
					////NEOPIXELS
					case 4:
						tft.cursorX -= 4*2*6;
						for(int i = 0; i < 4; i++){
    65a8:	3501      	adds	r5, #1
							if(neoPixelsIntensity <= i){
								tft.setColor(DARKGRAY, BROWN);
							} else {
								tft.setColor(WHITE, BROWN);
							}
							tft.print("*");
    65aa:	f009 fae3 	bl	fb74 <_ZN5Print5printEPKc>
						}
					break;
					////NEOPIXELS
					case 4:
						tft.cursorX -= 4*2*6;
						for(int i = 0; i < 4; i++){
    65ae:	2d04      	cmp	r5, #4
    65b0:	d023      	beq.n	65fa <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x60e>
							if(neoPixelsIntensity <= i){
    65b2:	9903      	ldr	r1, [sp, #12]
								tft.setColor(DARKGRAY, BROWN);
    65b4:	1c20      	adds	r0, r4, #0
					break;
					////NEOPIXELS
					case 4:
						tft.cursorX -= 4*2*6;
						for(int i = 0; i < 4; i++){
							if(neoPixelsIntensity <= i){
    65b6:	42a9      	cmp	r1, r5
    65b8:	dcf0      	bgt.n	659c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x5b0>
								tft.setColor(DARKGRAY, BROWN);
    65ba:	4971      	ldr	r1, [pc, #452]	; (6780 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x794>)
    65bc:	4a6a      	ldr	r2, [pc, #424]	; (6768 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x77c>)
    65be:	f003 fc3f 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
    65c2:	e7ef      	b.n	65a4 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x5b8>
				switch(currentItem){
					////VOLUME
					case 1:
						tft.cursorX -= 4*2*4;
						if(!sound.isMute() && sound.getVolume()) {
							tft.setColor(WHITE, BROWN);
    65c4:	1c20      	adds	r0, r4, #0
    65c6:	496f      	ldr	r1, [pc, #444]	; (6784 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x798>)
    65c8:	4a67      	ldr	r2, [pc, #412]	; (6768 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x77c>)
    65ca:	f003 fc39 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
							tft.print("\23\24");
    65ce:	1c20      	adds	r0, r4, #0
    65d0:	496f      	ldr	r1, [pc, #444]	; (6790 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x7a4>)
    65d2:	f009 facf 	bl	fb74 <_ZN5Print5printEPKc>
							if(sound.getVolume() > 6){
    65d6:	1c30      	adds	r0, r6, #0
    65d8:	f008 fc9a 	bl	ef10 <_ZN14Gamebuino_Meta5Sound9getVolumeEv>
    65dc:	2806      	cmp	r0, #6
    65de:	d904      	bls.n	65ea <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x5fe>
								tft.setColor(RED, BROWN);
    65e0:	1c20      	adds	r0, r4, #0
    65e2:	4963      	ldr	r1, [pc, #396]	; (6770 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x784>)
    65e4:	4a60      	ldr	r2, [pc, #384]	; (6768 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x77c>)
    65e6:	f003 fc2b 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
							}
							tft.print(sound.getVolume());
    65ea:	1c30      	adds	r0, r6, #0
    65ec:	f008 fc90 	bl	ef10 <_ZN14Gamebuino_Meta5Sound9getVolumeEv>
    65f0:	220a      	movs	r2, #10
    65f2:	1c01      	adds	r1, r0, #0
    65f4:	1c20      	adds	r0, r4, #0
    65f6:	f009 fb2c 	bl	fc52 <_ZN5Print5printEhi>
						}
					break;
					
				}
				//upper text
				tft.cursorX = xOffset;
    65fa:	4b59      	ldr	r3, [pc, #356]	; (6760 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x774>)
    65fc:	2228      	movs	r2, #40	; 0x28
    65fe:	801a      	strh	r2, [r3, #0]
				tft.cursorY = yOffset1;
    6600:	4b5e      	ldr	r3, [pc, #376]	; (677c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x790>)
    6602:	222a      	movs	r2, #42	; 0x2a
    6604:	801a      	strh	r2, [r3, #0]
				tft.setColor(BROWN, DARKGRAY);
    6606:	1c20      	adds	r0, r4, #0
    6608:	4a5d      	ldr	r2, [pc, #372]	; (6780 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x794>)
    660a:	4957      	ldr	r1, [pc, #348]	; (6768 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x77c>)
    660c:	f003 fc18 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
				tft.print(language.get(menuText[wrap(currentItem-1, numItems)], NUMBER_SYSTEM_LANGUAGES));
    6610:	9804      	ldr	r0, [sp, #16]
    6612:	2105      	movs	r1, #5
    6614:	3004      	adds	r0, #4
    6616:	f00a ff63 	bl	114e0 <__aeabi_idivmod>
    661a:	ab19      	add	r3, sp, #100	; 0x64
    661c:	0089      	lsls	r1, r1, #2
    661e:	58c8      	ldr	r0, [r1, r3]
    6620:	2103      	movs	r1, #3
    6622:	f006 f85b 	bl	c6dc <_ZN14Gamebuino_Meta8Language3getEPKNS_9MultiLangEh>
    6626:	1c01      	adds	r1, r0, #0
    6628:	1c20      	adds	r0, r4, #0
    662a:	f009 faa3 	bl	fb74 <_ZN5Print5printEPKc>
			}
			
			//updated nopixels
			neoPixels.show();
    662e:	9806      	ldr	r0, [sp, #24]
			
			changed = false;
    6630:	2500      	movs	r5, #0
				tft.setColor(BROWN, DARKGRAY);
				tft.print(language.get(menuText[wrap(currentItem-1, numItems)], NUMBER_SYSTEM_LANGUAGES));
			}
			
			//updated nopixels
			neoPixels.show();
    6632:	f000 ff7d 	bl	7530 <_ZN17Adafruit_NeoPixel4showEv>
			
			changed = false;
    6636:	9505      	str	r5, [sp, #20]
    6638:	e59d      	b.n	6176 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x18a>
							settings.set(SETTING_VOLUME_MUTE, 1);
						}
						changed = true;
					}
					if ((buttons.repeat(Button::right, 4) && (sound.getVolume() < 8))){
						sound.setVolume(sound.getVolume() + 1);
    663a:	1c30      	adds	r0, r6, #0
    663c:	f008 fc68 	bl	ef10 <_ZN14Gamebuino_Meta5Sound9getVolumeEv>
    6640:	1c41      	adds	r1, r0, #1
    6642:	b2c9      	uxtb	r1, r1
    6644:	1c30      	adds	r0, r6, #0
    6646:	f008 fc59 	bl	eefc <_ZN14Gamebuino_Meta5Sound9setVolumeEh>
						settings.set(SETTING_VOLUME, sound.getVolume());
    664a:	1c30      	adds	r0, r6, #0
    664c:	f008 fc60 	bl	ef10 <_ZN14Gamebuino_Meta5Sound9getVolumeEv>
    6650:	2584      	movs	r5, #132	; 0x84
    6652:	006d      	lsls	r5, r5, #1
    6654:	1c02      	adds	r2, r0, #0
    6656:	2100      	movs	r1, #0
    6658:	1978      	adds	r0, r7, r5
    665a:	f006 fbbd 	bl	cdd8 <_ZN14Gamebuino_Meta4Save3setEtl>
						sound.playTick();
						changed = true;
    665e:	2501      	movs	r5, #1
						changed = true;
					}
					if ((buttons.repeat(Button::right, 4) && (sound.getVolume() < 8))){
						sound.setVolume(sound.getVolume() + 1);
						settings.set(SETTING_VOLUME, sound.getVolume());
						sound.playTick();
    6660:	1c30      	adds	r0, r6, #0
    6662:	f008 fbf9 	bl	ee58 <_ZN14Gamebuino_Meta5Sound8playTickEv>
						changed = true;
    6666:	9505      	str	r5, [sp, #20]
    6668:	e691      	b.n	638e <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x3a2>
					}
					if (buttons.repeat(Button::left, 4) && sound.getVolume() && !sound.isMute()){
						sound.setVolume(sound.getVolume() - 1);
    666a:	1c30      	adds	r0, r6, #0
    666c:	f008 fc50 	bl	ef10 <_ZN14Gamebuino_Meta5Sound9getVolumeEv>
    6670:	1e41      	subs	r1, r0, #1
    6672:	b2c9      	uxtb	r1, r1
    6674:	1c30      	adds	r0, r6, #0
    6676:	f008 fc41 	bl	eefc <_ZN14Gamebuino_Meta5Sound9setVolumeEh>
						settings.set(SETTING_VOLUME, sound.getVolume());
    667a:	1c30      	adds	r0, r6, #0
    667c:	f008 fc48 	bl	ef10 <_ZN14Gamebuino_Meta5Sound9getVolumeEv>
    6680:	2184      	movs	r1, #132	; 0x84
    6682:	0049      	lsls	r1, r1, #1
    6684:	1c02      	adds	r2, r0, #0
    6686:	1878      	adds	r0, r7, r1
    6688:	1c29      	adds	r1, r5, #0
    668a:	f006 fba5 	bl	cdd8 <_ZN14Gamebuino_Meta4Save3setEtl>
						sound.playTick();
    668e:	1c30      	adds	r0, r6, #0
    6690:	f008 fbe2 	bl	ee58 <_ZN14Gamebuino_Meta5Sound8playTickEv>
    6694:	e72c      	b.n	64f0 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x504>
					}
				break;
				////RECORD SCREEN
				case 3:
					if (buttons.released(Button::a) || buttons.held(Button::a, 25)){
						tft.print(language._get(lang_homeMenu_READY));
    6696:	483f      	ldr	r0, [pc, #252]	; (6794 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x7a8>)
    6698:	f7ff fca2 	bl	5fe0 <_ZN14Gamebuino_Meta8Language4_getILh3EEEPKcRAT__KNS_9MultiLangE>
						char name[] = "REC/00000.GMV";
    669c:	ad15      	add	r5, sp, #84	; 0x54
					}
				break;
				////RECORD SCREEN
				case 3:
					if (buttons.released(Button::a) || buttons.held(Button::a, 25)){
						tft.print(language._get(lang_homeMenu_READY));
    669e:	1c01      	adds	r1, r0, #0
    66a0:	1c20      	adds	r0, r4, #0
    66a2:	f009 fa67 	bl	fb74 <_ZN5Print5printEPKc>
						char name[] = "REC/00000.GMV";
    66a6:	492d      	ldr	r1, [pc, #180]	; (675c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x770>)
    66a8:	220e      	movs	r2, #14
    66aa:	1c28      	adds	r0, r5, #0
    66ac:	f00a ff85 	bl	115ba <memcpy>
						bool success = homeMenuGetUniquePath(name, 4, 5);
    66b0:	2104      	movs	r1, #4
    66b2:	2205      	movs	r2, #5
    66b4:	1c28      	adds	r0, r5, #0
    66b6:	f7ff fb8f 	bl	5dd8 <_ZN14Gamebuino_Meta21homeMenuGetUniquePathEPchh>
						bool infinite = buttons.held(Button::a, 25);
    66ba:	2219      	movs	r2, #25
				////RECORD SCREEN
				case 3:
					if (buttons.released(Button::a) || buttons.held(Button::a, 25)){
						tft.print(language._get(lang_homeMenu_READY));
						char name[] = "REC/00000.GMV";
						bool success = homeMenuGetUniquePath(name, 4, 5);
    66bc:	9005      	str	r0, [sp, #20]
						bool infinite = buttons.held(Button::a, 25);
    66be:	2104      	movs	r1, #4
    66c0:	1c38      	adds	r0, r7, #0
    66c2:	f001 faed 	bl	7ca0 <_ZN14Gamebuino_Meta7Buttons4heldENS_6ButtonEt>
						if (success) {
    66c6:	9a05      	ldr	r2, [sp, #20]
				case 3:
					if (buttons.released(Button::a) || buttons.held(Button::a, 25)){
						tft.print(language._get(lang_homeMenu_READY));
						char name[] = "REC/00000.GMV";
						bool success = homeMenuGetUniquePath(name, 4, 5);
						bool infinite = buttons.held(Button::a, 25);
    66c8:	9013      	str	r0, [sp, #76]	; 0x4c
						if (success) {
    66ca:	2a00      	cmp	r2, #0
    66cc:	d01d      	beq.n	670a <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x71e>
							if (!infinite) {
    66ce:	9813      	ldr	r0, [sp, #76]	; 0x4c
    66d0:	2800      	cmp	r0, #0
    66d2:	d110      	bne.n	66f6 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x70a>
	return true;
}

template<uint8_t N>
void fileEndingGmvToBmp(char (&name)[N]) {
	name[N-4] = 'B';
    66d4:	2342      	movs	r3, #66	; 0x42
    66d6:	72ab      	strb	r3, [r5, #10]
	//name[N-3] = 'M'; // no need as GMV and BMP have same second letter
	name[N-2] = 'P';
    66d8:	2350      	movs	r3, #80	; 0x50
    66da:	732b      	strb	r3, [r5, #12]
						bool success = homeMenuGetUniquePath(name, 4, 5);
						bool infinite = buttons.held(Button::a, 25);
						if (success) {
							if (!infinite) {
								fileEndingGmvToBmp(name);
								framesDisplayRecording = (1000 / timePerFrame) * 3;
    66dc:	23c2      	movs	r3, #194	; 0xc2
    66de:	005b      	lsls	r3, r3, #1
    66e0:	20fa      	movs	r0, #250	; 0xfa
    66e2:	5cf9      	ldrb	r1, [r7, r3]
    66e4:	0080      	lsls	r0, r0, #2
    66e6:	f00a fea5 	bl	11434 <__aeabi_idiv>
    66ea:	2303      	movs	r3, #3
    66ec:	4358      	muls	r0, r3
    66ee:	23c9      	movs	r3, #201	; 0xc9
    66f0:	005b      	lsls	r3, r3, #1
    66f2:	52f8      	strh	r0, [r7, r3]
    66f4:	e004      	b.n	6700 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x714>
							} else {
								framesDisplayRecording = -1;
    66f6:	2201      	movs	r2, #1
    66f8:	23c9      	movs	r3, #201	; 0xc9
    66fa:	4252      	negs	r2, r2
    66fc:	005b      	lsls	r3, r3, #1
    66fe:	52fa      	strh	r2, [r7, r3]
							}
							success = display.startRecording(name);
    6700:	9808      	ldr	r0, [sp, #32]
    6702:	a915      	add	r1, sp, #84	; 0x54
    6704:	f004 fb55 	bl	adb2 <_ZN14Gamebuino_Meta5Image14startRecordingEPc>
    6708:	9005      	str	r0, [sp, #20]
						}
						// we temp. set inited to false so that delay() won't re-draw the screen
						inited = false;
    670a:	25b6      	movs	r5, #182	; 0xb6
						if (success) {
    670c:	9905      	ldr	r1, [sp, #20]
								framesDisplayRecording = -1;
							}
							success = display.startRecording(name);
						}
						// we temp. set inited to false so that delay() won't re-draw the screen
						inited = false;
    670e:	006d      	lsls	r5, r5, #1
    6710:	2300      	movs	r3, #0
    6712:	557b      	strb	r3, [r7, r5]
						if (success) {
    6714:	4299      	cmp	r1, r3
    6716:	d050      	beq.n	67ba <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x7ce>
							recording_screen = true;
    6718:	4b1f      	ldr	r3, [pc, #124]	; (6798 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x7ac>)
							if (infinite) {
    671a:	9d13      	ldr	r5, [sp, #76]	; 0x4c
							success = display.startRecording(name);
						}
						// we temp. set inited to false so that delay() won't re-draw the screen
						inited = false;
						if (success) {
							recording_screen = true;
    671c:	2201      	movs	r2, #1
    671e:	701a      	strb	r2, [r3, #0]
							if (infinite) {
    6720:	2d00      	cmp	r5, #0
    6722:	d13d      	bne.n	67a0 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x7b4>
								do {
									delay(10);
									buttons.update();
								} while (!buttons.released(Button::a));
							}
							delay(250);
    6724:	20fa      	movs	r0, #250	; 0xfa
    6726:	f008 fe33 	bl	f390 <delay>
							tft.cursorX = xOffset;
    672a:	4d0d      	ldr	r5, [pc, #52]	; (6760 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x774>)
    672c:	2328      	movs	r3, #40	; 0x28
							tft.print(language._get(lang_homeMenu_GO));
    672e:	481b      	ldr	r0, [pc, #108]	; (679c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x7b0>)
									delay(10);
									buttons.update();
								} while (!buttons.released(Button::a));
							}
							delay(250);
							tft.cursorX = xOffset;
    6730:	802b      	strh	r3, [r5, #0]
							tft.print(language._get(lang_homeMenu_GO));
    6732:	f7ff fc55 	bl	5fe0 <_ZN14Gamebuino_Meta8Language4_getILh3EEEPKcRAT__KNS_9MultiLangE>
    6736:	1c01      	adds	r1, r0, #0
    6738:	1c20      	adds	r0, r4, #0
    673a:	f009 fa1b 	bl	fb74 <_ZN5Print5printEPKc>
							delay(250);
    673e:	20fa      	movs	r0, #250	; 0xfa
    6740:	f008 fe26 	bl	f390 <delay>
							inited = true;
    6744:	2201      	movs	r2, #1
    6746:	23b6      	movs	r3, #182	; 0xb6
    6748:	4093      	lsls	r3, r2
    674a:	54fa      	strb	r2, [r7, r3]
							sound.stopEfxOnly();
    674c:	1c30      	adds	r0, r6, #0
    674e:	f008 fbcf 	bl	eef0 <_ZN14Gamebuino_Meta5Sound11stopEfxOnlyEv>
							HOME_MENU_RESTORE_STATE;
    6752:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    6754:	802c      	strh	r4, [r5, #0]
    6756:	e53b      	b.n	61d0 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x1e4>
    6758:	00014b0c 	.word	0x00014b0c
    675c:	00014d28 	.word	0x00014d28
    6760:	20000cdc 	.word	0x20000cdc
    6764:	00008668 	.word	0x00008668
    6768:	0000cc68 	.word	0x0000cc68
    676c:	00014fcc 	.word	0x00014fcc
    6770:	0000d8e4 	.word	0x0000d8e4
    6774:	00015014 	.word	0x00015014
    6778:	00014cec 	.word	0x00014cec
    677c:	20000cc4 	.word	0x20000cc4
    6780:	000072c7 	.word	0x000072c7
    6784:	0000ffff 	.word	0x0000ffff
    6788:	00014e14 	.word	0x00014e14
    678c:	00014d20 	.word	0x00014d20
    6790:	00014d22 	.word	0x00014d22
    6794:	00014adc 	.word	0x00014adc
    6798:	20000a38 	.word	0x20000a38
    679c:	00014f4c 	.word	0x00014f4c
						inited = false;
						if (success) {
							recording_screen = true;
							if (infinite) {
								do {
									delay(10);
    67a0:	200a      	movs	r0, #10
    67a2:	f008 fdf5 	bl	f390 <delay>
									buttons.update();
    67a6:	1c38      	adds	r0, r7, #0
    67a8:	f001 fa24 	bl	7bf4 <_ZN14Gamebuino_Meta7Buttons6updateEv>
								} while (!buttons.released(Button::a));
    67ac:	1c38      	adds	r0, r7, #0
    67ae:	2104      	movs	r1, #4
    67b0:	f001 fa6c 	bl	7c8c <_ZN14Gamebuino_Meta7Buttons8releasedENS_6ButtonE>
						// we temp. set inited to false so that delay() won't re-draw the screen
						inited = false;
						if (success) {
							recording_screen = true;
							if (infinite) {
								do {
    67b4:	2800      	cmp	r0, #0
    67b6:	d0f3      	beq.n	67a0 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x7b4>
    67b8:	e7b4      	b.n	6724 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x738>
							sound.stopEfxOnly();
							HOME_MENU_RESTORE_STATE;
							Hook_ExitHomeMenu();
							return;
						} else {
							tft.setColor(RED, BROWN);
    67ba:	491d      	ldr	r1, [pc, #116]	; (6830 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x844>)
    67bc:	1c20      	adds	r0, r4, #0
    67be:	4a1d      	ldr	r2, [pc, #116]	; (6834 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x848>)
    67c0:	f003 fb3e 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
							tft.cursorX = xOffset;
    67c4:	4b1c      	ldr	r3, [pc, #112]	; (6838 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x84c>)
    67c6:	2228      	movs	r2, #40	; 0x28
							tft.print(language._get(lang_homeMenu_ERROR));
    67c8:	481c      	ldr	r0, [pc, #112]	; (683c <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x850>)
							HOME_MENU_RESTORE_STATE;
							Hook_ExitHomeMenu();
							return;
						} else {
							tft.setColor(RED, BROWN);
							tft.cursorX = xOffset;
    67ca:	801a      	strh	r2, [r3, #0]
							tft.print(language._get(lang_homeMenu_ERROR));
    67cc:	f7ff fc08 	bl	5fe0 <_ZN14Gamebuino_Meta8Language4_getILh3EEEPKcRAT__KNS_9MultiLangE>
    67d0:	1c01      	adds	r1, r0, #0
    67d2:	1c20      	adds	r0, r4, #0
    67d4:	f009 f9ce 	bl	fb74 <_ZN5Print5printEPKc>
							delay(250);
    67d8:	20fa      	movs	r0, #250	; 0xfa
    67da:	f008 fdd9 	bl	f390 <delay>
							changed = true;
						}
						inited = true;
    67de:	2301      	movs	r3, #1
    67e0:	557b      	strb	r3, [r7, r5]
    67e2:	e685      	b.n	64f0 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x504>
					}
				break;
				//// NEOPIXELS
				case 4:
					if (buttons.released(Button::a) || buttons.repeat(Button::right, 4)){
						neoPixelsIntensity ++;
    67e4:	9b03      	ldr	r3, [sp, #12]
						if(neoPixelsIntensity > 4){
							neoPixelsIntensity = 0;
    67e6:	2504      	movs	r5, #4
					}
				break;
				//// NEOPIXELS
				case 4:
					if (buttons.released(Button::a) || buttons.repeat(Button::right, 4)){
						neoPixelsIntensity ++;
    67e8:	3301      	adds	r3, #1
    67ea:	b2db      	uxtb	r3, r3
    67ec:	9303      	str	r3, [sp, #12]
						if(neoPixelsIntensity > 4){
							neoPixelsIntensity = 0;
    67ee:	9803      	ldr	r0, [sp, #12]
    67f0:	2300      	movs	r3, #0
    67f2:	4285      	cmp	r5, r0
    67f4:	415b      	adcs	r3, r3
    67f6:	425b      	negs	r3, r3
    67f8:	4018      	ands	r0, r3
						}
						changed = true;
						neoPixels.setBrightness(neoPixelsIntensities[neoPixelsIntensity]);
    67fa:	4b11      	ldr	r3, [pc, #68]	; (6840 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x854>)
				//// NEOPIXELS
				case 4:
					if (buttons.released(Button::a) || buttons.repeat(Button::right, 4)){
						neoPixelsIntensity ++;
						if(neoPixelsIntensity > 4){
							neoPixelsIntensity = 0;
    67fc:	9003      	str	r0, [sp, #12]
						}
						changed = true;
						neoPixels.setBrightness(neoPixelsIntensities[neoPixelsIntensity]);
    67fe:	5c19      	ldrb	r1, [r3, r0]
    6800:	9806      	ldr	r0, [sp, #24]
    6802:	f000 ff61 	bl	76c8 <_ZN17Adafruit_NeoPixel13setBrightnessEh>
						settings.set(SETTING_NEOPIXELS_INTENSITY, neoPixelsIntensity);
    6806:	2184      	movs	r1, #132	; 0x84
    6808:	0049      	lsls	r1, r1, #1
    680a:	1878      	adds	r0, r7, r1
    680c:	9a03      	ldr	r2, [sp, #12]
    680e:	1c29      	adds	r1, r5, #0
					if (buttons.released(Button::a) || buttons.repeat(Button::right, 4)){
						neoPixelsIntensity ++;
						if(neoPixelsIntensity > 4){
							neoPixelsIntensity = 0;
						}
						changed = true;
    6810:	2501      	movs	r5, #1
    6812:	f006 fae1 	bl	cdd8 <_ZN14Gamebuino_Meta4Save3setEtl>
    6816:	9505      	str	r5, [sp, #20]
    6818:	e636      	b.n	6488 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x49c>
							if(sound.getVolume() > 6){
								tft.setColor(RED, BROWN);
							}
							tft.print(sound.getVolume());
						} else {
							tft.setColor(DARKGRAY, BROWN);
    681a:	1c20      	adds	r0, r4, #0
    681c:	4909      	ldr	r1, [pc, #36]	; (6844 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x858>)
    681e:	4a05      	ldr	r2, [pc, #20]	; (6834 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x848>)
    6820:	f003 fb0e 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
							tft.print("\23x");
    6824:	1c20      	adds	r0, r4, #0
    6826:	4908      	ldr	r1, [pc, #32]	; (6848 <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x85c>)
    6828:	f009 f9a4 	bl	fb74 <_ZN5Print5printEPKc>
    682c:	e6e5      	b.n	65fa <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv+0x60e>
    682e:	46c0      	nop			; (mov r8, r8)
    6830:	0000d8e4 	.word	0x0000d8e4
    6834:	0000cc68 	.word	0x0000cc68
    6838:	20000cdc 	.word	0x20000cdc
    683c:	00015014 	.word	0x00015014
    6840:	00014cec 	.word	0x00014cec
    6844:	000072c7 	.word	0x000072c7
    6848:	00014d25 	.word	0x00014d25

0000684c <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv>:
	display.textWrap = hm_save_textWrap; \
	display.font = hm_save_font; \
	display.fontWidth = hm_save_fontWidth; \
	display.fontHeight = hm_save_fontHeight;

void Gamebuino::checkHomeMenu() {
    684c:	b5f0      	push	{r4, r5, r6, r7, lr}
	//get back to game list when "HOME is held
	if (buttons.held(Button::d, 25)){
    684e:	2107      	movs	r1, #7
	display.textWrap = hm_save_textWrap; \
	display.font = hm_save_font; \
	display.fontWidth = hm_save_fontWidth; \
	display.fontHeight = hm_save_fontHeight;

void Gamebuino::checkHomeMenu() {
    6850:	b08b      	sub	sp, #44	; 0x2c
	//get back to game list when "HOME is held
	if (buttons.held(Button::d, 25)){
    6852:	2219      	movs	r2, #25
	display.textWrap = hm_save_textWrap; \
	display.font = hm_save_font; \
	display.fontWidth = hm_save_fontWidth; \
	display.fontHeight = hm_save_fontHeight;

void Gamebuino::checkHomeMenu() {
    6854:	1c04      	adds	r4, r0, #0
	//get back to game list when "HOME is held
	if (buttons.held(Button::d, 25)){
    6856:	f001 fa23 	bl	7ca0 <_ZN14Gamebuino_Meta7Buttons4heldENS_6ButtonEt>
    685a:	2800      	cmp	r0, #0
    685c:	d002      	beq.n	6864 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x18>
		changeGame();
    685e:	1c20      	adds	r0, r4, #0
    6860:	f7ff fbb2 	bl	5fc8 <_ZN14Gamebuino_Meta9Gamebuino10changeGameEv>
	}
	if (framesDisplayRecording != -1) {
    6864:	25c9      	movs	r5, #201	; 0xc9
    6866:	006d      	lsls	r5, r5, #1
    6868:	5b63      	ldrh	r3, [r4, r5]
    686a:	b21a      	sxth	r2, r3
    686c:	3201      	adds	r2, #1
    686e:	d001      	beq.n	6874 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x28>
		framesDisplayRecording--;
    6870:	3b01      	subs	r3, #1
    6872:	5363      	strh	r3, [r4, r5]
	}
	if (buttons.released(Button::d) || (framesDisplayRecording == 0 && recording_screen)) {
    6874:	1c20      	adds	r0, r4, #0
    6876:	2107      	movs	r1, #7
    6878:	f001 fa08 	bl	7c8c <_ZN14Gamebuino_Meta7Buttons8releasedENS_6ButtonE>
    687c:	2800      	cmp	r0, #0
    687e:	d106      	bne.n	688e <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x42>
    6880:	5f63      	ldrsh	r3, [r4, r5]
    6882:	2b00      	cmp	r3, #0
    6884:	d16e      	bne.n	6964 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x118>
    6886:	4b38      	ldr	r3, [pc, #224]	; (6968 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x11c>)
    6888:	781b      	ldrb	r3, [r3, #0]
    688a:	2b00      	cmp	r3, #0
    688c:	d06a      	beq.n	6964 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x118>
		if (recording_screen) {
    688e:	4a36      	ldr	r2, [pc, #216]	; (6968 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x11c>)
    6890:	7813      	ldrb	r3, [r2, #0]
    6892:	2b00      	cmp	r3, #0
    6894:	d063      	beq.n	695e <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x112>
			// stop the recording
			HOME_MENU_SAVE_STATE;
    6896:	4b35      	ldr	r3, [pc, #212]	; (696c <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x120>)
    6898:	4a35      	ldr	r2, [pc, #212]	; (6970 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x124>)
    689a:	881b      	ldrh	r3, [r3, #0]
			sound.startEfxOnly();
    689c:	1c25      	adds	r5, r4, #0
		framesDisplayRecording--;
	}
	if (buttons.released(Button::d) || (framesDisplayRecording == 0 && recording_screen)) {
		if (recording_screen) {
			// stop the recording
			HOME_MENU_SAVE_STATE;
    689e:	9300      	str	r3, [sp, #0]
    68a0:	4b34      	ldr	r3, [pc, #208]	; (6974 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x128>)
    68a2:	8812      	ldrh	r2, [r2, #0]
    68a4:	881b      	ldrh	r3, [r3, #0]
			sound.startEfxOnly();
    68a6:	3538      	adds	r5, #56	; 0x38
		framesDisplayRecording--;
	}
	if (buttons.released(Button::d) || (framesDisplayRecording == 0 && recording_screen)) {
		if (recording_screen) {
			// stop the recording
			HOME_MENU_SAVE_STATE;
    68a8:	9302      	str	r3, [sp, #8]
    68aa:	4b33      	ldr	r3, [pc, #204]	; (6978 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x12c>)
			sound.startEfxOnly();
    68ac:	1c28      	adds	r0, r5, #0
		framesDisplayRecording--;
	}
	if (buttons.released(Button::d) || (framesDisplayRecording == 0 && recording_screen)) {
		if (recording_screen) {
			// stop the recording
			HOME_MENU_SAVE_STATE;
    68ae:	881b      	ldrh	r3, [r3, #0]
    68b0:	9201      	str	r2, [sp, #4]
    68b2:	9303      	str	r3, [sp, #12]
    68b4:	4b31      	ldr	r3, [pc, #196]	; (697c <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x130>)
			sound.startEfxOnly();
			bool isMute = sound.isMute();
			sound.mute();
			display.setFont(font3x5);
    68b6:	1c26      	adds	r6, r4, #0
		framesDisplayRecording--;
	}
	if (buttons.released(Button::d) || (framesDisplayRecording == 0 && recording_screen)) {
		if (recording_screen) {
			// stop the recording
			HOME_MENU_SAVE_STATE;
    68b8:	781b      	ldrb	r3, [r3, #0]
			sound.startEfxOnly();
			bool isMute = sound.isMute();
			sound.mute();
			display.setFont(font3x5);
    68ba:	3610      	adds	r6, #16
		framesDisplayRecording--;
	}
	if (buttons.released(Button::d) || (framesDisplayRecording == 0 && recording_screen)) {
		if (recording_screen) {
			// stop the recording
			HOME_MENU_SAVE_STATE;
    68bc:	9304      	str	r3, [sp, #16]
    68be:	4b30      	ldr	r3, [pc, #192]	; (6980 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x134>)
    68c0:	781b      	ldrb	r3, [r3, #0]
    68c2:	9305      	str	r3, [sp, #20]
    68c4:	4b2f      	ldr	r3, [pc, #188]	; (6984 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x138>)
    68c6:	681b      	ldr	r3, [r3, #0]
    68c8:	9306      	str	r3, [sp, #24]
    68ca:	4b2f      	ldr	r3, [pc, #188]	; (6988 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x13c>)
    68cc:	781b      	ldrb	r3, [r3, #0]
    68ce:	9307      	str	r3, [sp, #28]
    68d0:	4b2e      	ldr	r3, [pc, #184]	; (698c <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x140>)
    68d2:	781b      	ldrb	r3, [r3, #0]
    68d4:	9308      	str	r3, [sp, #32]
			sound.startEfxOnly();
    68d6:	f008 fb05 	bl	eee4 <_ZN14Gamebuino_Meta5Sound12startEfxOnlyEv>
			bool isMute = sound.isMute();
    68da:	1c28      	adds	r0, r5, #0
    68dc:	f008 fafc 	bl	eed8 <_ZN14Gamebuino_Meta5Sound6isMuteEv>
    68e0:	9009      	str	r0, [sp, #36]	; 0x24
			sound.mute();
    68e2:	1c28      	adds	r0, r5, #0
    68e4:	f008 faec 	bl	eec0 <_ZN14Gamebuino_Meta5Sound4muteEv>
			display.setFont(font3x5);
    68e8:	4929      	ldr	r1, [pc, #164]	; (6990 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x144>)
    68ea:	1c30      	adds	r0, r6, #0
    68ec:	f003 fadc 	bl	9ea8 <_ZN14Gamebuino_Meta8Graphics7setFontEPKh>
			neoPixels.clear();
    68f0:	22b8      	movs	r2, #184	; 0xb8
    68f2:	0052      	lsls	r2, r2, #1
    68f4:	18a7      	adds	r7, r4, r2
    68f6:	1c38      	adds	r0, r7, #0
    68f8:	f000 ff12 	bl	7720 <_ZN17Adafruit_NeoPixel5clearEv>
			neoPixels.show();
    68fc:	1c38      	adds	r0, r7, #0
    68fe:	f000 fe17 	bl	7530 <_ZN17Adafruit_NeoPixel4showEv>
			display.stopRecording(true);
    6902:	1c30      	adds	r0, r6, #0
    6904:	2101      	movs	r1, #1
    6906:	f004 fa5f 	bl	adc8 <_ZN14Gamebuino_Meta5Image13stopRecordingEb>
			recording_screen = false;
    690a:	4a17      	ldr	r2, [pc, #92]	; (6968 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x11c>)
    690c:	2300      	movs	r3, #0
			//refresh screen to erase log messages
			updateDisplay();
    690e:	1c20      	adds	r0, r4, #0
			sound.mute();
			display.setFont(font3x5);
			neoPixels.clear();
			neoPixels.show();
			display.stopRecording(true);
			recording_screen = false;
    6910:	7013      	strb	r3, [r2, #0]
			//refresh screen to erase log messages
			updateDisplay();
    6912:	f7ff fa2d 	bl	5d70 <_ZN14Gamebuino_Meta9Gamebuino13updateDisplayEv>
			if (!isMute) {
    6916:	9b09      	ldr	r3, [sp, #36]	; 0x24
    6918:	4f14      	ldr	r7, [pc, #80]	; (696c <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x120>)
    691a:	4e16      	ldr	r6, [pc, #88]	; (6974 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x128>)
    691c:	2b00      	cmp	r3, #0
    691e:	d102      	bne.n	6926 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0xda>
				sound.unmute();
    6920:	1c28      	adds	r0, r5, #0
    6922:	f008 fad3 	bl	eecc <_ZN14Gamebuino_Meta5Sound6unmuteEv>
			}
			sound.stopEfxOnly();
    6926:	1c28      	adds	r0, r5, #0
    6928:	f008 fae2 	bl	eef0 <_ZN14Gamebuino_Meta5Sound11stopEfxOnlyEv>
			HOME_MENU_RESTORE_STATE;
    692c:	9a00      	ldr	r2, [sp, #0]
    692e:	4b10      	ldr	r3, [pc, #64]	; (6970 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x124>)
    6930:	803a      	strh	r2, [r7, #0]
    6932:	9a01      	ldr	r2, [sp, #4]
    6934:	801a      	strh	r2, [r3, #0]
    6936:	9b02      	ldr	r3, [sp, #8]
    6938:	9a03      	ldr	r2, [sp, #12]
    693a:	8033      	strh	r3, [r6, #0]
    693c:	4b0e      	ldr	r3, [pc, #56]	; (6978 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x12c>)
    693e:	801a      	strh	r2, [r3, #0]
    6940:	4b0e      	ldr	r3, [pc, #56]	; (697c <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x130>)
    6942:	9a04      	ldr	r2, [sp, #16]
    6944:	701a      	strb	r2, [r3, #0]
    6946:	4b0e      	ldr	r3, [pc, #56]	; (6980 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x134>)
    6948:	9a05      	ldr	r2, [sp, #20]
    694a:	701a      	strb	r2, [r3, #0]
    694c:	4b0d      	ldr	r3, [pc, #52]	; (6984 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x138>)
    694e:	9a06      	ldr	r2, [sp, #24]
    6950:	601a      	str	r2, [r3, #0]
    6952:	4b0d      	ldr	r3, [pc, #52]	; (6988 <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x13c>)
    6954:	9a07      	ldr	r2, [sp, #28]
    6956:	701a      	strb	r2, [r3, #0]
    6958:	4b0c      	ldr	r3, [pc, #48]	; (698c <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv+0x140>)
    695a:	9a08      	ldr	r2, [sp, #32]
    695c:	701a      	strb	r2, [r3, #0]
		}
		homeMenu();
    695e:	1c20      	adds	r0, r4, #0
    6960:	f7ff fb44 	bl	5fec <_ZN14Gamebuino_Meta9Gamebuino8homeMenuEv>
	}
}
    6964:	b00b      	add	sp, #44	; 0x2c
    6966:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6968:	20000a38 	.word	0x20000a38
    696c:	20000cdc 	.word	0x20000cdc
    6970:	20000cc4 	.word	0x20000cc4
    6974:	20000cd8 	.word	0x20000cd8
    6978:	20000cc2 	.word	0x20000cc2
    697c:	20000cd4 	.word	0x20000cd4
    6980:	20000077 	.word	0x20000077
    6984:	20000cc8 	.word	0x20000cc8
    6988:	20000cc0 	.word	0x20000cc0
    698c:	20000cd5 	.word	0x20000cd5
    6990:	00015110 	.word	0x00015110

00006994 <_ZN14Gamebuino_Meta9Gamebuino6updateEv>:
	display.init(ts_backup_width, ts_backup_height, ts_backup_colorMode);
}

bool recording_screen = false;

bool Gamebuino::update() {
    6994:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (((nextFrameMillis - millis()) > timePerFrame) && frameEndMicros) { //if time to render a new frame is reached and the frame end has ran once
    6996:	26c4      	movs	r6, #196	; 0xc4
	display.init(ts_backup_width, ts_backup_height, ts_backup_colorMode);
}

bool recording_screen = false;

bool Gamebuino::update() {
    6998:	b08b      	sub	sp, #44	; 0x2c
	if (((nextFrameMillis - millis()) > timePerFrame) && frameEndMicros) { //if time to render a new frame is reached and the frame end has ran once
    699a:	0076      	lsls	r6, r6, #1
	display.init(ts_backup_width, ts_backup_height, ts_backup_colorMode);
}

bool recording_screen = false;

bool Gamebuino::update() {
    699c:	1c04      	adds	r4, r0, #0
	if (((nextFrameMillis - millis()) > timePerFrame) && frameEndMicros) { //if time to render a new frame is reached and the frame end has ran once
    699e:	5985      	ldr	r5, [r0, r6]
    69a0:	f008 fcbe 	bl	f320 <millis>
    69a4:	27c2      	movs	r7, #194	; 0xc2
    69a6:	007f      	lsls	r7, r7, #1
    69a8:	5de3      	ldrb	r3, [r4, r7]
    69aa:	1a28      	subs	r0, r5, r0
    69ac:	1c25      	adds	r5, r4, #0
    69ae:	35fc      	adds	r5, #252	; 0xfc
    69b0:	4298      	cmp	r0, r3
    69b2:	d902      	bls.n	69ba <_ZN14Gamebuino_Meta9Gamebuino6updateEv+0x26>
    69b4:	6ee8      	ldr	r0, [r5, #108]	; 0x6c
    69b6:	2800      	cmp	r0, #0
    69b8:	d17e      	bne.n	6ab8 <_ZN14Gamebuino_Meta9Gamebuino6updateEv+0x124>
		buttons.update();

		return true;

	}
	if (frameEndMicros) {
    69ba:	6eee      	ldr	r6, [r5, #108]	; 0x6c
		return false;
    69bc:	2000      	movs	r0, #0
		buttons.update();

		return true;

	}
	if (frameEndMicros) {
    69be:	4286      	cmp	r6, r0
    69c0:	d000      	beq.n	69c4 <_ZN14Gamebuino_Meta9Gamebuino6updateEv+0x30>
    69c2:	e08a      	b.n	6ada <_ZN14Gamebuino_Meta9Gamebuino6updateEv+0x146>
		return false;
	}
	// ok, here is the first time after a frame, so we'll better check stuff correctly
	
	//Home menu
	checkHomeMenu();
    69c4:	1c20      	adds	r0, r4, #0
    69c6:	f7ff ff41 	bl	684c <_ZN14Gamebuino_Meta9Gamebuino13checkHomeMenuEv>
	
	//draw and update popups
	updatePopup();
    69ca:	1c20      	adds	r0, r4, #0
    69cc:	f7ff fa86 	bl	5edc <_ZN14Gamebuino_Meta9Gamebuino11updatePopupEv>
	
	Graphics_SD::update(); // update screen recordings
    69d0:	f005 fe68 	bl	c6a4 <_ZN14Gamebuino_Meta11Graphics_SD6updateEv>
	
	sound.update(); // update sound stuff once per frame
    69d4:	1c20      	adds	r0, r4, #0
    69d6:	3038      	adds	r0, #56	; 0x38
    69d8:	f008 fa46 	bl	ee68 <_ZN14Gamebuino_Meta5Sound6updateEv>
	
	
	//send buffer to the screen
	updateDisplay();
    69dc:	1c20      	adds	r0, r4, #0
    69de:	f7ff f9c7 	bl	5d70 <_ZN14Gamebuino_Meta9Gamebuino13updateDisplayEv>
	
	//neoPixels update
	uint8_t px_height = lights.height();
    69e2:	1c21      	adds	r1, r4, #0
    69e4:	3190      	adds	r1, #144	; 0x90
    69e6:	1c08      	adds	r0, r1, #0
    69e8:	9103      	str	r1, [sp, #12]
    69ea:	f003 fb1d 	bl	a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>
    69ee:	b2c0      	uxtb	r0, r0
    69f0:	9005      	str	r0, [sp, #20]
	uint8_t px_width = lights.width();
    69f2:	9803      	ldr	r0, [sp, #12]
    69f4:	f003 fb08 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
	const uint8_t px_map[] = {
		7, 0,
		6, 1,
		5, 2,
		4, 3,
	};
    69f8:	4939      	ldr	r1, [pc, #228]	; (6ae0 <_ZN14Gamebuino_Meta9Gamebuino6updateEv+0x14c>)
	//send buffer to the screen
	updateDisplay();
	
	//neoPixels update
	uint8_t px_height = lights.height();
	uint8_t px_width = lights.width();
    69fa:	b2c0      	uxtb	r0, r0
    69fc:	9004      	str	r0, [sp, #16]
	const uint8_t px_map[] = {
		7, 0,
		6, 1,
		5, 2,
		4, 3,
	};
    69fe:	3114      	adds	r1, #20
    6a00:	a808      	add	r0, sp, #32
    6a02:	2208      	movs	r2, #8
    6a04:	f00a fdd9 	bl	115ba <memcpy>
    6a08:	af08      	add	r7, sp, #32
	for (uint8_t y = 0; y < px_height; y++) {
    6a0a:	9905      	ldr	r1, [sp, #20]
    6a0c:	428e      	cmp	r6, r1
    6a0e:	d227      	bcs.n	6a60 <_ZN14Gamebuino_Meta9Gamebuino6updateEv+0xcc>
    6a10:	2500      	movs	r5, #0
		for (uint8_t x = 0; x < px_width; x++) {
    6a12:	9804      	ldr	r0, [sp, #16]
    6a14:	b2eb      	uxtb	r3, r5
    6a16:	4283      	cmp	r3, r0
    6a18:	d21e      	bcs.n	6a58 <_ZN14Gamebuino_Meta9Gamebuino6updateEv+0xc4>
			RGB888 c = rgb565Torgb888(lights.getPixel(x, y));
    6a1a:	b229      	sxth	r1, r5
    6a1c:	b232      	sxth	r2, r6
    6a1e:	9803      	ldr	r0, [sp, #12]
    6a20:	f004 f9ee 	bl	ae00 <_ZN14Gamebuino_Meta5Image8getPixelEss>
    6a24:	f005 fec5 	bl	c7b2 <_ZN14Gamebuino_Meta14rgb565Torgb888Et>
    6a28:	0201      	lsls	r1, r0, #8
    6a2a:	0e09      	lsrs	r1, r1, #24
    6a2c:	0403      	lsls	r3, r0, #16
    6a2e:	aa07      	add	r2, sp, #28
    6a30:	468c      	mov	ip, r1
    6a32:	0e1b      	lsrs	r3, r3, #24
    6a34:	7010      	strb	r0, [r2, #0]
    6a36:	7053      	strb	r3, [r2, #1]
    6a38:	7091      	strb	r1, [r2, #2]
			// intensity is scaled directly via neoPixels.setBrightness
			neoPixels.setPixelColor(px_map[y*px_width + x], c.r, c.g, c.b);
    6a3a:	b2db      	uxtb	r3, r3
    6a3c:	b2c2      	uxtb	r2, r0
    6a3e:	4660      	mov	r0, ip
    6a40:	9302      	str	r3, [sp, #8]
    6a42:	b2c3      	uxtb	r3, r0
    6a44:	5d79      	ldrb	r1, [r7, r5]
    6a46:	9300      	str	r3, [sp, #0]
    6a48:	23b8      	movs	r3, #184	; 0xb8
    6a4a:	005b      	lsls	r3, r3, #1
    6a4c:	18e0      	adds	r0, r4, r3
    6a4e:	9b02      	ldr	r3, [sp, #8]
    6a50:	f000 fe15 	bl	767e <_ZN17Adafruit_NeoPixel13setPixelColorEthhh>
    6a54:	3501      	adds	r5, #1
    6a56:	e7dc      	b.n	6a12 <_ZN14Gamebuino_Meta9Gamebuino6updateEv+0x7e>
		7, 0,
		6, 1,
		5, 2,
		4, 3,
	};
	for (uint8_t y = 0; y < px_height; y++) {
    6a58:	3601      	adds	r6, #1
    6a5a:	b2f6      	uxtb	r6, r6
    6a5c:	183f      	adds	r7, r7, r0
    6a5e:	e7d4      	b.n	6a0a <_ZN14Gamebuino_Meta9Gamebuino6updateEv+0x76>
			// intensity is scaled directly via neoPixels.setBrightness
			neoPixels.setPixelColor(px_map[y*px_width + x], c.r, c.g, c.b);
		}
	}
	//show a red blinking pixel on recording screen
	if (recording_screen) {
    6a60:	4b20      	ldr	r3, [pc, #128]	; (6ae4 <_ZN14Gamebuino_Meta9Gamebuino6updateEv+0x150>)
    6a62:	1c25      	adds	r5, r4, #0
    6a64:	781b      	ldrb	r3, [r3, #0]
    6a66:	3471      	adds	r4, #113	; 0x71
    6a68:	35fc      	adds	r5, #252	; 0xfc
    6a6a:	34ff      	adds	r4, #255	; 0xff
    6a6c:	2b00      	cmp	r3, #0
    6a6e:	d015      	beq.n	6a9c <_ZN14Gamebuino_Meta9Gamebuino6updateEv+0x108>
		if ((frameCount % 10) < 5) {
    6a70:	6e28      	ldr	r0, [r5, #96]	; 0x60
    6a72:	210a      	movs	r1, #10
    6a74:	f00a fcd4 	bl	11420 <__aeabi_uidivmod>
    6a78:	ab08      	add	r3, sp, #32
    6a7a:	2904      	cmp	r1, #4
    6a7c:	d807      	bhi.n	6a8e <_ZN14Gamebuino_Meta9Gamebuino6updateEv+0xfa>
			neoPixels.setPixelColor(px_map[0], 0xFF, 0, 0);
    6a7e:	7819      	ldrb	r1, [r3, #0]
    6a80:	2300      	movs	r3, #0
    6a82:	9300      	str	r3, [sp, #0]
    6a84:	1c20      	adds	r0, r4, #0
    6a86:	22ff      	movs	r2, #255	; 0xff
    6a88:	f000 fdf9 	bl	767e <_ZN17Adafruit_NeoPixel13setPixelColorEthhh>
    6a8c:	e006      	b.n	6a9c <_ZN14Gamebuino_Meta9Gamebuino6updateEv+0x108>
		} else {
			neoPixels.setPixelColor(px_map[0], 0, 0, 0);
    6a8e:	7819      	ldrb	r1, [r3, #0]
    6a90:	2300      	movs	r3, #0
    6a92:	9300      	str	r3, [sp, #0]
    6a94:	1c20      	adds	r0, r4, #0
    6a96:	1c1a      	adds	r2, r3, #0
    6a98:	f000 fdf1 	bl	767e <_ZN17Adafruit_NeoPixel13setPixelColorEthhh>
		}
	}
	neoPixels.show();
    6a9c:	1c20      	adds	r0, r4, #0
    6a9e:	f000 fd47 	bl	7530 <_ZN17Adafruit_NeoPixel4showEv>
	neoPixels.clear();
    6aa2:	1c20      	adds	r0, r4, #0
    6aa4:	f000 fe3c 	bl	7720 <_ZN17Adafruit_NeoPixel5clearEv>

	frameEndMicros = micros(); //measure the frame's end time
    6aa8:	f008 fc40 	bl	f32c <micros>
	frameDurationMicros = frameEndMicros - frameStartMicros;
    6aac:	6eaa      	ldr	r2, [r5, #104]	; 0x68
		}
	}
	neoPixels.show();
	neoPixels.clear();

	frameEndMicros = micros(); //measure the frame's end time
    6aae:	66e8      	str	r0, [r5, #108]	; 0x6c
	frameDurationMicros = frameEndMicros - frameStartMicros;
    6ab0:	1a80      	subs	r0, r0, r2
    6ab2:	6668      	str	r0, [r5, #100]	; 0x64
    6ab4:	2000      	movs	r0, #0
    6ab6:	e010      	b.n	6ada <_ZN14Gamebuino_Meta9Gamebuino6updateEv+0x146>

bool recording_screen = false;

bool Gamebuino::update() {
	if (((nextFrameMillis - millis()) > timePerFrame) && frameEndMicros) { //if time to render a new frame is reached and the frame end has ran once
		nextFrameMillis = millis() + timePerFrame;
    6ab8:	f008 fc32 	bl	f320 <millis>
    6abc:	5de3      	ldrb	r3, [r4, r7]
    6abe:	18c0      	adds	r0, r0, r3
		frameCount++;
    6ac0:	6e2b      	ldr	r3, [r5, #96]	; 0x60

bool recording_screen = false;

bool Gamebuino::update() {
	if (((nextFrameMillis - millis()) > timePerFrame) && frameEndMicros) { //if time to render a new frame is reached and the frame end has ran once
		nextFrameMillis = millis() + timePerFrame;
    6ac2:	51a0      	str	r0, [r4, r6]
		frameCount++;
    6ac4:	3301      	adds	r3, #1
    6ac6:	662b      	str	r3, [r5, #96]	; 0x60

		frameEndMicros = 0;
    6ac8:	2300      	movs	r3, #0
    6aca:	66eb      	str	r3, [r5, #108]	; 0x6c
		frameStartMicros = micros();
    6acc:	f008 fc2e 	bl	f32c <micros>
    6ad0:	66a8      	str	r0, [r5, #104]	; 0x68

		buttons.update();
    6ad2:	1c20      	adds	r0, r4, #0
    6ad4:	f001 f88e 	bl	7bf4 <_ZN14Gamebuino_Meta7Buttons6updateEv>

		return true;
    6ad8:	2001      	movs	r0, #1
	neoPixels.clear();

	frameEndMicros = micros(); //measure the frame's end time
	frameDurationMicros = frameEndMicros - frameStartMicros;
	return false;
}
    6ada:	b00b      	add	sp, #44	; 0x2c
    6adc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6ade:	46c0      	nop			; (mov r8, r8)
    6ae0:	00014a70 	.word	0x00014a70
    6ae4:	20000a38 	.word	0x20000a38

00006ae8 <yield>:
void noTone(uint32_t outputPin) {
	gb.sound.stop(Gamebuino_Meta::tone_identifier);
	Gamebuino_Meta::tone_identifier = -1;
}

void yield() {
    6ae8:	b508      	push	{r3, lr}
	if (gb.inited && (gb.frameEndMicros || gb.frameStartMicros)) {
    6aea:	4808      	ldr	r0, [pc, #32]	; (6b0c <yield+0x24>)
    6aec:	23b6      	movs	r3, #182	; 0xb6
    6aee:	005b      	lsls	r3, r3, #1
    6af0:	5cc3      	ldrb	r3, [r0, r3]
    6af2:	2b00      	cmp	r3, #0
    6af4:	d009      	beq.n	6b0a <yield+0x22>
    6af6:	1c03      	adds	r3, r0, #0
    6af8:	33fc      	adds	r3, #252	; 0xfc
    6afa:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    6afc:	2a00      	cmp	r2, #0
    6afe:	d102      	bne.n	6b06 <yield+0x1e>
    6b00:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    6b02:	2b00      	cmp	r3, #0
    6b04:	d001      	beq.n	6b0a <yield+0x22>
		gb.update();
    6b06:	f7ff ff45 	bl	6994 <_ZN14Gamebuino_Meta9Gamebuino6updateEv>
	}
}
    6b0a:	bd08      	pop	{r3, pc}
    6b0c:	20000a3c 	.word	0x20000a3c

00006b10 <_GLOBAL__sub_I_SD>:
    6b10:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 */
class FatVolume {
 public:
  /** Create an instance of FatVolume
   */
  FatVolume() : m_fatType(0) {}
    6b12:	4b30      	ldr	r3, [pc, #192]	; (6bd4 <_GLOBAL__sub_I_SD+0xc4>)
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
    6b14:	4a30      	ldr	r2, [pc, #192]	; (6bd8 <_GLOBAL__sub_I_SD+0xc8>)
    6b16:	2500      	movs	r5, #0
    6b18:	549d      	strb	r5, [r3, r2]
    6b1a:	4a30      	ldr	r2, [pc, #192]	; (6bdc <_GLOBAL__sub_I_SD+0xcc>)
#else  // SD_SPI_CONFIGURATION < 3
  typedef SdSpiBase m_spi_t;
#endif  // SD_SPI_CONFIGURATION < 3
  /** Construct an instance of SdSpiCard. */
  SdSpiCard() : m_selected(false),
                m_errorCode(SD_CARD_ERROR_INIT_NOT_CALLED), m_type(0) {}
    6b1c:	2119      	movs	r1, #25
    6b1e:	549d      	strb	r5, [r3, r2]
    6b20:	4a2f      	ldr	r2, [pc, #188]	; (6be0 <_GLOBAL__sub_I_SD+0xd0>)
#define NEOPIX_PIN	(38u)
#define BAT_PIN		(A5)

#define wrap(i, imax) ((imax+i)%(imax))

class Gamebuino {
    6b22:	4c30      	ldr	r4, [pc, #192]	; (6be4 <_GLOBAL__sub_I_SD+0xd4>)
    6b24:	549d      	strb	r5, [r3, r2]
    6b26:	4a30      	ldr	r2, [pc, #192]	; (6be8 <_GLOBAL__sub_I_SD+0xd8>)
    6b28:	2601      	movs	r6, #1
    6b2a:	5499      	strb	r1, [r3, r2]
    6b2c:	4a2f      	ldr	r2, [pc, #188]	; (6bec <_GLOBAL__sub_I_SD+0xdc>)
    6b2e:	1c20      	adds	r0, r4, #0
    6b30:	549d      	strb	r5, [r3, r2]
//==============================================================================
/**
 * \class SdFat
 * \brief Main file system class for %SdFat library.
 */
class SdFat : public SdFatBase {
    6b32:	4a2f      	ldr	r2, [pc, #188]	; (6bf0 <_GLOBAL__sub_I_SD+0xe0>)
    6b34:	71dd      	strb	r5, [r3, #7]
    6b36:	601a      	str	r2, [r3, #0]
    6b38:	2150      	movs	r1, #80	; 0x50
    6b3a:	1c2b      	adds	r3, r5, #0
    6b3c:	9600      	str	r6, [sp, #0]
    6b3e:	9601      	str	r6, [sp, #4]
    6b40:	2240      	movs	r2, #64	; 0x40
    6b42:	3010      	adds	r0, #16
    6b44:	f004 fa9e 	bl	b084 <_ZN14Gamebuino_Meta5ImageC1EttNS_9ColorModeEth>
    6b48:	1c20      	adds	r0, r4, #0
    6b4a:	1c2b      	adds	r3, r5, #0
    6b4c:	211e      	movs	r1, #30
    6b4e:	221f      	movs	r2, #31
    6b50:	303c      	adds	r0, #60	; 0x3c
    6b52:	f001 f8d3 	bl	7cfc <_ZN14Gamebuino_Meta14Display_ST7735C1Eaaa>
    6b56:	1c20      	adds	r0, r4, #0
    6b58:	1c2b      	adds	r3, r5, #0
    6b5a:	2102      	movs	r1, #2
    6b5c:	2204      	movs	r2, #4
    6b5e:	9600      	str	r6, [sp, #0]
    6b60:	9601      	str	r6, [sp, #4]
    6b62:	3090      	adds	r0, #144	; 0x90
    6b64:	f004 fa8e 	bl	b084 <_ZN14Gamebuino_Meta5ImageC1EttNS_9ColorModeEth>
//	SaveDefault(const uint8_t i, const uint8_t type, const void* ptr, const uint8_t length): i(i), type(type), val{.ptr=ptr}, length(length){};
};

class Save {
public:
	Save(){};
    6b68:	1c20      	adds	r0, r4, #0
    6b6a:	30bc      	adds	r0, #188	; 0xbc
    6b6c:	f7ff f8e2 	bl	5d34 <_ZN4FileC1Ev>
    6b70:	1c23      	adds	r3, r4, #0
    6b72:	33f0      	adds	r3, #240	; 0xf0
    6b74:	701d      	strb	r5, [r3, #0]
    6b76:	1c23      	adds	r3, r4, #0
    6b78:	33f1      	adds	r3, #241	; 0xf1
    6b7a:	701d      	strb	r5, [r3, #0]
    6b7c:	1c27      	adds	r7, r4, #0
    6b7e:	2386      	movs	r3, #134	; 0x86
    6b80:	37fc      	adds	r7, #252	; 0xfc
    6b82:	005b      	lsls	r3, r3, #1
    6b84:	607d      	str	r5, [r7, #4]
    6b86:	18e0      	adds	r0, r4, r3
    6b88:	f7ff f8d4 	bl	5d34 <_ZN4FileC1Ev>
    6b8c:	23a0      	movs	r3, #160	; 0xa0
    6b8e:	40b3      	lsls	r3, r6
    6b90:	54e5      	strb	r5, [r4, r3]
    6b92:	2342      	movs	r3, #66	; 0x42
    6b94:	33ff      	adds	r3, #255	; 0xff
    6b96:	54e5      	strb	r5, [r4, r3]
    6b98:	23b6      	movs	r3, #182	; 0xb6
    6b9a:	40b3      	lsls	r3, r6
    6b9c:	54e6      	strb	r6, [r4, r3]
    6b9e:	23b8      	movs	r3, #184	; 0xb8
    6ba0:	005b      	lsls	r3, r3, #1
    6ba2:	657d      	str	r5, [r7, #84]	; 0x54
    6ba4:	18e0      	adds	r0, r4, r3
    6ba6:	2108      	movs	r1, #8
    6ba8:	2226      	movs	r2, #38	; 0x26
    6baa:	2352      	movs	r3, #82	; 0x52
    6bac:	f000 fd50 	bl	7650 <_ZN17Adafruit_NeoPixelC1Etht>
    6bb0:	23c9      	movs	r3, #201	; 0xc9
    6bb2:	4272      	negs	r2, r6
    6bb4:	40b3      	lsls	r3, r6
    6bb6:	52e2      	strh	r2, [r4, r3]
    6bb8:	23ca      	movs	r3, #202	; 0xca
    6bba:	005b      	lsls	r3, r3, #1
    6bbc:	18e0      	adds	r0, r4, r3
    6bbe:	490d      	ldr	r1, [pc, #52]	; (6bf4 <_GLOBAL__sub_I_SD+0xe4>)
    6bc0:	220a      	movs	r2, #10
    6bc2:	f00a fcfa 	bl	115ba <memcpy>
int8_t tone_identifier = -1;

} // namespace Gamebuino_Meta

#ifndef GAMEBUINO_COMPAT_MODE
Gamebuino gb;
    6bc6:	1c20      	adds	r0, r4, #0
    6bc8:	490b      	ldr	r1, [pc, #44]	; (6bf8 <_GLOBAL__sub_I_SD+0xe8>)
    6bca:	4a0c      	ldr	r2, [pc, #48]	; (6bfc <_GLOBAL__sub_I_SD+0xec>)
    6bcc:	f00a fc94 	bl	114f8 <__aeabi_atexit>

void yield() {
	if (gb.inited && (gb.frameEndMicros || gb.frameStartMicros)) {
		gb.update();
	}
}
    6bd0:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    6bd2:	46c0      	nop			; (mov r8, r8)
    6bd4:	200005c8 	.word	0x200005c8
    6bd8:	0000043c 	.word	0x0000043c
    6bdc:	0000043d 	.word	0x0000043d
    6be0:	00000464 	.word	0x00000464
    6be4:	20000a3c 	.word	0x20000a3c
    6be8:	00000466 	.word	0x00000466
    6bec:	00000469 	.word	0x00000469
    6bf0:	00014a60 	.word	0x00014a60
    6bf4:	00014d36 	.word	0x00014d36
    6bf8:	00006c65 	.word	0x00006c65
    6bfc:	20000000 	.word	0x20000000

00006c00 <_ZN14Gamebuino_Meta9Gamebuino8drawLogoEaa>:
	}
	pickRandomSeed();
	display.clear();
}

void Gamebuino::drawLogo(int8_t x, int8_t y) {
    6c00:	b570      	push	{r4, r5, r6, lr}
	Image logo(78, 10, ColorMode::index);
    6c02:	2301      	movs	r3, #1
	}
	pickRandomSeed();
	display.clear();
}

void Gamebuino::drawLogo(int8_t x, int8_t y) {
    6c04:	b08c      	sub	sp, #48	; 0x30
	Image logo(78, 10, ColorMode::index);
    6c06:	9300      	str	r3, [sp, #0]
    6c08:	9301      	str	r3, [sp, #4]
	}
	pickRandomSeed();
	display.clear();
}

void Gamebuino::drawLogo(int8_t x, int8_t y) {
    6c0a:	1c06      	adds	r6, r0, #0
    6c0c:	1c0d      	adds	r5, r1, #0
    6c0e:	1c14      	adds	r4, r2, #0
	Image logo(78, 10, ColorMode::index);
    6c10:	214e      	movs	r1, #78	; 0x4e
    6c12:	220a      	movs	r2, #10
    6c14:	a802      	add	r0, sp, #8
    6c16:	f004 fa35 	bl	b084 <_ZN14Gamebuino_Meta5ImageC1EttNS_9ColorModeEth>
	logo.clear();
    6c1a:	a802      	add	r0, sp, #8
    6c1c:	f003 f9ee 	bl	9ffc <_ZN14Gamebuino_Meta8Graphics5clearEv>
	logo.drawBitmap(-2, 0, gamebuinoLogo);
    6c20:	2102      	movs	r1, #2
    6c22:	a802      	add	r0, sp, #8
    6c24:	4249      	negs	r1, r1
    6c26:	2200      	movs	r2, #0
    6c28:	4b0c      	ldr	r3, [pc, #48]	; (6c5c <_ZN14Gamebuino_Meta9Gamebuino8drawLogoEaa+0x5c>)
    6c2a:	f003 fdc9 	bl	a7c0 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh>
	display.drawImage(x*display.fontSize, y*display.fontSize, logo, 78*display.fontSize, 10*display.fontSize);
    6c2e:	4b0c      	ldr	r3, [pc, #48]	; (6c60 <_ZN14Gamebuino_Meta9Gamebuino8drawLogoEaa+0x60>)
    6c30:	1c22      	adds	r2, r4, #0
    6c32:	781b      	ldrb	r3, [r3, #0]
    6c34:	244e      	movs	r4, #78	; 0x4e
    6c36:	435c      	muls	r4, r3
    6c38:	1c29      	adds	r1, r5, #0
    6c3a:	9400      	str	r4, [sp, #0]
    6c3c:	240a      	movs	r4, #10
    6c3e:	4359      	muls	r1, r3
    6c40:	435a      	muls	r2, r3
    6c42:	4363      	muls	r3, r4
    6c44:	1c30      	adds	r0, r6, #0
    6c46:	9301      	str	r3, [sp, #4]
    6c48:	3010      	adds	r0, #16
    6c4a:	ab02      	add	r3, sp, #8
    6c4c:	f004 fb04 	bl	b258 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_ss>
    6c50:	a802      	add	r0, sp, #8
    6c52:	f003 fae5 	bl	a220 <_ZN14Gamebuino_Meta5ImageD1Ev>
}
    6c56:	b00c      	add	sp, #48	; 0x30
    6c58:	bd70      	pop	{r4, r5, r6, pc}
    6c5a:	46c0      	nop			; (mov r8, r8)
    6c5c:	00014f64 	.word	0x00014f64
    6c60:	20000cd4 	.word	0x20000cd4

00006c64 <_ZN14Gamebuino_Meta9GamebuinoD1Ev>:
    6c64:	23b8      	movs	r3, #184	; 0xb8
    6c66:	005b      	lsls	r3, r3, #1
    6c68:	b510      	push	{r4, lr}
    6c6a:	1c04      	adds	r4, r0, #0
    6c6c:	18c0      	adds	r0, r0, r3
    6c6e:	f000 fbf9 	bl	7464 <_ZN17Adafruit_NeoPixelD1Ev>
    6c72:	1c20      	adds	r0, r4, #0
    6c74:	3090      	adds	r0, #144	; 0x90
    6c76:	f003 fad3 	bl	a220 <_ZN14Gamebuino_Meta5ImageD1Ev>
    6c7a:	1c20      	adds	r0, r4, #0
    6c7c:	303c      	adds	r0, #60	; 0x3c
    6c7e:	f7ff f821 	bl	5cc4 <_ZN14Gamebuino_Meta14Display_ST7735D1Ev>
    6c82:	1c20      	adds	r0, r4, #0
    6c84:	3010      	adds	r0, #16
    6c86:	f003 facb 	bl	a220 <_ZN14Gamebuino_Meta5ImageD1Ev>
    6c8a:	1c20      	adds	r0, r4, #0
    6c8c:	bd10      	pop	{r4, pc}
	...

00006c90 <_ZN14Gamebuino_Meta9Gamebuino11startScreenEv>:

void Gamebuino::startScreen(){
    6c90:	b570      	push	{r4, r5, r6, lr}
    6c92:	b096      	sub	sp, #88	; 0x58
	Image startLights(startLightsData, 24);
    6c94:	2301      	movs	r3, #1
	logo.clear();
	logo.drawBitmap(-2, 0, gamebuinoLogo);
	display.drawImage(x*display.fontSize, y*display.fontSize, logo, 78*display.fontSize, 10*display.fontSize);
}

void Gamebuino::startScreen(){
    6c96:	1c04      	adds	r4, r0, #0
	Image startLights(startLightsData, 24);
    6c98:	4924      	ldr	r1, [pc, #144]	; (6d2c <_ZN14Gamebuino_Meta9Gamebuino11startScreenEv+0x9c>)
    6c9a:	2218      	movs	r2, #24
    6c9c:	a802      	add	r0, sp, #8
    6c9e:	f004 f9b1 	bl	b004 <_ZN14Gamebuino_Meta5ImageC1EPKtth>
	int8_t i = 24;
	update();
    6ca2:	1c20      	adds	r0, r4, #0
    6ca4:	f7ff fe76 	bl	6994 <_ZN14Gamebuino_Meta9Gamebuino6updateEv>
	sound.play(startSound);
    6ca8:	1c20      	adds	r0, r4, #0
    6caa:	2200      	movs	r2, #0
    6cac:	3038      	adds	r0, #56	; 0x38
    6cae:	4920      	ldr	r1, [pc, #128]	; (6d30 <_ZN14Gamebuino_Meta9Gamebuino11startScreenEv+0xa0>)
    6cb0:	f008 f8a0 	bl	edf4 <_ZN14Gamebuino_Meta5Sound4playEPKtb>
	display.fontSize = SYSTEM_DEFAULT_FONT_SIZE;
    6cb4:	4b1f      	ldr	r3, [pc, #124]	; (6d34 <_ZN14Gamebuino_Meta9Gamebuino11startScreenEv+0xa4>)
    6cb6:	2201      	movs	r2, #1
    6cb8:	701a      	strb	r2, [r3, #0]
	display.drawImage(x*display.fontSize, y*display.fontSize, logo, 78*display.fontSize, 10*display.fontSize);
}

void Gamebuino::startScreen(){
	Image startLights(startLightsData, 24);
	int8_t i = 24;
    6cba:	2518      	movs	r5, #24
	update();
	sound.play(startSound);
	display.fontSize = SYSTEM_DEFAULT_FONT_SIZE;
	while(i){
		if(update()){
    6cbc:	1c20      	adds	r0, r4, #0
    6cbe:	f7ff fe69 	bl	6994 <_ZN14Gamebuino_Meta9Gamebuino6updateEv>
    6cc2:	2800      	cmp	r0, #0
    6cc4:	d0fa      	beq.n	6cbc <_ZN14Gamebuino_Meta9Gamebuino11startScreenEv+0x2c>
			i--;
			display.clear();
    6cc6:	1c20      	adds	r0, r4, #0
    6cc8:	3d01      	subs	r5, #1
    6cca:	3010      	adds	r0, #16
    6ccc:	f003 f996 	bl	9ffc <_ZN14Gamebuino_Meta8Graphics5clearEv>
    6cd0:	b2ee      	uxtb	r6, r5
			Image logo(78, 10, ColorMode::index);
    6cd2:	2301      	movs	r3, #1
    6cd4:	9300      	str	r3, [sp, #0]
    6cd6:	9301      	str	r3, [sp, #4]
    6cd8:	220a      	movs	r2, #10
    6cda:	b2f5      	uxtb	r5, r6
    6cdc:	a80c      	add	r0, sp, #48	; 0x30
    6cde:	214e      	movs	r1, #78	; 0x4e
    6ce0:	f004 f9d0 	bl	b084 <_ZN14Gamebuino_Meta5ImageC1EttNS_9ColorModeEth>
			drawLogo(2, min(0, i-10));
    6ce4:	b26b      	sxtb	r3, r5
    6ce6:	2200      	movs	r2, #0
    6ce8:	2b0a      	cmp	r3, #10
    6cea:	dc01      	bgt.n	6cf0 <_ZN14Gamebuino_Meta9Gamebuino11startScreenEv+0x60>
    6cec:	3e0a      	subs	r6, #10
    6cee:	b2f2      	uxtb	r2, r6
    6cf0:	b252      	sxtb	r2, r2
    6cf2:	1c20      	adds	r0, r4, #0
    6cf4:	2102      	movs	r1, #2
			lights.drawImage(0, 0, startLights);
    6cf6:	1c26      	adds	r6, r4, #0
	while(i){
		if(update()){
			i--;
			display.clear();
			Image logo(78, 10, ColorMode::index);
			drawLogo(2, min(0, i-10));
    6cf8:	f7ff ff82 	bl	6c00 <_ZN14Gamebuino_Meta9Gamebuino8drawLogoEaa>
			lights.drawImage(0, 0, startLights);
    6cfc:	3690      	adds	r6, #144	; 0x90
    6cfe:	2100      	movs	r1, #0
    6d00:	1c30      	adds	r0, r6, #0
    6d02:	1c0a      	adds	r2, r1, #0
    6d04:	ab02      	add	r3, sp, #8
    6d06:	f004 f9ff 	bl	b108 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_>
    6d0a:	a80c      	add	r0, sp, #48	; 0x30
    6d0c:	f003 fa88 	bl	a220 <_ZN14Gamebuino_Meta5ImageD1Ev>
	Image startLights(startLightsData, 24);
	int8_t i = 24;
	update();
	sound.play(startSound);
	display.fontSize = SYSTEM_DEFAULT_FONT_SIZE;
	while(i){
    6d10:	2d00      	cmp	r5, #0
    6d12:	d1d3      	bne.n	6cbc <_ZN14Gamebuino_Meta9Gamebuino11startScreenEv+0x2c>
			Image logo(78, 10, ColorMode::index);
			drawLogo(2, min(0, i-10));
			lights.drawImage(0, 0, startLights);
		}
	}
	lights.clear();
    6d14:	1c30      	adds	r0, r6, #0
    6d16:	f003 f971 	bl	9ffc <_ZN14Gamebuino_Meta8Graphics5clearEv>
	update();
    6d1a:	1c20      	adds	r0, r4, #0
    6d1c:	f7ff fe3a 	bl	6994 <_ZN14Gamebuino_Meta9Gamebuino6updateEv>
    6d20:	a802      	add	r0, sp, #8
    6d22:	f003 fa7d 	bl	a220 <_ZN14Gamebuino_Meta5ImageD1Ev>
}
    6d26:	b016      	add	sp, #88	; 0x58
    6d28:	bd70      	pop	{r4, r5, r6, pc}
    6d2a:	46c0      	nop			; (mov r8, r8)
    6d2c:	00014b36 	.word	0x00014b36
    6d30:	00014b24 	.word	0x00014b24
    6d34:	20000cd4 	.word	0x20000cd4

00006d38 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv>:

void Gamebuino::titleScreen() {
    6d38:	b5f0      	push	{r4, r5, r6, r7, lr}
	ColorMode ts_backup_colorMode = display.colorMode;
    6d3a:	7e85      	ldrb	r5, [r0, #26]
	}
	lights.clear();
	update();
}

void Gamebuino::titleScreen() {
    6d3c:	b0bb      	sub	sp, #236	; 0xec
	ColorMode ts_backup_colorMode = display.colorMode;
    6d3e:	950d      	str	r5, [sp, #52]	; 0x34
	uint16_t ts_backup_width = display._width;
    6d40:	8c06      	ldrh	r6, [r0, #32]
	uint16_t ts_backup_height = display._height;
	display.fontSize = SYSTEM_DEFAULT_FONT_SIZE;
	char filename[17] = "TITLESCREEN.BMP";
    6d42:	49c6      	ldr	r1, [pc, #792]	; (705c <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x324>)
	update();
}

void Gamebuino::titleScreen() {
	ColorMode ts_backup_colorMode = display.colorMode;
	uint16_t ts_backup_width = display._width;
    6d44:	960a      	str	r6, [sp, #40]	; 0x28
	uint16_t ts_backup_height = display._height;
    6d46:	8c45      	ldrh	r5, [r0, #34]	; 0x22
	display.fontSize = SYSTEM_DEFAULT_FONT_SIZE;
    6d48:	4bc5      	ldr	r3, [pc, #788]	; (7060 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x328>)
	char filename[17] = "TITLESCREEN.BMP";
    6d4a:	ac0e      	add	r4, sp, #56	; 0x38
}

void Gamebuino::titleScreen() {
	ColorMode ts_backup_colorMode = display.colorMode;
	uint16_t ts_backup_width = display._width;
	uint16_t ts_backup_height = display._height;
    6d4c:	950b      	str	r5, [sp, #44]	; 0x2c
	display.fontSize = SYSTEM_DEFAULT_FONT_SIZE;
	char filename[17] = "TITLESCREEN.BMP";
    6d4e:	311c      	adds	r1, #28

void Gamebuino::titleScreen() {
	ColorMode ts_backup_colorMode = display.colorMode;
	uint16_t ts_backup_width = display._width;
	uint16_t ts_backup_height = display._height;
	display.fontSize = SYSTEM_DEFAULT_FONT_SIZE;
    6d50:	2501      	movs	r5, #1
	char filename[17] = "TITLESCREEN.BMP";
    6d52:	2210      	movs	r2, #16
	}
	lights.clear();
	update();
}

void Gamebuino::titleScreen() {
    6d54:	1c07      	adds	r7, r0, #0
	ColorMode ts_backup_colorMode = display.colorMode;
	uint16_t ts_backup_width = display._width;
	uint16_t ts_backup_height = display._height;
	display.fontSize = SYSTEM_DEFAULT_FONT_SIZE;
	char filename[17] = "TITLESCREEN.BMP";
    6d56:	1c20      	adds	r0, r4, #0

void Gamebuino::titleScreen() {
	ColorMode ts_backup_colorMode = display.colorMode;
	uint16_t ts_backup_width = display._width;
	uint16_t ts_backup_height = display._height;
	display.fontSize = SYSTEM_DEFAULT_FONT_SIZE;
    6d58:	701d      	strb	r5, [r3, #0]
	char filename[17] = "TITLESCREEN.BMP";
    6d5a:	f00a fc2e 	bl	115ba <memcpy>
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return vwd()->exists(path);
    6d5e:	4ec1      	ldr	r6, [pc, #772]	; (7064 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x32c>)
    6d60:	48c1      	ldr	r0, [pc, #772]	; (7068 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x330>)
    6d62:	2300      	movs	r3, #0
    6d64:	1836      	adds	r6, r6, r0
    6d66:	1c30      	adds	r0, r6, #0
    6d68:	1c21      	adds	r1, r4, #0
    6d6a:	7423      	strb	r3, [r4, #16]
    6d6c:	f7fe ffc7 	bl	5cfe <_ZN7FatFile6existsEPKc>
	
	bool titleScreenImageExists = SD.exists(filename);
	bool displayName = !titleScreenImageExists;
    6d70:	1c03      	adds	r3, r0, #0
    6d72:	406b      	eors	r3, r5
    6d74:	b2db      	uxtb	r3, r3
    6d76:	9002      	str	r0, [sp, #8]
    6d78:	9304      	str	r3, [sp, #16]
	if (!titleScreenImageExists && SD.exists("REC")) {
    6d7a:	2800      	cmp	r0, #0
    6d7c:	d136      	bne.n	6dec <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0xb4>
    6d7e:	1c30      	adds	r0, r6, #0
    6d80:	49ba      	ldr	r1, [pc, #744]	; (706c <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x334>)
    6d82:	f7fe ffbc 	bl	5cfe <_ZN7FatFile6existsEPKc>
    6d86:	2800      	cmp	r0, #0
    6d88:	d039      	beq.n	6dfe <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0xc6>
		strcpy(filename, "REC/");
    6d8a:	49b9      	ldr	r1, [pc, #740]	; (7070 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x338>)
    6d8c:	1c20      	adds	r0, r4, #0
    6d8e:	f00a fd3d 	bl	1180c <strcpy>
   * \param[in] path location of file to be opened.
   * \param[in] mode open mode flags.
   * \return a File object.
   */
  File open(const char *path, uint8_t mode = FILE_READ) {
    File tmpFile;
    6d92:	a813      	add	r0, sp, #76	; 0x4c
    6d94:	f7fe ffce 	bl	5d34 <_ZN4FileC1Ev>
    tmpFile.open(vwd(), path, mode);
    6d98:	a817      	add	r0, sp, #92	; 0x5c
    6d9a:	1c31      	adds	r1, r6, #0
    6d9c:	1c22      	adds	r2, r4, #0
    6d9e:	1c2b      	adds	r3, r5, #0
    6da0:	f006 fb31 	bl	d406 <_ZN7FatFile4openEPS_PKch>
		const uint8_t f_offset = 4;
		File dir_walk = SD.open(filename);
		File entry;
    6da4:	a820      	add	r0, sp, #128	; 0x80
    6da6:	f7fe ffc5 	bl	5d34 <_ZN4FileC1Ev>
   *
   * \param[in] mode open mode flags.
   * \return a File object.
   */
  File openNextFile(uint8_t mode = O_READ) {
    File tmpFile;
    6daa:	a82d      	add	r0, sp, #180	; 0xb4
    6dac:	f7fe ffc2 	bl	5d34 <_ZN4FileC1Ev>
    tmpFile.openNext(this, mode);
    6db0:	a917      	add	r1, sp, #92	; 0x5c
    6db2:	2201      	movs	r2, #1
    6db4:	a831      	add	r0, sp, #196	; 0xc4
    6db6:	f006 fa96 	bl	d2e6 <_ZN7FatFile8openNextEPS_h>
		while (entry = dir_walk.openNextFile()) {
    6dba:	a820      	add	r0, sp, #128	; 0x80
    6dbc:	a92d      	add	r1, sp, #180	; 0xb4
    6dbe:	f7fe ffc5 	bl	5d4c <_ZN4FileaSEOS_>
  /** The parenthesis operator.
    *
    * \return true if a file is open.
    */
  operator bool() {
    return isOpen();
    6dc2:	7c03      	ldrb	r3, [r0, #16]
    6dc4:	2b00      	cmp	r3, #0
    6dc6:	d01a      	beq.n	6dfe <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0xc6>
			if (!entry.isFile()) {
    6dc8:	a824      	add	r0, sp, #144	; 0x90
  bool isDir() const {
    return m_attr & FILE_ATTR_DIR;
  }
  /** \return True if this is a normal file else false. */
  bool isFile() const {
    return m_attr & FILE_ATTR_FILE;
    6dca:	7803      	ldrb	r3, [r0, #0]
    6dcc:	071a      	lsls	r2, r3, #28
    6dce:	d5ec      	bpl.n	6daa <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x72>
				continue;
			}
			entry.getName(filename + f_offset, sizeof(filename) - f_offset);
    6dd0:	a90f      	add	r1, sp, #60	; 0x3c
    6dd2:	220d      	movs	r2, #13
    6dd4:	f006 fd9c 	bl	d910 <_ZN7FatFile7getNameEPcj>
			if (!strstr(filename, ".GMV") && !strstr(filename, ".gmv")) {
    6dd8:	a80e      	add	r0, sp, #56	; 0x38
    6dda:	49a6      	ldr	r1, [pc, #664]	; (7074 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x33c>)
    6ddc:	f00a fd25 	bl	1182a <strstr>
    6de0:	2800      	cmp	r0, #0
    6de2:	d100      	bne.n	6de6 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0xae>
    6de4:	e12f      	b.n	7046 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x30e>
				continue;
			}
			titleScreenImageExists = true;
			displayName = true;
    6de6:	2501      	movs	r5, #1
    6de8:	9504      	str	r5, [sp, #16]
			}
			entry.getName(filename + f_offset, sizeof(filename) - f_offset);
			if (!strstr(filename, ".GMV") && !strstr(filename, ".gmv")) {
				continue;
			}
			titleScreenImageExists = true;
    6dea:	9502      	str	r5, [sp, #8]
			displayName = true;
			break;
		}
	}
	if (titleScreenImageExists) {
		display.init(ts_backup_width, ts_backup_height, filename);
    6dec:	2301      	movs	r3, #1
    6dee:	1c38      	adds	r0, r7, #0
    6df0:	9300      	str	r3, [sp, #0]
    6df2:	3010      	adds	r0, #16
    6df4:	990a      	ldr	r1, [sp, #40]	; 0x28
    6df6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    6df8:	ab0e      	add	r3, sp, #56	; 0x38
    6dfa:	f003 ff6b 	bl	acd4 <_ZN14Gamebuino_Meta5Image4initEttPch>
	}
	
	bool first = true;
	bool reInitDisplay = false;
	
	const char* msg = language._get(lang_titlescreen_a_start);
    6dfe:	489e      	ldr	r0, [pc, #632]	; (7078 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x340>)
    6e00:	f7ff f8ee 	bl	5fe0 <_ZN14Gamebuino_Meta8Language4_getILh3EEEPKcRAT__KNS_9MultiLangE>
    6e04:	900c      	str	r0, [sp, #48]	; 0x30
	uint8_t w = display.fontWidth*strlen(msg)*display.fontSize;
    6e06:	f00a fd09 	bl	1181c <strlen>
    6e0a:	4b95      	ldr	r3, [pc, #596]	; (7060 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x328>)
    6e0c:	4a9b      	ldr	r2, [pc, #620]	; (707c <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x344>)
    6e0e:	781b      	ldrb	r3, [r3, #0]
    6e10:	7812      	ldrb	r2, [r2, #0]
	uint8_t h = display.fontHeight*display.fontSize;
	uint8_t x = (display.width() - w) / 2;
    6e12:	1c3c      	adds	r4, r7, #0
	
	bool first = true;
	bool reInitDisplay = false;
	
	const char* msg = language._get(lang_titlescreen_a_start);
	uint8_t w = display.fontWidth*strlen(msg)*display.fontSize;
    6e14:	435a      	muls	r2, r3
    6e16:	4350      	muls	r0, r2
	uint8_t h = display.fontHeight*display.fontSize;
    6e18:	4a99      	ldr	r2, [pc, #612]	; (7080 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x348>)
	
	bool first = true;
	bool reInitDisplay = false;
	
	const char* msg = language._get(lang_titlescreen_a_start);
	uint8_t w = display.fontWidth*strlen(msg)*display.fontSize;
    6e1a:	b2c0      	uxtb	r0, r0
	uint8_t h = display.fontHeight*display.fontSize;
    6e1c:	7812      	ldrb	r2, [r2, #0]
	uint8_t x = (display.width() - w) / 2;
    6e1e:	3410      	adds	r4, #16
	bool first = true;
	bool reInitDisplay = false;
	
	const char* msg = language._get(lang_titlescreen_a_start);
	uint8_t w = display.fontWidth*strlen(msg)*display.fontSize;
	uint8_t h = display.fontHeight*display.fontSize;
    6e20:	4353      	muls	r3, r2
	
	bool first = true;
	bool reInitDisplay = false;
	
	const char* msg = language._get(lang_titlescreen_a_start);
	uint8_t w = display.fontWidth*strlen(msg)*display.fontSize;
    6e22:	9003      	str	r0, [sp, #12]
	uint8_t h = display.fontHeight*display.fontSize;
    6e24:	b2db      	uxtb	r3, r3
	uint8_t x = (display.width() - w) / 2;
    6e26:	1c20      	adds	r0, r4, #0
	bool first = true;
	bool reInitDisplay = false;
	
	const char* msg = language._get(lang_titlescreen_a_start);
	uint8_t w = display.fontWidth*strlen(msg)*display.fontSize;
	uint8_t h = display.fontHeight*display.fontSize;
    6e28:	9305      	str	r3, [sp, #20]
	uint8_t x = (display.width() - w) / 2;
    6e2a:	f003 f8ed 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
    6e2e:	9d03      	ldr	r5, [sp, #12]
    6e30:	1b40      	subs	r0, r0, r5
    6e32:	0fc3      	lsrs	r3, r0, #31
    6e34:	1818      	adds	r0, r3, r0
    6e36:	1040      	asrs	r0, r0, #1
    6e38:	b2c0      	uxtb	r0, r0
    6e3a:	9006      	str	r0, [sp, #24]
	uint8_t y = (display.height() / 5) * 3 + h;
    6e3c:	1c20      	adds	r0, r4, #0
    6e3e:	f003 f8f3 	bl	a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>
    6e42:	2105      	movs	r1, #5
    6e44:	f00a faf6 	bl	11434 <__aeabi_idiv>
    6e48:	2303      	movs	r3, #3
    6e4a:	4358      	muls	r0, r3
    6e4c:	9e05      	ldr	r6, [sp, #20]
	if (titleScreenImageExists) {
		display.init(ts_backup_width, ts_backup_height, filename);
	}
	
	bool first = true;
	bool reInitDisplay = false;
    6e4e:	2500      	movs	r5, #0
	
	const char* msg = language._get(lang_titlescreen_a_start);
	uint8_t w = display.fontWidth*strlen(msg)*display.fontSize;
	uint8_t h = display.fontHeight*display.fontSize;
	uint8_t x = (display.width() - w) / 2;
	uint8_t y = (display.height() / 5) * 3 + h;
    6e50:	1830      	adds	r0, r6, r0
    6e52:	b2c0      	uxtb	r0, r0
	}
	if (titleScreenImageExists) {
		display.init(ts_backup_width, ts_backup_height, filename);
	}
	
	bool first = true;
    6e54:	2601      	movs	r6, #1
	
	const char* msg = language._get(lang_titlescreen_a_start);
	uint8_t w = display.fontWidth*strlen(msg)*display.fontSize;
	uint8_t h = display.fontHeight*display.fontSize;
	uint8_t x = (display.width() - w) / 2;
	uint8_t y = (display.height() / 5) * 3 + h;
    6e56:	9007      	str	r0, [sp, #28]
	if (titleScreenImageExists) {
		display.init(ts_backup_width, ts_backup_height, filename);
	}
	
	bool first = true;
	bool reInitDisplay = false;
    6e58:	9509      	str	r5, [sp, #36]	; 0x24
	}
	if (titleScreenImageExists) {
		display.init(ts_backup_width, ts_backup_height, filename);
	}
	
	bool first = true;
    6e5a:	9608      	str	r6, [sp, #32]
	uint8_t w = display.fontWidth*strlen(msg)*display.fontSize;
	uint8_t h = display.fontHeight*display.fontSize;
	uint8_t x = (display.width() - w) / 2;
	uint8_t y = (display.height() / 5) * 3 + h;
	while(1) {
		if(!update()) {
    6e5c:	1c38      	adds	r0, r7, #0
    6e5e:	f7ff fd99 	bl	6994 <_ZN14Gamebuino_Meta9Gamebuino6updateEv>
    6e62:	2800      	cmp	r0, #0
    6e64:	d0fa      	beq.n	6e5c <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x124>
			continue;
		}
		if (reInitDisplay && titleScreenImageExists) {
    6e66:	9d09      	ldr	r5, [sp, #36]	; 0x24
    6e68:	2d00      	cmp	r5, #0
    6e6a:	d00d      	beq.n	6e88 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x150>
    6e6c:	9e02      	ldr	r6, [sp, #8]
    6e6e:	2e00      	cmp	r6, #0
    6e70:	d013      	beq.n	6e9a <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x162>
			if (display.frames == 1) {
    6e72:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
    6e74:	2b01      	cmp	r3, #1
    6e76:	d10a      	bne.n	6e8e <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x156>
				display.init(ts_backup_width, ts_backup_height, (char*)filename);
    6e78:	9300      	str	r3, [sp, #0]
    6e7a:	1c20      	adds	r0, r4, #0
    6e7c:	990a      	ldr	r1, [sp, #40]	; 0x28
    6e7e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    6e80:	ab0e      	add	r3, sp, #56	; 0x38
    6e82:	f003 ff27 	bl	acd4 <_ZN14Gamebuino_Meta5Image4initEttPch>
    6e86:	e002      	b.n	6e8e <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x156>
			}
			reInitDisplay = false;
		}
		if (titleScreenImageExists) {
    6e88:	9d02      	ldr	r5, [sp, #8]
    6e8a:	2d00      	cmp	r5, #0
    6e8c:	d005      	beq.n	6e9a <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x162>
			display.nextFrame();
    6e8e:	1c20      	adds	r0, r4, #0
    6e90:	2600      	movs	r6, #0
    6e92:	f003 ffd5 	bl	ae40 <_ZN14Gamebuino_Meta5Image9nextFrameEv>
    6e96:	9609      	str	r6, [sp, #36]	; 0x24
    6e98:	e002      	b.n	6ea0 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x168>
		} else {
			display.clear();
    6e9a:	1c20      	adds	r0, r4, #0
    6e9c:	f003 f8ae 	bl	9ffc <_ZN14Gamebuino_Meta8Graphics5clearEv>
		}
		
		if (displayName) {
    6ea0:	9d04      	ldr	r5, [sp, #16]
    6ea2:	2d00      	cmp	r5, #0
    6ea4:	d04b      	beq.n	6f3e <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x206>
			// center bar
			display.setColor(BROWN);
    6ea6:	1c20      	adds	r0, r4, #0
    6ea8:	4976      	ldr	r1, [pc, #472]	; (7084 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x34c>)
    6eaa:	f002 ff93 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
			display.fillRect(0, 15*display.fontSize, 80*display.fontSize, 9*display.fontSize);
    6eae:	4e6c      	ldr	r6, [pc, #432]	; (7060 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x328>)
    6eb0:	2550      	movs	r5, #80	; 0x50
    6eb2:	7831      	ldrb	r1, [r6, #0]
    6eb4:	2009      	movs	r0, #9
    6eb6:	220f      	movs	r2, #15
    6eb8:	1c2b      	adds	r3, r5, #0
    6eba:	434a      	muls	r2, r1
    6ebc:	434b      	muls	r3, r1
    6ebe:	4341      	muls	r1, r0
    6ec0:	1c20      	adds	r0, r4, #0
    6ec2:	9100      	str	r1, [sp, #0]
    6ec4:	2100      	movs	r1, #0
    6ec6:	f001 fe09 	bl	8adc <_ZN14Gamebuino_Meta8Graphics8fillRectEssss>
			display.setColor(DARKGRAY);
    6eca:	1c20      	adds	r0, r4, #0
    6ecc:	496e      	ldr	r1, [pc, #440]	; (7088 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x350>)
    6ece:	f002 ff81 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
			display.drawFastHLine(0, 14*display.fontSize, 80*display.fontSize);
    6ed2:	7833      	ldrb	r3, [r6, #0]
    6ed4:	220e      	movs	r2, #14
    6ed6:	435a      	muls	r2, r3
    6ed8:	1c20      	adds	r0, r4, #0
    6eda:	436b      	muls	r3, r5
    6edc:	2100      	movs	r1, #0
    6ede:	f003 f8ef 	bl	a0c0 <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss>
			display.drawFastHLine(0, 24*display.fontSize, 80*display.fontSize);
    6ee2:	7833      	ldrb	r3, [r6, #0]
    6ee4:	2218      	movs	r2, #24
    6ee6:	435a      	muls	r2, r3
    6ee8:	1c20      	adds	r0, r4, #0
    6eea:	436b      	muls	r3, r5
    6eec:	2100      	movs	r1, #0
    6eee:	f003 f8e7 	bl	a0c0 <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss>
			if (display.fontSize > 1) {
    6ef2:	7833      	ldrb	r3, [r6, #0]
    6ef4:	2b01      	cmp	r3, #1
    6ef6:	d910      	bls.n	6f1a <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x1e2>
				display.drawFastHLine(0, 14*display.fontSize + 1, 80*display.fontSize);
    6ef8:	220e      	movs	r2, #14
    6efa:	435a      	muls	r2, r3
    6efc:	1c20      	adds	r0, r4, #0
    6efe:	3201      	adds	r2, #1
    6f00:	436b      	muls	r3, r5
    6f02:	2100      	movs	r1, #0
    6f04:	f003 f8dc 	bl	a0c0 <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss>
				display.drawFastHLine(0, 24*display.fontSize + 1, 80*display.fontSize);
    6f08:	7833      	ldrb	r3, [r6, #0]
    6f0a:	2618      	movs	r6, #24
    6f0c:	435e      	muls	r6, r3
    6f0e:	1c20      	adds	r0, r4, #0
    6f10:	1c72      	adds	r2, r6, #1
    6f12:	436b      	muls	r3, r5
    6f14:	2100      	movs	r1, #0
    6f16:	f003 f8d3 	bl	a0c0 <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss>
			}
			
			// game name
			display.setColor(WHITE);
    6f1a:	1c20      	adds	r0, r4, #0
    6f1c:	495b      	ldr	r1, [pc, #364]	; (708c <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x354>)
    6f1e:	f002 ff59 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
			display.setCursor(2*display.fontSize, 17*display.fontSize);
    6f22:	4b4f      	ldr	r3, [pc, #316]	; (7060 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x328>)
    6f24:	2211      	movs	r2, #17
    6f26:	781b      	ldrb	r3, [r3, #0]
			display.println(folder_name);
    6f28:	26ca      	movs	r6, #202	; 0xca
				display.drawFastHLine(0, 24*display.fontSize + 1, 80*display.fontSize);
			}
			
			// game name
			display.setColor(WHITE);
			display.setCursor(2*display.fontSize, 17*display.fontSize);
    6f2a:	0059      	lsls	r1, r3, #1
    6f2c:	1c20      	adds	r0, r4, #0
    6f2e:	435a      	muls	r2, r3
			display.println(folder_name);
    6f30:	0076      	lsls	r6, r6, #1
				display.drawFastHLine(0, 24*display.fontSize + 1, 80*display.fontSize);
			}
			
			// game name
			display.setColor(WHITE);
			display.setCursor(2*display.fontSize, 17*display.fontSize);
    6f32:	f002 ffaf 	bl	9e94 <_ZN14Gamebuino_Meta8Graphics9setCursorEss>
			display.println(folder_name);
    6f36:	1c20      	adds	r0, r4, #0
    6f38:	19b9      	adds	r1, r7, r6
    6f3a:	f008 fe2d 	bl	fb98 <_ZN5Print7printlnEPKc>
		}
		// flashing "A to start"
		if ((frameCount % 32) < 20) {
    6f3e:	1c3b      	adds	r3, r7, #0
    6f40:	33fc      	adds	r3, #252	; 0xfc
    6f42:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    6f44:	231f      	movs	r3, #31
    6f46:	4013      	ands	r3, r2
    6f48:	2b13      	cmp	r3, #19
    6f4a:	d85a      	bhi.n	7002 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x2ca>
			
			display.setColor(Color::darkgray);
    6f4c:	1c20      	adds	r0, r4, #0
    6f4e:	494e      	ldr	r1, [pc, #312]	; (7088 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x350>)
    6f50:	f002 ff40 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
			display.drawRect(x - display.fontSize*2, y - display.fontSize*2, w + display.fontSize*4, h + display.fontSize*3);
    6f54:	4e42      	ldr	r6, [pc, #264]	; (7060 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x328>)
    6f56:	9d06      	ldr	r5, [sp, #24]
    6f58:	7830      	ldrb	r0, [r6, #0]
    6f5a:	0042      	lsls	r2, r0, #1
    6f5c:	4252      	negs	r2, r2
    6f5e:	b292      	uxth	r2, r2
    6f60:	18a9      	adds	r1, r5, r2
    6f62:	9d07      	ldr	r5, [sp, #28]
    6f64:	0083      	lsls	r3, r0, #2
    6f66:	18aa      	adds	r2, r5, r2
    6f68:	9d03      	ldr	r5, [sp, #12]
    6f6a:	b209      	sxth	r1, r1
    6f6c:	18eb      	adds	r3, r5, r3
    6f6e:	2503      	movs	r5, #3
    6f70:	4368      	muls	r0, r5
    6f72:	4684      	mov	ip, r0
    6f74:	9805      	ldr	r0, [sp, #20]
    6f76:	b212      	sxth	r2, r2
    6f78:	4484      	add	ip, r0
    6f7a:	4660      	mov	r0, ip
    6f7c:	9000      	str	r0, [sp, #0]
    6f7e:	1c20      	adds	r0, r4, #0
    6f80:	f001 fd6a 	bl	8a58 <_ZN14Gamebuino_Meta8Graphics8drawRectEssss>
			if (display.fontSize > 1) {
    6f84:	7830      	ldrb	r0, [r6, #0]
    6f86:	2801      	cmp	r0, #1
    6f88:	d916      	bls.n	6fb8 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x280>
				display.drawRect(x - display.fontSize*2 + 1, y - display.fontSize*2 + 1, w + display.fontSize*4 - 2, h + display.fontSize*3 - 2);
    6f8a:	0042      	lsls	r2, r0, #1
    6f8c:	0083      	lsls	r3, r0, #2
    6f8e:	4252      	negs	r2, r2
    6f90:	4368      	muls	r0, r5
    6f92:	9e06      	ldr	r6, [sp, #24]
    6f94:	3201      	adds	r2, #1
    6f96:	b292      	uxth	r2, r2
    6f98:	9d05      	ldr	r5, [sp, #20]
    6f9a:	18b1      	adds	r1, r6, r2
    6f9c:	9e07      	ldr	r6, [sp, #28]
    6f9e:	1828      	adds	r0, r5, r0
    6fa0:	18b2      	adds	r2, r6, r2
    6fa2:	3802      	subs	r0, #2
    6fa4:	9e03      	ldr	r6, [sp, #12]
    6fa6:	b200      	sxth	r0, r0
    6fa8:	3b02      	subs	r3, #2
    6faa:	9000      	str	r0, [sp, #0]
    6fac:	b209      	sxth	r1, r1
    6fae:	b212      	sxth	r2, r2
    6fb0:	18f3      	adds	r3, r6, r3
    6fb2:	1c20      	adds	r0, r4, #0
    6fb4:	f001 fd50 	bl	8a58 <_ZN14Gamebuino_Meta8Graphics8drawRectEssss>
			}
			
			display.setColor(Color::brown);
    6fb8:	1c20      	adds	r0, r4, #0
    6fba:	4932      	ldr	r1, [pc, #200]	; (7084 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x34c>)
    6fbc:	f002 ff0a 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
			display.fillRect(x - display.fontSize, y - display.fontSize, w + display.fontSize*2, h + display.fontSize);
    6fc0:	4b27      	ldr	r3, [pc, #156]	; (7060 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x328>)
    6fc2:	9d07      	ldr	r5, [sp, #28]
    6fc4:	7818      	ldrb	r0, [r3, #0]
    6fc6:	9e06      	ldr	r6, [sp, #24]
    6fc8:	1a2a      	subs	r2, r5, r0
    6fca:	9d05      	ldr	r5, [sp, #20]
    6fcc:	1a31      	subs	r1, r6, r0
    6fce:	9e03      	ldr	r6, [sp, #12]
    6fd0:	0043      	lsls	r3, r0, #1
    6fd2:	1828      	adds	r0, r5, r0
    6fd4:	18f3      	adds	r3, r6, r3
    6fd6:	9000      	str	r0, [sp, #0]
    6fd8:	1c20      	adds	r0, r4, #0
    6fda:	f001 fd7f 	bl	8adc <_ZN14Gamebuino_Meta8Graphics8fillRectEssss>
			display.setColor(Color::white);
    6fde:	1c20      	adds	r0, r4, #0
    6fe0:	492a      	ldr	r1, [pc, #168]	; (708c <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x354>)
    6fe2:	f002 fef7 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
			display.setCursor(x, y);
    6fe6:	9e06      	ldr	r6, [sp, #24]
    6fe8:	9d07      	ldr	r5, [sp, #28]
    6fea:	b231      	sxth	r1, r6
    6fec:	b22a      	sxth	r2, r5
    6fee:	1c20      	adds	r0, r4, #0
    6ff0:	f002 ff50 	bl	9e94 <_ZN14Gamebuino_Meta8Graphics9setCursorEss>
			display.print(msg);
			first = true;
    6ff4:	2601      	movs	r6, #1
			
			display.setColor(Color::brown);
			display.fillRect(x - display.fontSize, y - display.fontSize, w + display.fontSize*2, h + display.fontSize);
			display.setColor(Color::white);
			display.setCursor(x, y);
			display.print(msg);
    6ff6:	1c20      	adds	r0, r4, #0
    6ff8:	990c      	ldr	r1, [sp, #48]	; 0x30
    6ffa:	f008 fdbb 	bl	fb74 <_ZN5Print5printEPKc>
			first = true;
    6ffe:	9608      	str	r6, [sp, #32]
    7000:	e00b      	b.n	701a <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x2e2>
		} else if (display.frames == 1 && titleScreenImageExists && first) {
    7002:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
    7004:	2b01      	cmp	r3, #1
    7006:	d108      	bne.n	701a <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x2e2>
    7008:	9d02      	ldr	r5, [sp, #8]
    700a:	2d00      	cmp	r5, #0
    700c:	d005      	beq.n	701a <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x2e2>
    700e:	9e08      	ldr	r6, [sp, #32]
    7010:	2e00      	cmp	r6, #0
    7012:	d002      	beq.n	701a <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x2e2>
			reInitDisplay = true;
			first = false;
    7014:	2500      	movs	r5, #0
			display.setColor(Color::white);
			display.setCursor(x, y);
			display.print(msg);
			first = true;
		} else if (display.frames == 1 && titleScreenImageExists && first) {
			reInitDisplay = true;
    7016:	9309      	str	r3, [sp, #36]	; 0x24
			first = false;
    7018:	9508      	str	r5, [sp, #32]
		}
		if (gb.buttons.pressed(Button::a)) {
    701a:	481d      	ldr	r0, [pc, #116]	; (7090 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x358>)
    701c:	2104      	movs	r1, #4
    701e:	f000 fe2d 	bl	7c7c <_ZN14Gamebuino_Meta7Buttons7pressedENS_6ButtonE>
    7022:	2800      	cmp	r0, #0
    7024:	d100      	bne.n	7028 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x2f0>
    7026:	e719      	b.n	6e5c <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x124>
			sound.playOK();
    7028:	1c38      	adds	r0, r7, #0
    702a:	3038      	adds	r0, #56	; 0x38
    702c:	f007 ff04 	bl	ee38 <_ZN14Gamebuino_Meta5Sound6playOKEv>
			break;
		}
	}
	display.init(ts_backup_width, ts_backup_height, ts_backup_colorMode);
    7030:	2301      	movs	r3, #1
    7032:	9300      	str	r3, [sp, #0]
    7034:	9301      	str	r3, [sp, #4]
    7036:	1c20      	adds	r0, r4, #0
    7038:	990a      	ldr	r1, [sp, #40]	; 0x28
    703a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    703c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    703e:	f003 ff53 	bl	aee8 <_ZN14Gamebuino_Meta5Image4initEttNS_9ColorModeEth>
}
    7042:	b03b      	add	sp, #236	; 0xec
    7044:	bdf0      	pop	{r4, r5, r6, r7, pc}
		while (entry = dir_walk.openNextFile()) {
			if (!entry.isFile()) {
				continue;
			}
			entry.getName(filename + f_offset, sizeof(filename) - f_offset);
			if (!strstr(filename, ".GMV") && !strstr(filename, ".gmv")) {
    7046:	a80e      	add	r0, sp, #56	; 0x38
    7048:	4912      	ldr	r1, [pc, #72]	; (7094 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x35c>)
    704a:	f00a fbee 	bl	1182a <strstr>
    704e:	2800      	cmp	r0, #0
    7050:	d100      	bne.n	7054 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x31c>
    7052:	e6aa      	b.n	6daa <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0x72>
				continue;
			}
			titleScreenImageExists = true;
			displayName = true;
    7054:	2601      	movs	r6, #1
    7056:	9604      	str	r6, [sp, #16]
			}
			entry.getName(filename + f_offset, sizeof(filename) - f_offset);
			if (!strstr(filename, ".GMV") && !strstr(filename, ".gmv")) {
				continue;
			}
			titleScreenImageExists = true;
    7058:	9602      	str	r6, [sp, #8]
    705a:	e6c7      	b.n	6dec <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv+0xb4>
    705c:	00014a70 	.word	0x00014a70
    7060:	20000cd4 	.word	0x20000cd4
    7064:	200005c8 	.word	0x200005c8
    7068:	0000043c 	.word	0x0000043c
    706c:	00014d0c 	.word	0x00014d0c
    7070:	00014d45 	.word	0x00014d45
    7074:	00014d31 	.word	0x00014d31
    7078:	00014af4 	.word	0x00014af4
    707c:	20000cc0 	.word	0x20000cc0
    7080:	20000cd5 	.word	0x20000cd5
    7084:	0000cc68 	.word	0x0000cc68
    7088:	000072c7 	.word	0x000072c7
    708c:	0000ffff 	.word	0x0000ffff
    7090:	20000a3c 	.word	0x20000a3c
    7094:	00014d40 	.word	0x00014d40

00007098 <_ZN14Gamebuino_Meta9Gamebuino5beginEv>:
	0b00111111,0b00110011,0b00110011,0b00110011,0b11110011,0b11110011,0b11110011,0b00110011,0b00111111,0b00000000,
};

const uint16_t startSound[] = {0x0005,0x338,0x3FC,0x254,0x1FC,0x25C,0x3FC,0x368,0x0000};

void Gamebuino::begin() {
    7098:	b5f0      	push	{r4, r5, r6, r7, lr}
	// first we disable the watchdog timer so that we tell the bootloader everything is fine!
	WDT->CTRL.bit.ENABLE = 0;
    709a:	4bc6      	ldr	r3, [pc, #792]	; (73b4 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x31c>)
    709c:	2502      	movs	r5, #2
    709e:	781a      	ldrb	r2, [r3, #0]
	0b00111111,0b00110011,0b00110011,0b00110011,0b11110011,0b11110011,0b11110011,0b00110011,0b00111111,0b00000000,
};

const uint16_t startSound[] = {0x0005,0x338,0x3FC,0x254,0x1FC,0x25C,0x3FC,0x368,0x0000};

void Gamebuino::begin() {
    70a0:	1c04      	adds	r4, r0, #0
	// first we disable the watchdog timer so that we tell the bootloader everything is fine!
	WDT->CTRL.bit.ENABLE = 0;
    70a2:	43aa      	bics	r2, r5
    70a4:	701a      	strb	r2, [r3, #0]
	static_assert(sizeof __SKETCH_NAME__ - 1 >= 4 + 4, "Your sketch name is less than 4 chars long, please define FOLDER_NAME!");
	memcpy(folder_name, __SKETCH_NAME__, sizeof __SKETCH_NAME__ - 4);
	folder_name[sizeof __SKETCH_NAME__ - 4] = '\0';
#endif
	
	timePerFrame = 40; //25 FPS
    70a6:	23c2      	movs	r3, #194	; 0xc2
    70a8:	2228      	movs	r2, #40	; 0x28
    70aa:	005b      	lsls	r3, r3, #1
    70ac:	54c2      	strb	r2, [r0, r3]
	//nextFrameMillis = 0;
	//frameCount = 0;
	frameEndMicros = 1;
    70ae:	1c03      	adds	r3, r0, #0
    70b0:	33fc      	adds	r3, #252	; 0xfc
    70b2:	2001      	movs	r0, #1
	startMenuTimer = 255;

	//neoPixels
	neoPixels.begin();
    70b4:	21b8      	movs	r1, #184	; 0xb8
#endif
	
	timePerFrame = 40; //25 FPS
	//nextFrameMillis = 0;
	//frameCount = 0;
	frameEndMicros = 1;
    70b6:	66d8      	str	r0, [r3, #108]	; 0x6c
	startMenuTimer = 255;

	//neoPixels
	neoPixels.begin();
    70b8:	0049      	lsls	r1, r1, #1
	
	timePerFrame = 40; //25 FPS
	//nextFrameMillis = 0;
	//frameCount = 0;
	frameEndMicros = 1;
	startMenuTimer = 255;
    70ba:	23ad      	movs	r3, #173	; 0xad
    70bc:	4083      	lsls	r3, r0

	//neoPixels
	neoPixels.begin();
    70be:	1861      	adds	r1, r4, r1
	
	timePerFrame = 40; //25 FPS
	//nextFrameMillis = 0;
	//frameCount = 0;
	frameEndMicros = 1;
	startMenuTimer = 255;
    70c0:	22ff      	movs	r2, #255	; 0xff
	0b00111111,0b00110011,0b00110011,0b00110011,0b11110011,0b11110011,0b11110011,0b00110011,0b00111111,0b00000000,
};

const uint16_t startSound[] = {0x0005,0x338,0x3FC,0x254,0x1FC,0x25C,0x3FC,0x368,0x0000};

void Gamebuino::begin() {
    70c2:	b099      	sub	sp, #100	; 0x64
	
	timePerFrame = 40; //25 FPS
	//nextFrameMillis = 0;
	//frameCount = 0;
	frameEndMicros = 1;
	startMenuTimer = 255;
    70c4:	54e2      	strb	r2, [r4, r3]

	//neoPixels
	neoPixels.begin();
    70c6:	1c08      	adds	r0, r1, #0
    70c8:	9103      	str	r1, [sp, #12]
    70ca:	f000 f9db 	bl	7484 <_ZN17Adafruit_NeoPixel5beginEv>
	neoPixels.clear();
    70ce:	9803      	ldr	r0, [sp, #12]
    70d0:	f000 fb26 	bl	7720 <_ZN17Adafruit_NeoPixel5clearEv>

	//buttons
	buttons.begin();
    70d4:	1c20      	adds	r0, r4, #0
    70d6:	f000 fd7d 	bl	7bd4 <_ZN14Gamebuino_Meta7Buttons5beginEv>
	buttons.update();
    70da:	1c20      	adds	r0, r4, #0
    70dc:	f000 fd8a 	bl	7bf4 <_ZN14Gamebuino_Meta7Buttons6updateEv>
	
	//tft
	tft.initR(INITR_BLACKTAB);
    70e0:	1c22      	adds	r2, r4, #0
    70e2:	323c      	adds	r2, #60	; 0x3c
    70e4:	1c10      	adds	r0, r2, #0
    70e6:	1c29      	adds	r1, r5, #0
	tft.setRotation(3);
	
	
	display.fill(Color::black);
    70e8:	1c27      	adds	r7, r4, #0
    70ea:	3710      	adds	r7, #16
	//buttons
	buttons.begin();
	buttons.update();
	
	//tft
	tft.initR(INITR_BLACKTAB);
    70ec:	9202      	str	r2, [sp, #8]
    70ee:	f000 ffa1 	bl	8034 <_ZN14Gamebuino_Meta14Display_ST77355initREh>
	tft.setRotation(3);
    70f2:	9802      	ldr	r0, [sp, #8]
    70f4:	2103      	movs	r1, #3
    70f6:	f001 f9f5 	bl	84e4 <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh>
	
	
	display.fill(Color::black);
    70fa:	1c38      	adds	r0, r7, #0
    70fc:	2100      	movs	r1, #0
    70fe:	f002 fe2d 	bl	9d5c <_ZN14Gamebuino_Meta8Graphics4fillENS_5ColorE>
	display.fontSize = SYSTEM_DEFAULT_FONT_SIZE;
    7102:	4ead      	ldr	r6, [pc, #692]	; (73b8 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x320>)
    7104:	2301      	movs	r3, #1
	
	display.setColor(Color::white);
    7106:	1c38      	adds	r0, r7, #0
    7108:	49ac      	ldr	r1, [pc, #688]	; (73bc <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x324>)
	tft.initR(INITR_BLACKTAB);
	tft.setRotation(3);
	
	
	display.fill(Color::black);
	display.fontSize = SYSTEM_DEFAULT_FONT_SIZE;
    710a:	7033      	strb	r3, [r6, #0]
	
	display.setColor(Color::white);
    710c:	f002 fe62 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
	drawLogo(2, 0);
    7110:	1c29      	adds	r1, r5, #0
    7112:	1c20      	adds	r0, r4, #0
    7114:	2200      	movs	r2, #0
    7116:	f7ff fd73 	bl	6c00 <_ZN14Gamebuino_Meta9Gamebuino8drawLogoEaa>
	display.setColor(Color::brown, Color::black);
    711a:	49a9      	ldr	r1, [pc, #676]	; (73c0 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x328>)
    711c:	2200      	movs	r2, #0
    711e:	1c38      	adds	r0, r7, #0
    7120:	f002 fe8e 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
	display.setCursor(0,display.height() - (display.getFontHeight()*display.fontSize));
    7124:	1c38      	adds	r0, r7, #0
    7126:	f002 ff7f 	bl	a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>
    712a:	9001      	str	r0, [sp, #4]
    712c:	1c38      	adds	r0, r7, #0
    712e:	f002 fa4b 	bl	95c8 <_ZNK14Gamebuino_Meta8Graphics13getFontHeightEv>
    7132:	7832      	ldrb	r2, [r6, #0]
    7134:	2100      	movs	r1, #0
    7136:	4342      	muls	r2, r0
    7138:	9801      	ldr	r0, [sp, #4]
    713a:	1a83      	subs	r3, r0, r2
    713c:	b21a      	sxth	r2, r3
    713e:	1c38      	adds	r0, r7, #0
    7140:	f002 fea8 	bl	9e94 <_ZN14Gamebuino_Meta8Graphics9setCursorEss>
	display.print("SD INIT... ");
    7144:	499f      	ldr	r1, [pc, #636]	; (73c4 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x32c>)
    7146:	1c38      	adds	r0, r7, #0
    7148:	f008 fd14 	bl	fb74 <_ZN5Print5printEPKc>
	updateDisplay();
    714c:	1c20      	adds	r0, r4, #0
    714e:	f7fe fe0f 	bl	5d70 <_ZN14Gamebuino_Meta9Gamebuino13updateDisplayEv>
   * \param[in] csPin SD card chip select pin.
   * \param[in] divisor SPI divisor.
   * \return true for success else false.
   */
  bool begin(SdSpiCard::m_spi_t* spi, uint8_t csPin = SS, uint8_t divisor = 2) {
    return m_sdCard.begin(spi, csPin, divisor) &&
    7152:	4e9d      	ldr	r6, [pc, #628]	; (73c8 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x330>)
    7154:	4a9d      	ldr	r2, [pc, #628]	; (73cc <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x334>)
    7156:	218c      	movs	r1, #140	; 0x8c
    7158:	00c9      	lsls	r1, r1, #3
    715a:	1870      	adds	r0, r6, r1
    715c:	1c2b      	adds	r3, r5, #0
    715e:	18b1      	adds	r1, r6, r2
    7160:	221a      	movs	r2, #26
    7162:	f007 fa47 	bl	e5f4 <_ZN9SdSpiCard5beginEP5SdSpihh>
    7166:	1c35      	adds	r5, r6, #0
    7168:	2800      	cmp	r0, #0
    716a:	d01e      	beq.n	71aa <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x112>
   * \param[in] part partition to initialize.
   * \return The value true is returned for success and
   * the value false is returned for failure.
   */
  bool begin(uint8_t part = 0) {
    vwd()->close();
    716c:	4b98      	ldr	r3, [pc, #608]	; (73d0 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x338>)
    716e:	18f0      	adds	r0, r6, r3
    7170:	f006 f942 	bl	d3f8 <_ZN7FatFile5closeEv>
    return (part ? init(part) : init(1) || init(0))
    7174:	2101      	movs	r1, #1
    7176:	1c30      	adds	r0, r6, #0
    7178:	f007 f8d2 	bl	e320 <_ZN9FatVolume4initEh>
    717c:	1e01      	subs	r1, r0, #0
            && vwd()->openRoot(this) && FatFile::setCwd(vwd());
    717e:	d008      	beq.n	7192 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0xfa>
    7180:	4893      	ldr	r0, [pc, #588]	; (73d0 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x338>)
    7182:	1c29      	adds	r1, r5, #0
    7184:	182e      	adds	r6, r5, r0
    7186:	1c30      	adds	r0, r6, #0
    7188:	f005 fef5 	bl	cf76 <_ZN7FatFile8openRootEP9FatVolume>
    718c:	2800      	cmp	r0, #0
    718e:	d00c      	beq.n	71aa <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x112>
    7190:	e005      	b.n	719e <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x106>
   * \return The value true is returned for success and
   * the value false is returned for failure.
   */
  bool begin(uint8_t part = 0) {
    vwd()->close();
    return (part ? init(part) : init(1) || init(0))
    7192:	1c30      	adds	r0, r6, #0
    7194:	f007 f8c4 	bl	e320 <_ZN9FatVolume4initEh>
    7198:	2800      	cmp	r0, #0
    719a:	d1f1      	bne.n	7180 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0xe8>
    719c:	e005      	b.n	71aa <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x112>
            && vwd()->openRoot(this) && FatFile::setCwd(vwd());
    719e:	1c30      	adds	r0, r6, #0
    71a0:	f7fe fdbc 	bl	5d1c <_ZN7FatFile6setCwdEPS_>
    71a4:	2800      	cmp	r0, #0
    71a6:	d000      	beq.n	71aa <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x112>
    71a8:	e0f6      	b.n	7398 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x300>
	
	if (!SD.begin(SD_CS)) {
		display.setColor(Color::red, Color::black);
    71aa:	2200      	movs	r2, #0
    71ac:	1c38      	adds	r0, r7, #0
    71ae:	4989      	ldr	r1, [pc, #548]	; (73d4 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x33c>)
    71b0:	f002 fe46 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
		display.println("FAILED!");
    71b4:	4988      	ldr	r1, [pc, #544]	; (73d8 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x340>)
    71b6:	1c38      	adds	r0, r7, #0
    71b8:	f008 fcee 	bl	fb98 <_ZN5Print7printlnEPKc>
		updateDisplay();
    71bc:	1c20      	adds	r0, r4, #0
    71be:	f7fe fdd7 	bl	5d70 <_ZN14Gamebuino_Meta9Gamebuino13updateDisplayEv>
		delay(1000);
    71c2:	20fa      	movs	r0, #250	; 0xfa
    71c4:	0080      	lsls	r0, r0, #2
    71c6:	f008 f8e3 	bl	f390 <delay>
		display.setColor(Color::lightgreen, Color::black);
		display.println("OK!");
		updateDisplay();
	}

	display.setColor(Color::white, Color::black);
    71ca:	2200      	movs	r2, #0
    71cc:	1c38      	adds	r0, r7, #0
    71ce:	497b      	ldr	r1, [pc, #492]	; (73bc <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x324>)
    71d0:	f002 fe36 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
	display.fill(Color::black);
    71d4:	1c38      	adds	r0, r7, #0
    71d6:	2100      	movs	r1, #0
    71d8:	f002 fdc0 	bl	9d5c <_ZN14Gamebuino_Meta8Graphics4fillENS_5ColorE>
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return vwd()->exists(path);
    71dc:	4a7c      	ldr	r2, [pc, #496]	; (73d0 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x338>)
	
	// SD is initialized, let's switch to the folder!
	if (!SD.exists(folder_name)) {
    71de:	21ca      	movs	r1, #202	; 0xca
    71e0:	0049      	lsls	r1, r1, #1
    71e2:	18ae      	adds	r6, r5, r2
    71e4:	1861      	adds	r1, r4, r1
    71e6:	1c30      	adds	r0, r6, #0
    71e8:	9101      	str	r1, [sp, #4]
    71ea:	f7fe fd88 	bl	5cfe <_ZN7FatFile6existsEPKc>
    71ee:	2800      	cmp	r0, #0
    71f0:	d108      	bne.n	7204 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x16c>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
    71f2:	466b      	mov	r3, sp
    71f4:	7418      	strb	r0, [r3, #16]
    71f6:	7458      	strb	r0, [r3, #17]
   * \return The value true is returned for success and
   * the value false is returned for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    71f8:	1c31      	adds	r1, r6, #0
    71fa:	a804      	add	r0, sp, #16
    71fc:	9a01      	ldr	r2, [sp, #4]
    71fe:	2301      	movs	r3, #1
    7200:	f006 f9ce 	bl	d5a0 <_ZN7FatFile5mkdirEPS_PKcb>
    7204:	2300      	movs	r3, #0
    7206:	4668      	mov	r0, sp
    7208:	7403      	strb	r3, [r0, #16]
    720a:	7443      	strb	r3, [r0, #17]
   * the value false is returned for failure.
   */
  //----------------------------------------------------------------------------
  bool chdir(const char *path, bool set_cwd = false) {
    FatFile dir;
    if (path[0] == '/' && path[1] == '\0') {
    720c:	23ca      	movs	r3, #202	; 0xca
    720e:	005b      	lsls	r3, r3, #1
    7210:	5ce3      	ldrb	r3, [r4, r3]
    7212:	2b2f      	cmp	r3, #47	; 0x2f
    7214:	d10e      	bne.n	7234 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x19c>
    7216:	2396      	movs	r3, #150	; 0x96
    7218:	33ff      	adds	r3, #255	; 0xff
    721a:	5ce3      	ldrb	r3, [r4, r3]
    721c:	2b00      	cmp	r3, #0
    721e:	d109      	bne.n	7234 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x19c>
   *
   * \return The value true is returned for success and
   * the value false is returned for failure.
   */
  bool chdir(bool set_cwd = false) {
    vwd()->close();
    7220:	496b      	ldr	r1, [pc, #428]	; (73d0 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x338>)
    7222:	186e      	adds	r6, r5, r1
    7224:	1c30      	adds	r0, r6, #0
    7226:	f006 f8e7 	bl	d3f8 <_ZN7FatFile5closeEv>
    return vwd()->openRoot(this) && (set_cwd ? FatFile::setCwd(vwd()) : true);
    722a:	1c30      	adds	r0, r6, #0
    722c:	1c29      	adds	r1, r5, #0
    722e:	f005 fea2 	bl	cf76 <_ZN7FatFile8openRootEP9FatVolume>
    7232:	e015      	b.n	7260 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x1c8>
  bool chdir(const char *path, bool set_cwd = false) {
    FatFile dir;
    if (path[0] == '/' && path[1] == '\0') {
      return chdir(set_cwd);
    }
    if (!dir.open(vwd(), path, O_READ)) {
    7234:	4a66      	ldr	r2, [pc, #408]	; (73d0 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x338>)
    7236:	ae04      	add	r6, sp, #16
    7238:	18ad      	adds	r5, r5, r2
    723a:	1c30      	adds	r0, r6, #0
    723c:	1c29      	adds	r1, r5, #0
    723e:	9a01      	ldr	r2, [sp, #4]
    7240:	2301      	movs	r3, #1
    7242:	f006 f8e0 	bl	d406 <_ZN7FatFile4openEPS_PKch>
    7246:	2800      	cmp	r0, #0
    7248:	d00a      	beq.n	7260 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x1c8>
   * the value false, is returned for failure.
   */  
  bool getSFN(char* name);
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_attr & FILE_ATTR_DIR;
    724a:	7832      	ldrb	r2, [r6, #0]
      goto fail;
    }
    if (!dir.isDir()) {
    724c:	2370      	movs	r3, #112	; 0x70
    724e:	421a      	tst	r2, r3
    7250:	d006      	beq.n	7260 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x1c8>
      goto fail;
    }
//    *m_vwd = dir;
    m_vwd = dir;
    7252:	1c2b      	adds	r3, r5, #0
    7254:	ce07      	ldmia	r6!, {r0, r1, r2}
    7256:	c307      	stmia	r3!, {r0, r1, r2}
    7258:	ce07      	ldmia	r6!, {r0, r1, r2}
    725a:	c307      	stmia	r3!, {r0, r1, r2}
    725c:	ce07      	ldmia	r6!, {r0, r1, r2}
    725e:	c307      	stmia	r3!, {r0, r1, r2}
		SD.mkdir(folder_name);
	}
	SD.chdir(folder_name);
	
	save = Save(&tft, SAVEFILE_NAME, folder_name);
    7260:	4a5e      	ldr	r2, [pc, #376]	; (73dc <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x344>)
    7262:	9902      	ldr	r1, [sp, #8]
    7264:	9b01      	ldr	r3, [sp, #4]
    7266:	a804      	add	r0, sp, #16
    7268:	f005 fade 	bl	c828 <_ZN14Gamebuino_Meta4SaveC1EPNS_14Display_ST7735EPKcS4_>
	const uint32_t length;
//	SaveDefault(const uint8_t i, const uint8_t type, const int32_t ival): i(i), type(type), val{.ival=ival}, length(0){};
//	SaveDefault(const uint8_t i, const uint8_t type, const void* ptr, const uint8_t length): i(i), type(type), val{.ptr=ptr}, length(length){};
};

class Save {
    726c:	1c25      	adds	r5, r4, #0
    726e:	9b04      	ldr	r3, [sp, #16]
    7270:	35b8      	adds	r5, #184	; 0xb8
    7272:	1c20      	adds	r0, r4, #0
    7274:	602b      	str	r3, [r5, #0]
    7276:	a905      	add	r1, sp, #20
    7278:	30bc      	adds	r0, #188	; 0xbc
    727a:	f7fe fd67 	bl	5d4c <_ZN4FileaSEOS_>
    727e:	a812      	add	r0, sp, #72	; 0x48
    7280:	7802      	ldrb	r2, [r0, #0]
    7282:	1c23      	adds	r3, r4, #0
    7284:	33f0      	adds	r3, #240	; 0xf0
    7286:	2149      	movs	r1, #73	; 0x49
    7288:	701a      	strb	r2, [r3, #0]
    728a:	4469      	add	r1, sp
    728c:	780a      	ldrb	r2, [r1, #0]
    728e:	a815      	add	r0, sp, #84	; 0x54
    7290:	705a      	strb	r2, [r3, #1]
    7292:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    7294:	9b14      	ldr	r3, [sp, #80]	; 0x50
    7296:	63ea      	str	r2, [r5, #60]	; 0x3c
    7298:	642b      	str	r3, [r5, #64]	; 0x40
    729a:	8802      	ldrh	r2, [r0, #0]
    729c:	1c23      	adds	r3, r4, #0
    729e:	33be      	adds	r3, #190	; 0xbe
    72a0:	87da      	strh	r2, [r3, #62]	; 0x3e
    72a2:	ae06      	add	r6, sp, #24
    72a4:	8ff2      	ldrh	r2, [r6, #62]	; 0x3e
    72a6:	3302      	adds	r3, #2
    72a8:	87da      	strh	r2, [r3, #62]	; 0x3e
    72aa:	9916      	ldr	r1, [sp, #88]	; 0x58
    72ac:	9a17      	ldr	r2, [sp, #92]	; 0x5c
	
	settings = Save(&tft, "/SETTINGS.SAV", "GBMS");
    72ae:	2384      	movs	r3, #132	; 0x84
    72b0:	005b      	lsls	r3, r3, #1
    72b2:	64a9      	str	r1, [r5, #72]	; 0x48
    72b4:	64ea      	str	r2, [r5, #76]	; 0x4c
    72b6:	9902      	ldr	r1, [sp, #8]
    72b8:	18e5      	adds	r5, r4, r3
    72ba:	4a49      	ldr	r2, [pc, #292]	; (73e0 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x348>)
    72bc:	4b49      	ldr	r3, [pc, #292]	; (73e4 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x34c>)
    72be:	a804      	add	r0, sp, #16
    72c0:	f005 fab2 	bl	c828 <_ZN14Gamebuino_Meta4SaveC1EPNS_14Display_ST7735EPKcS4_>
    72c4:	9804      	ldr	r0, [sp, #16]
    72c6:	2384      	movs	r3, #132	; 0x84
    72c8:	2186      	movs	r1, #134	; 0x86
    72ca:	005b      	lsls	r3, r3, #1
    72cc:	0049      	lsls	r1, r1, #1
    72ce:	50e0      	str	r0, [r4, r3]
    72d0:	1860      	adds	r0, r4, r1
    72d2:	a905      	add	r1, sp, #20
    72d4:	f7fe fd3a 	bl	5d4c <_ZN4FileaSEOS_>
    72d8:	ab12      	add	r3, sp, #72	; 0x48
    72da:	20a0      	movs	r0, #160	; 0xa0
    72dc:	781a      	ldrb	r2, [r3, #0]
    72de:	0040      	lsls	r0, r0, #1
    72e0:	1823      	adds	r3, r4, r0
    72e2:	2149      	movs	r1, #73	; 0x49
    72e4:	701a      	strb	r2, [r3, #0]
    72e6:	4469      	add	r1, sp
    72e8:	2042      	movs	r0, #66	; 0x42
    72ea:	780a      	ldrb	r2, [r1, #0]
    72ec:	30ff      	adds	r0, #255	; 0xff
    72ee:	1823      	adds	r3, r4, r0
    72f0:	701a      	strb	r2, [r3, #0]
    72f2:	9913      	ldr	r1, [sp, #76]	; 0x4c
    72f4:	9a14      	ldr	r2, [sp, #80]	; 0x50
    72f6:	63e9      	str	r1, [r5, #60]	; 0x3c
    72f8:	642a      	str	r2, [r5, #64]	; 0x40
    72fa:	ab15      	add	r3, sp, #84	; 0x54
    72fc:	2087      	movs	r0, #135	; 0x87
    72fe:	881a      	ldrh	r2, [r3, #0]
    7300:	0040      	lsls	r0, r0, #1
    7302:	1823      	adds	r3, r4, r0
    7304:	87da      	strh	r2, [r3, #62]	; 0x3e
    7306:	2188      	movs	r1, #136	; 0x88
    7308:	8ff2      	ldrh	r2, [r6, #62]	; 0x3e
    730a:	0049      	lsls	r1, r1, #1
    730c:	1863      	adds	r3, r4, r1
    730e:	87da      	strh	r2, [r3, #62]	; 0x3e
    7310:	9a16      	ldr	r2, [sp, #88]	; 0x58
    7312:	9b17      	ldr	r3, [sp, #92]	; 0x5c
	settings.config(SETTINGSCONF_NUM_BLOCKS, settingsDefaults);
	
	//sound
	sound.begin();
    7314:	1c26      	adds	r6, r4, #0
	void config(const SaveDefault (&_defaults)[N]) {
		config(_defaults, N);
	}
	template<uint8_t N>
	void config(uint16_t _blocks, const SaveDefault (&_defaults)[N]) {
		config(_blocks, _defaults, N);
    7316:	2120      	movs	r1, #32
	const uint32_t length;
//	SaveDefault(const uint8_t i, const uint8_t type, const int32_t ival): i(i), type(type), val{.ival=ival}, length(0){};
//	SaveDefault(const uint8_t i, const uint8_t type, const void* ptr, const uint8_t length): i(i), type(type), val{.ptr=ptr}, length(length){};
};

class Save {
    7318:	64aa      	str	r2, [r5, #72]	; 0x48
    731a:	64eb      	str	r3, [r5, #76]	; 0x4c
	void config(const SaveDefault (&_defaults)[N]) {
		config(_defaults, N);
	}
	template<uint8_t N>
	void config(uint16_t _blocks, const SaveDefault (&_defaults)[N]) {
		config(_blocks, _defaults, N);
    731c:	1c28      	adds	r0, r5, #0
    731e:	4a32      	ldr	r2, [pc, #200]	; (73e8 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x350>)
    7320:	2305      	movs	r3, #5
    7322:	3638      	adds	r6, #56	; 0x38
    7324:	f005 fa9c 	bl	c860 <_ZN14Gamebuino_Meta4Save6configEtPKNS_11SaveDefaultEt>
    7328:	1c30      	adds	r0, r6, #0
    732a:	f007 fd57 	bl	eddc <_ZN14Gamebuino_Meta5Sound5beginEv>
	if (settings.get(SETTING_VOLUME_MUTE)) {
    732e:	1c28      	adds	r0, r5, #0
    7330:	2101      	movs	r1, #1
    7332:	f005 fd21 	bl	cd78 <_ZN14Gamebuino_Meta4Save3getEt>
    7336:	2800      	cmp	r0, #0
    7338:	d002      	beq.n	7340 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x2a8>
		sound.mute();
    733a:	1c30      	adds	r0, r6, #0
    733c:	f007 fdc0 	bl	eec0 <_ZN14Gamebuino_Meta5Sound4muteEv>
	}
	sound.setVolume(settings.get(SETTING_VOLUME));
    7340:	2100      	movs	r1, #0
    7342:	1c28      	adds	r0, r5, #0
    7344:	f005 fd18 	bl	cd78 <_ZN14Gamebuino_Meta4Save3getEt>
    7348:	b2c1      	uxtb	r1, r0
    734a:	1c30      	adds	r0, r6, #0
    734c:	f007 fdd6 	bl	eefc <_ZN14Gamebuino_Meta5Sound9setVolumeEh>
	
	// language
	language.setCurrentLang((LangCode)settings.get(SETTING_LANGUAGE));
    7350:	2103      	movs	r1, #3
    7352:	1c28      	adds	r0, r5, #0
    7354:	f005 fd10 	bl	cd78 <_ZN14Gamebuino_Meta4Save3getEt>
    7358:	f005 f9ba 	bl	c6d0 <_ZN14Gamebuino_Meta8Language14setCurrentLangENS_8LangCodeE>
	
	// neoPixels
	neoPixels.setBrightness(neoPixelsIntensities[settings.get(SETTING_NEOPIXELS_INTENSITY)]);
    735c:	2104      	movs	r1, #4
    735e:	1c28      	adds	r0, r5, #0
    7360:	f005 fd0a 	bl	cd78 <_ZN14Gamebuino_Meta4Save3getEt>
    7364:	4b21      	ldr	r3, [pc, #132]	; (73ec <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x354>)
    7366:	5c19      	ldrb	r1, [r3, r0]
    7368:	9803      	ldr	r0, [sp, #12]
    736a:	f000 f9ad 	bl	76c8 <_ZN17Adafruit_NeoPixel13setBrightnessEh>
	
	Graphics_SD::setTft(&tft);
    736e:	9802      	ldr	r0, [sp, #8]
    7370:	f005 f9a8 	bl	c6c4 <_ZN14Gamebuino_Meta11Graphics_SD6setTftEPNS_14Display_ST7735E>
	// only do titleScreen after a hard power on
	if (PM->RCAUSE.bit.POR) {
    7374:	4b1e      	ldr	r3, [pc, #120]	; (73f0 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x358>)
    7376:	781b      	ldrb	r3, [r3, #0]
    7378:	07d8      	lsls	r0, r3, #31
    737a:	d505      	bpl.n	7388 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x2f0>
		startScreen();
    737c:	1c20      	adds	r0, r4, #0
    737e:	f7ff fc87 	bl	6c90 <_ZN14Gamebuino_Meta9Gamebuino11startScreenEv>
#if AUTOSHOW_TITLESCREEN
		titleScreen();
    7382:	1c20      	adds	r0, r4, #0
    7384:	f7ff fcd8 	bl	6d38 <_ZN14Gamebuino_Meta9Gamebuino11titleScreenEv>
#endif
	}
	pickRandomSeed();
    7388:	1c20      	adds	r0, r4, #0
    738a:	f7fe fd10 	bl	5dae <_ZN14Gamebuino_Meta9Gamebuino14pickRandomSeedEv>
	display.clear();
    738e:	1c38      	adds	r0, r7, #0
    7390:	f002 fe34 	bl	9ffc <_ZN14Gamebuino_Meta8Graphics5clearEv>
}
    7394:	b019      	add	sp, #100	; 0x64
    7396:	bdf0      	pop	{r4, r5, r6, r7, pc}
		display.setColor(Color::red, Color::black);
		display.println("FAILED!");
		updateDisplay();
		delay(1000);
	} else {
		display.setColor(Color::lightgreen, Color::black);
    7398:	1c38      	adds	r0, r7, #0
    739a:	2200      	movs	r2, #0
    739c:	4915      	ldr	r1, [pc, #84]	; (73f4 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x35c>)
    739e:	f002 fd4f 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
		display.println("OK!");
    73a2:	1c38      	adds	r0, r7, #0
    73a4:	4914      	ldr	r1, [pc, #80]	; (73f8 <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x360>)
    73a6:	f008 fbf7 	bl	fb98 <_ZN5Print7printlnEPKc>
		updateDisplay();
    73aa:	1c20      	adds	r0, r4, #0
    73ac:	f7fe fce0 	bl	5d70 <_ZN14Gamebuino_Meta9Gamebuino13updateDisplayEv>
    73b0:	e70b      	b.n	71ca <_ZN14Gamebuino_Meta9Gamebuino5beginEv+0x132>
    73b2:	46c0      	nop			; (mov r8, r8)
    73b4:	40001000 	.word	0x40001000
    73b8:	20000cd4 	.word	0x20000cd4
    73bc:	0000ffff 	.word	0x0000ffff
    73c0:	0000cc68 	.word	0x0000cc68
    73c4:	00014d4a 	.word	0x00014d4a
    73c8:	200005c8 	.word	0x200005c8
    73cc:	0000046c 	.word	0x0000046c
    73d0:	0000043c 	.word	0x0000043c
    73d4:	0000d8e4 	.word	0x0000d8e4
    73d8:	00014d72 	.word	0x00014d72
    73dc:	00014d56 	.word	0x00014d56
    73e0:	00014d5f 	.word	0x00014d5f
    73e4:	00014d6d 	.word	0x00014d6d
    73e8:	00014aa0 	.word	0x00014aa0
    73ec:	00014cec 	.word	0x00014cec
    73f0:	40000438 	.word	0x40000438
    73f4:	00008668 	.word	0x00008668
    73f8:	00014d7a 	.word	0x00014d7a

000073fc <cpu_irq_enter_critical>:
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
    73fc:	4b0a      	ldr	r3, [pc, #40]	; (7428 <cpu_irq_enter_critical+0x2c>)
    73fe:	681a      	ldr	r2, [r3, #0]
    7400:	2a00      	cmp	r2, #0
    7402:	d10c      	bne.n	741e <cpu_irq_enter_critical+0x22>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    7404:	f3ef 8010 	mrs	r0, PRIMASK
    7408:	2100      	movs	r1, #0
    740a:	4a08      	ldr	r2, [pc, #32]	; (742c <cpu_irq_enter_critical+0x30>)
		if (cpu_irq_is_enabled()) {
    740c:	4288      	cmp	r0, r1
    740e:	d105      	bne.n	741c <cpu_irq_enter_critical+0x20>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    7410:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    7412:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
    7416:	4806      	ldr	r0, [pc, #24]	; (7430 <cpu_irq_enter_critical+0x34>)
    7418:	7001      	strb	r1, [r0, #0]
			cpu_irq_prev_interrupt_state = true;
    741a:	2101      	movs	r1, #1
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
    741c:	7011      	strb	r1, [r2, #0]
		}

	}

	cpu_irq_critical_section_counter++;
    741e:	681a      	ldr	r2, [r3, #0]
    7420:	3201      	adds	r2, #1
    7422:	601a      	str	r2, [r3, #0]
}
    7424:	4770      	bx	lr
    7426:	46c0      	nop			; (mov r8, r8)
    7428:	20000bdc 	.word	0x20000bdc
    742c:	20000be0 	.word	0x20000be0
    7430:	20000040 	.word	0x20000040

00007434 <cpu_irq_leave_critical>:
void cpu_irq_leave_critical(void)
{
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
    7434:	4b08      	ldr	r3, [pc, #32]	; (7458 <cpu_irq_leave_critical+0x24>)
    7436:	681a      	ldr	r2, [r3, #0]
    7438:	3a01      	subs	r2, #1
    743a:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
    743c:	681b      	ldr	r3, [r3, #0]
    743e:	2b00      	cmp	r3, #0
    7440:	d109      	bne.n	7456 <cpu_irq_leave_critical+0x22>
    7442:	4b06      	ldr	r3, [pc, #24]	; (745c <cpu_irq_leave_critical+0x28>)
    7444:	781b      	ldrb	r3, [r3, #0]
    7446:	2b00      	cmp	r3, #0
    7448:	d005      	beq.n	7456 <cpu_irq_leave_critical+0x22>
		cpu_irq_enable();
    744a:	4b05      	ldr	r3, [pc, #20]	; (7460 <cpu_irq_leave_critical+0x2c>)
    744c:	2201      	movs	r2, #1
    744e:	701a      	strb	r2, [r3, #0]
    7450:	f3bf 8f5f 	dmb	sy
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    7454:	b662      	cpsie	i
	}
}
    7456:	4770      	bx	lr
    7458:	20000bdc 	.word	0x20000bdc
    745c:	20000be0 	.word	0x20000be0
    7460:	20000040 	.word	0x20000040

00007464 <_ZN17Adafruit_NeoPixelD1Ev>:
  begun(false), numLEDs(0), numBytes(0), pin(-1), brightness(0), pixels(NULL),
  rOffset(1), gOffset(0), bOffset(2), wOffset(1), endTime(0)
{
}

Adafruit_NeoPixel::~Adafruit_NeoPixel() {
    7464:	b510      	push	{r4, lr}
    7466:	1c04      	adds	r4, r0, #0
  if(pixels)   free(pixels);
    7468:	6880      	ldr	r0, [r0, #8]
    746a:	2800      	cmp	r0, #0
    746c:	d001      	beq.n	7472 <_ZN17Adafruit_NeoPixelD1Ev+0xe>
    746e:	f00a f88b 	bl	11588 <free>
  if(pin >= 0) pinMode(pin, INPUT);
    7472:	2006      	movs	r0, #6
    7474:	5620      	ldrsb	r0, [r4, r0]
    7476:	2800      	cmp	r0, #0
    7478:	db02      	blt.n	7480 <_ZN17Adafruit_NeoPixelD1Ev+0x1c>
    747a:	2100      	movs	r1, #0
    747c:	f008 fa74 	bl	f968 <pinMode>
}
    7480:	1c20      	adds	r0, r4, #0
    7482:	bd10      	pop	{r4, pc}

00007484 <_ZN17Adafruit_NeoPixel5beginEv>:

void Adafruit_NeoPixel::begin(void) {
    7484:	b510      	push	{r4, lr}
    7486:	1c04      	adds	r4, r0, #0
  if(pin >= 0) {
    7488:	2006      	movs	r0, #6
    748a:	5620      	ldrsb	r0, [r4, r0]
    748c:	2800      	cmp	r0, #0
    748e:	db07      	blt.n	74a0 <_ZN17Adafruit_NeoPixel5beginEv+0x1c>
    pinMode(pin, OUTPUT);
    7490:	2101      	movs	r1, #1
    7492:	f008 fa69 	bl	f968 <pinMode>
    digitalWrite(pin, LOW);
    7496:	2006      	movs	r0, #6
    7498:	5620      	ldrsb	r0, [r4, r0]
    749a:	2100      	movs	r1, #0
    749c:	f008 fabe 	bl	fa1c <digitalWrite>
  }
  begun = true;
    74a0:	2301      	movs	r3, #1
    74a2:	7063      	strb	r3, [r4, #1]
}
    74a4:	bd10      	pop	{r4, pc}

000074a6 <_ZN17Adafruit_NeoPixel12updateLengthEt>:

void Adafruit_NeoPixel::updateLength(uint16_t n) {
    74a6:	b570      	push	{r4, r5, r6, lr}
    74a8:	1c04      	adds	r4, r0, #0
  if(pixels) free(pixels); // Free existing data (if any)
    74aa:	6880      	ldr	r0, [r0, #8]
    digitalWrite(pin, LOW);
  }
  begun = true;
}

void Adafruit_NeoPixel::updateLength(uint16_t n) {
    74ac:	1c0e      	adds	r6, r1, #0
  if(pixels) free(pixels); // Free existing data (if any)
    74ae:	2800      	cmp	r0, #0
    74b0:	d001      	beq.n	74b6 <_ZN17Adafruit_NeoPixel12updateLengthEt+0x10>
    74b2:	f00a f869 	bl	11588 <free>

  // Allocate new data -- note: ALL PIXELS ARE CLEARED
  numBytes = n * ((wOffset == rOffset) ? 3 : 4);
    74b6:	7b23      	ldrb	r3, [r4, #12]
    74b8:	7be5      	ldrb	r5, [r4, #15]
    74ba:	1aed      	subs	r5, r5, r3
    74bc:	1e6b      	subs	r3, r5, #1
    74be:	419d      	sbcs	r5, r3
    74c0:	3503      	adds	r5, #3
    74c2:	4375      	muls	r5, r6
    74c4:	b2ad      	uxth	r5, r5
    74c6:	80a5      	strh	r5, [r4, #4]
  if((pixels = (uint8_t *)malloc(numBytes))) {
    74c8:	1c28      	adds	r0, r5, #0
    74ca:	f00a f853 	bl	11574 <malloc>
    74ce:	60a0      	str	r0, [r4, #8]
    74d0:	2800      	cmp	r0, #0
    74d2:	d005      	beq.n	74e0 <_ZN17Adafruit_NeoPixel12updateLengthEt+0x3a>
    memset(pixels, 0, numBytes);
    74d4:	2100      	movs	r1, #0
    74d6:	1c2a      	adds	r2, r5, #0
    74d8:	f00a f878 	bl	115cc <memset>
    numLEDs = n;
    74dc:	8066      	strh	r6, [r4, #2]
    74de:	e001      	b.n	74e4 <_ZN17Adafruit_NeoPixel12updateLengthEt+0x3e>
  } else {
    numLEDs = numBytes = 0;
    74e0:	80a0      	strh	r0, [r4, #4]
    74e2:	8060      	strh	r0, [r4, #2]
  }
}
    74e4:	bd70      	pop	{r4, r5, r6, pc}

000074e6 <_ZN17Adafruit_NeoPixel10updateTypeEt>:

void Adafruit_NeoPixel::updateType(neoPixelType t) {
  boolean oldThreeBytesPerPixel = (wOffset == rOffset); // false if RGBW
    74e6:	7b03      	ldrb	r3, [r0, #12]
  } else {
    numLEDs = numBytes = 0;
  }
}

void Adafruit_NeoPixel::updateType(neoPixelType t) {
    74e8:	b570      	push	{r4, r5, r6, lr}
  boolean oldThreeBytesPerPixel = (wOffset == rOffset); // false if RGBW
    74ea:	7bc5      	ldrb	r5, [r0, #15]

  wOffset = (t >> 6) & 0b11; // See notes in header file
    74ec:	118c      	asrs	r4, r1, #6
    numLEDs = numBytes = 0;
  }
}

void Adafruit_NeoPixel::updateType(neoPixelType t) {
  boolean oldThreeBytesPerPixel = (wOffset == rOffset); // false if RGBW
    74ee:	1aed      	subs	r5, r5, r3
    74f0:	426b      	negs	r3, r5
    74f2:	415d      	adcs	r5, r3

  wOffset = (t >> 6) & 0b11; // See notes in header file
  rOffset = (t >> 4) & 0b11; // regarding R/G/B/W offsets
    74f4:	110a      	asrs	r2, r1, #4
}

void Adafruit_NeoPixel::updateType(neoPixelType t) {
  boolean oldThreeBytesPerPixel = (wOffset == rOffset); // false if RGBW

  wOffset = (t >> 6) & 0b11; // See notes in header file
    74f6:	2303      	movs	r3, #3
  rOffset = (t >> 4) & 0b11; // regarding R/G/B/W offsets
  gOffset = (t >> 2) & 0b11;
    74f8:	108e      	asrs	r6, r1, #2
    74fa:	401e      	ands	r6, r3
}

void Adafruit_NeoPixel::updateType(neoPixelType t) {
  boolean oldThreeBytesPerPixel = (wOffset == rOffset); // false if RGBW

  wOffset = (t >> 6) & 0b11; // See notes in header file
    74fc:	401c      	ands	r4, r3
  rOffset = (t >> 4) & 0b11; // regarding R/G/B/W offsets
    74fe:	401a      	ands	r2, r3
  gOffset = (t >> 2) & 0b11;
  bOffset =  t       & 0b11;
    7500:	400b      	ands	r3, r1
void Adafruit_NeoPixel::updateType(neoPixelType t) {
  boolean oldThreeBytesPerPixel = (wOffset == rOffset); // false if RGBW

  wOffset = (t >> 6) & 0b11; // See notes in header file
  rOffset = (t >> 4) & 0b11; // regarding R/G/B/W offsets
  gOffset = (t >> 2) & 0b11;
    7502:	7346      	strb	r6, [r0, #13]
  bOffset =  t       & 0b11;
    7504:	7383      	strb	r3, [r0, #14]
#ifdef NEO_KHZ400
  is800KHz = (t < 256);      // 400 KHz flag is 1<<8
    7506:	26ff      	movs	r6, #255	; 0xff
    7508:	2300      	movs	r3, #0
    750a:	428e      	cmp	r6, r1
    750c:	415b      	adcs	r3, r3
    750e:	7003      	strb	r3, [r0, #0]
#endif

  // If bytes-per-pixel has changed (and pixel data was previously
  // allocated), re-allocate to new size.  Will clear any data.
  if(pixels) {
    7510:	6883      	ldr	r3, [r0, #8]
    numLEDs = numBytes = 0;
  }
}

void Adafruit_NeoPixel::updateType(neoPixelType t) {
  boolean oldThreeBytesPerPixel = (wOffset == rOffset); // false if RGBW
    7512:	b2ed      	uxtb	r5, r5

  wOffset = (t >> 6) & 0b11; // See notes in header file
    7514:	73c4      	strb	r4, [r0, #15]
  rOffset = (t >> 4) & 0b11; // regarding R/G/B/W offsets
    7516:	7302      	strb	r2, [r0, #12]
  is800KHz = (t < 256);      // 400 KHz flag is 1<<8
#endif

  // If bytes-per-pixel has changed (and pixel data was previously
  // allocated), re-allocate to new size.  Will clear any data.
  if(pixels) {
    7518:	2b00      	cmp	r3, #0
    751a:	d007      	beq.n	752c <_ZN17Adafruit_NeoPixel10updateTypeEt+0x46>
    boolean newThreeBytesPerPixel = (wOffset == rOffset);
    751c:	1aa2      	subs	r2, r4, r2
    751e:	4253      	negs	r3, r2
    7520:	4153      	adcs	r3, r2
    if(newThreeBytesPerPixel != oldThreeBytesPerPixel) updateLength(numLEDs);
    7522:	42ab      	cmp	r3, r5
    7524:	d002      	beq.n	752c <_ZN17Adafruit_NeoPixel10updateTypeEt+0x46>
    7526:	8841      	ldrh	r1, [r0, #2]
    7528:	f7ff ffbd 	bl	74a6 <_ZN17Adafruit_NeoPixel12updateLengthEt>
  }
}
    752c:	bd70      	pop	{r4, r5, r6, pc}
	...

00007530 <_ZN17Adafruit_NeoPixel4showEv>:
// ESP8266 show() is external to enforce ICACHE_RAM_ATTR execution
extern "C" void ICACHE_RAM_ATTR espShow(
  uint8_t pin, uint8_t *pixels, uint32_t numBytes, uint8_t type);
#endif // ESP8266

void Adafruit_NeoPixel::show(void) {
    7530:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  if(!pixels) return;
    7532:	6883      	ldr	r3, [r0, #8]
// ESP8266 show() is external to enforce ICACHE_RAM_ATTR execution
extern "C" void ICACHE_RAM_ATTR espShow(
  uint8_t pin, uint8_t *pixels, uint32_t numBytes, uint8_t type);
#endif // ESP8266

void Adafruit_NeoPixel::show(void) {
    7534:	1c04      	adds	r4, r0, #0

  if(!pixels) return;
    7536:	2b00      	cmp	r3, #0
    7538:	d100      	bne.n	753c <_ZN17Adafruit_NeoPixel4showEv+0xc>
    753a:	e068      	b.n	760e <_ZN17Adafruit_NeoPixel4showEv+0xde>
    Color(uint8_t r, uint8_t g, uint8_t b),
    Color(uint8_t r, uint8_t g, uint8_t b, uint8_t w);
  uint32_t
    getPixelColor(uint16_t n) const;
  inline bool
    canShow(void) { return (micros() - endTime) >= 50L; }
    753c:	f007 fef6 	bl	f32c <micros>
    7540:	6923      	ldr	r3, [r4, #16]
    7542:	1ac0      	subs	r0, r0, r3
  // put a delay at the end of the function, the ending time is noted and
  // the function will simply hold off (if needed) on issuing the
  // subsequent round of data until the latch time has elapsed.  This
  // allows the mainline code to start generating the next frame of data
  // rather than stalling for the latch.
  while(!canShow());
    7544:	2831      	cmp	r0, #49	; 0x31
    7546:	d9f9      	bls.n	753c <_ZN17Adafruit_NeoPixel4showEv+0xc>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    7548:	b672      	cpsid	i
  // resolution.  So yay, you get a load of goofball NOPs...

  uint8_t  *ptr, *end, p, bitMask, portNum;
  uint32_t  pinMask;

  portNum =  g_APinDescription[pin].ulPort;
    754a:	2306      	movs	r3, #6
    754c:	56e3      	ldrsb	r3, [r4, r3]
  pinMask =  1ul << g_APinDescription[pin].ulPin;
    754e:	2718      	movs	r7, #24
    7550:	435f      	muls	r7, r3
    7552:	4d2f      	ldr	r5, [pc, #188]	; (7610 <_ZN17Adafruit_NeoPixel4showEv+0xe0>)
    7554:	2101      	movs	r1, #1
    7556:	19eb      	adds	r3, r5, r7
    7558:	685b      	ldr	r3, [r3, #4]
  ptr     =  pixels;
  end     =  ptr + numBytes;
    755a:	88a6      	ldrh	r6, [r4, #4]

  uint8_t  *ptr, *end, p, bitMask, portNum;
  uint32_t  pinMask;

  portNum =  g_APinDescription[pin].ulPort;
  pinMask =  1ul << g_APinDescription[pin].ulPin;
    755c:	4099      	lsls	r1, r3
  ptr     =  pixels;
    755e:	68a3      	ldr	r3, [r4, #8]
  end     =  ptr + numBytes;
  p       = *ptr++;
  bitMask =  0x80;

  volatile uint32_t *set = &(PORT->Group[portNum].OUTSET.reg),
    7560:	5d7d      	ldrb	r5, [r7, r5]
  uint32_t  pinMask;

  portNum =  g_APinDescription[pin].ulPort;
  pinMask =  1ul << g_APinDescription[pin].ulPin;
  ptr     =  pixels;
  end     =  ptr + numBytes;
    7562:	199e      	adds	r6, r3, r6
  p       = *ptr++;
    7564:	1c5a      	adds	r2, r3, #1
    7566:	7818      	ldrb	r0, [r3, #0]
  bitMask =  0x80;

  volatile uint32_t *set = &(PORT->Group[portNum].OUTSET.reg),
    7568:	4b2a      	ldr	r3, [pc, #168]	; (7614 <_ZN17Adafruit_NeoPixel4showEv+0xe4>)
    756a:	01ed      	lsls	r5, r5, #7
    756c:	18ef      	adds	r7, r5, r3
                    *clr = &(PORT->Group[portNum].OUTCLR.reg);
    756e:	4b2a      	ldr	r3, [pc, #168]	; (7618 <_ZN17Adafruit_NeoPixel4showEv+0xe8>)
    7570:	18ed      	adds	r5, r5, r3
  portNum =  g_APinDescription[pin].ulPort;
  pinMask =  1ul << g_APinDescription[pin].ulPin;
  ptr     =  pixels;
  end     =  ptr + numBytes;
  p       = *ptr++;
  bitMask =  0x80;
    7572:	2380      	movs	r3, #128	; 0x80

  volatile uint32_t *set = &(PORT->Group[portNum].OUTSET.reg),
                    *clr = &(PORT->Group[portNum].OUTCLR.reg);

  for(;;) {
    *set = pinMask;
    7574:	6039      	str	r1, [r7, #0]
    asm("nop; nop; nop; nop; nop; nop; nop; nop;");
    7576:	46c0      	nop			; (mov r8, r8)
    7578:	46c0      	nop			; (mov r8, r8)
    757a:	46c0      	nop			; (mov r8, r8)
    757c:	46c0      	nop			; (mov r8, r8)
    757e:	46c0      	nop			; (mov r8, r8)
    7580:	46c0      	nop			; (mov r8, r8)
    7582:	46c0      	nop			; (mov r8, r8)
    7584:	46c0      	nop			; (mov r8, r8)
    if(p & bitMask) {
    7586:	4218      	tst	r0, r3
    7588:	d015      	beq.n	75b6 <_ZN17Adafruit_NeoPixel4showEv+0x86>
      asm("nop; nop; nop; nop; nop; nop; nop; nop;"
          "nop; nop; nop; nop; nop; nop; nop; nop;"
          "nop; nop; nop; nop;");
    758a:	46c0      	nop			; (mov r8, r8)
    758c:	46c0      	nop			; (mov r8, r8)
    758e:	46c0      	nop			; (mov r8, r8)
    7590:	46c0      	nop			; (mov r8, r8)
    7592:	46c0      	nop			; (mov r8, r8)
    7594:	46c0      	nop			; (mov r8, r8)
    7596:	46c0      	nop			; (mov r8, r8)
    7598:	46c0      	nop			; (mov r8, r8)
    759a:	46c0      	nop			; (mov r8, r8)
    759c:	46c0      	nop			; (mov r8, r8)
    759e:	46c0      	nop			; (mov r8, r8)
    75a0:	46c0      	nop			; (mov r8, r8)
    75a2:	46c0      	nop			; (mov r8, r8)
    75a4:	46c0      	nop			; (mov r8, r8)
    75a6:	46c0      	nop			; (mov r8, r8)
    75a8:	46c0      	nop			; (mov r8, r8)
    75aa:	46c0      	nop			; (mov r8, r8)
    75ac:	46c0      	nop			; (mov r8, r8)
    75ae:	46c0      	nop			; (mov r8, r8)
    75b0:	46c0      	nop			; (mov r8, r8)
      *clr = pinMask;
    75b2:	6029      	str	r1, [r5, #0]
    75b4:	e014      	b.n	75e0 <_ZN17Adafruit_NeoPixel4showEv+0xb0>
    } else {
      *clr = pinMask;
    75b6:	6029      	str	r1, [r5, #0]
      asm("nop; nop; nop; nop; nop; nop; nop; nop;"
          "nop; nop; nop; nop; nop; nop; nop; nop;"
          "nop; nop; nop; nop;");
    75b8:	46c0      	nop			; (mov r8, r8)
    75ba:	46c0      	nop			; (mov r8, r8)
    75bc:	46c0      	nop			; (mov r8, r8)
    75be:	46c0      	nop			; (mov r8, r8)
    75c0:	46c0      	nop			; (mov r8, r8)
    75c2:	46c0      	nop			; (mov r8, r8)
    75c4:	46c0      	nop			; (mov r8, r8)
    75c6:	46c0      	nop			; (mov r8, r8)
    75c8:	46c0      	nop			; (mov r8, r8)
    75ca:	46c0      	nop			; (mov r8, r8)
    75cc:	46c0      	nop			; (mov r8, r8)
    75ce:	46c0      	nop			; (mov r8, r8)
    75d0:	46c0      	nop			; (mov r8, r8)
    75d2:	46c0      	nop			; (mov r8, r8)
    75d4:	46c0      	nop			; (mov r8, r8)
    75d6:	46c0      	nop			; (mov r8, r8)
    75d8:	46c0      	nop			; (mov r8, r8)
    75da:	46c0      	nop			; (mov r8, r8)
    75dc:	46c0      	nop			; (mov r8, r8)
    75de:	46c0      	nop			; (mov r8, r8)
    }
    if(bitMask >>= 1) {
    75e0:	085b      	lsrs	r3, r3, #1
    75e2:	d009      	beq.n	75f8 <_ZN17Adafruit_NeoPixel4showEv+0xc8>
        asm("nop; nop; nop; nop; nop; nop; nop; nop; nop;");
    75e4:	46c0      	nop			; (mov r8, r8)
    75e6:	46c0      	nop			; (mov r8, r8)
    75e8:	46c0      	nop			; (mov r8, r8)
    75ea:	46c0      	nop			; (mov r8, r8)
    75ec:	46c0      	nop			; (mov r8, r8)
    75ee:	46c0      	nop			; (mov r8, r8)
    75f0:	46c0      	nop			; (mov r8, r8)
    75f2:	46c0      	nop			; (mov r8, r8)
    75f4:	46c0      	nop			; (mov r8, r8)
    75f6:	e7bd      	b.n	7574 <_ZN17Adafruit_NeoPixel4showEv+0x44>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    75f8:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    75fa:	b672      	cpsid	i
    } else {
      interrupts();
      noInterrupts();
      if(ptr >= end) break;
    75fc:	42b2      	cmp	r2, r6
    75fe:	d202      	bcs.n	7606 <_ZN17Adafruit_NeoPixel4showEv+0xd6>
      p       = *ptr++;
    7600:	7810      	ldrb	r0, [r2, #0]
    7602:	3201      	adds	r2, #1
    7604:	e7b5      	b.n	7572 <_ZN17Adafruit_NeoPixel4showEv+0x42>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    7606:	b662      	cpsie	i
      bitMask = 0x80;
    }
  }

  interrupts();
  endTime = micros(); // Save EOD time for latch on next call
    7608:	f007 fe90 	bl	f32c <micros>
    760c:	6120      	str	r0, [r4, #16]
}
    760e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7610:	000156a8 	.word	0x000156a8
    7614:	41004418 	.word	0x41004418
    7618:	41004414 	.word	0x41004414

0000761c <_ZN17Adafruit_NeoPixel6setPinEh>:

// Set the output pin number
void Adafruit_NeoPixel::setPin(uint8_t p) {
    761c:	b538      	push	{r3, r4, r5, lr}
  if(begun && (pin >= 0)) pinMode(pin, INPUT);
    761e:	7843      	ldrb	r3, [r0, #1]
  interrupts();
  endTime = micros(); // Save EOD time for latch on next call
}

// Set the output pin number
void Adafruit_NeoPixel::setPin(uint8_t p) {
    7620:	1c04      	adds	r4, r0, #0
    7622:	1c0d      	adds	r5, r1, #0
  if(begun && (pin >= 0)) pinMode(pin, INPUT);
    7624:	2b00      	cmp	r3, #0
    7626:	d006      	beq.n	7636 <_ZN17Adafruit_NeoPixel6setPinEh+0x1a>
    7628:	2006      	movs	r0, #6
    762a:	5620      	ldrsb	r0, [r4, r0]
    762c:	2800      	cmp	r0, #0
    762e:	db02      	blt.n	7636 <_ZN17Adafruit_NeoPixel6setPinEh+0x1a>
    7630:	2100      	movs	r1, #0
    7632:	f008 f999 	bl	f968 <pinMode>
    pin = p;
    if(begun) {
    7636:	7863      	ldrb	r3, [r4, #1]
}

// Set the output pin number
void Adafruit_NeoPixel::setPin(uint8_t p) {
  if(begun && (pin >= 0)) pinMode(pin, INPUT);
    pin = p;
    7638:	71a5      	strb	r5, [r4, #6]
    if(begun) {
    763a:	2b00      	cmp	r3, #0
    763c:	d007      	beq.n	764e <_ZN17Adafruit_NeoPixel6setPinEh+0x32>
      pinMode(p, OUTPUT);
    763e:	1c28      	adds	r0, r5, #0
    7640:	2101      	movs	r1, #1
    7642:	f008 f991 	bl	f968 <pinMode>
      digitalWrite(p, LOW);
    7646:	1c28      	adds	r0, r5, #0
    7648:	2100      	movs	r1, #0
    764a:	f008 f9e7 	bl	fa1c <digitalWrite>
    }
#ifdef __AVR__
    port    = portOutputRegister(digitalPinToPort(p));
    pinMask = digitalPinToBitMask(p);
#endif
}
    764e:	bd38      	pop	{r3, r4, r5, pc}

00007650 <_ZN17Adafruit_NeoPixelC1Etht>:
  -------------------------------------------------------------------------*/

#include "Adafruit_NeoPixel.h"

// Constructor when length, pin and type are known at compile-time:
Adafruit_NeoPixel::Adafruit_NeoPixel(uint16_t n, uint8_t p, neoPixelType t) :
    7650:	b570      	push	{r4, r5, r6, lr}
    7652:	1c04      	adds	r4, r0, #0
  begun(false), brightness(0), pixels(NULL), endTime(0)
    7654:	2000      	movs	r0, #0
  -------------------------------------------------------------------------*/

#include "Adafruit_NeoPixel.h"

// Constructor when length, pin and type are known at compile-time:
Adafruit_NeoPixel::Adafruit_NeoPixel(uint16_t n, uint8_t p, neoPixelType t) :
    7656:	1c0e      	adds	r6, r1, #0
  begun(false), brightness(0), pixels(NULL), endTime(0)
    7658:	7060      	strb	r0, [r4, #1]
{
  updateType(t);
    765a:	1c19      	adds	r1, r3, #0

#include "Adafruit_NeoPixel.h"

// Constructor when length, pin and type are known at compile-time:
Adafruit_NeoPixel::Adafruit_NeoPixel(uint16_t n, uint8_t p, neoPixelType t) :
  begun(false), brightness(0), pixels(NULL), endTime(0)
    765c:	71e0      	strb	r0, [r4, #7]
    765e:	60a0      	str	r0, [r4, #8]
    7660:	6120      	str	r0, [r4, #16]
{
  updateType(t);
    7662:	1c20      	adds	r0, r4, #0
  -------------------------------------------------------------------------*/

#include "Adafruit_NeoPixel.h"

// Constructor when length, pin and type are known at compile-time:
Adafruit_NeoPixel::Adafruit_NeoPixel(uint16_t n, uint8_t p, neoPixelType t) :
    7664:	1c15      	adds	r5, r2, #0
  begun(false), brightness(0), pixels(NULL), endTime(0)
{
  updateType(t);
    7666:	f7ff ff3e 	bl	74e6 <_ZN17Adafruit_NeoPixel10updateTypeEt>
  updateLength(n);
    766a:	1c31      	adds	r1, r6, #0
    766c:	1c20      	adds	r0, r4, #0
    766e:	f7ff ff1a 	bl	74a6 <_ZN17Adafruit_NeoPixel12updateLengthEt>
  setPin(p);
    7672:	1c20      	adds	r0, r4, #0
    7674:	1c29      	adds	r1, r5, #0
    7676:	f7ff ffd1 	bl	761c <_ZN17Adafruit_NeoPixel6setPinEh>
}
    767a:	1c20      	adds	r0, r4, #0
    767c:	bd70      	pop	{r4, r5, r6, pc}

0000767e <_ZN17Adafruit_NeoPixel13setPixelColorEthhh>:
#endif
}

// Set pixel color from separate R,G,B components:
void Adafruit_NeoPixel::setPixelColor(
 uint16_t n, uint8_t r, uint8_t g, uint8_t b) {
    767e:	b5f0      	push	{r4, r5, r6, r7, lr}
    7680:	ac05      	add	r4, sp, #20
    7682:	7825      	ldrb	r5, [r4, #0]

  if(n < numLEDs) {
    7684:	8844      	ldrh	r4, [r0, #2]
    7686:	428c      	cmp	r4, r1
    7688:	d91b      	bls.n	76c2 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x44>
    if(brightness) { // See notes in setBrightness()
    768a:	79c4      	ldrb	r4, [r0, #7]
    768c:	2c00      	cmp	r4, #0
    768e:	d005      	beq.n	769c <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x1e>
      r = (r * brightness) >> 8;
    7690:	4362      	muls	r2, r4
      g = (g * brightness) >> 8;
    7692:	4363      	muls	r3, r4
      b = (b * brightness) >> 8;
    7694:	4365      	muls	r5, r4
void Adafruit_NeoPixel::setPixelColor(
 uint16_t n, uint8_t r, uint8_t g, uint8_t b) {

  if(n < numLEDs) {
    if(brightness) { // See notes in setBrightness()
      r = (r * brightness) >> 8;
    7696:	0a12      	lsrs	r2, r2, #8
      g = (g * brightness) >> 8;
    7698:	0a1b      	lsrs	r3, r3, #8
      b = (b * brightness) >> 8;
    769a:	0a2d      	lsrs	r5, r5, #8
    }
    uint8_t *p;
    if(wOffset == rOffset) { // Is an RGB-type strip
    769c:	7bc4      	ldrb	r4, [r0, #15]
    769e:	7b07      	ldrb	r7, [r0, #12]
    76a0:	6886      	ldr	r6, [r0, #8]
    76a2:	42a7      	cmp	r7, r4
    76a4:	d103      	bne.n	76ae <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x30>
      p = &pixels[n * 3];    // 3 bytes per pixel
    76a6:	2403      	movs	r4, #3
    76a8:	4361      	muls	r1, r4
    76aa:	1871      	adds	r1, r6, r1
    76ac:	e003      	b.n	76b6 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x38>
    } else {                 // Is a WRGB-type strip
      p = &pixels[n * 4];    // 4 bytes per pixel
    76ae:	0089      	lsls	r1, r1, #2
    76b0:	1871      	adds	r1, r6, r1
      p[wOffset] = 0;        // But only R,G,B passed -- set W to 0
    76b2:	2600      	movs	r6, #0
    76b4:	550e      	strb	r6, [r1, r4]
    }
    p[rOffset] = r;          // R,G,B always stored
    76b6:	7b04      	ldrb	r4, [r0, #12]
    76b8:	550a      	strb	r2, [r1, r4]
    p[gOffset] = g;
    76ba:	7b42      	ldrb	r2, [r0, #13]
    76bc:	548b      	strb	r3, [r1, r2]
    p[bOffset] = b;
    76be:	7b83      	ldrb	r3, [r0, #14]
    76c0:	54cd      	strb	r5, [r1, r3]
  }
}
    76c2:	bdf0      	pop	{r4, r5, r6, r7, pc}

000076c4 <_ZNK17Adafruit_NeoPixel9numPixelsEv>:
uint8_t *Adafruit_NeoPixel::getPixels(void) const {
  return pixels;
}

uint16_t Adafruit_NeoPixel::numPixels(void) const {
  return numLEDs;
    76c4:	8840      	ldrh	r0, [r0, #2]
}
    76c6:	4770      	bx	lr

000076c8 <_ZN17Adafruit_NeoPixel13setBrightnessEh>:
// and scale it (subsequent graphics commands also work at this
// brightness level).  If there's a significant step up in brightness,
// the limited number of steps (quantization) in the old data will be
// quite visible in the re-scaled version.  For a non-destructive
// change, you'll need to re-render the full strip data.  C'est la vie.
void Adafruit_NeoPixel::setBrightness(uint8_t b) {
    76c8:	b570      	push	{r4, r5, r6, lr}
    76ca:	1c0b      	adds	r3, r1, #0
  // This simplifies the actual scaling math later, allowing a fast
  // 8x8-bit multiply and taking the MSB.  'brightness' is a uint8_t,
  // adding 1 here may (intentionally) roll over...so 0 = max brightness
  // (color values are interpreted literally; no scaling), 1 = min
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
    76cc:	1c4d      	adds	r5, r1, #1
  if(newBrightness != brightness) { // Compare against prior value
    76ce:	79c1      	ldrb	r1, [r0, #7]
  // This simplifies the actual scaling math later, allowing a fast
  // 8x8-bit multiply and taking the MSB.  'brightness' is a uint8_t,
  // adding 1 here may (intentionally) roll over...so 0 = max brightness
  // (color values are interpreted literally; no scaling), 1 = min
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
    76d0:	b2ed      	uxtb	r5, r5
// and scale it (subsequent graphics commands also work at this
// brightness level).  If there's a significant step up in brightness,
// the limited number of steps (quantization) in the old data will be
// quite visible in the re-scaled version.  For a non-destructive
// change, you'll need to re-render the full strip data.  C'est la vie.
void Adafruit_NeoPixel::setBrightness(uint8_t b) {
    76d2:	1c04      	adds	r4, r0, #0
  // 8x8-bit multiply and taking the MSB.  'brightness' is a uint8_t,
  // adding 1 here may (intentionally) roll over...so 0 = max brightness
  // (color values are interpreted literally; no scaling), 1 = min
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
  if(newBrightness != brightness) { // Compare against prior value
    76d4:	428d      	cmp	r5, r1
    76d6:	d01b      	beq.n	7710 <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x48>
    // Brightness has changed -- re-scale existing data in RAM
    uint8_t  c,
            *ptr           = pixels,
             oldBrightness = brightness - 1; // De-wrap old brightness value
    76d8:	3901      	subs	r1, #1
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
  if(newBrightness != brightness) { // Compare against prior value
    // Brightness has changed -- re-scale existing data in RAM
    uint8_t  c,
            *ptr           = pixels,
    76da:	6886      	ldr	r6, [r0, #8]
             oldBrightness = brightness - 1; // De-wrap old brightness value
    76dc:	b2c9      	uxtb	r1, r1
    uint16_t scale;
    if(oldBrightness == 0) scale = 0; // Avoid /0
    76de:	2000      	movs	r0, #0
    76e0:	4281      	cmp	r1, r0
    76e2:	d008      	beq.n	76f6 <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x2e>
    else if(b == 255) scale = 65535 / oldBrightness;
    76e4:	2bff      	cmp	r3, #255	; 0xff
    76e6:	d101      	bne.n	76ec <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x24>
    76e8:	480a      	ldr	r0, [pc, #40]	; (7714 <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x4c>)
    76ea:	e001      	b.n	76f0 <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x28>
    else scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
    76ec:	0228      	lsls	r0, r5, #8
    76ee:	3801      	subs	r0, #1
    76f0:	f009 fea0 	bl	11434 <__aeabi_idiv>
    76f4:	b280      	uxth	r0, r0
    for(uint16_t i=0; i<numBytes; i++) {
    76f6:	1c33      	adds	r3, r6, #0
    76f8:	1b9a      	subs	r2, r3, r6
    76fa:	88a1      	ldrh	r1, [r4, #4]
    76fc:	b292      	uxth	r2, r2
    76fe:	4291      	cmp	r1, r2
    7700:	d905      	bls.n	770e <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x46>
      c      = *ptr;
      *ptr++ = (c * scale) >> 8;
    7702:	781a      	ldrb	r2, [r3, #0]
    7704:	4342      	muls	r2, r0
    7706:	1212      	asrs	r2, r2, #8
    7708:	701a      	strb	r2, [r3, #0]
    770a:	3301      	adds	r3, #1
    770c:	e7f4      	b.n	76f8 <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x30>
    }
    brightness = newBrightness;
    770e:	71e5      	strb	r5, [r4, #7]
  }
}
    7710:	bd70      	pop	{r4, r5, r6, pc}
    7712:	46c0      	nop			; (mov r8, r8)
    7714:	0000ffff 	.word	0x0000ffff

00007718 <_ZNK17Adafruit_NeoPixel13getBrightnessEv>:

//Return the brightness value
uint8_t Adafruit_NeoPixel::getBrightness(void) const {
  return brightness - 1;
    7718:	79c0      	ldrb	r0, [r0, #7]
    771a:	3801      	subs	r0, #1
    771c:	b2c0      	uxtb	r0, r0
}
    771e:	4770      	bx	lr

00007720 <_ZN17Adafruit_NeoPixel5clearEv>:

void Adafruit_NeoPixel::clear() {
    7720:	b508      	push	{r3, lr}
  memset(pixels, 0, numBytes);
    7722:	2100      	movs	r1, #0
    7724:	8882      	ldrh	r2, [r0, #4]
    7726:	6880      	ldr	r0, [r0, #8]
    7728:	f009 ff50 	bl	115cc <memset>
}
    772c:	bd08      	pop	{r3, pc}

0000772e <_ZN14Gamebuino_Meta16Adafruit_ZeroDMAC1Ev>:

namespace Gamebuino_Meta {

// mostly from asfdoc_sam0_dma_basic_use_case.html

Adafruit_ZeroDMA::Adafruit_ZeroDMA(void) {
    772e:	b510      	push	{r4, lr}
    7730:	1c04      	adds	r4, r0, #0
  dma_get_config_defaults(&_config);
    7732:	f000 f8b5 	bl	78a0 <dma_get_config_defaults>
}
    7736:	1c20      	adds	r0, r4, #0
    7738:	bd10      	pop	{r4, pc}

0000773a <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA27configure_peripheraltriggerEm>:

void Adafruit_ZeroDMA::configure_peripheraltrigger(uint32_t periphtrigger) {
  _config.peripheral_trigger = periphtrigger;
    773a:	7041      	strb	r1, [r0, #1]
  //Serial.print("periph trigger: 0x"); Serial.println(periphtrigger,HEX);
}
    773c:	4770      	bx	lr

0000773e <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA23configure_triggeractionE27dma_transfer_trigger_action>:

void Adafruit_ZeroDMA::configure_triggeraction(dma_transfer_trigger_action action) {
  _config.trigger_action = action;
    773e:	7081      	strb	r1, [r0, #2]
}
    7740:	4770      	bx	lr

00007742 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA8allocateEv>:

status_code Adafruit_ZeroDMA::allocate(void) {
    7742:	b508      	push	{r3, lr}
    7744:	1c01      	adds	r1, r0, #0
  return dma_allocate(&_resource, &_config);
    7746:	3030      	adds	r0, #48	; 0x30
    7748:	f000 f8b2 	bl	78b0 <dma_allocate>
}
    774c:	bd08      	pop	{r3, pc}

0000774e <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA25setup_transfer_descriptorEPvS1_m13dma_beat_sizebb>:

void Adafruit_ZeroDMA::setup_transfer_descriptor(void *source_memory, void *destination_memory, uint32_t xfercount, dma_beat_size beatsize, bool srcinc, bool destinc)
{
    774e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    7750:	ac08      	add	r4, sp, #32
    7752:	7826      	ldrb	r6, [r4, #0]
    7754:	ac09      	add	r4, sp, #36	; 0x24
    7756:	7824      	ldrb	r4, [r4, #0]
    7758:	46a4      	mov	ip, r4
    775a:	ac0a      	add	r4, sp, #40	; 0x28
    775c:	7824      	ldrb	r4, [r4, #0]
    775e:	9400      	str	r4, [sp, #0]
    7760:	2401      	movs	r4, #1
  uint8_t countsize;
  if (beatsize == DMA_BEAT_SIZE_BYTE) countsize = 1;
  if (beatsize == DMA_BEAT_SIZE_HWORD) countsize = 2; // in bytes
    7762:	42a6      	cmp	r6, r4
    7764:	d004      	beq.n	7770 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA25setup_transfer_descriptorEPvS1_m13dma_beat_sizebb+0x22>
  if (beatsize == DMA_BEAT_SIZE_WORD) countsize = 4;  // in bytes
    7766:	2504      	movs	r5, #4
    7768:	2e02      	cmp	r6, #2
    776a:	d002      	beq.n	7772 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA25setup_transfer_descriptorEPvS1_m13dma_beat_sizebb+0x24>
    776c:	1c25      	adds	r5, r4, #0
    776e:	e000      	b.n	7772 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA25setup_transfer_descriptorEPvS1_m13dma_beat_sizebb+0x24>

void Adafruit_ZeroDMA::setup_transfer_descriptor(void *source_memory, void *destination_memory, uint32_t xfercount, dma_beat_size beatsize, bool srcinc, bool destinc)
{
  uint8_t countsize;
  if (beatsize == DMA_BEAT_SIZE_BYTE) countsize = 1;
  if (beatsize == DMA_BEAT_SIZE_HWORD) countsize = 2; // in bytes
    7770:	2502      	movs	r5, #2
static inline void dma_descriptor_get_config_defaults(struct dma_descriptor_config *config)
{
	Assert(config);

	/* Set descriptor as valid */
	config->descriptor_valid = true;
    7772:	7204      	strb	r4, [r0, #8]
	/* Disable event output */
	config->event_output_selection = DMA_EVENT_OUTPUT_DISABLE;
    7774:	2400      	movs	r4, #0
  if (beatsize == DMA_BEAT_SIZE_WORD) countsize = 4;  // in bytes
    
    dma_descriptor_get_config_defaults(&descriptor_config);
    7776:	1c07      	adds	r7, r0, #0
    7778:	7244      	strb	r4, [r0, #9]
	/* No block action */
	config->block_action = DMA_BLOCK_ACTION_NOACT;
    777a:	7284      	strb	r4, [r0, #10]
	/* Enable source increment */
	config->src_increment_enable = true;
	/* Enable destination increment */
	config->dst_increment_enable = true;
	/* Step size is applied to the destination address */
	config->step_selection = DMA_STEPSEL_DST;
    777c:	7384      	strb	r4, [r0, #14]
	/* Address increment is beat size multiplied by 1*/
	config->step_size = DMA_ADDRESS_INCREMENT_STEP_SIZE_1;
    777e:	73c4      	strb	r4, [r0, #15]
	/* Default transfer size is set to 0 */
	config->block_transfer_count = 0;
	/* Default source address is set to NULL */
	config->source_address = (uint32_t)NULL;
    7780:	6144      	str	r4, [r0, #20]
	/* Default destination address is set to NULL */
	config->destination_address = (uint32_t)NULL;
    7782:	6184      	str	r4, [r0, #24]
	/** Next descriptor address set to 0 */
	config->next_descriptor_address = 0;
    7784:	61c4      	str	r4, [r0, #28]

    descriptor_config.beat_size = beatsize;
    descriptor_config.dst_increment_enable = destinc;
    7786:	9c00      	ldr	r4, [sp, #0]
  uint8_t countsize;
  if (beatsize == DMA_BEAT_SIZE_BYTE) countsize = 1;
  if (beatsize == DMA_BEAT_SIZE_HWORD) countsize = 2; // in bytes
  if (beatsize == DMA_BEAT_SIZE_WORD) countsize = 4;  // in bytes
    
    dma_descriptor_get_config_defaults(&descriptor_config);
    7788:	3708      	adds	r7, #8
    778a:	9701      	str	r7, [sp, #4]

    descriptor_config.beat_size = beatsize;
    descriptor_config.dst_increment_enable = destinc;
    778c:	7344      	strb	r4, [r0, #13]
    descriptor_config.src_increment_enable = srcinc;
    778e:	4667      	mov	r7, ip

    descriptor_config.block_transfer_count = xfercount;

    descriptor_config.source_address = (uint32_t)source_memory;
    if (srcinc) 
    7790:	4664      	mov	r4, ip
  if (beatsize == DMA_BEAT_SIZE_HWORD) countsize = 2; // in bytes
  if (beatsize == DMA_BEAT_SIZE_WORD) countsize = 4;  // in bytes
    
    dma_descriptor_get_config_defaults(&descriptor_config);

    descriptor_config.beat_size = beatsize;
    7792:	72c6      	strb	r6, [r0, #11]
    descriptor_config.dst_increment_enable = destinc;
    descriptor_config.src_increment_enable = srcinc;
    7794:	7307      	strb	r7, [r0, #12]

    descriptor_config.block_transfer_count = xfercount;
    7796:	8203      	strh	r3, [r0, #16]

    descriptor_config.source_address = (uint32_t)source_memory;
    if (srcinc) 
    7798:	2c00      	cmp	r4, #0
    779a:	d002      	beq.n	77a2 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA25setup_transfer_descriptorEPvS1_m13dma_beat_sizebb+0x54>
      descriptor_config.source_address += countsize*xfercount; // the *end* of the transfer
    779c:	1c1c      	adds	r4, r3, #0
    779e:	436c      	muls	r4, r5
    77a0:	1861      	adds	r1, r4, r1

    descriptor_config.destination_address = (uint32_t)destination_memory;
    if (destinc) 
    77a2:	9f00      	ldr	r7, [sp, #0]

    descriptor_config.block_transfer_count = xfercount;

    descriptor_config.source_address = (uint32_t)source_memory;
    if (srcinc) 
      descriptor_config.source_address += countsize*xfercount; // the *end* of the transfer
    77a4:	6141      	str	r1, [r0, #20]

    descriptor_config.destination_address = (uint32_t)destination_memory;
    if (destinc) 
    77a6:	2f00      	cmp	r7, #0
    77a8:	d001      	beq.n	77ae <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA25setup_transfer_descriptorEPvS1_m13dma_beat_sizebb+0x60>
       descriptor_config.destination_address += countsize*xfercount; // the *end* of the transfer
    77aa:	435d      	muls	r5, r3
    77ac:	18aa      	adds	r2, r5, r2
    77ae:	6182      	str	r2, [r0, #24]

    dma_descriptor_create(&_descriptor, &descriptor_config);
    77b0:	9901      	ldr	r1, [sp, #4]
    77b2:	3020      	adds	r0, #32
    77b4:	f000 f97c 	bl	7ab0 <dma_descriptor_create>
}
    77b8:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

000077ba <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA14add_descriptorEv>:

status_code Adafruit_ZeroDMA::add_descriptor(void) {
    77ba:	b508      	push	{r3, lr}
    77bc:	1c01      	adds	r1, r0, #0
   return dma_add_descriptor(&_resource, &_descriptor);
    77be:	3120      	adds	r1, #32
    77c0:	3030      	adds	r0, #48	; 0x30
    77c2:	f000 f9c9 	bl	7b58 <dma_add_descriptor>
}
    77c6:	bd08      	pop	{r3, pc}

000077c8 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA4freeEv>:

status_code Adafruit_ZeroDMA::free(void) {
    77c8:	b508      	push	{r3, lr}
   return dma_free(&_resource);
    77ca:	3030      	adds	r0, #48	; 0x30
    77cc:	f000 f908 	bl	79e0 <dma_free>
}
    77d0:	bd08      	pop	{r3, pc}

000077d2 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA18start_transfer_jobEv>:

void Adafruit_ZeroDMA::trigger_transfer(void) {
  return dma_trigger_transfer(&_resource);
}

status_code Adafruit_ZeroDMA::start_transfer_job(void) {
    77d2:	b508      	push	{r3, lr}
  return dma_start_transfer_job(&_resource);
    77d4:	3030      	adds	r0, #48	; 0x30
    77d6:	f000 f929 	bl	7a2c <dma_start_transfer_job>
}
    77da:	bd08      	pop	{r3, pc}

000077dc <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA17register_callbackEPFvP12dma_resourceE17dma_callback_type>:
static inline void dma_register_callback(struct dma_resource *resource,
		dma_callback_t callback, enum dma_callback_type type)
{
	Assert(resource);

	resource->callback[type] = callback;
    77dc:	0092      	lsls	r2, r2, #2
    77de:	1880      	adds	r0, r0, r2
    77e0:	6341      	str	r1, [r0, #52]	; 0x34

void Adafruit_ZeroDMA::register_callback(dma_callback_t callback, dma_callback_type type) {
  return dma_register_callback(&_resource, callback, type);
}
    77e2:	4770      	bx	lr

000077e4 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA15enable_callbackE17dma_callback_type>:
static inline void dma_enable_callback(struct dma_resource *resource,
		enum dma_callback_type type)
{
	Assert(resource);

	resource->callback_enable |= 1 << type;
    77e4:	2301      	movs	r3, #1
    77e6:	3030      	adds	r0, #48	; 0x30
    77e8:	408b      	lsls	r3, r1
    77ea:	1c19      	adds	r1, r3, #0
    77ec:	7c03      	ldrb	r3, [r0, #16]
	g_chan_interrupt_flag[resource->channel_id] |= (1UL << type);
    77ee:	4a04      	ldr	r2, [pc, #16]	; (7800 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA15enable_callbackE17dma_callback_type+0x1c>)
static inline void dma_enable_callback(struct dma_resource *resource,
		enum dma_callback_type type)
{
	Assert(resource);

	resource->callback_enable |= 1 << type;
    77f0:	430b      	orrs	r3, r1
    77f2:	7403      	strb	r3, [r0, #16]
	g_chan_interrupt_flag[resource->channel_id] |= (1UL << type);
    77f4:	7803      	ldrb	r3, [r0, #0]
    77f6:	5cd0      	ldrb	r0, [r2, r3]
    77f8:	4301      	orrs	r1, r0
    77fa:	54d1      	strb	r1, [r2, r3]

void Adafruit_ZeroDMA::enable_callback(dma_callback_type type) {
  return dma_enable_callback(&_resource, type);
}
    77fc:	4770      	bx	lr
    77fe:	46c0      	nop			; (mov r8, r8)
    7800:	20000c54 	.word	0x20000c54

00007804 <DMAC_Handler>:
/**
 * \brief DMA interrupt service routine.
 *
 */
void DMAC_Handler( void )
{
    7804:	b538      	push	{r3, r4, r5, lr}
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    7806:	f7ff fdf9 	bl	73fc <cpu_irq_enter_critical>
	uint32_t total_size;

	system_interrupt_enter_critical_section();

	/* Get Pending channel */
	active_channel =  DMAC->INTPEND.reg & DMAC_INTPEND_ID_Msk;
    780a:	4b1f      	ldr	r3, [pc, #124]	; (7888 <DMAC_Handler+0x84>)

	Assert(_dma_active_resource[active_channel]);

	/* Get active DMA resource based on channel */
	resource = _dma_active_resource[active_channel];
    780c:	4a1f      	ldr	r2, [pc, #124]	; (788c <DMAC_Handler+0x88>)
	uint32_t total_size;

	system_interrupt_enter_critical_section();

	/* Get Pending channel */
	active_channel =  DMAC->INTPEND.reg & DMAC_INTPEND_ID_Msk;
    780e:	8c19      	ldrh	r1, [r3, #32]
    7810:	230f      	movs	r3, #15

	Assert(_dma_active_resource[active_channel]);

	/* Get active DMA resource based on channel */
	resource = _dma_active_resource[active_channel];
    7812:	4019      	ands	r1, r3
    7814:	0089      	lsls	r1, r1, #2
    7816:	5888      	ldr	r0, [r1, r2]
	/* Select the active channel */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
	isr = DMAC->CHINTFLAG.reg;

	/* Calculate block transfer size of the DMA transfer */
	total_size = descriptor_section[resource->channel_id].BTCNT.reg;
    7818:	4c1d      	ldr	r4, [pc, #116]	; (7890 <DMAC_Handler+0x8c>)

	/* Get active DMA resource based on channel */
	resource = _dma_active_resource[active_channel];

	/* Select the active channel */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
    781a:	7802      	ldrb	r2, [r0, #0]
	isr = DMAC->CHINTFLAG.reg;

	/* Calculate block transfer size of the DMA transfer */
	total_size = descriptor_section[resource->channel_id].BTCNT.reg;
	write_size = _write_back_section[resource->channel_id].BTCNT.reg;
    781c:	4d1d      	ldr	r5, [pc, #116]	; (7894 <DMAC_Handler+0x90>)

	/* Get active DMA resource based on channel */
	resource = _dma_active_resource[active_channel];

	/* Select the active channel */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
    781e:	4013      	ands	r3, r2
    7820:	4a1d      	ldr	r2, [pc, #116]	; (7898 <DMAC_Handler+0x94>)
    7822:	7013      	strb	r3, [r2, #0]
	isr = DMAC->CHINTFLAG.reg;

	/* Calculate block transfer size of the DMA transfer */
	total_size = descriptor_section[resource->channel_id].BTCNT.reg;
    7824:	7802      	ldrb	r2, [r0, #0]
	/* Get active DMA resource based on channel */
	resource = _dma_active_resource[active_channel];

	/* Select the active channel */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
	isr = DMAC->CHINTFLAG.reg;
    7826:	4b1d      	ldr	r3, [pc, #116]	; (789c <DMAC_Handler+0x98>)

	/* Calculate block transfer size of the DMA transfer */
	total_size = descriptor_section[resource->channel_id].BTCNT.reg;
    7828:	0112      	lsls	r2, r2, #4
    782a:	18a4      	adds	r4, r4, r2
	write_size = _write_back_section[resource->channel_id].BTCNT.reg;
    782c:	18aa      	adds	r2, r5, r2
	/* Get active DMA resource based on channel */
	resource = _dma_active_resource[active_channel];

	/* Select the active channel */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
	isr = DMAC->CHINTFLAG.reg;
    782e:	7819      	ldrb	r1, [r3, #0]

	/* Calculate block transfer size of the DMA transfer */
	total_size = descriptor_section[resource->channel_id].BTCNT.reg;
    7830:	8864      	ldrh	r4, [r4, #2]
	write_size = _write_back_section[resource->channel_id].BTCNT.reg;
    7832:	8852      	ldrh	r2, [r2, #2]
	/* Get active DMA resource based on channel */
	resource = _dma_active_resource[active_channel];

	/* Select the active channel */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
	isr = DMAC->CHINTFLAG.reg;
    7834:	b2c9      	uxtb	r1, r1

	/* Calculate block transfer size of the DMA transfer */
	total_size = descriptor_section[resource->channel_id].BTCNT.reg;
	write_size = _write_back_section[resource->channel_id].BTCNT.reg;
	resource->transfered_size = total_size - write_size;
    7836:	1aa2      	subs	r2, r4, r2
    7838:	6142      	str	r2, [r0, #20]

	/* DMA channel interrupt handler */
	if (isr & DMAC_CHINTENCLR_TERR) {
    783a:	1c0c      	adds	r4, r1, #0
    783c:	2201      	movs	r2, #1
    783e:	4014      	ands	r4, r2
    7840:	d007      	beq.n	7852 <DMAC_Handler+0x4e>
		/* Clear transfer error flag */
		DMAC->CHINTFLAG.reg = DMAC_CHINTENCLR_TERR;
    7842:	701a      	strb	r2, [r3, #0]

		/* Set I/O ERROR status */
		resource->job_status = STATUS_ERR_IO;
    7844:	2310      	movs	r3, #16
    7846:	7443      	strb	r3, [r0, #17]

		/* Execute the callback function */
		if ((resource->callback_enable & (1<<DMA_CALLBACK_TRANSFER_ERROR)) &&
    7848:	7c03      	ldrb	r3, [r0, #16]
    784a:	4213      	tst	r3, r2
    784c:	d018      	beq.n	7880 <DMAC_Handler+0x7c>
				(resource->callback[DMA_CALLBACK_TRANSFER_ERROR])) {
    784e:	6843      	ldr	r3, [r0, #4]
    7850:	e013      	b.n	787a <DMAC_Handler+0x76>
			resource->callback[DMA_CALLBACK_TRANSFER_ERROR](resource);
		}
	} else if (isr & DMAC_CHINTENCLR_TCMPL) {
    7852:	2202      	movs	r2, #2
    7854:	4211      	tst	r1, r2
    7856:	d006      	beq.n	7866 <DMAC_Handler+0x62>
		/* Clear the transfer complete flag */
		DMAC->CHINTFLAG.reg = DMAC_CHINTENCLR_TCMPL;
    7858:	701a      	strb	r2, [r3, #0]

		/* Set job status */
		resource->job_status = STATUS_OK;

		/* Execute the callback function */
		if ((resource->callback_enable & (1 << DMA_CALLBACK_TRANSFER_DONE)) &&
    785a:	7c03      	ldrb	r3, [r0, #16]
	} else if (isr & DMAC_CHINTENCLR_TCMPL) {
		/* Clear the transfer complete flag */
		DMAC->CHINTFLAG.reg = DMAC_CHINTENCLR_TCMPL;

		/* Set job status */
		resource->job_status = STATUS_OK;
    785c:	7444      	strb	r4, [r0, #17]

		/* Execute the callback function */
		if ((resource->callback_enable & (1 << DMA_CALLBACK_TRANSFER_DONE)) &&
    785e:	4213      	tst	r3, r2
    7860:	d00e      	beq.n	7880 <DMAC_Handler+0x7c>
				(resource->callback[DMA_CALLBACK_TRANSFER_DONE])) {
    7862:	6883      	ldr	r3, [r0, #8]
    7864:	e009      	b.n	787a <DMAC_Handler+0x76>
			resource->callback[DMA_CALLBACK_TRANSFER_DONE](resource);
		}
	} else if (isr & DMAC_CHINTENCLR_SUSP) {
    7866:	2204      	movs	r2, #4
    7868:	4211      	tst	r1, r2
    786a:	d009      	beq.n	7880 <DMAC_Handler+0x7c>
		/* Clear channel suspend flag */
		DMAC->CHINTFLAG.reg = DMAC_CHINTENCLR_SUSP;
    786c:	701a      	strb	r2, [r3, #0]

		/* Set job status */
		resource->job_status = STATUS_SUSPEND;
    786e:	2306      	movs	r3, #6
    7870:	7443      	strb	r3, [r0, #17]

		/* Execute the callback function */
		if ((resource->callback_enable & (1 << DMA_CALLBACK_CHANNEL_SUSPEND)) &&
    7872:	7c03      	ldrb	r3, [r0, #16]
    7874:	4213      	tst	r3, r2
    7876:	d003      	beq.n	7880 <DMAC_Handler+0x7c>
			(resource->callback[DMA_CALLBACK_CHANNEL_SUSPEND])){
    7878:	68c3      	ldr	r3, [r0, #12]

		/* Set job status */
		resource->job_status = STATUS_SUSPEND;

		/* Execute the callback function */
		if ((resource->callback_enable & (1 << DMA_CALLBACK_CHANNEL_SUSPEND)) &&
    787a:	2b00      	cmp	r3, #0
    787c:	d000      	beq.n	7880 <DMAC_Handler+0x7c>
			(resource->callback[DMA_CALLBACK_CHANNEL_SUSPEND])){
			resource->callback[DMA_CALLBACK_CHANNEL_SUSPEND](resource);
    787e:	4798      	blx	r3
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    7880:	f7ff fdd8 	bl	7434 <cpu_irq_leave_critical>
		}
	}

	system_interrupt_leave_critical_section();
}
    7884:	bd38      	pop	{r3, r4, r5, pc}
    7886:	46c0      	nop			; (mov r8, r8)
    7888:	41004800 	.word	0x41004800
    788c:	20000c40 	.word	0x20000c40
    7890:	20001530 	.word	0x20001530
    7894:	20000bf0 	.word	0x20000bf0
    7898:	4100483f 	.word	0x4100483f
    789c:	4100484e 	.word	0x4100484e

000078a0 <dma_get_config_defaults>:
 */
void dma_get_config_defaults(struct dma_resource_config *config)
{
	Assert(config);
	/* Set as priority 0 */
	config->priority = DMA_PRIORITY_LEVEL_0;
    78a0:	2300      	movs	r3, #0
	/* Only software/event trigger */
	config->peripheral_trigger = 0;
	/* Transaction trigger */
	config->trigger_action = DMA_TRIGGER_ACTON_TRANSACTION;
    78a2:	2203      	movs	r2, #3
 */
void dma_get_config_defaults(struct dma_resource_config *config)
{
	Assert(config);
	/* Set as priority 0 */
	config->priority = DMA_PRIORITY_LEVEL_0;
    78a4:	7003      	strb	r3, [r0, #0]
	/* Only software/event trigger */
	config->peripheral_trigger = 0;
    78a6:	7043      	strb	r3, [r0, #1]
	/* Transaction trigger */
	config->trigger_action = DMA_TRIGGER_ACTON_TRANSACTION;
    78a8:	7082      	strb	r2, [r0, #2]

	/* Event configurations, no event input/output */
	config->event_config.input_action = DMA_EVENT_INPUT_NOACT;
    78aa:	70c3      	strb	r3, [r0, #3]
	config->event_config.event_output_enable = false;
    78ac:	7103      	strb	r3, [r0, #4]
#ifdef FEATURE_DMA_CHANNEL_STANDBY
	config->run_in_standby = false;
#endif
}
    78ae:	4770      	bx	lr

000078b0 <dma_allocate>:
 * \retval STATUS_OK The DMA resource was allocated successfully
 * \retval STATUS_ERR_NOT_FOUND DMA resource allocation failed
 */
enum status_code dma_allocate(struct dma_resource *resource,
		struct dma_resource_config *config)
{
    78b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    78b2:	1c04      	adds	r4, r0, #0
    78b4:	1c0d      	adds	r5, r1, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    78b6:	f7ff fda1 	bl	73fc <cpu_irq_enter_critical>

	Assert(resource);

	system_interrupt_enter_critical_section();

	if (!_dma_inst._dma_init) {
    78ba:	4f40      	ldr	r7, [pc, #256]	; (79bc <dma_allocate+0x10c>)
    78bc:	783b      	ldrb	r3, [r7, #0]
    78be:	2b00      	cmp	r3, #0
    78c0:	d116      	bne.n	78f0 <dma_allocate+0x40>
 * \param[in] ahb_mask  AHB clock mask to enable
 */
static inline void system_ahb_clock_set_mask(
		const uint32_t ahb_mask)
{
	PM->AHBMASK.reg |= ahb_mask;
    78c2:	4b3f      	ldr	r3, [pc, #252]	; (79c0 <dma_allocate+0x110>)
    78c4:	2120      	movs	r1, #32
    78c6:	695a      	ldr	r2, [r3, #20]
    78c8:	430a      	orrs	r2, r1
    78ca:	615a      	str	r2, [r3, #20]
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
			break;

		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
    78cc:	69da      	ldr	r2, [r3, #28]
    78ce:	2110      	movs	r1, #16
    78d0:	430a      	orrs	r2, r1
    78d2:	61da      	str	r2, [r3, #28]
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBB,
				PM_APBBMASK_DMAC);
#endif

		/* Perform a software reset before enable DMA controller */
		DMAC->CTRL.reg &= ~DMAC_CTRL_DMAENABLE;
    78d4:	4b3b      	ldr	r3, [pc, #236]	; (79c4 <dma_allocate+0x114>)
    78d6:	2102      	movs	r1, #2
    78d8:	881a      	ldrh	r2, [r3, #0]
    78da:	438a      	bics	r2, r1
		DMAC->CTRL.reg = DMAC_CTRL_SWRST;

		/* Setup descriptor base address and write back section base
		 * address */
		DMAC->BASEADDR.reg = (uint32_t)descriptor_section;
    78dc:	493a      	ldr	r1, [pc, #232]	; (79c8 <dma_allocate+0x118>)
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBB,
				PM_APBBMASK_DMAC);
#endif

		/* Perform a software reset before enable DMA controller */
		DMAC->CTRL.reg &= ~DMAC_CTRL_DMAENABLE;
    78de:	801a      	strh	r2, [r3, #0]
		DMAC->CTRL.reg = DMAC_CTRL_SWRST;
    78e0:	2201      	movs	r2, #1
    78e2:	801a      	strh	r2, [r3, #0]

		/* Setup descriptor base address and write back section base
		 * address */
		DMAC->BASEADDR.reg = (uint32_t)descriptor_section;
    78e4:	6359      	str	r1, [r3, #52]	; 0x34
		DMAC->WRBADDR.reg = (uint32_t)_write_back_section;
    78e6:	4939      	ldr	r1, [pc, #228]	; (79cc <dma_allocate+0x11c>)
    78e8:	6399      	str	r1, [r3, #56]	; 0x38

		/* Enable all priority level at the same time */
		DMAC->CTRL.reg = DMAC_CTRL_DMAENABLE | DMAC_CTRL_LVLEN(0xf);
    78ea:	4939      	ldr	r1, [pc, #228]	; (79d0 <dma_allocate+0x120>)
    78ec:	8019      	strh	r1, [r3, #0]

		_dma_inst._dma_init = true;
    78ee:	703a      	strb	r2, [r7, #0]
    78f0:	f7ff fd84 	bl	73fc <cpu_irq_enter_critical>
	uint32_t tmp;
	bool allocated = false;

	system_interrupt_enter_critical_section();

	tmp = _dma_inst.allocated_channels;
    78f4:	687b      	ldr	r3, [r7, #4]

	for (count = 0; count < CONF_MAX_USED_CHANNEL_NUM; ++count) {
    78f6:	2600      	movs	r6, #0
		if (!(tmp & 0x00000001)) {
    78f8:	2201      	movs	r2, #1
    78fa:	4213      	tst	r3, r2
    78fc:	d109      	bne.n	7912 <dma_allocate+0x62>
			/* If free channel found, set as allocated and return
			 *number */

			_dma_inst.allocated_channels |= 1 << count;
    78fe:	687b      	ldr	r3, [r7, #4]
    7900:	1c11      	adds	r1, r2, #0
    7902:	40b1      	lsls	r1, r6
    7904:	430b      	orrs	r3, r1
    7906:	607b      	str	r3, [r7, #4]
			_dma_inst.free_channels--;
    7908:	7a3b      	ldrb	r3, [r7, #8]
    790a:	3b01      	subs	r3, #1
    790c:	723b      	strb	r3, [r7, #8]
			allocated = true;
    790e:	1c17      	adds	r7, r2, #0
    7910:	e005      	b.n	791e <dma_allocate+0x6e>

	system_interrupt_enter_critical_section();

	tmp = _dma_inst.allocated_channels;

	for (count = 0; count < CONF_MAX_USED_CHANNEL_NUM; ++count) {
    7912:	3601      	adds	r6, #1
    7914:	b2f6      	uxtb	r6, r6
			allocated = true;

			break;
		}

		tmp = tmp >> 1;
    7916:	085b      	lsrs	r3, r3, #1

	system_interrupt_enter_critical_section();

	tmp = _dma_inst.allocated_channels;

	for (count = 0; count < CONF_MAX_USED_CHANNEL_NUM; ++count) {
    7918:	2e05      	cmp	r6, #5
    791a:	d1ed      	bne.n	78f8 <dma_allocate+0x48>
 */
static uint8_t _dma_find_first_free_channel_and_allocate(void)
{
	uint8_t count;
	uint32_t tmp;
	bool allocated = false;
    791c:	2700      	movs	r7, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    791e:	f7ff fd89 	bl	7434 <cpu_irq_leave_critical>
		tmp = tmp >> 1;
	}

	system_interrupt_leave_critical_section();

	if (!allocated) {
    7922:	2f00      	cmp	r7, #0
    7924:	d001      	beq.n	792a <dma_allocate+0x7a>

	/* Find the proper channel */
	new_channel = _dma_find_first_free_channel_and_allocate();

	/* If no channel available, return not found */
	if (new_channel == DMA_INVALID_CHANNEL) {
    7926:	2eff      	cmp	r6, #255	; 0xff
    7928:	d103      	bne.n	7932 <dma_allocate+0x82>
    792a:	f7ff fd83 	bl	7434 <cpu_irq_leave_critical>
		system_interrupt_leave_critical_section();

		return STATUS_ERR_NOT_FOUND;
    792e:	2014      	movs	r0, #20
    7930:	e042      	b.n	79b8 <dma_allocate+0x108>

	/* Set the channel */
	resource->channel_id = new_channel;

	/** Perform a reset for the allocated channel */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
    7932:	270f      	movs	r7, #15
    7934:	1c33      	adds	r3, r6, #0
    7936:	4927      	ldr	r1, [pc, #156]	; (79d4 <dma_allocate+0x124>)
    7938:	403b      	ands	r3, r7

		return STATUS_ERR_NOT_FOUND;
	}

	/* Set the channel */
	resource->channel_id = new_channel;
    793a:	7026      	strb	r6, [r4, #0]

	/** Perform a reset for the allocated channel */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
    793c:	700b      	strb	r3, [r1, #0]
	DMAC->CHCTRLA.reg &= ~DMAC_CHCTRLA_ENABLE;
    793e:	4b26      	ldr	r3, [pc, #152]	; (79d8 <dma_allocate+0x128>)
    7940:	2102      	movs	r1, #2
    7942:	781a      	ldrb	r2, [r3, #0]

	/* Set the channel */
	resource->channel_id = new_channel;

	/** Perform a reset for the allocated channel */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
    7944:	4e1f      	ldr	r6, [pc, #124]	; (79c4 <dma_allocate+0x114>)
	DMAC->CHCTRLA.reg &= ~DMAC_CHCTRLA_ENABLE;
    7946:	438a      	bics	r2, r1
    7948:	701a      	strb	r2, [r3, #0]
	DMAC->CHCTRLA.reg = DMAC_CHCTRLA_SWRST;
    794a:	2201      	movs	r2, #1
    794c:	701a      	strb	r2, [r3, #0]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    794e:	f7ff fd55 	bl	73fc <cpu_irq_enter_critical>
	Assert(resource_config);
	uint32_t temp_CHCTRLB_reg;
	system_interrupt_enter_critical_section();

	/** Select the DMA channel and clear software trigger */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
    7952:	7823      	ldrb	r3, [r4, #0]
	DMAC->SWTRIGCTRL.reg &= (uint32_t)(~(1 << resource->channel_id));
    7954:	2101      	movs	r1, #1
	Assert(resource_config);
	uint32_t temp_CHCTRLB_reg;
	system_interrupt_enter_critical_section();

	/** Select the DMA channel and clear software trigger */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
    7956:	401f      	ands	r7, r3
    7958:	4b1e      	ldr	r3, [pc, #120]	; (79d4 <dma_allocate+0x124>)
    795a:	701f      	strb	r7, [r3, #0]
	DMAC->SWTRIGCTRL.reg &= (uint32_t)(~(1 << resource->channel_id));
    795c:	7822      	ldrb	r2, [r4, #0]
    795e:	6933      	ldr	r3, [r6, #16]
    7960:	4091      	lsls	r1, r2
    7962:	438b      	bics	r3, r1
    7964:	6133      	str	r3, [r6, #16]

	temp_CHCTRLB_reg = DMAC_CHCTRLB_LVL(resource_config->priority) | \
			DMAC_CHCTRLB_TRIGSRC(resource_config->peripheral_trigger) | \
    7966:	786a      	ldrb	r2, [r5, #1]
    7968:	23fc      	movs	r3, #252	; 0xfc
    796a:	0212      	lsls	r2, r2, #8
    796c:	019b      	lsls	r3, r3, #6
    796e:	4013      	ands	r3, r2

	/** Select the DMA channel and clear software trigger */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
	DMAC->SWTRIGCTRL.reg &= (uint32_t)(~(1 << resource->channel_id));

	temp_CHCTRLB_reg = DMAC_CHCTRLB_LVL(resource_config->priority) | \
    7970:	782a      	ldrb	r2, [r5, #0]
    7972:	2160      	movs	r1, #96	; 0x60
    7974:	0152      	lsls	r2, r2, #5
    7976:	400a      	ands	r2, r1
			DMAC_CHCTRLB_TRIGSRC(resource_config->peripheral_trigger) | \
			DMAC_CHCTRLB_TRIGACT(resource_config->trigger_action);
    7978:	78a9      	ldrb	r1, [r5, #2]

	/** Select the DMA channel and clear software trigger */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
	DMAC->SWTRIGCTRL.reg &= (uint32_t)(~(1 << resource->channel_id));

	temp_CHCTRLB_reg = DMAC_CHCTRLB_LVL(resource_config->priority) | \
    797a:	4313      	orrs	r3, r2
			DMAC_CHCTRLB_TRIGSRC(resource_config->peripheral_trigger) | \
			DMAC_CHCTRLB_TRIGACT(resource_config->trigger_action);
    797c:	22c0      	movs	r2, #192	; 0xc0
    797e:	0589      	lsls	r1, r1, #22
    7980:	0412      	lsls	r2, r2, #16
    7982:	400a      	ands	r2, r1

	/** Select the DMA channel and clear software trigger */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
	DMAC->SWTRIGCTRL.reg &= (uint32_t)(~(1 << resource->channel_id));

	temp_CHCTRLB_reg = DMAC_CHCTRLB_LVL(resource_config->priority) | \
    7984:	4313      	orrs	r3, r2
			DMAC_CHCTRLB_TRIGSRC(resource_config->peripheral_trigger) | \
			DMAC_CHCTRLB_TRIGACT(resource_config->trigger_action);


	if(resource_config->event_config.input_action){
    7986:	78ea      	ldrb	r2, [r5, #3]
    7988:	2a00      	cmp	r2, #0
    798a:	d004      	beq.n	7996 <dma_allocate+0xe6>
	temp_CHCTRLB_reg |= DMAC_CHCTRLB_EVIE | DMAC_CHCTRLB_EVACT(
    798c:	2107      	movs	r1, #7
    798e:	400a      	ands	r2, r1
    7990:	2108      	movs	r1, #8
    7992:	430a      	orrs	r2, r1
    7994:	4313      	orrs	r3, r2
				resource_config->event_config.input_action);
	}

	/** Enable event output, the event output selection is configured in
	 * each transfer descriptor  */
	if (resource_config->event_config.event_output_enable) {
    7996:	792a      	ldrb	r2, [r5, #4]
    7998:	2a00      	cmp	r2, #0
    799a:	d001      	beq.n	79a0 <dma_allocate+0xf0>
		temp_CHCTRLB_reg |= DMAC_CHCTRLB_EVOE;
    799c:	2210      	movs	r2, #16
    799e:	4313      	orrs	r3, r2
	}

	/* Write config to CTRLB register */
	DMAC->CHCTRLB.reg = temp_CHCTRLB_reg;
    79a0:	6473      	str	r3, [r6, #68]	; 0x44
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    79a2:	f7ff fd47 	bl	7434 <cpu_irq_leave_critical>
	_dma_set_config(resource, config);

	resource->descriptor = NULL;

	/* Log the DMA resource into the internal DMA resource pool */
	_dma_active_resource[resource->channel_id] = resource;
    79a6:	7822      	ldrb	r2, [r4, #0]
#endif

	/** Configure the DMA control,channel registers and descriptors here */
	_dma_set_config(resource, config);

	resource->descriptor = NULL;
    79a8:	2500      	movs	r5, #0

	/* Log the DMA resource into the internal DMA resource pool */
	_dma_active_resource[resource->channel_id] = resource;
    79aa:	4b0c      	ldr	r3, [pc, #48]	; (79dc <dma_allocate+0x12c>)
    79ac:	0092      	lsls	r2, r2, #2
#endif

	/** Configure the DMA control,channel registers and descriptors here */
	_dma_set_config(resource, config);

	resource->descriptor = NULL;
    79ae:	61a5      	str	r5, [r4, #24]

	/* Log the DMA resource into the internal DMA resource pool */
	_dma_active_resource[resource->channel_id] = resource;
    79b0:	50d4      	str	r4, [r2, r3]
    79b2:	f7ff fd3f 	bl	7434 <cpu_irq_leave_critical>

	system_interrupt_leave_critical_section();

	return STATUS_OK;
    79b6:	1c28      	adds	r0, r5, #0
}
    79b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    79ba:	46c0      	nop			; (mov r8, r8)
    79bc:	20000044 	.word	0x20000044
    79c0:	40000400 	.word	0x40000400
    79c4:	41004800 	.word	0x41004800
    79c8:	20001530 	.word	0x20001530
    79cc:	20000bf0 	.word	0x20000bf0
    79d0:	00000f02 	.word	0x00000f02
    79d4:	4100483f 	.word	0x4100483f
    79d8:	41004840 	.word	0x41004840
    79dc:	20000c40 	.word	0x20000c40

000079e0 <dma_free>:
 * \retval STATUS_OK The DMA resource was freed successfully
 * \retval STATUS_BUSY The DMA resource was busy and can't be freed
 * \retval STATUS_ERR_NOT_INITIALIZED DMA resource was not initialized
 */
enum status_code dma_free(struct dma_resource *resource)
{
    79e0:	b538      	push	{r3, r4, r5, lr}
    79e2:	1c05      	adds	r5, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    79e4:	f7ff fd0a 	bl	73fc <cpu_irq_enter_critical>
 */
static inline bool dma_is_busy(struct dma_resource *resource)
{
	Assert(resource);

	return (resource->job_status == STATUS_BUSY);
    79e8:	7c6c      	ldrb	r4, [r5, #17]
    79ea:	b2e4      	uxtb	r4, r4
	Assert(resource->channel_id != DMA_INVALID_CHANNEL);

	system_interrupt_enter_critical_section();

	/* Check if channel is busy */
	if (dma_is_busy(resource)) {
    79ec:	2c05      	cmp	r4, #5
    79ee:	d014      	beq.n	7a1a <dma_free+0x3a>
		system_interrupt_leave_critical_section();
		return STATUS_BUSY;
	}

	/* Check if DMA resource was not allocated */
	if (!(_dma_inst.allocated_channels & (1 << resource->channel_id))) {
    79f0:	4b0c      	ldr	r3, [pc, #48]	; (7a24 <dma_free+0x44>)
    79f2:	782a      	ldrb	r2, [r5, #0]
    79f4:	2101      	movs	r1, #1
    79f6:	6858      	ldr	r0, [r3, #4]
    79f8:	4091      	lsls	r1, r2
    79fa:	4208      	tst	r0, r1
    79fc:	d103      	bne.n	7a06 <dma_free+0x26>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    79fe:	f7ff fd19 	bl	7434 <cpu_irq_leave_critical>
		system_interrupt_leave_critical_section();
		return STATUS_ERR_NOT_INITIALIZED;
    7a02:	241f      	movs	r4, #31
    7a04:	e00b      	b.n	7a1e <dma_free+0x3e>
 * \param[in]  channel  Channel id to be released
 *
 */
static void _dma_release_channel(uint8_t channel)
{
	_dma_inst.allocated_channels &= ~(1 << channel);
    7a06:	6858      	ldr	r0, [r3, #4]

	/* Release the DMA resource */
	_dma_release_channel(resource->channel_id);

	/* Reset the item in the DMA resource pool */
	_dma_active_resource[resource->channel_id] = NULL;
    7a08:	0092      	lsls	r2, r2, #2
 * \param[in]  channel  Channel id to be released
 *
 */
static void _dma_release_channel(uint8_t channel)
{
	_dma_inst.allocated_channels &= ~(1 << channel);
    7a0a:	4388      	bics	r0, r1
	_dma_inst.free_channels++;
    7a0c:	7a19      	ldrb	r1, [r3, #8]
 * \param[in]  channel  Channel id to be released
 *
 */
static void _dma_release_channel(uint8_t channel)
{
	_dma_inst.allocated_channels &= ~(1 << channel);
    7a0e:	6058      	str	r0, [r3, #4]
	_dma_inst.free_channels++;
    7a10:	3101      	adds	r1, #1
    7a12:	7219      	strb	r1, [r3, #8]

	/* Release the DMA resource */
	_dma_release_channel(resource->channel_id);

	/* Reset the item in the DMA resource pool */
	_dma_active_resource[resource->channel_id] = NULL;
    7a14:	4b04      	ldr	r3, [pc, #16]	; (7a28 <dma_free+0x48>)
    7a16:	2400      	movs	r4, #0
    7a18:	50d4      	str	r4, [r2, r3]
    7a1a:	f7ff fd0b 	bl	7434 <cpu_irq_leave_critical>

	system_interrupt_leave_critical_section();

	return STATUS_OK;
}
    7a1e:	1c20      	adds	r0, r4, #0
    7a20:	bd38      	pop	{r3, r4, r5, pc}
    7a22:	46c0      	nop			; (mov r8, r8)
    7a24:	20000044 	.word	0x20000044
    7a28:	20000c40 	.word	0x20000c40

00007a2c <dma_start_transfer_job>:
 * \retval STATUS_OK The transfer was started successfully
 * \retval STATUS_BUSY The DMA resource was busy and the transfer was not started
 * \retval STATUS_ERR_INVALID_ARG Transfer size is 0 and transfer was not started
 */
enum status_code dma_start_transfer_job(struct dma_resource *resource)
{
    7a2c:	b538      	push	{r3, r4, r5, lr}
    7a2e:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    7a30:	f7ff fce4 	bl	73fc <cpu_irq_enter_critical>
	Assert(resource->channel_id != DMA_INVALID_CHANNEL);

	system_interrupt_enter_critical_section();

	/* Check if resource was busy */
	if (resource->job_status == STATUS_BUSY) {
    7a34:	7c65      	ldrb	r5, [r4, #17]
    7a36:	b2ed      	uxtb	r5, r5
    7a38:	2d05      	cmp	r5, #5
    7a3a:	d102      	bne.n	7a42 <dma_start_transfer_job+0x16>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    7a3c:	f7ff fcfa 	bl	7434 <cpu_irq_leave_critical>
		system_interrupt_leave_critical_section();
		return STATUS_BUSY;
    7a40:	e028      	b.n	7a94 <dma_start_transfer_job+0x68>
	}

	/* Check if transfer size is valid */
	if (resource->descriptor->BTCNT.reg == 0) {
    7a42:	69a2      	ldr	r2, [r4, #24]
    7a44:	8853      	ldrh	r3, [r2, #2]
    7a46:	2b00      	cmp	r3, #0
    7a48:	d103      	bne.n	7a52 <dma_start_transfer_job+0x26>
    7a4a:	f7ff fcf3 	bl	7434 <cpu_irq_leave_critical>
		system_interrupt_leave_critical_section();
		return STATUS_ERR_INVALID_ARG;
    7a4e:	2517      	movs	r5, #23
    7a50:	e020      	b.n	7a94 <dma_start_transfer_job+0x68>
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    7a52:	4b11      	ldr	r3, [pc, #68]	; (7a98 <dma_start_transfer_job+0x6c>)
    7a54:	2240      	movs	r2, #64	; 0x40
    7a56:	601a      	str	r2, [r3, #0]

	/* Enable DMA interrupt */
	system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_DMA);

	/* Set the interrupt flag */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
    7a58:	7822      	ldrb	r2, [r4, #0]
    7a5a:	230f      	movs	r3, #15
    7a5c:	401a      	ands	r2, r3
    7a5e:	4b0f      	ldr	r3, [pc, #60]	; (7a9c <dma_start_transfer_job+0x70>)
	/* Enable the transfer channel */
	DMAC->CHCTRLA.reg |= DMAC_CHCTRLA_ENABLE;

	system_interrupt_leave_critical_section();

	return STATUS_OK;
    7a60:	2500      	movs	r5, #0

	/* Enable DMA interrupt */
	system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_DMA);

	/* Set the interrupt flag */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
    7a62:	701a      	strb	r2, [r3, #0]
	DMAC->CHINTENSET.reg = (DMAC_CHINTENSET_MASK & g_chan_interrupt_flag[resource->channel_id]);
    7a64:	7823      	ldrb	r3, [r4, #0]
    7a66:	4a0e      	ldr	r2, [pc, #56]	; (7aa0 <dma_start_transfer_job+0x74>)
    7a68:	5cd2      	ldrb	r2, [r2, r3]
    7a6a:	2307      	movs	r3, #7
    7a6c:	401a      	ands	r2, r3
    7a6e:	4b0d      	ldr	r3, [pc, #52]	; (7aa4 <dma_start_transfer_job+0x78>)
    7a70:	701a      	strb	r2, [r3, #0]
	/* Set job status */
	resource->job_status = STATUS_BUSY;

	/* Set channel x descriptor 0 to the descriptor base address */
	memcpy(&descriptor_section[resource->channel_id], resource->descriptor,
    7a72:	7820      	ldrb	r0, [r4, #0]

	/* Set the interrupt flag */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
	DMAC->CHINTENSET.reg = (DMAC_CHINTENSET_MASK & g_chan_interrupt_flag[resource->channel_id]);
	/* Set job status */
	resource->job_status = STATUS_BUSY;
    7a74:	2305      	movs	r3, #5
    7a76:	7463      	strb	r3, [r4, #17]

	/* Set channel x descriptor 0 to the descriptor base address */
	memcpy(&descriptor_section[resource->channel_id], resource->descriptor,
    7a78:	4b0b      	ldr	r3, [pc, #44]	; (7aa8 <dma_start_transfer_job+0x7c>)
    7a7a:	0100      	lsls	r0, r0, #4
    7a7c:	18c0      	adds	r0, r0, r3
    7a7e:	69a1      	ldr	r1, [r4, #24]
    7a80:	2210      	movs	r2, #16
    7a82:	f009 fd9a 	bl	115ba <memcpy>
						sizeof(DmacDescriptor));

	/* Enable the transfer channel */
	DMAC->CHCTRLA.reg |= DMAC_CHCTRLA_ENABLE;
    7a86:	4b09      	ldr	r3, [pc, #36]	; (7aac <dma_start_transfer_job+0x80>)
    7a88:	2102      	movs	r1, #2
    7a8a:	781a      	ldrb	r2, [r3, #0]
    7a8c:	430a      	orrs	r2, r1
    7a8e:	701a      	strb	r2, [r3, #0]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    7a90:	f7ff fcd0 	bl	7434 <cpu_irq_leave_critical>

	system_interrupt_leave_critical_section();

	return STATUS_OK;
}
    7a94:	1c28      	adds	r0, r5, #0
    7a96:	bd38      	pop	{r3, r4, r5, pc}
    7a98:	e000e100 	.word	0xe000e100
    7a9c:	4100483f 	.word	0x4100483f
    7aa0:	20000c54 	.word	0x20000c54
    7aa4:	4100484d 	.word	0x4100484d
    7aa8:	20001530 	.word	0x20001530
    7aac:	41004840 	.word	0x41004840

00007ab0 <dma_descriptor_create>:
 */
void dma_descriptor_create(DmacDescriptor* descriptor,
	struct dma_descriptor_config *config)
{
	/* Set block transfer control */
	descriptor->BTCTRL.bit.VALID = config->descriptor_valid;
    7ab0:	8802      	ldrh	r2, [r0, #0]
 * \param[in] config Pointer to the descriptor configuration structure
 *
 */
void dma_descriptor_create(DmacDescriptor* descriptor,
	struct dma_descriptor_config *config)
{
    7ab2:	b570      	push	{r4, r5, r6, lr}
	/* Set block transfer control */
	descriptor->BTCTRL.bit.VALID = config->descriptor_valid;
    7ab4:	780c      	ldrb	r4, [r1, #0]
    7ab6:	2301      	movs	r3, #1
    7ab8:	401c      	ands	r4, r3
    7aba:	439a      	bics	r2, r3
    7abc:	4322      	orrs	r2, r4
    7abe:	8002      	strh	r2, [r0, #0]
	descriptor->BTCTRL.bit.EVOSEL = config->event_output_selection;
    7ac0:	784d      	ldrb	r5, [r1, #1]
    7ac2:	8804      	ldrh	r4, [r0, #0]
    7ac4:	2203      	movs	r2, #3
    7ac6:	4015      	ands	r5, r2
    7ac8:	2606      	movs	r6, #6
    7aca:	409d      	lsls	r5, r3
    7acc:	43b4      	bics	r4, r6
    7ace:	432c      	orrs	r4, r5
    7ad0:	8004      	strh	r4, [r0, #0]
	descriptor->BTCTRL.bit.BLOCKACT = config->block_action;
    7ad2:	788d      	ldrb	r5, [r1, #2]
    7ad4:	8804      	ldrh	r4, [r0, #0]
    7ad6:	2618      	movs	r6, #24
    7ad8:	4015      	ands	r5, r2
    7ada:	4095      	lsls	r5, r2
    7adc:	43b4      	bics	r4, r6
    7ade:	432c      	orrs	r4, r5
    7ae0:	8004      	strh	r4, [r0, #0]
	descriptor->BTCTRL.bit.BEATSIZE = config->beat_size;
    7ae2:	78cc      	ldrb	r4, [r1, #3]
    7ae4:	8805      	ldrh	r5, [r0, #0]
    7ae6:	4022      	ands	r2, r4
    7ae8:	0214      	lsls	r4, r2, #8
    7aea:	4a17      	ldr	r2, [pc, #92]	; (7b48 <dma_descriptor_create+0x98>)
    7aec:	402a      	ands	r2, r5
    7aee:	4322      	orrs	r2, r4
    7af0:	8002      	strh	r2, [r0, #0]
	descriptor->BTCTRL.bit.SRCINC = config->src_increment_enable;
    7af2:	790c      	ldrb	r4, [r1, #4]
    7af4:	8805      	ldrh	r5, [r0, #0]
    7af6:	4a15      	ldr	r2, [pc, #84]	; (7b4c <dma_descriptor_create+0x9c>)
    7af8:	401c      	ands	r4, r3
    7afa:	02a4      	lsls	r4, r4, #10
    7afc:	402a      	ands	r2, r5
    7afe:	4322      	orrs	r2, r4
    7b00:	8002      	strh	r2, [r0, #0]
	descriptor->BTCTRL.bit.DSTINC = config->dst_increment_enable;
    7b02:	794c      	ldrb	r4, [r1, #5]
    7b04:	8805      	ldrh	r5, [r0, #0]
    7b06:	4a12      	ldr	r2, [pc, #72]	; (7b50 <dma_descriptor_create+0xa0>)
    7b08:	401c      	ands	r4, r3
    7b0a:	402a      	ands	r2, r5
    7b0c:	02e4      	lsls	r4, r4, #11
    7b0e:	4322      	orrs	r2, r4
    7b10:	8002      	strh	r2, [r0, #0]
	descriptor->BTCTRL.bit.STEPSEL = config->step_selection;
    7b12:	798a      	ldrb	r2, [r1, #6]
    7b14:	8804      	ldrh	r4, [r0, #0]
    7b16:	4013      	ands	r3, r2
    7b18:	031a      	lsls	r2, r3, #12
    7b1a:	4b0e      	ldr	r3, [pc, #56]	; (7b54 <dma_descriptor_create+0xa4>)
    7b1c:	4023      	ands	r3, r4
    7b1e:	4313      	orrs	r3, r2
    7b20:	8003      	strh	r3, [r0, #0]
	descriptor->BTCTRL.bit.STEPSIZE = config->step_size;
    7b22:	79ca      	ldrb	r2, [r1, #7]
    7b24:	2307      	movs	r3, #7
    7b26:	401a      	ands	r2, r3
    7b28:	8803      	ldrh	r3, [r0, #0]
    7b2a:	0352      	lsls	r2, r2, #13
    7b2c:	04db      	lsls	r3, r3, #19
    7b2e:	0cdb      	lsrs	r3, r3, #19
    7b30:	4313      	orrs	r3, r2
    7b32:	8003      	strh	r3, [r0, #0]

	/* Set transfer size, source address and destination address */
	descriptor->BTCNT.reg = config->block_transfer_count;
    7b34:	890b      	ldrh	r3, [r1, #8]
    7b36:	8043      	strh	r3, [r0, #2]
	descriptor->SRCADDR.reg = config->source_address;
    7b38:	68cb      	ldr	r3, [r1, #12]
    7b3a:	6043      	str	r3, [r0, #4]
	descriptor->DSTADDR.reg = config->destination_address;
    7b3c:	690b      	ldr	r3, [r1, #16]
    7b3e:	6083      	str	r3, [r0, #8]

	/* Set next transfer descriptor address */
	descriptor->DESCADDR.reg = config->next_descriptor_address;
    7b40:	694b      	ldr	r3, [r1, #20]
    7b42:	60c3      	str	r3, [r0, #12]
}
    7b44:	bd70      	pop	{r4, r5, r6, pc}
    7b46:	46c0      	nop			; (mov r8, r8)
    7b48:	fffffcff 	.word	0xfffffcff
    7b4c:	fffffbff 	.word	0xfffffbff
    7b50:	fffff7ff 	.word	0xfffff7ff
    7b54:	ffffefff 	.word	0xffffefff

00007b58 <dma_add_descriptor>:
 * \retval STATUS_OK The descriptor is added to the DMA resource
 * \retval STATUS_BUSY The DMA resource was busy and the descriptor is not added
 */
enum status_code dma_add_descriptor(struct dma_resource *resource,
		DmacDescriptor* descriptor)
{
    7b58:	1c02      	adds	r2, r0, #0
	DmacDescriptor* desc = resource->descriptor;
    7b5a:	6983      	ldr	r3, [r0, #24]

	if (resource->job_status == STATUS_BUSY) {
    7b5c:	7c40      	ldrb	r0, [r0, #17]
    7b5e:	b2c0      	uxtb	r0, r0
    7b60:	2805      	cmp	r0, #5
    7b62:	d00a      	beq.n	7b7a <dma_add_descriptor+0x22>
		return STATUS_BUSY;
	}

	/* Look up for an empty space for the descriptor */
	if (desc == NULL) {
    7b64:	2b00      	cmp	r3, #0
    7b66:	d102      	bne.n	7b6e <dma_add_descriptor+0x16>
		resource->descriptor = descriptor;
    7b68:	6191      	str	r1, [r2, #24]

		/* Set to the end of descriptor list */
		desc->DESCADDR.reg = (uint32_t)descriptor;
	}

	return STATUS_OK;
    7b6a:	1c18      	adds	r0, r3, #0
    7b6c:	e005      	b.n	7b7a <dma_add_descriptor+0x22>
	/* Look up for an empty space for the descriptor */
	if (desc == NULL) {
		resource->descriptor = descriptor;
	} else {
		/* Looking for end of descriptor link */
		while(desc->DESCADDR.reg != 0) {
    7b6e:	68d8      	ldr	r0, [r3, #12]
    7b70:	2800      	cmp	r0, #0
    7b72:	d001      	beq.n	7b78 <dma_add_descriptor+0x20>
			desc = (DmacDescriptor*)(desc->DESCADDR.reg);
    7b74:	68db      	ldr	r3, [r3, #12]
    7b76:	e7fa      	b.n	7b6e <dma_add_descriptor+0x16>
		}

		/* Set to the end of descriptor list */
		desc->DESCADDR.reg = (uint32_t)descriptor;
    7b78:	60d9      	str	r1, [r3, #12]
	}

	return STATUS_OK;
}
    7b7a:	4770      	bx	lr

00007b7c <_ZN14Gamebuino_Meta10Bootloader6loaderEv>:

void Bootloader::game(char* filename) {
	game((const char*)filename);
}

void Bootloader::loader() {
    7b7c:	b508      	push	{r3, lr}
	((void(*)(void))(*((uint32_t*)0x3FF4)))();
    7b7e:	4b02      	ldr	r3, [pc, #8]	; (7b88 <_ZN14Gamebuino_Meta10Bootloader6loaderEv+0xc>)
    7b80:	681b      	ldr	r3, [r3, #0]
    7b82:	4798      	blx	r3
}
    7b84:	bd08      	pop	{r3, pc}
    7b86:	46c0      	nop			; (mov r8, r8)
    7b88:	00003ff4 	.word	0x00003ff4

00007b8c <_ZN14Gamebuino_Meta10Bootloader5errorEt>:

void Bootloader::enter() {
	((void(*)(void))(*((uint32_t*)0x3FEC)))();
}

void Bootloader::error(uint16_t e) {
    7b8c:	b508      	push	{r3, lr}
#endif

namespace Gamebuino_Meta {

uint32_t Bootloader::version() {
	return *(uint32_t*)0x3FFC;
    7b8e:	4b06      	ldr	r3, [pc, #24]	; (7ba8 <_ZN14Gamebuino_Meta10Bootloader5errorEt+0x1c>)
void Bootloader::enter() {
	((void(*)(void))(*((uint32_t*)0x3FEC)))();
}

void Bootloader::error(uint16_t e) {
	if (version() <= 0x10001) {
    7b90:	681a      	ldr	r2, [r3, #0]
    7b92:	4b06      	ldr	r3, [pc, #24]	; (7bac <_ZN14Gamebuino_Meta10Bootloader5errorEt+0x20>)
    7b94:	429a      	cmp	r2, r3
    7b96:	d802      	bhi.n	7b9e <_ZN14Gamebuino_Meta10Bootloader5errorEt+0x12>
		loader();
    7b98:	f7ff fff0 	bl	7b7c <_ZN14Gamebuino_Meta10Bootloader6loaderEv>
    7b9c:	e003      	b.n	7ba6 <_ZN14Gamebuino_Meta10Bootloader5errorEt+0x1a>
	} else {
		((void(*)(uint16_t))(*((uint32_t*)0x3FE8)))(e);
    7b9e:	4b04      	ldr	r3, [pc, #16]	; (7bb0 <_ZN14Gamebuino_Meta10Bootloader5errorEt+0x24>)
    7ba0:	1c08      	adds	r0, r1, #0
    7ba2:	681b      	ldr	r3, [r3, #0]
    7ba4:	4798      	blx	r3
	}
}
    7ba6:	bd08      	pop	{r3, pc}
    7ba8:	00003ffc 	.word	0x00003ffc
    7bac:	00010001 	.word	0x00010001
    7bb0:	00003fe8 	.word	0x00003fe8

00007bb4 <NMI_Handler>:
#include "../../Gamebuino-Meta.h"
extern Gamebuino gb;


// create our custom NMI handler
void NMI_Handler() {
    7bb4:	b508      	push	{r3, lr}
	gb.bootloader.error(1);
    7bb6:	4802      	ldr	r0, [pc, #8]	; (7bc0 <NMI_Handler+0xc>)
    7bb8:	2101      	movs	r1, #1
    7bba:	f7ff ffe7 	bl	7b8c <_ZN14Gamebuino_Meta10Bootloader5errorEt>
}
    7bbe:	bd08      	pop	{r3, pc}
    7bc0:	20000b95 	.word	0x20000b95

00007bc4 <HardFault_Handler>:
#ifdef __cplusplus
}
#endif

#else // HARDFAULT_DEBUG_HANDLER
void HardFault_Handler() {
    7bc4:	b508      	push	{r3, lr}
	gb.bootloader.error(2);
    7bc6:	4802      	ldr	r0, [pc, #8]	; (7bd0 <HardFault_Handler+0xc>)
    7bc8:	2102      	movs	r1, #2
    7bca:	f7ff ffdf 	bl	7b8c <_ZN14Gamebuino_Meta10Bootloader5errorEt>
}
    7bce:	bd08      	pop	{r3, pc}
    7bd0:	20000b95 	.word	0x20000b95

00007bd4 <_ZN14Gamebuino_Meta7Buttons5beginEv>:
#include <SPI.h>

namespace Gamebuino_Meta {


void Buttons::begin() {
    7bd4:	b508      	push	{r3, lr}
	SPI.begin();
    7bd6:	4806      	ldr	r0, [pc, #24]	; (7bf0 <_ZN14Gamebuino_Meta7Buttons5beginEv+0x1c>)
    7bd8:	f007 fa84 	bl	f0e4 <_ZN8SPIClass5beginEv>
	pinMode(BTN_CS, OUTPUT);
    7bdc:	2019      	movs	r0, #25
    7bde:	2101      	movs	r1, #1
    7be0:	f007 fec2 	bl	f968 <pinMode>
	digitalWrite(BTN_CS, HIGH);
    7be4:	2019      	movs	r0, #25
    7be6:	2101      	movs	r1, #1
    7be8:	f007 ff18 	bl	fa1c <digitalWrite>
}
    7bec:	bd08      	pop	{r3, pc}
    7bee:	46c0      	nop			; (mov r8, r8)
    7bf0:	20000e40 	.word	0x20000e40

00007bf4 <_ZN14Gamebuino_Meta7Buttons6updateEv>:

/*
 * reads each button states and store it
 */
void Buttons::update() {
    7bf4:	b573      	push	{r0, r1, r4, r5, r6, lr}
  }

  void init_AlwaysInline(uint32_t clock, BitOrder bitOrder, uint8_t dataMode) __attribute__((__always_inline__)) {
    this->clockFreq = (clock >= (F_CPU / SPI_MIN_CLOCK_DIVIDER) ? F_CPU / SPI_MIN_CLOCK_DIVIDER : clock);

    this->bitOrder = (bitOrder == MSBFIRST ? MSB_FIRST : LSB_FIRST);
    7bf6:	2400      	movs	r4, #0
    7bf8:	1c06      	adds	r6, r0, #0
    7bfa:	4668      	mov	r0, sp
    7bfc:	7144      	strb	r4, [r0, #5]

    switch (dataMode)
    {
      case SPI_MODE0:
        this->dataMode = SERCOM_SPI_MODE_0; break;
    7bfe:	7104      	strb	r4, [r0, #4]
  void init_MightInline(uint32_t clock, BitOrder bitOrder, uint8_t dataMode) {
    init_AlwaysInline(clock, bitOrder, dataMode);
  }

  void init_AlwaysInline(uint32_t clock, BitOrder bitOrder, uint8_t dataMode) __attribute__((__always_inline__)) {
    this->clockFreq = (clock >= (F_CPU / SPI_MIN_CLOCK_DIVIDER) ? F_CPU / SPI_MIN_CLOCK_DIVIDER : clock);
    7c00:	491a      	ldr	r1, [pc, #104]	; (7c6c <_ZN14Gamebuino_Meta7Buttons6updateEv+0x78>)
	
	//start SPI
	SPI.beginTransaction(SPISettings(12000000, MSBFIRST, SPI_MODE0));
    7c02:	9a01      	ldr	r2, [sp, #4]
    7c04:	481a      	ldr	r0, [pc, #104]	; (7c70 <_ZN14Gamebuino_Meta7Buttons6updateEv+0x7c>)
    7c06:	9100      	str	r1, [sp, #0]
    7c08:	f007 fa94 	bl	f134 <_ZN8SPIClass16beginTransactionE11SPISettings>
	digitalWrite(BTN_CS, LOW);
    7c0c:	2019      	movs	r0, #25
    7c0e:	1c21      	adds	r1, r4, #0
    7c10:	f007 ff04 	bl	fa1c <digitalWrite>
    "   sub %0, #1   \n" // substract 1 from %0 (n)
    "   bne 1b       \n" // if result is not 0 jump to 1
    : "+r" (n)           // '%0' is n variable with RW constraints
    :                    // no input
    :                    // no clobber
  );
    7c14:	2310      	movs	r3, #16
    7c16:	3b01      	subs	r3, #1
    7c18:	d1fd      	bne.n	7c16 <_ZN14Gamebuino_Meta7Buttons6updateEv+0x22>
	//wait for PL to recover
	delayMicroseconds(1);
	//get the buttons states from the shift register
	byte buttonsData = SPI.transfer(1);
    7c1a:	4c15      	ldr	r4, [pc, #84]	; (7c70 <_ZN14Gamebuino_Meta7Buttons6updateEv+0x7c>)
    7c1c:	2101      	movs	r1, #1
    7c1e:	1c20      	adds	r0, r4, #0
    7c20:	f007 fabe 	bl	f1a0 <_ZN8SPIClass8transferEh>
	//end SPI
	digitalWrite(BTN_CS, HIGH);
    7c24:	2101      	movs	r1, #1
	SPI.beginTransaction(SPISettings(12000000, MSBFIRST, SPI_MODE0));
	digitalWrite(BTN_CS, LOW);
	//wait for PL to recover
	delayMicroseconds(1);
	//get the buttons states from the shift register
	byte buttonsData = SPI.transfer(1);
    7c26:	1c05      	adds	r5, r0, #0
	//end SPI
	digitalWrite(BTN_CS, HIGH);
    7c28:	2019      	movs	r0, #25
    7c2a:	f007 fef7 	bl	fa1c <digitalWrite>
	SPI.endTransaction();
    7c2e:	1c20      	adds	r0, r4, #0
    7c30:	f007 fa9c 	bl	f16c <_ZN8SPIClass14endTransactionEv>
    7c34:	1c33      	adds	r3, r6, #0
    7c36:	2200      	movs	r2, #0
	//SerialUSB.println(buttonsData,BIN);
  
	for (uint8_t thisButton = 0; thisButton < NUM_BTN; thisButton++) {
		//extract the corresponding bit corresponding to the current button
		//Inverted logic : button pressed = low state = 0
		bool pressed = (buttonsData & (1 << thisButton)) == 0;
    7c38:	1c29      	adds	r1, r5, #0
    7c3a:	4111      	asrs	r1, r2
		
		if (pressed) { //if button pressed
    7c3c:	07c8      	lsls	r0, r1, #31
    7c3e:	d405      	bmi.n	7c4c <_ZN14Gamebuino_Meta7Buttons6updateEv+0x58>
			if (states[thisButton] < 0xFFFD) { // we want 0xFFFE to be max value for the counter
    7c40:	8819      	ldrh	r1, [r3, #0]
    7c42:	480c      	ldr	r0, [pc, #48]	; (7c74 <_ZN14Gamebuino_Meta7Buttons6updateEv+0x80>)
    7c44:	4281      	cmp	r1, r0
    7c46:	d80c      	bhi.n	7c62 <_ZN14Gamebuino_Meta7Buttons6updateEv+0x6e>
				states[thisButton]++; //increase button hold time
    7c48:	3101      	adds	r1, #1
    7c4a:	e009      	b.n	7c60 <_ZN14Gamebuino_Meta7Buttons6updateEv+0x6c>
			}
		} else {
			if (states[thisButton] == 0) {//button idle
    7c4c:	8819      	ldrh	r1, [r3, #0]
    7c4e:	2900      	cmp	r1, #0
    7c50:	d007      	beq.n	7c62 <_ZN14Gamebuino_Meta7Buttons6updateEv+0x6e>
				continue;
			}
			if (states[thisButton] == 0xFFFF) {//if previously released
    7c52:	4809      	ldr	r0, [pc, #36]	; (7c78 <_ZN14Gamebuino_Meta7Buttons6updateEv+0x84>)
    7c54:	4281      	cmp	r1, r0
    7c56:	d101      	bne.n	7c5c <_ZN14Gamebuino_Meta7Buttons6updateEv+0x68>
				states[thisButton] = 0; //set to idle
    7c58:	2100      	movs	r1, #0
    7c5a:	e001      	b.n	7c60 <_ZN14Gamebuino_Meta7Buttons6updateEv+0x6c>
			} else {
				states[thisButton] = 0xFFFF; //button just released
    7c5c:	2101      	movs	r1, #1
    7c5e:	4249      	negs	r1, r1
    7c60:	8019      	strh	r1, [r3, #0]
    7c62:	3201      	adds	r2, #1
    7c64:	3302      	adds	r3, #2
	digitalWrite(BTN_CS, HIGH);
	SPI.endTransaction();
	//Print raw data to native USB
	//SerialUSB.println(buttonsData,BIN);
  
	for (uint8_t thisButton = 0; thisButton < NUM_BTN; thisButton++) {
    7c66:	2a08      	cmp	r2, #8
    7c68:	d1e6      	bne.n	7c38 <_ZN14Gamebuino_Meta7Buttons6updateEv+0x44>
			} else {
				states[thisButton] = 0xFFFF; //button just released
			}
		}
	}
}
    7c6a:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    7c6c:	00b71b00 	.word	0x00b71b00
    7c70:	20000e40 	.word	0x20000e40
    7c74:	0000fffc 	.word	0x0000fffc
    7c78:	0000ffff 	.word	0x0000ffff

00007c7c <_ZN14Gamebuino_Meta7Buttons7pressedENS_6ButtonE>:
/*
 * Returns true when 'button' is pressed.
 * The button has to be released for it to be triggered again.
 */
bool Buttons::pressed(Button button) {
	return states[(uint8_t)button] == 1;
    7c7c:	0049      	lsls	r1, r1, #1
    7c7e:	5a08      	ldrh	r0, [r1, r0]
    7c80:	3801      	subs	r0, #1
    7c82:	4243      	negs	r3, r0
    7c84:	4158      	adcs	r0, r3
    7c86:	b2c0      	uxtb	r0, r0
}
    7c88:	4770      	bx	lr
	...

00007c8c <_ZN14Gamebuino_Meta7Buttons8releasedENS_6ButtonE>:

/*
 * return true if 'button' is released
 */
bool Buttons::released(Button button) {
	return states[(uint8_t)button] == 0xFFFF;
    7c8c:	0049      	lsls	r1, r1, #1
    7c8e:	4b03      	ldr	r3, [pc, #12]	; (7c9c <_ZN14Gamebuino_Meta7Buttons8releasedENS_6ButtonE+0x10>)
    7c90:	5a08      	ldrh	r0, [r1, r0]
    7c92:	18c0      	adds	r0, r0, r3
    7c94:	4243      	negs	r3, r0
    7c96:	4158      	adcs	r0, r3
    7c98:	b2c0      	uxtb	r0, r0
}
    7c9a:	4770      	bx	lr
    7c9c:	ffff0001 	.word	0xffff0001

00007ca0 <_ZN14Gamebuino_Meta7Buttons4heldENS_6ButtonEt>:
 * @param button The button's ID
 * @param time How much frames button must be held, between 1 and 254.
 * @return true when 'button' is held for 'time' frames
 */
bool Buttons::held(Button button, uint16_t time){
	return states[(uint8_t)button] == (time+1);
    7ca0:	0049      	lsls	r1, r1, #1
    7ca2:	5a08      	ldrh	r0, [r1, r0]
    7ca4:	3201      	adds	r2, #1
    7ca6:	1a80      	subs	r0, r0, r2
    7ca8:	4243      	negs	r3, r0
    7caa:	4158      	adcs	r0, r3
    7cac:	b2c0      	uxtb	r0, r0
}
    7cae:	4770      	bx	lr

00007cb0 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt>:
 * returns true every 'period' frames when 'button' is held
 * @param button The button's ID
 * @param period How much frames button must be held, between 1 and 254.
 * @return true if the button is held for the given time
 */
bool Buttons::repeat(Button button, uint16_t period) {
    7cb0:	b508      	push	{r3, lr}
    7cb2:	0049      	lsls	r1, r1, #1
	if (period <= 1) {
    7cb4:	2a01      	cmp	r2, #1
    7cb6:	d807      	bhi.n	7cc8 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt+0x18>
		if ((states[(uint8_t)button] != 0xFFFF) && (states[(uint8_t)button])) {
    7cb8:	5a43      	ldrh	r3, [r0, r1]
    7cba:	4a0b      	ldr	r2, [pc, #44]	; (7ce8 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt+0x38>)
    7cbc:	3b01      	subs	r3, #1
    7cbe:	b29b      	uxth	r3, r3
    7cc0:	2000      	movs	r0, #0
    7cc2:	429a      	cmp	r2, r3
    7cc4:	4140      	adcs	r0, r0
    7cc6:	e00a      	b.n	7cde <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt+0x2e>
			return true;
		}
	} else {
		if ((states[(uint8_t)button] != 0xFFFF) && ((states[(uint8_t)button] % period) == 1)) {
    7cc8:	5a40      	ldrh	r0, [r0, r1]
    7cca:	4b08      	ldr	r3, [pc, #32]	; (7cec <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt+0x3c>)
    7ccc:	4298      	cmp	r0, r3
    7cce:	d008      	beq.n	7ce2 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt+0x32>
    7cd0:	1c11      	adds	r1, r2, #0
    7cd2:	f009 fba5 	bl	11420 <__aeabi_uidivmod>
    7cd6:	b288      	uxth	r0, r1
    7cd8:	3801      	subs	r0, #1
    7cda:	4243      	negs	r3, r0
    7cdc:	4158      	adcs	r0, r3
    7cde:	b2c0      	uxtb	r0, r0
    7ce0:	e000      	b.n	7ce4 <_ZN14Gamebuino_Meta7Buttons6repeatENS_6ButtonEt+0x34>
			return true;
		}
	}
	return false;
    7ce2:	2000      	movs	r0, #0
}
    7ce4:	bd08      	pop	{r3, pc}
    7ce6:	46c0      	nop			; (mov r8, r8)
    7ce8:	0000fffd 	.word	0x0000fffd
    7cec:	0000ffff 	.word	0x0000ffff

00007cf0 <_ZN14Gamebuino_Meta12dma_callbackEP12dma_resource>:
status_code stat; // we'll use this to read and print out the DMA status codes
// are we done yet?
volatile bool transfer_is_done = false;
// If you like, a callback can be used
void dma_callback(struct dma_resource* const resource) {
	transfer_is_done = true;
    7cf0:	4b01      	ldr	r3, [pc, #4]	; (7cf8 <_ZN14Gamebuino_Meta12dma_callbackEP12dma_resource+0x8>)
    7cf2:	2201      	movs	r2, #1
    7cf4:	701a      	strb	r2, [r3, #0]
}
    7cf6:	4770      	bx	lr
    7cf8:	20000c64 	.word	0x20000c64

00007cfc <_ZN14Gamebuino_Meta14Display_ST7735C1Eaaa>:
}


// Constructor when using hardware SPI.	Faster, but must use SPI pins
// specific to each board type (e.g. 11,13 for Uno, 51,52 for Mega, etc.)
Display_ST7735::Display_ST7735(int8_t cs, int8_t rs, int8_t rst)  : Graphics(ST7735_TFTWIDTH, ST7735_TFTHEIGHT_18) {
    7cfc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7cfe:	1c0f      	adds	r7, r1, #0
    7d00:	1c16      	adds	r6, r2, #0
    7d02:	2180      	movs	r1, #128	; 0x80
    7d04:	22a0      	movs	r2, #160	; 0xa0
    7d06:	1c04      	adds	r4, r0, #0
    7d08:	1c1d      	adds	r5, r3, #0
    7d0a:	f002 f8e5 	bl	9ed8 <_ZN14Gamebuino_Meta8GraphicsC1Ess>
    7d0e:	4b07      	ldr	r3, [pc, #28]	; (7d2c <_ZN14Gamebuino_Meta14Display_ST7735C1Eaaa+0x30>)
	_cs	 = cs;
	_rs	 = rs;
	_rst	= rst;
	hwSPI = true;
    7d10:	2201      	movs	r2, #1
}


// Constructor when using hardware SPI.	Faster, but must use SPI pins
// specific to each board type (e.g. 11,13 for Uno, 51,52 for Mega, etc.)
Display_ST7735::Display_ST7735(int8_t cs, int8_t rs, int8_t rst)  : Graphics(ST7735_TFTWIDTH, ST7735_TFTHEIGHT_18) {
    7d12:	3308      	adds	r3, #8
    7d14:	6023      	str	r3, [r4, #0]
    7d16:	2300      	movs	r3, #0
	_cs	 = cs;
    7d18:	62a7      	str	r7, [r4, #40]	; 0x28
	_rs	 = rs;
    7d1a:	62e6      	str	r6, [r4, #44]	; 0x2c
	_rst	= rst;
    7d1c:	6525      	str	r5, [r4, #80]	; 0x50
	hwSPI = true;
	_sid	= _sclk = 0;

}
    7d1e:	1c20      	adds	r0, r4, #0
}


// Constructor when using hardware SPI.	Faster, but must use SPI pins
// specific to each board type (e.g. 11,13 for Uno, 51,52 for Mega, etc.)
Display_ST7735::Display_ST7735(int8_t cs, int8_t rs, int8_t rst)  : Graphics(ST7735_TFTWIDTH, ST7735_TFTHEIGHT_18) {
    7d20:	7523      	strb	r3, [r4, #20]
	_cs	 = cs;
	_rs	 = rs;
	_rst	= rst;
	hwSPI = true;
    7d22:	75a2      	strb	r2, [r4, #22]
	_sid	= _sclk = 0;
    7d24:	6363      	str	r3, [r4, #52]	; 0x34
    7d26:	6323      	str	r3, [r4, #48]	; 0x30

}
    7d28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7d2a:	46c0      	nop			; (mov r8, r8)
    7d2c:	00015078 	.word	0x00015078

00007d30 <_ZN14Gamebuino_Meta14Display_ST77358spiwriteEh>:

#if defined(CORE_TEENSY) && !defined(__AVR__)
#define __AVR__
#endif

inline void Display_ST7735::spiwrite(uint8_t c) {
    7d30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

	//Serial.println(c, HEX);

	if (hwSPI) {
    7d32:	7d83      	ldrb	r3, [r0, #22]
    7d34:	2b00      	cmp	r3, #0
    7d36:	d003      	beq.n	7d40 <_ZN14Gamebuino_Meta14Display_ST77358spiwriteEh+0x10>
#if defined (SPI_HAS_TRANSACTION)
		SPI.transfer(c);
    7d38:	480e      	ldr	r0, [pc, #56]	; (7d74 <_ZN14Gamebuino_Meta14Display_ST77358spiwriteEh+0x44>)
    7d3a:	f007 fa31 	bl	f1a0 <_ZN8SPIClass8transferEh>
    7d3e:	e018      	b.n	7d72 <_ZN14Gamebuino_Meta14Display_ST77358spiwriteEh+0x42>
	} else {
		// Fast SPI bitbang swiped from LPD8806 library
		for(uint8_t bit = 0x80; bit; bit >>= 1) {
			if(c & bit) *dataport |=	datapinmask;
			else				*dataport &= ~datapinmask;
			*clkport |=	clkpinmask;
    7d40:	69c3      	ldr	r3, [r0, #28]
    7d42:	2408      	movs	r4, #8
    7d44:	2580      	movs	r5, #128	; 0x80
    7d46:	6982      	ldr	r2, [r0, #24]
    7d48:	6b86      	ldr	r6, [r0, #56]	; 0x38
		SPI.transfer(c);
#endif
	} else {
		// Fast SPI bitbang swiped from LPD8806 library
		for(uint8_t bit = 0x80; bit; bit >>= 1) {
			if(c & bit) *dataport |=	datapinmask;
    7d4a:	6817      	ldr	r7, [r2, #0]
    7d4c:	4229      	tst	r1, r5
    7d4e:	d002      	beq.n	7d56 <_ZN14Gamebuino_Meta14Display_ST77358spiwriteEh+0x26>
    7d50:	433e      	orrs	r6, r7
    7d52:	6016      	str	r6, [r2, #0]
    7d54:	e001      	b.n	7d5a <_ZN14Gamebuino_Meta14Display_ST77358spiwriteEh+0x2a>
			else				*dataport &= ~datapinmask;
    7d56:	43b7      	bics	r7, r6
    7d58:	6017      	str	r7, [r2, #0]
			*clkport |=	clkpinmask;
    7d5a:	681a      	ldr	r2, [r3, #0]
    7d5c:	6bc6      	ldr	r6, [r0, #60]	; 0x3c
    7d5e:	3c01      	subs	r4, #1
    7d60:	4332      	orrs	r2, r6
    7d62:	601a      	str	r2, [r3, #0]
			*clkport &= ~clkpinmask;
    7d64:	681a      	ldr	r2, [r3, #0]
    7d66:	6bc6      	ldr	r6, [r0, #60]	; 0x3c
		SPI.setDataMode(SPI_MODE0);
		SPI.transfer(c);
#endif
	} else {
		// Fast SPI bitbang swiped from LPD8806 library
		for(uint8_t bit = 0x80; bit; bit >>= 1) {
    7d68:	086d      	lsrs	r5, r5, #1
			if(c & bit) *dataport |=	datapinmask;
			else				*dataport &= ~datapinmask;
			*clkport |=	clkpinmask;
			*clkport &= ~clkpinmask;
    7d6a:	43b2      	bics	r2, r6
    7d6c:	601a      	str	r2, [r3, #0]
		SPI.setDataMode(SPI_MODE0);
		SPI.transfer(c);
#endif
	} else {
		// Fast SPI bitbang swiped from LPD8806 library
		for(uint8_t bit = 0x80; bit; bit >>= 1) {
    7d6e:	2c00      	cmp	r4, #0
    7d70:	d1e9      	bne.n	7d46 <_ZN14Gamebuino_Meta14Display_ST77358spiwriteEh+0x16>
			else				*dataport &= ~datapinmask;
			*clkport |=	clkpinmask;
			*clkport &= ~clkpinmask;
		}
	}
}
    7d72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7d74:	20000e40 	.word	0x20000e40

00007d78 <_ZN14Gamebuino_Meta14Display_ST773510sendBufferEPtt>:
}

//fast method to quickly push a buffered line of pixels
//boundary check must be made prior to this function
//the color must be formated as the destination
void Display_ST7735::sendBuffer(uint16_t *buffer, uint16_t n) {
    7d78:	b5f0      	push	{r4, r5, r6, r7, lr}

	//configure DMA
	myDMA.configure_peripheraltrigger(SERCOM4_DMAC_ID_TX); // SERMCOM4 == SPI native SERCOM
    7d7a:	4c16      	ldr	r4, [pc, #88]	; (7dd4 <_ZN14Gamebuino_Meta14Display_ST773510sendBufferEPtt+0x5c>)
}

//fast method to quickly push a buffered line of pixels
//boundary check must be made prior to this function
//the color must be formated as the destination
void Display_ST7735::sendBuffer(uint16_t *buffer, uint16_t n) {
    7d7c:	b085      	sub	sp, #20
    7d7e:	1c0f      	adds	r7, r1, #0

	//configure DMA
	myDMA.configure_peripheraltrigger(SERCOM4_DMAC_ID_TX); // SERMCOM4 == SPI native SERCOM
    7d80:	1c20      	adds	r0, r4, #0
    7d82:	210a      	movs	r1, #10
}

//fast method to quickly push a buffered line of pixels
//boundary check must be made prior to this function
//the color must be formated as the destination
void Display_ST7735::sendBuffer(uint16_t *buffer, uint16_t n) {
    7d84:	1c15      	adds	r5, r2, #0

	//configure DMA
	myDMA.configure_peripheraltrigger(SERCOM4_DMAC_ID_TX); // SERMCOM4 == SPI native SERCOM
    7d86:	f7ff fcd8 	bl	773a <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA27configure_peripheraltriggerEm>
	myDMA.configure_triggeraction(DMA_TRIGGER_ACTON_BEAT);
    7d8a:	1c20      	adds	r0, r4, #0
    7d8c:	2102      	movs	r1, #2
    7d8e:	f7ff fcd6 	bl	773e <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA23configure_triggeractionE27dma_transfer_trigger_action>

	//allocate DMA
	myDMA.allocate();
    7d92:	1c20      	adds	r0, r4, #0
    7d94:	f7ff fcd5 	bl	7742 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA8allocateEv>
	myDMA.setup_transfer_descriptor(buffer,// move data from here
		(void *)(&SERCOM4->SPI.DATA.reg),		// to here
		n * 2,								// this many...
		DMA_BEAT_SIZE_BYTE,						// 8 bits bytes
		true,									// increment source addr?
		false);									// increment dest addr?
    7d98:	2600      	movs	r6, #0
	//printStatus(stat);

	//set up transfer 
	myDMA.setup_transfer_descriptor(buffer,// move data from here
		(void *)(&SERCOM4->SPI.DATA.reg),		// to here
		n * 2,								// this many...
    7d9a:	006b      	lsls	r3, r5, #1
		DMA_BEAT_SIZE_BYTE,						// 8 bits bytes
		true,									// increment source addr?
		false);									// increment dest addr?
    7d9c:	2501      	movs	r5, #1
    7d9e:	1c39      	adds	r1, r7, #0
    7da0:	1c20      	adds	r0, r4, #0
    7da2:	4a0d      	ldr	r2, [pc, #52]	; (7dd8 <_ZN14Gamebuino_Meta14Display_ST773510sendBufferEPtt+0x60>)
    7da4:	9600      	str	r6, [sp, #0]
    7da6:	9501      	str	r5, [sp, #4]
    7da8:	9602      	str	r6, [sp, #8]
    7daa:	f7ff fcd0 	bl	774e <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA25setup_transfer_descriptorEPvS1_m13dma_beat_sizebb>

	//add descriptor
	//Serial.print("Adding descriptor...");
	myDMA.add_descriptor();
    7dae:	1c20      	adds	r0, r4, #0
    7db0:	f7ff fd03 	bl	77ba <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA14add_descriptorEv>
	//printStatus(stat);

	//register and enable call back
	transfer_is_done = false;
    7db4:	4b09      	ldr	r3, [pc, #36]	; (7ddc <_ZN14Gamebuino_Meta14Display_ST773510sendBufferEPtt+0x64>)

	myDMA.register_callback(dma_callback); // by default, called when xfer done
    7db6:	1c2a      	adds	r2, r5, #0
    7db8:	1c20      	adds	r0, r4, #0
    7dba:	4909      	ldr	r1, [pc, #36]	; (7de0 <_ZN14Gamebuino_Meta14Display_ST773510sendBufferEPtt+0x68>)
	//Serial.print("Adding descriptor...");
	myDMA.add_descriptor();
	//printStatus(stat);

	//register and enable call back
	transfer_is_done = false;
    7dbc:	701e      	strb	r6, [r3, #0]

	myDMA.register_callback(dma_callback); // by default, called when xfer done
    7dbe:	f7ff fd0d 	bl	77dc <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA17register_callbackEPFvP12dma_resourceE17dma_callback_type>
	myDMA.enable_callback();// by default, for xfer done registers
    7dc2:	1c20      	adds	r0, r4, #0
    7dc4:	1c29      	adds	r1, r5, #0
    7dc6:	f7ff fd0d 	bl	77e4 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA15enable_callbackE17dma_callback_type>

	//start transfer
	// once started, we dont need to trigger it because it will autorun
	//Serial.println("Starting transfer job");
	myDMA.start_transfer_job();
    7dca:	1c20      	adds	r0, r4, #0
    7dcc:	f7ff fd01 	bl	77d2 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA18start_transfer_jobEv>
}
    7dd0:	b005      	add	sp, #20
    7dd2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7dd4:	20000c70 	.word	0x20000c70
    7dd8:	42001828 	.word	0x42001828
    7ddc:	20000c64 	.word	0x20000c64
    7de0:	00007cf1 	.word	0x00007cf1

00007de4 <_ZN14Gamebuino_Meta14Display_ST77358dataModeEv>:
uint16_t swap_endians_16(uint16_t b) {
	return (b << 8) | (b >> 8);
}

void Display_ST7735::dataMode() {
	*rsport |= rspinmask;
    7de4:	6a43      	ldr	r3, [r0, #36]	; 0x24
    7de6:	6c41      	ldr	r1, [r0, #68]	; 0x44
    7de8:	681a      	ldr	r2, [r3, #0]
    7dea:	430a      	orrs	r2, r1
    7dec:	601a      	str	r2, [r3, #0]
	*csport &= ~cspinmask;
    7dee:	6a03      	ldr	r3, [r0, #32]
    7df0:	6c01      	ldr	r1, [r0, #64]	; 0x40
    7df2:	681a      	ldr	r2, [r3, #0]
    7df4:	438a      	bics	r2, r1
    7df6:	601a      	str	r2, [r3, #0]
}
    7df8:	4770      	bx	lr

00007dfa <_ZN14Gamebuino_Meta14Display_ST773511commandModeEv>:

void Display_ST7735::commandMode() {
	*rsport &= ~rspinmask;
    7dfa:	6a43      	ldr	r3, [r0, #36]	; 0x24
    7dfc:	6c41      	ldr	r1, [r0, #68]	; 0x44
    7dfe:	681a      	ldr	r2, [r3, #0]
    7e00:	438a      	bics	r2, r1
    7e02:	601a      	str	r2, [r3, #0]
	*csport &= ~cspinmask;
    7e04:	6a03      	ldr	r3, [r0, #32]
    7e06:	6c01      	ldr	r1, [r0, #64]	; 0x40
    7e08:	681a      	ldr	r2, [r3, #0]
    7e0a:	438a      	bics	r2, r1
    7e0c:	601a      	str	r2, [r3, #0]
}
    7e0e:	4770      	bx	lr

00007e10 <_ZN14Gamebuino_Meta14Display_ST77358idleModeEv>:

void Display_ST7735::idleMode() {
	*csport |= cspinmask;
    7e10:	6a03      	ldr	r3, [r0, #32]
    7e12:	6c02      	ldr	r2, [r0, #64]	; 0x40
    7e14:	6819      	ldr	r1, [r3, #0]
    7e16:	430a      	orrs	r2, r1
    7e18:	601a      	str	r2, [r3, #0]
}
    7e1a:	4770      	bx	lr

00007e1c <_ZN14Gamebuino_Meta14Display_ST773512writecommandEh>:
		}
	}
}


void Display_ST7735::writecommand(uint8_t c) {
    7e1c:	b570      	push	{r4, r5, r6, lr}
#if defined (SPI_HAS_TRANSACTION)
	SPI.beginTransaction(mySPISettings);
    7e1e:	4b0b      	ldr	r3, [pc, #44]	; (7e4c <_ZN14Gamebuino_Meta14Display_ST773512writecommandEh+0x30>)
    7e20:	4d0b      	ldr	r5, [pc, #44]	; (7e50 <_ZN14Gamebuino_Meta14Display_ST773512writecommandEh+0x34>)
		}
	}
}


void Display_ST7735::writecommand(uint8_t c) {
    7e22:	1c04      	adds	r4, r0, #0
    7e24:	1c0e      	adds	r6, r1, #0
#if defined (SPI_HAS_TRANSACTION)
	SPI.beginTransaction(mySPISettings);
    7e26:	1c28      	adds	r0, r5, #0
    7e28:	cb06      	ldmia	r3!, {r1, r2}
    7e2a:	f007 f983 	bl	f134 <_ZN8SPIClass16beginTransactionE11SPISettings>
#endif
	commandMode();
    7e2e:	1c20      	adds	r0, r4, #0
    7e30:	f7ff ffe3 	bl	7dfa <_ZN14Gamebuino_Meta14Display_ST773511commandModeEv>

	//Serial.print("C ");
	spiwrite(c);
    7e34:	1c31      	adds	r1, r6, #0
    7e36:	1c20      	adds	r0, r4, #0
    7e38:	f7ff ff7a 	bl	7d30 <_ZN14Gamebuino_Meta14Display_ST77358spiwriteEh>

	idleMode();
    7e3c:	1c20      	adds	r0, r4, #0
    7e3e:	f7ff ffe7 	bl	7e10 <_ZN14Gamebuino_Meta14Display_ST77358idleModeEv>
#if defined (SPI_HAS_TRANSACTION)
	SPI.endTransaction();
    7e42:	1c28      	adds	r0, r5, #0
    7e44:	f007 f992 	bl	f16c <_ZN8SPIClass14endTransactionEv>
#endif
}
    7e48:	bd70      	pop	{r4, r5, r6, pc}
    7e4a:	46c0      	nop			; (mov r8, r8)
    7e4c:	20000c5c 	.word	0x20000c5c
    7e50:	20000e40 	.word	0x20000e40

00007e54 <_ZN14Gamebuino_Meta14Display_ST773513invertDisplayEb>:
		break;
	}
}


void Display_ST7735::invertDisplay(boolean i) {
    7e54:	b508      	push	{r3, lr}
	writecommand(i ? ST7735_INVON : ST7735_INVOFF);
    7e56:	424b      	negs	r3, r1
    7e58:	414b      	adcs	r3, r1
    7e5a:	2121      	movs	r1, #33	; 0x21
    7e5c:	1ac9      	subs	r1, r1, r3
    7e5e:	f7ff ffdd 	bl	7e1c <_ZN14Gamebuino_Meta14Display_ST773512writecommandEh>
}
    7e62:	bd08      	pop	{r3, pc}

00007e64 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh>:
	SPI.endTransaction();
#endif
}


void Display_ST7735::writedata(uint8_t c) {
    7e64:	b570      	push	{r4, r5, r6, lr}
#if defined (SPI_HAS_TRANSACTION)
	SPI.beginTransaction(mySPISettings);
    7e66:	4b0b      	ldr	r3, [pc, #44]	; (7e94 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh+0x30>)
    7e68:	4d0b      	ldr	r5, [pc, #44]	; (7e98 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh+0x34>)
	SPI.endTransaction();
#endif
}


void Display_ST7735::writedata(uint8_t c) {
    7e6a:	1c04      	adds	r4, r0, #0
    7e6c:	1c0e      	adds	r6, r1, #0
#if defined (SPI_HAS_TRANSACTION)
	SPI.beginTransaction(mySPISettings);
    7e6e:	1c28      	adds	r0, r5, #0
    7e70:	cb06      	ldmia	r3!, {r1, r2}
    7e72:	f007 f95f 	bl	f134 <_ZN8SPIClass16beginTransactionE11SPISettings>
#endif
	dataMode();
    7e76:	1c20      	adds	r0, r4, #0
    7e78:	f7ff ffb4 	bl	7de4 <_ZN14Gamebuino_Meta14Display_ST77358dataModeEv>
		
	//Serial.print("D ");
	spiwrite(c);
    7e7c:	1c31      	adds	r1, r6, #0
    7e7e:	1c20      	adds	r0, r4, #0
    7e80:	f7ff ff56 	bl	7d30 <_ZN14Gamebuino_Meta14Display_ST77358spiwriteEh>

	idleMode();
    7e84:	1c20      	adds	r0, r4, #0
    7e86:	f7ff ffc3 	bl	7e10 <_ZN14Gamebuino_Meta14Display_ST77358idleModeEv>
#if defined (SPI_HAS_TRANSACTION)
	SPI.endTransaction();
    7e8a:	1c28      	adds	r0, r5, #0
    7e8c:	f007 f96e 	bl	f16c <_ZN8SPIClass14endTransactionEv>
#endif
}
    7e90:	bd70      	pop	{r4, r5, r6, pc}
    7e92:	46c0      	nop			; (mov r8, r8)
    7e94:	20000c5c 	.word	0x20000c5c
    7e98:	20000e40 	.word	0x20000e40

00007e9c <_ZN14Gamebuino_Meta14Display_ST773511commandListEPKh>:
			100 };                  //     100 ms delay


// Companion code to the above tables.	Reads and issues
// a series of LCD commands stored in PROGMEM byte array.
void Display_ST7735::commandList(const uint8_t *addr) {
    7e9c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}

	uint8_t	numCommands, numArgs;
	uint16_t ms;

	numCommands = pgm_read_byte(addr++);	 // Number of commands to follow
    7e9e:	780d      	ldrb	r5, [r1, #0]
			100 };                  //     100 ms delay


// Companion code to the above tables.	Reads and issues
// a series of LCD commands stored in PROGMEM byte array.
void Display_ST7735::commandList(const uint8_t *addr) {
    7ea0:	1c06      	adds	r6, r0, #0

	uint8_t	numCommands, numArgs;
	uint16_t ms;

	numCommands = pgm_read_byte(addr++);	 // Number of commands to follow
    7ea2:	1c4c      	adds	r4, r1, #1
	while(numCommands--) {								 // For each command...
    7ea4:	2d00      	cmp	r5, #0
    7ea6:	d027      	beq.n	7ef8 <_ZN14Gamebuino_Meta14Display_ST773511commandListEPKh+0x5c>
		writecommand(pgm_read_byte(addr++)); //	 Read, issue command
    7ea8:	7821      	ldrb	r1, [r4, #0]
    7eaa:	1c30      	adds	r0, r6, #0
    7eac:	f7ff ffb6 	bl	7e1c <_ZN14Gamebuino_Meta14Display_ST773512writecommandEh>
		numArgs	= pgm_read_byte(addr++);		//	 Number of args to follow
    7eb0:	7862      	ldrb	r2, [r4, #1]
		ms			 = numArgs & DELAY;					//	 If hibit set, delay follows args
    7eb2:	237f      	movs	r3, #127	; 0x7f
    7eb4:	1c11      	adds	r1, r2, #0
	uint16_t ms;

	numCommands = pgm_read_byte(addr++);	 // Number of commands to follow
	while(numCommands--) {								 // For each command...
		writecommand(pgm_read_byte(addr++)); //	 Read, issue command
		numArgs	= pgm_read_byte(addr++);		//	 Number of args to follow
    7eb6:	1ca7      	adds	r7, r4, #2
		ms			 = numArgs & DELAY;					//	 If hibit set, delay follows args
    7eb8:	4399      	bics	r1, r3
		numArgs &= ~DELAY;									 //	 Mask out delay bit
    7eba:	401a      	ands	r2, r3

	numCommands = pgm_read_byte(addr++);	 // Number of commands to follow
	while(numCommands--) {								 // For each command...
		writecommand(pgm_read_byte(addr++)); //	 Read, issue command
		numArgs	= pgm_read_byte(addr++);		//	 Number of args to follow
		ms			 = numArgs & DELAY;					//	 If hibit set, delay follows args
    7ebc:	9100      	str	r1, [sp, #0]
		numArgs &= ~DELAY;									 //	 Mask out delay bit
    7ebe:	9201      	str	r2, [sp, #4]
		while(numArgs--) {									 //	 For each argument...
    7ec0:	1c3c      	adds	r4, r7, #0
    7ec2:	9a01      	ldr	r2, [sp, #4]
    7ec4:	18bb      	adds	r3, r7, r2
    7ec6:	b2d9      	uxtb	r1, r3
    7ec8:	b2e2      	uxtb	r2, r4
    7eca:	4291      	cmp	r1, r2
    7ecc:	d005      	beq.n	7eda <_ZN14Gamebuino_Meta14Display_ST773511commandListEPKh+0x3e>
			writedata(pgm_read_byte(addr++));	//		 Read, issue argument
    7ece:	7821      	ldrb	r1, [r4, #0]
    7ed0:	1c30      	adds	r0, r6, #0
    7ed2:	f7ff ffc7 	bl	7e64 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh>
    7ed6:	3401      	adds	r4, #1
    7ed8:	e7f3      	b.n	7ec2 <_ZN14Gamebuino_Meta14Display_ST773511commandListEPKh+0x26>
		}

		if(ms) {
    7eda:	9900      	ldr	r1, [sp, #0]
    7edc:	1c1c      	adds	r4, r3, #0
    7ede:	2900      	cmp	r1, #0
    7ee0:	d007      	beq.n	7ef2 <_ZN14Gamebuino_Meta14Display_ST773511commandListEPKh+0x56>
			ms = pgm_read_byte(addr++); // Read post-command delay time (ms)
    7ee2:	7818      	ldrb	r0, [r3, #0]
    7ee4:	1c5c      	adds	r4, r3, #1
			if(ms == 255) ms = 500;		 // If 255, delay for 500 ms
    7ee6:	28ff      	cmp	r0, #255	; 0xff
    7ee8:	d101      	bne.n	7eee <_ZN14Gamebuino_Meta14Display_ST773511commandListEPKh+0x52>
    7eea:	20fa      	movs	r0, #250	; 0xfa
    7eec:	0040      	lsls	r0, r0, #1
			delay(ms);
    7eee:	f007 fa4f 	bl	f390 <delay>
    7ef2:	3d01      	subs	r5, #1
    7ef4:	b2ed      	uxtb	r5, r5
    7ef6:	e7d5      	b.n	7ea4 <_ZN14Gamebuino_Meta14Display_ST773511commandListEPKh+0x8>
		}
	}
}
    7ef8:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
	...

00007efc <_ZN14Gamebuino_Meta14Display_ST773510commonInitEPKh>:


// Initialization code common to both 'B' and 'R' type displays
void Display_ST7735::commonInit(const uint8_t *cmdList) {
    7efc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	colstart	= rowstart = 0; // May be overridden in init func
    7efe:	2700      	movs	r7, #0
	}
}


// Initialization code common to both 'B' and 'R' type displays
void Display_ST7735::commonInit(const uint8_t *cmdList) {
    7f00:	1c04      	adds	r4, r0, #0
    7f02:	9101      	str	r1, [sp, #4]
	colstart	= rowstart = 0; // May be overridden in init func
    7f04:	64c7      	str	r7, [r0, #76]	; 0x4c
    7f06:	6487      	str	r7, [r0, #72]	; 0x48

	pinMode(_rs, OUTPUT);
    7f08:	2101      	movs	r1, #1
    7f0a:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
    7f0c:	f007 fd2c 	bl	f968 <pinMode>
	pinMode(_cs, OUTPUT);
    7f10:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    7f12:	2101      	movs	r1, #1
    7f14:	f007 fd28 	bl	f968 <pinMode>
	csport = portOutputRegister(digitalPinToPort(_cs));
    7f18:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    7f1a:	2218      	movs	r2, #24
    7f1c:	4342      	muls	r2, r0
    7f1e:	4d3f      	ldr	r5, [pc, #252]	; (801c <_ZN14Gamebuino_Meta14Display_ST773510commonInitEPKh+0x120>)
    7f20:	493f      	ldr	r1, [pc, #252]	; (8020 <_ZN14Gamebuino_Meta14Display_ST773510commonInitEPKh+0x124>)
    7f22:	5753      	ldrsb	r3, [r2, r5]
	rsport = portOutputRegister(digitalPinToPort(_rs));
    7f24:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
void Display_ST7735::commonInit(const uint8_t *cmdList) {
	colstart	= rowstart = 0; // May be overridden in init func

	pinMode(_rs, OUTPUT);
	pinMode(_cs, OUTPUT);
	csport = portOutputRegister(digitalPinToPort(_cs));
    7f26:	01db      	lsls	r3, r3, #7
    7f28:	185b      	adds	r3, r3, r1
    7f2a:	6223      	str	r3, [r4, #32]
	rsport = portOutputRegister(digitalPinToPort(_rs));
    7f2c:	2318      	movs	r3, #24
    7f2e:	4343      	muls	r3, r0
    7f30:	5759      	ldrsb	r1, [r3, r5]
    7f32:	483b      	ldr	r0, [pc, #236]	; (8020 <_ZN14Gamebuino_Meta14Display_ST773510commonInitEPKh+0x124>)
    7f34:	01c9      	lsls	r1, r1, #7
	cspinmask = digitalPinToBitMask(_cs);
    7f36:	18aa      	adds	r2, r5, r2
    7f38:	6852      	ldr	r2, [r2, #4]
	colstart	= rowstart = 0; // May be overridden in init func

	pinMode(_rs, OUTPUT);
	pinMode(_cs, OUTPUT);
	csport = portOutputRegister(digitalPinToPort(_cs));
	rsport = portOutputRegister(digitalPinToPort(_rs));
    7f3a:	1809      	adds	r1, r1, r0
	cspinmask = digitalPinToBitMask(_cs);
    7f3c:	2601      	movs	r6, #1
	colstart	= rowstart = 0; // May be overridden in init func

	pinMode(_rs, OUTPUT);
	pinMode(_cs, OUTPUT);
	csport = portOutputRegister(digitalPinToPort(_cs));
	rsport = portOutputRegister(digitalPinToPort(_rs));
    7f3e:	6261      	str	r1, [r4, #36]	; 0x24
	cspinmask = digitalPinToBitMask(_cs);
    7f40:	1c31      	adds	r1, r6, #0
    7f42:	4091      	lsls	r1, r2
    7f44:	6421      	str	r1, [r4, #64]	; 0x40
	rspinmask = digitalPinToBitMask(_rs);
    7f46:	18eb      	adds	r3, r5, r3
    7f48:	685b      	ldr	r3, [r3, #4]
    7f4a:	1c32      	adds	r2, r6, #0
    7f4c:	409a      	lsls	r2, r3

	if(hwSPI) { // Using hardware SPI
    7f4e:	7da3      	ldrb	r3, [r4, #22]
	pinMode(_rs, OUTPUT);
	pinMode(_cs, OUTPUT);
	csport = portOutputRegister(digitalPinToPort(_cs));
	rsport = portOutputRegister(digitalPinToPort(_rs));
	cspinmask = digitalPinToBitMask(_cs);
	rspinmask = digitalPinToBitMask(_rs);
    7f50:	6462      	str	r2, [r4, #68]	; 0x44

	if(hwSPI) { // Using hardware SPI
    7f52:	42bb      	cmp	r3, r7
    7f54:	d008      	beq.n	7f68 <_ZN14Gamebuino_Meta14Display_ST773510commonInitEPKh+0x6c>
#if defined (SPI_HAS_TRANSACTION)
		SPI.begin();
    7f56:	4833      	ldr	r0, [pc, #204]	; (8024 <_ZN14Gamebuino_Meta14Display_ST773510commonInitEPKh+0x128>)
    7f58:	f007 f8c4 	bl	f0e4 <_ZN8SPIClass5beginEv>
	
		mySPISettings = SPISettings(24000000, MSBFIRST, SPI_MODE0);
    7f5c:	4b32      	ldr	r3, [pc, #200]	; (8028 <_ZN14Gamebuino_Meta14Display_ST773510commonInitEPKh+0x12c>)
    7f5e:	4a33      	ldr	r2, [pc, #204]	; (802c <_ZN14Gamebuino_Meta14Display_ST773510commonInitEPKh+0x130>)
    7f60:	711f      	strb	r7, [r3, #4]
    7f62:	601a      	str	r2, [r3, #0]
    7f64:	715f      	strb	r7, [r3, #5]
    7f66:	e02d      	b.n	7fc4 <_ZN14Gamebuino_Meta14Display_ST773510commonInitEPKh+0xc8>
		SPI.begin();
		SPI.setClockDivider(21); //4MHz
		SPI.setDataMode(SPI_MODE0);
#endif
	} else {
		pinMode(_sclk, OUTPUT);
    7f68:	1c31      	adds	r1, r6, #0
    7f6a:	6b60      	ldr	r0, [r4, #52]	; 0x34
    7f6c:	f007 fcfc 	bl	f968 <pinMode>
		pinMode(_sid , OUTPUT);
    7f70:	1c31      	adds	r1, r6, #0
    7f72:	6b20      	ldr	r0, [r4, #48]	; 0x30
    7f74:	f007 fcf8 	bl	f968 <pinMode>
		clkport = portOutputRegister(digitalPinToPort(_sclk));
    7f78:	6b67      	ldr	r7, [r4, #52]	; 0x34
    7f7a:	2318      	movs	r3, #24
    7f7c:	437b      	muls	r3, r7
    7f7e:	469c      	mov	ip, r3
    7f80:	575b      	ldrsb	r3, [r3, r5]
    7f82:	482b      	ldr	r0, [pc, #172]	; (8030 <_ZN14Gamebuino_Meta14Display_ST773510commonInitEPKh+0x134>)
    7f84:	4926      	ldr	r1, [pc, #152]	; (8020 <_ZN14Gamebuino_Meta14Display_ST773510commonInitEPKh+0x124>)
    7f86:	01db      	lsls	r3, r3, #7
    7f88:	181a      	adds	r2, r3, r0
    7f8a:	185b      	adds	r3, r3, r1
    7f8c:	61e3      	str	r3, [r4, #28]
		dataport = portOutputRegister(digitalPinToPort(_sid));
    7f8e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    7f90:	2018      	movs	r0, #24
    7f92:	4358      	muls	r0, r3
    7f94:	5747      	ldrsb	r7, [r0, r5]
    7f96:	4926      	ldr	r1, [pc, #152]	; (8030 <_ZN14Gamebuino_Meta14Display_ST773510commonInitEPKh+0x134>)
    7f98:	01ff      	lsls	r7, r7, #7
    7f9a:	187b      	adds	r3, r7, r1
    7f9c:	4920      	ldr	r1, [pc, #128]	; (8020 <_ZN14Gamebuino_Meta14Display_ST773510commonInitEPKh+0x124>)
    7f9e:	187f      	adds	r7, r7, r1
    7fa0:	61a7      	str	r7, [r4, #24]
		clkpinmask = digitalPinToBitMask(_sclk);
    7fa2:	4667      	mov	r7, ip
    7fa4:	19e9      	adds	r1, r5, r7
    7fa6:	6849      	ldr	r1, [r1, #4]
    7fa8:	1c37      	adds	r7, r6, #0
    7faa:	408f      	lsls	r7, r1
    7fac:	63e7      	str	r7, [r4, #60]	; 0x3c
		datapinmask = digitalPinToBitMask(_sid);
    7fae:	182d      	adds	r5, r5, r0
    7fb0:	6868      	ldr	r0, [r5, #4]
    7fb2:	4086      	lsls	r6, r0
    7fb4:	63a6      	str	r6, [r4, #56]	; 0x38
		*clkport &= ~clkpinmask;
    7fb6:	6910      	ldr	r0, [r2, #16]
    7fb8:	43b8      	bics	r0, r7
    7fba:	6110      	str	r0, [r2, #16]
		*dataport &= ~datapinmask;
    7fbc:	691a      	ldr	r2, [r3, #16]
    7fbe:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    7fc0:	4382      	bics	r2, r0
    7fc2:	611a      	str	r2, [r3, #16]
	}

	// toggle RST low to reset; CS low so it'll listen to us
	*csport &= ~cspinmask;
    7fc4:	6a23      	ldr	r3, [r4, #32]
    7fc6:	6c21      	ldr	r1, [r4, #64]	; 0x40
    7fc8:	681a      	ldr	r2, [r3, #0]
    7fca:	438a      	bics	r2, r1
    7fcc:	601a      	str	r2, [r3, #0]
	if (_rst) {
    7fce:	6d20      	ldr	r0, [r4, #80]	; 0x50
    7fd0:	2800      	cmp	r0, #0
    7fd2:	d01a      	beq.n	800a <_ZN14Gamebuino_Meta14Display_ST773510commonInitEPKh+0x10e>
		pinMode(_rst, OUTPUT);
    7fd4:	2101      	movs	r1, #1
    7fd6:	f007 fcc7 	bl	f968 <pinMode>
		digitalWrite(_rst, HIGH);
    7fda:	2101      	movs	r1, #1
    7fdc:	6d20      	ldr	r0, [r4, #80]	; 0x50
    7fde:	f007 fd1d 	bl	fa1c <digitalWrite>
		delay(500);
    7fe2:	20fa      	movs	r0, #250	; 0xfa
    7fe4:	0040      	lsls	r0, r0, #1
    7fe6:	f007 f9d3 	bl	f390 <delay>
		digitalWrite(_rst, LOW);
    7fea:	2100      	movs	r1, #0
    7fec:	6d20      	ldr	r0, [r4, #80]	; 0x50
    7fee:	f007 fd15 	bl	fa1c <digitalWrite>
		delay(500);
    7ff2:	20fa      	movs	r0, #250	; 0xfa
    7ff4:	0040      	lsls	r0, r0, #1
    7ff6:	f007 f9cb 	bl	f390 <delay>
		digitalWrite(_rst, HIGH);
    7ffa:	6d20      	ldr	r0, [r4, #80]	; 0x50
    7ffc:	2101      	movs	r1, #1
    7ffe:	f007 fd0d 	bl	fa1c <digitalWrite>
		delay(500);
    8002:	20fa      	movs	r0, #250	; 0xfa
    8004:	0040      	lsls	r0, r0, #1
    8006:	f007 f9c3 	bl	f390 <delay>
	}

	if(cmdList) commandList(cmdList);
    800a:	9f01      	ldr	r7, [sp, #4]
    800c:	2f00      	cmp	r7, #0
    800e:	d003      	beq.n	8018 <_ZN14Gamebuino_Meta14Display_ST773510commonInitEPKh+0x11c>
    8010:	1c20      	adds	r0, r4, #0
    8012:	1c39      	adds	r1, r7, #0
    8014:	f7ff ff42 	bl	7e9c <_ZN14Gamebuino_Meta14Display_ST773511commandListEPKh>
}
    8018:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    801a:	46c0      	nop			; (mov r8, r8)
    801c:	000156a8 	.word	0x000156a8
    8020:	41004410 	.word	0x41004410
    8024:	20000e40 	.word	0x20000e40
    8028:	20000c5c 	.word	0x20000c5c
    802c:	016e3600 	.word	0x016e3600
    8030:	41004400 	.word	0x41004400

00008034 <_ZN14Gamebuino_Meta14Display_ST77355initREh>:
	commonInit(Bcmd);
}


// Initialization for ST7735R screens (green or red tabs)
void Display_ST7735::initR(uint8_t options) {
    8034:	b538      	push	{r3, r4, r5, lr}
    8036:	1c0d      	adds	r5, r1, #0
	commonInit(Rcmd1);
    8038:	4917      	ldr	r1, [pc, #92]	; (8098 <_ZN14Gamebuino_Meta14Display_ST77355initREh+0x64>)
	commonInit(Bcmd);
}


// Initialization for ST7735R screens (green or red tabs)
void Display_ST7735::initR(uint8_t options) {
    803a:	1c04      	adds	r4, r0, #0
	commonInit(Rcmd1);
    803c:	f7ff ff5e 	bl	7efc <_ZN14Gamebuino_Meta14Display_ST773510commonInitEPKh>
	if(options == INITR_GREENTAB) {
    8040:	2d00      	cmp	r5, #0
    8042:	d108      	bne.n	8056 <_ZN14Gamebuino_Meta14Display_ST77355initREh+0x22>
		commandList(Rcmd2green);
    8044:	1c20      	adds	r0, r4, #0
    8046:	4915      	ldr	r1, [pc, #84]	; (809c <_ZN14Gamebuino_Meta14Display_ST77355initREh+0x68>)
    8048:	f7ff ff28 	bl	7e9c <_ZN14Gamebuino_Meta14Display_ST773511commandListEPKh>
		colstart = 2;
    804c:	2302      	movs	r3, #2
    804e:	64a3      	str	r3, [r4, #72]	; 0x48
		rowstart = 1;
    8050:	2301      	movs	r3, #1
    8052:	64e3      	str	r3, [r4, #76]	; 0x4c
    8054:	e010      	b.n	8078 <_ZN14Gamebuino_Meta14Display_ST77355initREh+0x44>
	} else if(options == INITR_144GREENTAB) {
    8056:	2d01      	cmp	r5, #1
    8058:	d10a      	bne.n	8070 <_ZN14Gamebuino_Meta14Display_ST77355initREh+0x3c>
		_height = ST7735_TFTHEIGHT_144;
    805a:	2380      	movs	r3, #128	; 0x80
    805c:	8263      	strh	r3, [r4, #18]
		commandList(Rcmd2green144);
    805e:	1c20      	adds	r0, r4, #0
    8060:	490f      	ldr	r1, [pc, #60]	; (80a0 <_ZN14Gamebuino_Meta14Display_ST77355initREh+0x6c>)
    8062:	f7ff ff1b 	bl	7e9c <_ZN14Gamebuino_Meta14Display_ST773511commandListEPKh>
		colstart = 2;
    8066:	2302      	movs	r3, #2
    8068:	64a3      	str	r3, [r4, #72]	; 0x48
		rowstart = 3;
    806a:	2303      	movs	r3, #3
    806c:	64e3      	str	r3, [r4, #76]	; 0x4c
    806e:	e003      	b.n	8078 <_ZN14Gamebuino_Meta14Display_ST77355initREh+0x44>
	} else {
		// colstart, rowstart left at default '0' values
		commandList(Rcmd2red);
    8070:	1c20      	adds	r0, r4, #0
    8072:	490c      	ldr	r1, [pc, #48]	; (80a4 <_ZN14Gamebuino_Meta14Display_ST77355initREh+0x70>)
    8074:	f7ff ff12 	bl	7e9c <_ZN14Gamebuino_Meta14Display_ST773511commandListEPKh>
	}
	commandList(Rcmd3);
    8078:	1c20      	adds	r0, r4, #0
    807a:	490b      	ldr	r1, [pc, #44]	; (80a8 <_ZN14Gamebuino_Meta14Display_ST77355initREh+0x74>)
    807c:	f7ff ff0e 	bl	7e9c <_ZN14Gamebuino_Meta14Display_ST773511commandListEPKh>

	// if black, change MADCTL color filter
	if (options == INITR_BLACKTAB) {
    8080:	2d02      	cmp	r5, #2
    8082:	d107      	bne.n	8094 <_ZN14Gamebuino_Meta14Display_ST77355initREh+0x60>
		writecommand(ST7735_MADCTL);
    8084:	1c20      	adds	r0, r4, #0
    8086:	2136      	movs	r1, #54	; 0x36
    8088:	f7ff fec8 	bl	7e1c <_ZN14Gamebuino_Meta14Display_ST773512writecommandEh>
		writedata(0xC0);
    808c:	1c20      	adds	r0, r4, #0
    808e:	21c0      	movs	r1, #192	; 0xc0
    8090:	f7ff fee8 	bl	7e64 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh>
	}

	tabcolor = options;
    8094:	7565      	strb	r5, [r4, #21]
}
    8096:	bd38      	pop	{r3, r4, r5, pc}
    8098:	000150c8 	.word	0x000150c8
    809c:	00015057 	.word	0x00015057
    80a0:	00015103 	.word	0x00015103
    80a4:	00015064 	.word	0x00015064
    80a8:	0001502c 	.word	0x0001502c

000080ac <_ZN14Gamebuino_Meta14Display_ST773513setAddrWindowEhhhh>:


void Display_ST7735::setAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
    80ac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    80ae:	1c1e      	adds	r6, r3, #0
    80b0:	ab08      	add	r3, sp, #32
    80b2:	781b      	ldrb	r3, [r3, #0]
    80b4:	1c04      	adds	r4, r0, #0
    80b6:	1c0f      	adds	r7, r1, #0

	writecommand(ST7735_CASET); // Column addr set
    80b8:	212a      	movs	r1, #42	; 0x2a

	tabcolor = options;
}


void Display_ST7735::setAddrWindow(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
    80ba:	9301      	str	r3, [sp, #4]
    80bc:	1c15      	adds	r5, r2, #0

	writecommand(ST7735_CASET); // Column addr set
    80be:	f7ff fead 	bl	7e1c <_ZN14Gamebuino_Meta14Display_ST773512writecommandEh>
	writedata(0x00);
    80c2:	1c20      	adds	r0, r4, #0
    80c4:	2100      	movs	r1, #0
    80c6:	f7ff fecd 	bl	7e64 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh>
	writedata(x0+colstart);		 // XSTART 
    80ca:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    80cc:	1c20      	adds	r0, r4, #0
    80ce:	18bf      	adds	r7, r7, r2
    80d0:	b2f9      	uxtb	r1, r7
    80d2:	f7ff fec7 	bl	7e64 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh>
	writedata(0x00);
    80d6:	1c20      	adds	r0, r4, #0
    80d8:	2100      	movs	r1, #0
    80da:	f7ff fec3 	bl	7e64 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh>
	writedata(x1+colstart);		 // XEND
    80de:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    80e0:	1c20      	adds	r0, r4, #0
    80e2:	18f6      	adds	r6, r6, r3
    80e4:	b2f1      	uxtb	r1, r6
    80e6:	f7ff febd 	bl	7e64 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh>

	writecommand(ST7735_RASET); // Row addr set
    80ea:	1c20      	adds	r0, r4, #0
    80ec:	212b      	movs	r1, #43	; 0x2b
    80ee:	f7ff fe95 	bl	7e1c <_ZN14Gamebuino_Meta14Display_ST773512writecommandEh>
	writedata(0x00);
    80f2:	1c20      	adds	r0, r4, #0
    80f4:	2100      	movs	r1, #0
    80f6:	f7ff feb5 	bl	7e64 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh>
	writedata(y0+rowstart);		 // YSTART
    80fa:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
    80fc:	1c20      	adds	r0, r4, #0
    80fe:	18ad      	adds	r5, r5, r2
    8100:	b2e9      	uxtb	r1, r5
    8102:	f7ff feaf 	bl	7e64 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh>
	writedata(0x00);
    8106:	1c20      	adds	r0, r4, #0
    8108:	2100      	movs	r1, #0
    810a:	f7ff feab 	bl	7e64 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh>
	writedata(y1+rowstart);		 // YEND
    810e:	9b01      	ldr	r3, [sp, #4]
    8110:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
    8112:	1c20      	adds	r0, r4, #0
    8114:	1899      	adds	r1, r3, r2
    8116:	b2c9      	uxtb	r1, r1
    8118:	f7ff fea4 	bl	7e64 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh>

	writecommand(ST7735_RAMWR); // write to RAM
    811c:	1c20      	adds	r0, r4, #0
    811e:	212c      	movs	r1, #44	; 0x2c
    8120:	f7ff fe7c 	bl	7e1c <_ZN14Gamebuino_Meta14Display_ST773512writecommandEh>
}
    8124:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
	...

00008128 <_ZN14Gamebuino_Meta14Display_ST773516drawBufferedLineEssPttRNS_5ImageE>:

//fast method to quickly push a buffered line of pixels
//boundary check must be made prior to this function
//the color must be formated as the destination
void Display_ST7735::drawBufferedLine(int16_t x, int16_t y, uint16_t *buffer, uint16_t w, Image& img) {
    8128:	b5f0      	push	{r4, r5, r6, r7, lr}
    812a:	b089      	sub	sp, #36	; 0x24
    812c:	af04      	add	r7, sp, #16
    812e:	60f8      	str	r0, [r7, #12]
    8130:	8d38      	ldrh	r0, [r7, #40]	; 0x28
    8132:	1c0d      	adds	r5, r1, #0
    8134:	1c16      	adds	r6, r2, #0

	PORT->Group[0].OUTSET.reg = (1 << 17);	// set PORTA.17 high	"digitalWrite(13, HIGH)"
    8136:	4936      	ldr	r1, [pc, #216]	; (8210 <_ZN14Gamebuino_Meta14Display_ST773516drawBufferedLineEssPttRNS_5ImageE+0xe8>)
    8138:	2280      	movs	r2, #128	; 0x80

	//create a local buffer line not to mess up the source
	uint16_t bufferedLine[w];
    813a:	0044      	lsls	r4, r0, #1
//fast method to quickly push a buffered line of pixels
//boundary check must be made prior to this function
//the color must be formated as the destination
void Display_ST7735::drawBufferedLine(int16_t x, int16_t y, uint16_t *buffer, uint16_t w, Image& img) {

	PORT->Group[0].OUTSET.reg = (1 << 17);	// set PORTA.17 high	"digitalWrite(13, HIGH)"
    813c:	0292      	lsls	r2, r2, #10
}

//fast method to quickly push a buffered line of pixels
//boundary check must be made prior to this function
//the color must be formated as the destination
void Display_ST7735::drawBufferedLine(int16_t x, int16_t y, uint16_t *buffer, uint16_t w, Image& img) {
    813e:	603b      	str	r3, [r7, #0]

	PORT->Group[0].OUTSET.reg = (1 << 17);	// set PORTA.17 high	"digitalWrite(13, HIGH)"
    8140:	618a      	str	r2, [r1, #24]

	//create a local buffer line not to mess up the source
	uint16_t bufferedLine[w];
    8142:	1c22      	adds	r2, r4, #0
    8144:	3208      	adds	r2, #8
    8146:	08d2      	lsrs	r2, r2, #3
    8148:	00d2      	lsls	r2, r2, #3
    814a:	466b      	mov	r3, sp
    814c:	1a9b      	subs	r3, r3, r2
    814e:	469d      	mov	sp, r3
    8150:	607c      	str	r4, [r7, #4]
    8152:	ac04      	add	r4, sp, #16
    8154:	60bc      	str	r4, [r7, #8]
	for (uint16_t i = 0; i < w; i++) {
    8156:	2200      	movs	r2, #0
    8158:	b291      	uxth	r1, r2
    815a:	4281      	cmp	r1, r0
    815c:	d208      	bcs.n	8170 <_ZN14Gamebuino_Meta14Display_ST773516drawBufferedLineEssPttRNS_5ImageE+0x48>
    815e:	683b      	ldr	r3, [r7, #0]
    8160:	0051      	lsls	r1, r2, #1
    8162:	5a5c      	ldrh	r4, [r3, r1]
    8164:	3201      	adds	r2, #1
    8166:	ba64      	rev16	r4, r4
		uint16_t color = buffer[i];
		color = (color << 8) | (color >> 8); //change endianness
		bufferedLine[i] = color;
    8168:	1c23      	adds	r3, r4, #0
    816a:	68bc      	ldr	r4, [r7, #8]
    816c:	5263      	strh	r3, [r4, r1]
    816e:	e7f3      	b.n	8158 <_ZN14Gamebuino_Meta14Display_ST773516drawBufferedLineEssPttRNS_5ImageE+0x30>
	}

	setAddrWindow(x, y, x + w - 1, y + 1);
    8170:	b2e9      	uxtb	r1, r5
    8172:	1e4b      	subs	r3, r1, #1
    8174:	b2f2      	uxtb	r2, r6
    8176:	1818      	adds	r0, r3, r0
    8178:	b2c3      	uxtb	r3, r0
    817a:	1c50      	adds	r0, r2, #1
    817c:	b2c0      	uxtb	r0, r0
    817e:	9000      	str	r0, [sp, #0]
    8180:	68f8      	ldr	r0, [r7, #12]
    8182:	f7ff ff93 	bl	80ac <_ZN14Gamebuino_Meta14Display_ST773513setAddrWindowEhhhh>

	//configure DMA
	myDMA.configure_peripheraltrigger(SERCOM4_DMAC_ID_TX);	// SERMCOM4 == SPI native SERCOM
    8186:	4c23      	ldr	r4, [pc, #140]	; (8214 <_ZN14Gamebuino_Meta14Display_ST773516drawBufferedLineEssPttRNS_5ImageE+0xec>)
    8188:	210a      	movs	r1, #10
    818a:	1c20      	adds	r0, r4, #0
    818c:	f7ff fad5 	bl	773a <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA27configure_peripheraltriggerEm>
	myDMA.configure_triggeraction(DMA_TRIGGER_ACTON_BEAT);
    8190:	2102      	movs	r1, #2
    8192:	1c20      	adds	r0, r4, #0
    8194:	f7ff fad3 	bl	773e <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA23configure_triggeractionE27dma_transfer_trigger_action>
	myDMA.setup_transfer_descriptor(bufferedLine,// move data from here
		(void *)(&SERCOM4->SPI.DATA.reg),		// to here
		w * 2,								// this many...
		DMA_BEAT_SIZE_BYTE,						// 8 bits bytes
		true,									// increment source addr?
		false);									// increment dest addr?
    8198:	2501      	movs	r5, #1
    819a:	2600      	movs	r6, #0
	//configure DMA
	myDMA.configure_peripheraltrigger(SERCOM4_DMAC_ID_TX);	// SERMCOM4 == SPI native SERCOM
	myDMA.configure_triggeraction(DMA_TRIGGER_ACTON_BEAT);

	//allocate DMA
	myDMA.allocate();
    819c:	1c20      	adds	r0, r4, #0
    819e:	f7ff fad0 	bl	7742 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA8allocateEv>
	myDMA.setup_transfer_descriptor(bufferedLine,// move data from here
		(void *)(&SERCOM4->SPI.DATA.reg),		// to here
		w * 2,								// this many...
		DMA_BEAT_SIZE_BYTE,						// 8 bits bytes
		true,									// increment source addr?
		false);									// increment dest addr?
    81a2:	9501      	str	r5, [sp, #4]
    81a4:	9600      	str	r6, [sp, #0]
    81a6:	9602      	str	r6, [sp, #8]
    81a8:	687b      	ldr	r3, [r7, #4]
    81aa:	68b9      	ldr	r1, [r7, #8]
    81ac:	4a1a      	ldr	r2, [pc, #104]	; (8218 <_ZN14Gamebuino_Meta14Display_ST773516drawBufferedLineEssPttRNS_5ImageE+0xf0>)
    81ae:	1c20      	adds	r0, r4, #0
    81b0:	f7ff facd 	bl	774e <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA25setup_transfer_descriptorEPvS1_m13dma_beat_sizebb>

	//add descriptor
	//Serial.print("Adding descriptor...");
	myDMA.add_descriptor();
    81b4:	1c20      	adds	r0, r4, #0
    81b6:	f7ff fb00 	bl	77ba <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA14add_descriptorEv>
	//printStatus(stat);

	//register and enable call back
	transfer_is_done = false;
    81ba:	4a18      	ldr	r2, [pc, #96]	; (821c <_ZN14Gamebuino_Meta14Display_ST773516drawBufferedLineEssPttRNS_5ImageE+0xf4>)
	myDMA.register_callback(dma_callback); // by default, called when xfer done
    81bc:	1c20      	adds	r0, r4, #0
	//Serial.print("Adding descriptor...");
	myDMA.add_descriptor();
	//printStatus(stat);

	//register and enable call back
	transfer_is_done = false;
    81be:	7016      	strb	r6, [r2, #0]
	myDMA.register_callback(dma_callback); // by default, called when xfer done
    81c0:	4917      	ldr	r1, [pc, #92]	; (8220 <_ZN14Gamebuino_Meta14Display_ST773516drawBufferedLineEssPttRNS_5ImageE+0xf8>)
    81c2:	1c2a      	adds	r2, r5, #0
    81c4:	f7ff fb0a 	bl	77dc <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA17register_callbackEPFvP12dma_resourceE17dma_callback_type>
	myDMA.enable_callback(); // by default, for xfer done registers
    81c8:	1c29      	adds	r1, r5, #0
    81ca:	1c20      	adds	r0, r4, #0
    81cc:	f7ff fb0a 	bl	77e4 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA15enable_callbackE17dma_callback_type>

	//start transfer
	// once started, we dont need to trigger it because it will autorun
	//Serial.println("Starting transfer job");
	SPI.beginTransaction(mySPISettings);
    81d0:	4d14      	ldr	r5, [pc, #80]	; (8224 <_ZN14Gamebuino_Meta14Display_ST773516drawBufferedLineEssPttRNS_5ImageE+0xfc>)
    81d2:	4b15      	ldr	r3, [pc, #84]	; (8228 <_ZN14Gamebuino_Meta14Display_ST773516drawBufferedLineEssPttRNS_5ImageE+0x100>)
    81d4:	1c28      	adds	r0, r5, #0
    81d6:	cb06      	ldmia	r3!, {r1, r2}
    81d8:	f006 ffac 	bl	f134 <_ZN8SPIClass16beginTransactionE11SPISettings>
	dataMode();
    81dc:	68f8      	ldr	r0, [r7, #12]
    81de:	f7ff fe01 	bl	7de4 <_ZN14Gamebuino_Meta14Display_ST77358dataModeEv>

	myDMA.start_transfer_job();
    81e2:	1c20      	adds	r0, r4, #0
    81e4:	f7ff faf5 	bl	77d2 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA18start_transfer_jobEv>
    81e8:	4a0c      	ldr	r2, [pc, #48]	; (821c <_ZN14Gamebuino_Meta14Display_ST773516drawBufferedLineEssPttRNS_5ImageE+0xf4>)

	while (!transfer_is_done); //chill
    81ea:	7813      	ldrb	r3, [r2, #0]
    81ec:	2b00      	cmp	r3, #0
    81ee:	d0fc      	beq.n	81ea <_ZN14Gamebuino_Meta14Display_ST773516drawBufferedLineEssPttRNS_5ImageE+0xc2>

	idleMode();
    81f0:	68f8      	ldr	r0, [r7, #12]
    81f2:	f7ff fe0d 	bl	7e10 <_ZN14Gamebuino_Meta14Display_ST77358idleModeEv>
	SPI.endTransaction();
    81f6:	1c28      	adds	r0, r5, #0
    81f8:	f006 ffb8 	bl	f16c <_ZN8SPIClass14endTransactionEv>
	myDMA.free(); //free the DMA channel
    81fc:	1c20      	adds	r0, r4, #0
    81fe:	f7ff fae3 	bl	77c8 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA4freeEv>

	PORT->Group[0].OUTCLR.reg = (1 << 17); // clear PORTA.17 high "digitalWrite(13, LOW)"
    8202:	4c03      	ldr	r4, [pc, #12]	; (8210 <_ZN14Gamebuino_Meta14Display_ST773516drawBufferedLineEssPttRNS_5ImageE+0xe8>)
    8204:	2380      	movs	r3, #128	; 0x80
    8206:	029b      	lsls	r3, r3, #10
}
    8208:	46bd      	mov	sp, r7

	idleMode();
	SPI.endTransaction();
	myDMA.free(); //free the DMA channel

	PORT->Group[0].OUTCLR.reg = (1 << 17); // clear PORTA.17 high "digitalWrite(13, LOW)"
    820a:	6163      	str	r3, [r4, #20]
}
    820c:	b005      	add	sp, #20
    820e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8210:	41004400 	.word	0x41004400
    8214:	20000c70 	.word	0x20000c70
    8218:	42001828 	.word	0x42001828
    821c:	20000c64 	.word	0x20000c64
    8220:	00007cf1 	.word	0x00007cf1
    8224:	20000e40 	.word	0x20000e40
    8228:	20000c5c 	.word	0x20000c5c

0000822c <_ZN14Gamebuino_Meta14Display_ST773510_drawPixelEss>:
#if defined (SPI_HAS_TRANSACTION)
	SPI.endTransaction();
#endif
}

void Display_ST7735::_drawPixel(int16_t x, int16_t y) {
    822c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    822e:	1c04      	adds	r4, r0, #0

	if((x < 0) ||(x >= _width) || (y < 0) || (y >= _height)) return;
    8230:	2900      	cmp	r1, #0
    8232:	db2c      	blt.n	828e <_ZN14Gamebuino_Meta14Display_ST773510_drawPixelEss+0x62>
    8234:	2010      	movs	r0, #16
    8236:	5e23      	ldrsh	r3, [r4, r0]
    8238:	428b      	cmp	r3, r1
    823a:	dd28      	ble.n	828e <_ZN14Gamebuino_Meta14Display_ST773510_drawPixelEss+0x62>
    823c:	2a00      	cmp	r2, #0
    823e:	db26      	blt.n	828e <_ZN14Gamebuino_Meta14Display_ST773510_drawPixelEss+0x62>
    8240:	2012      	movs	r0, #18
    8242:	5e23      	ldrsh	r3, [r4, r0]
    8244:	4293      	cmp	r3, r2
    8246:	dd22      	ble.n	828e <_ZN14Gamebuino_Meta14Display_ST773510_drawPixelEss+0x62>

	setAddrWindow(x,y,x+1,y+1);
    8248:	b2d2      	uxtb	r2, r2
    824a:	b2c9      	uxtb	r1, r1
    824c:	1c50      	adds	r0, r2, #1
    824e:	1c4b      	adds	r3, r1, #1
    8250:	b2c0      	uxtb	r0, r0
    8252:	b2db      	uxtb	r3, r3
    8254:	9000      	str	r0, [sp, #0]
    8256:	1c20      	adds	r0, r4, #0
    8258:	f7ff ff28 	bl	80ac <_ZN14Gamebuino_Meta14Display_ST773513setAddrWindowEhhhh>

#if defined (SPI_HAS_TRANSACTION)
	SPI.beginTransaction(mySPISettings);
    825c:	4d0c      	ldr	r5, [pc, #48]	; (8290 <_ZN14Gamebuino_Meta14Display_ST773510_drawPixelEss+0x64>)
    825e:	4b0d      	ldr	r3, [pc, #52]	; (8294 <_ZN14Gamebuino_Meta14Display_ST773510_drawPixelEss+0x68>)
    8260:	1c28      	adds	r0, r5, #0
    8262:	cb06      	ldmia	r3!, {r1, r2}
    8264:	f006 ff66 	bl	f134 <_ZN8SPIClass16beginTransactionE11SPISettings>
#endif
	dataMode();
    8268:	1c20      	adds	r0, r4, #0
    826a:	f7ff fdbb 	bl	7de4 <_ZN14Gamebuino_Meta14Display_ST77358dataModeEv>
	
	spiwrite((uint16_t)color.c >> 8);
    826e:	4e0a      	ldr	r6, [pc, #40]	; (8298 <_ZN14Gamebuino_Meta14Display_ST773510_drawPixelEss+0x6c>)
    8270:	1c20      	adds	r0, r4, #0
    8272:	8831      	ldrh	r1, [r6, #0]
    8274:	0a09      	lsrs	r1, r1, #8
    8276:	f7ff fd5b 	bl	7d30 <_ZN14Gamebuino_Meta14Display_ST77358spiwriteEh>
	spiwrite((uint16_t)color.c);
    827a:	7831      	ldrb	r1, [r6, #0]
    827c:	1c20      	adds	r0, r4, #0
    827e:	f7ff fd57 	bl	7d30 <_ZN14Gamebuino_Meta14Display_ST77358spiwriteEh>

	idleMode();
    8282:	1c20      	adds	r0, r4, #0
    8284:	f7ff fdc4 	bl	7e10 <_ZN14Gamebuino_Meta14Display_ST77358idleModeEv>
#if defined (SPI_HAS_TRANSACTION)
	SPI.endTransaction();
    8288:	1c28      	adds	r0, r5, #0
    828a:	f006 ff6f 	bl	f16c <_ZN8SPIClass14endTransactionEv>
#endif
}
    828e:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    8290:	20000e40 	.word	0x20000e40
    8294:	20000c5c 	.word	0x20000c5c
    8298:	20000cd8 	.word	0x20000cd8

0000829c <_ZN14Gamebuino_Meta14Display_ST773513drawFastVLineEsss>:


void Display_ST7735::drawFastVLine(int16_t x, int16_t y, int16_t h) {
    829c:	b5f0      	push	{r4, r5, r6, r7, lr}
    829e:	1c04      	adds	r4, r0, #0
    82a0:	1c1d      	adds	r5, r3, #0
	// Rudimentary clipping
	if((x >= _width) || (y >= _height)) return;
    82a2:	2010      	movs	r0, #16
    82a4:	5e23      	ldrsh	r3, [r4, r0]
	SPI.endTransaction();
#endif
}


void Display_ST7735::drawFastVLine(int16_t x, int16_t y, int16_t h) {
    82a6:	b085      	sub	sp, #20
	// Rudimentary clipping
	if((x >= _width) || (y >= _height)) return;
    82a8:	428b      	cmp	r3, r1
    82aa:	dd33      	ble.n	8314 <_ZN14Gamebuino_Meta14Display_ST773513drawFastVLineEsss+0x78>
    82ac:	8a63      	ldrh	r3, [r4, #18]
    82ae:	b218      	sxth	r0, r3
    82b0:	4282      	cmp	r2, r0
    82b2:	da2f      	bge.n	8314 <_ZN14Gamebuino_Meta14Display_ST773513drawFastVLineEsss+0x78>
	if((y+h-1) >= _height) h = _height-y;
    82b4:	1956      	adds	r6, r2, r5
    82b6:	4286      	cmp	r6, r0
    82b8:	dd01      	ble.n	82be <_ZN14Gamebuino_Meta14Display_ST773513drawFastVLineEsss+0x22>
    82ba:	1a9d      	subs	r5, r3, r2
    82bc:	b22d      	sxth	r5, r5
	setAddrWindow(x, y, x, y+h-1);
    82be:	b2d2      	uxtb	r2, r2
    82c0:	b2cb      	uxtb	r3, r1
    82c2:	1e51      	subs	r1, r2, #1
    82c4:	1949      	adds	r1, r1, r5
    82c6:	b2c9      	uxtb	r1, r1
    82c8:	9100      	str	r1, [sp, #0]
    82ca:	1c20      	adds	r0, r4, #0
    82cc:	1c19      	adds	r1, r3, #0
    82ce:	f7ff feed 	bl	80ac <_ZN14Gamebuino_Meta14Display_ST773513setAddrWindowEhhhh>

	uint8_t hi = (uint16_t)Graphics::color.c >> 8, lo = (uint16_t)Graphics::color.c;
    82d2:	4b11      	ldr	r3, [pc, #68]	; (8318 <_ZN14Gamebuino_Meta14Display_ST773513drawFastVLineEsss+0x7c>)
		
#if defined (SPI_HAS_TRANSACTION)
	SPI.beginTransaction(mySPISettings);
    82d4:	4e11      	ldr	r6, [pc, #68]	; (831c <_ZN14Gamebuino_Meta14Display_ST773513drawFastVLineEsss+0x80>)
	// Rudimentary clipping
	if((x >= _width) || (y >= _height)) return;
	if((y+h-1) >= _height) h = _height-y;
	setAddrWindow(x, y, x, y+h-1);

	uint8_t hi = (uint16_t)Graphics::color.c >> 8, lo = (uint16_t)Graphics::color.c;
    82d6:	881f      	ldrh	r7, [r3, #0]
		
#if defined (SPI_HAS_TRANSACTION)
	SPI.beginTransaction(mySPISettings);
    82d8:	1c30      	adds	r0, r6, #0
	// Rudimentary clipping
	if((x >= _width) || (y >= _height)) return;
	if((y+h-1) >= _height) h = _height-y;
	setAddrWindow(x, y, x, y+h-1);

	uint8_t hi = (uint16_t)Graphics::color.c >> 8, lo = (uint16_t)Graphics::color.c;
    82da:	0a3b      	lsrs	r3, r7, #8
    82dc:	9303      	str	r3, [sp, #12]
		
#if defined (SPI_HAS_TRANSACTION)
	SPI.beginTransaction(mySPISettings);
    82de:	4b10      	ldr	r3, [pc, #64]	; (8320 <_ZN14Gamebuino_Meta14Display_ST773513drawFastVLineEsss+0x84>)
	// Rudimentary clipping
	if((x >= _width) || (y >= _height)) return;
	if((y+h-1) >= _height) h = _height-y;
	setAddrWindow(x, y, x, y+h-1);

	uint8_t hi = (uint16_t)Graphics::color.c >> 8, lo = (uint16_t)Graphics::color.c;
    82e0:	b2ff      	uxtb	r7, r7
		
#if defined (SPI_HAS_TRANSACTION)
	SPI.beginTransaction(mySPISettings);
    82e2:	cb06      	ldmia	r3!, {r1, r2}
    82e4:	f006 ff26 	bl	f134 <_ZN8SPIClass16beginTransactionE11SPISettings>
#endif
	dataMode();
    82e8:	1c20      	adds	r0, r4, #0
    82ea:	f7ff fd7b 	bl	7de4 <_ZN14Gamebuino_Meta14Display_ST77358dataModeEv>
    82ee:	b2ad      	uxth	r5, r5
	while (h--) {
		spiwrite(hi);
    82f0:	1c20      	adds	r0, r4, #0
		
#if defined (SPI_HAS_TRANSACTION)
	SPI.beginTransaction(mySPISettings);
#endif
	dataMode();
	while (h--) {
    82f2:	2d00      	cmp	r5, #0
    82f4:	d009      	beq.n	830a <_ZN14Gamebuino_Meta14Display_ST773513drawFastVLineEsss+0x6e>
		spiwrite(hi);
    82f6:	9903      	ldr	r1, [sp, #12]
    82f8:	f7ff fd1a 	bl	7d30 <_ZN14Gamebuino_Meta14Display_ST77358spiwriteEh>
    82fc:	3d01      	subs	r5, #1
		spiwrite(lo);
    82fe:	1c20      	adds	r0, r4, #0
    8300:	1c39      	adds	r1, r7, #0
    8302:	f7ff fd15 	bl	7d30 <_ZN14Gamebuino_Meta14Display_ST77358spiwriteEh>
    8306:	b2ad      	uxth	r5, r5
    8308:	e7f2      	b.n	82f0 <_ZN14Gamebuino_Meta14Display_ST773513drawFastVLineEsss+0x54>
	}
	idleMode();
    830a:	f7ff fd81 	bl	7e10 <_ZN14Gamebuino_Meta14Display_ST77358idleModeEv>
#if defined (SPI_HAS_TRANSACTION)
	SPI.endTransaction();
    830e:	1c30      	adds	r0, r6, #0
    8310:	f006 ff2c 	bl	f16c <_ZN8SPIClass14endTransactionEv>
#endif
}
    8314:	b005      	add	sp, #20
    8316:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8318:	20000cd8 	.word	0x20000cd8
    831c:	20000e40 	.word	0x20000e40
    8320:	20000c5c 	.word	0x20000c5c

00008324 <_ZN14Gamebuino_Meta14Display_ST773513drawFastHLineEsss>:


void Display_ST7735::drawFastHLine(int16_t x, int16_t y, int16_t w) {
    8324:	b5f0      	push	{r4, r5, r6, r7, lr}
    8326:	1c1d      	adds	r5, r3, #0
	// Rudimentary clipping
	if((x >= _width) || (y >= _height)) return;
    8328:	8a03      	ldrh	r3, [r0, #16]
	SPI.endTransaction();
#endif
}


void Display_ST7735::drawFastHLine(int16_t x, int16_t y, int16_t w) {
    832a:	1c04      	adds	r4, r0, #0
	// Rudimentary clipping
	if((x >= _width) || (y >= _height)) return;
    832c:	b218      	sxth	r0, r3
	SPI.endTransaction();
#endif
}


void Display_ST7735::drawFastHLine(int16_t x, int16_t y, int16_t w) {
    832e:	b085      	sub	sp, #20
	// Rudimentary clipping
	if((x >= _width) || (y >= _height)) return;
    8330:	4281      	cmp	r1, r0
    8332:	da32      	bge.n	839a <_ZN14Gamebuino_Meta14Display_ST773513drawFastHLineEsss+0x76>
    8334:	2712      	movs	r7, #18
    8336:	5fe6      	ldrsh	r6, [r4, r7]
    8338:	4296      	cmp	r6, r2
    833a:	dd2e      	ble.n	839a <_ZN14Gamebuino_Meta14Display_ST773513drawFastHLineEsss+0x76>
	if((x+w-1) >= _width)	w = _width-x;
    833c:	194e      	adds	r6, r1, r5
    833e:	4286      	cmp	r6, r0
    8340:	dd01      	ble.n	8346 <_ZN14Gamebuino_Meta14Display_ST773513drawFastHLineEsss+0x22>
    8342:	1a5d      	subs	r5, r3, r1
    8344:	b22d      	sxth	r5, r5
	setAddrWindow(x, y, x+w-1, y);
    8346:	b2c9      	uxtb	r1, r1
    8348:	1e4b      	subs	r3, r1, #1
    834a:	b2d2      	uxtb	r2, r2
    834c:	195b      	adds	r3, r3, r5
    834e:	b2db      	uxtb	r3, r3
    8350:	9200      	str	r2, [sp, #0]
    8352:	1c20      	adds	r0, r4, #0
    8354:	f7ff feaa 	bl	80ac <_ZN14Gamebuino_Meta14Display_ST773513setAddrWindowEhhhh>

	uint8_t hi = (uint16_t)Graphics::color.c >> 8, lo = (uint16_t)Graphics::color.c;
    8358:	4b11      	ldr	r3, [pc, #68]	; (83a0 <_ZN14Gamebuino_Meta14Display_ST773513drawFastHLineEsss+0x7c>)

#if defined (SPI_HAS_TRANSACTION)
	SPI.beginTransaction(mySPISettings);
    835a:	4e12      	ldr	r6, [pc, #72]	; (83a4 <_ZN14Gamebuino_Meta14Display_ST773513drawFastHLineEsss+0x80>)
	// Rudimentary clipping
	if((x >= _width) || (y >= _height)) return;
	if((x+w-1) >= _width)	w = _width-x;
	setAddrWindow(x, y, x+w-1, y);

	uint8_t hi = (uint16_t)Graphics::color.c >> 8, lo = (uint16_t)Graphics::color.c;
    835c:	881f      	ldrh	r7, [r3, #0]

#if defined (SPI_HAS_TRANSACTION)
	SPI.beginTransaction(mySPISettings);
    835e:	1c30      	adds	r0, r6, #0
	// Rudimentary clipping
	if((x >= _width) || (y >= _height)) return;
	if((x+w-1) >= _width)	w = _width-x;
	setAddrWindow(x, y, x+w-1, y);

	uint8_t hi = (uint16_t)Graphics::color.c >> 8, lo = (uint16_t)Graphics::color.c;
    8360:	0a3b      	lsrs	r3, r7, #8
    8362:	9303      	str	r3, [sp, #12]

#if defined (SPI_HAS_TRANSACTION)
	SPI.beginTransaction(mySPISettings);
    8364:	4b10      	ldr	r3, [pc, #64]	; (83a8 <_ZN14Gamebuino_Meta14Display_ST773513drawFastHLineEsss+0x84>)
	// Rudimentary clipping
	if((x >= _width) || (y >= _height)) return;
	if((x+w-1) >= _width)	w = _width-x;
	setAddrWindow(x, y, x+w-1, y);

	uint8_t hi = (uint16_t)Graphics::color.c >> 8, lo = (uint16_t)Graphics::color.c;
    8366:	b2ff      	uxtb	r7, r7

#if defined (SPI_HAS_TRANSACTION)
	SPI.beginTransaction(mySPISettings);
    8368:	cb06      	ldmia	r3!, {r1, r2}
    836a:	f006 fee3 	bl	f134 <_ZN8SPIClass16beginTransactionE11SPISettings>
#endif
	dataMode();
    836e:	1c20      	adds	r0, r4, #0
    8370:	f7ff fd38 	bl	7de4 <_ZN14Gamebuino_Meta14Display_ST77358dataModeEv>
    8374:	b2ad      	uxth	r5, r5
	while (w--) {
		spiwrite(hi);
    8376:	1c20      	adds	r0, r4, #0

#if defined (SPI_HAS_TRANSACTION)
	SPI.beginTransaction(mySPISettings);
#endif
	dataMode();
	while (w--) {
    8378:	2d00      	cmp	r5, #0
    837a:	d009      	beq.n	8390 <_ZN14Gamebuino_Meta14Display_ST773513drawFastHLineEsss+0x6c>
		spiwrite(hi);
    837c:	9903      	ldr	r1, [sp, #12]
    837e:	f7ff fcd7 	bl	7d30 <_ZN14Gamebuino_Meta14Display_ST77358spiwriteEh>
    8382:	3d01      	subs	r5, #1
		spiwrite(lo);
    8384:	1c20      	adds	r0, r4, #0
    8386:	1c39      	adds	r1, r7, #0
    8388:	f7ff fcd2 	bl	7d30 <_ZN14Gamebuino_Meta14Display_ST77358spiwriteEh>
    838c:	b2ad      	uxth	r5, r5
    838e:	e7f2      	b.n	8376 <_ZN14Gamebuino_Meta14Display_ST773513drawFastHLineEsss+0x52>
	}
	idleMode();
    8390:	f7ff fd3e 	bl	7e10 <_ZN14Gamebuino_Meta14Display_ST77358idleModeEv>
#if defined (SPI_HAS_TRANSACTION)
	SPI.endTransaction();
    8394:	1c30      	adds	r0, r6, #0
    8396:	f006 fee9 	bl	f16c <_ZN8SPIClass14endTransactionEv>
#endif
}
    839a:	b005      	add	sp, #20
    839c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    839e:	46c0      	nop			; (mov r8, r8)
    83a0:	20000cd8 	.word	0x20000cd8
    83a4:	20000e40 	.word	0x20000e40
    83a8:	20000c5c 	.word	0x20000c5c

000083ac <_ZN14Gamebuino_Meta14Display_ST77358fillRectEssss>:

// fill a rectangle
void Display_ST7735::fillRect(int16_t x, int16_t y, int16_t w, int16_t h) {
    83ac:	b5f0      	push	{r4, r5, r6, r7, lr}
    83ae:	b087      	sub	sp, #28
    83b0:	1c04      	adds	r4, r0, #0
    83b2:	9303      	str	r3, [sp, #12]
    83b4:	ab0c      	add	r3, sp, #48	; 0x30
    83b6:	2000      	movs	r0, #0
    83b8:	5e1e      	ldrsh	r6, [r3, r0]
	// rudimentary clipping (drawChar w/big text requires this)
	if((x >= _width) || (y >= _height)) return;
    83ba:	8a20      	ldrh	r0, [r4, #16]
    83bc:	b205      	sxth	r5, r0
    83be:	42a9      	cmp	r1, r5
    83c0:	da46      	bge.n	8450 <_ZN14Gamebuino_Meta14Display_ST77358fillRectEssss+0xa4>
    83c2:	8a63      	ldrh	r3, [r4, #18]
    83c4:	469c      	mov	ip, r3
    83c6:	b21b      	sxth	r3, r3
    83c8:	429a      	cmp	r2, r3
    83ca:	da41      	bge.n	8450 <_ZN14Gamebuino_Meta14Display_ST77358fillRectEssss+0xa4>
	if((x + w - 1) >= _width)	w = _width	- x;
    83cc:	9f03      	ldr	r7, [sp, #12]
    83ce:	19cf      	adds	r7, r1, r7
    83d0:	42af      	cmp	r7, r5
    83d2:	dd02      	ble.n	83da <_ZN14Gamebuino_Meta14Display_ST77358fillRectEssss+0x2e>
    83d4:	1a40      	subs	r0, r0, r1
    83d6:	b205      	sxth	r5, r0
    83d8:	9503      	str	r5, [sp, #12]
	if((y + h - 1) >= _height) h = _height - y;
    83da:	1990      	adds	r0, r2, r6
    83dc:	4298      	cmp	r0, r3
    83de:	dd02      	ble.n	83e6 <_ZN14Gamebuino_Meta14Display_ST77358fillRectEssss+0x3a>
    83e0:	4667      	mov	r7, ip
    83e2:	1abe      	subs	r6, r7, r2
    83e4:	b236      	sxth	r6, r6

	setAddrWindow(x, y, x+w-1, y+h-1);
    83e6:	b2d2      	uxtb	r2, r2
    83e8:	b2c9      	uxtb	r1, r1
    83ea:	1e50      	subs	r0, r2, #1
    83ec:	9d03      	ldr	r5, [sp, #12]
    83ee:	1e4b      	subs	r3, r1, #1
    83f0:	1980      	adds	r0, r0, r6
    83f2:	b2c0      	uxtb	r0, r0
    83f4:	195b      	adds	r3, r3, r5
    83f6:	b2db      	uxtb	r3, r3
    83f8:	9000      	str	r0, [sp, #0]
    83fa:	1c20      	adds	r0, r4, #0
    83fc:	f7ff fe56 	bl	80ac <_ZN14Gamebuino_Meta14Display_ST773513setAddrWindowEhhhh>

	uint8_t hi = (uint16_t)Graphics::color.c >> 8, lo = (uint16_t)Graphics::color.c;
    8400:	4b14      	ldr	r3, [pc, #80]	; (8454 <_ZN14Gamebuino_Meta14Display_ST77358fillRectEssss+0xa8>)
    8402:	881b      	ldrh	r3, [r3, #0]
    8404:	0a1f      	lsrs	r7, r3, #8
    8406:	b2db      	uxtb	r3, r3
    8408:	9704      	str	r7, [sp, #16]
    840a:	9305      	str	r3, [sp, #20]
		
#if defined (SPI_HAS_TRANSACTION)
	SPI.beginTransaction(mySPISettings);
    840c:	4f12      	ldr	r7, [pc, #72]	; (8458 <_ZN14Gamebuino_Meta14Display_ST77358fillRectEssss+0xac>)
    840e:	4b13      	ldr	r3, [pc, #76]	; (845c <_ZN14Gamebuino_Meta14Display_ST77358fillRectEssss+0xb0>)
    8410:	1c38      	adds	r0, r7, #0
    8412:	cb06      	ldmia	r3!, {r1, r2}
    8414:	f006 fe8e 	bl	f134 <_ZN8SPIClass16beginTransactionE11SPISettings>
#endif
	dataMode();
    8418:	1c20      	adds	r0, r4, #0
    841a:	f7ff fce3 	bl	7de4 <_ZN14Gamebuino_Meta14Display_ST77358dataModeEv>
	for(y=h; y>0; y--) {
    841e:	2e00      	cmp	r6, #0
    8420:	dd10      	ble.n	8444 <_ZN14Gamebuino_Meta14Display_ST77358fillRectEssss+0x98>
    8422:	9d03      	ldr	r5, [sp, #12]
		for(x=w; x>0; x--) {
    8424:	2d00      	cmp	r5, #0
    8426:	dd0a      	ble.n	843e <_ZN14Gamebuino_Meta14Display_ST77358fillRectEssss+0x92>
			spiwrite(hi);
    8428:	1c20      	adds	r0, r4, #0
    842a:	9904      	ldr	r1, [sp, #16]
    842c:	f7ff fc80 	bl	7d30 <_ZN14Gamebuino_Meta14Display_ST77358spiwriteEh>
    8430:	3d01      	subs	r5, #1
			spiwrite(lo);
    8432:	1c20      	adds	r0, r4, #0
    8434:	9905      	ldr	r1, [sp, #20]
    8436:	f7ff fc7b 	bl	7d30 <_ZN14Gamebuino_Meta14Display_ST77358spiwriteEh>
    843a:	b22d      	sxth	r5, r5
    843c:	e7f2      	b.n	8424 <_ZN14Gamebuino_Meta14Display_ST77358fillRectEssss+0x78>
    843e:	3e01      	subs	r6, #1
    8440:	b236      	sxth	r6, r6
    8442:	e7ec      	b.n	841e <_ZN14Gamebuino_Meta14Display_ST77358fillRectEssss+0x72>
		}
	}

	idleMode();
    8444:	1c20      	adds	r0, r4, #0
    8446:	f7ff fce3 	bl	7e10 <_ZN14Gamebuino_Meta14Display_ST77358idleModeEv>
#if defined (SPI_HAS_TRANSACTION)
	SPI.endTransaction();
    844a:	1c38      	adds	r0, r7, #0
    844c:	f006 fe8e 	bl	f16c <_ZN8SPIClass14endTransactionEv>
#endif
}
    8450:	b007      	add	sp, #28
    8452:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8454:	20000cd8 	.word	0x20000cd8
    8458:	20000e40 	.word	0x20000e40
    845c:	20000c5c 	.word	0x20000c5c

00008460 <_ZN14Gamebuino_Meta21bufferIndexLineDoubleEPtS0_st>:
	}
	
	Graphics::drawImage(x, y, img); //fallback to the usual
}

void bufferIndexLineDouble(uint16_t* preBufferLine, uint16_t* img_buffer, int16_t w, uint16_t j) {
    8460:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    8462:	1c06      	adds	r6, r0, #0
	int16_t w2 = w*2;
    8464:	b290      	uxth	r0, r2
	uint16_t *dest = preBufferLine;
	uint16_t *src = img_buffer + ((j * w) / 4);
    8466:	435a      	muls	r2, r3
    8468:	17d3      	asrs	r3, r2, #31
    846a:	0f9b      	lsrs	r3, r3, #30
    846c:	189a      	adds	r2, r3, r2
    846e:	1092      	asrs	r2, r2, #2
    8470:	0052      	lsls	r2, r2, #1
	Color *index = Graphics::colorIndex;
    8472:	4b1b      	ldr	r3, [pc, #108]	; (84e0 <_ZN14Gamebuino_Meta21bufferIndexLineDoubleEPtS0_st+0x80>)
	
	Graphics::drawImage(x, y, img); //fallback to the usual
}

void bufferIndexLineDouble(uint16_t* preBufferLine, uint16_t* img_buffer, int16_t w, uint16_t j) {
	int16_t w2 = w*2;
    8474:	0044      	lsls	r4, r0, #1
	uint16_t *dest = preBufferLine;
	uint16_t *src = img_buffer + ((j * w) / 4);
    8476:	1889      	adds	r1, r1, r2
	
	Graphics::drawImage(x, y, img); //fallback to the usual
}

void bufferIndexLineDouble(uint16_t* preBufferLine, uint16_t* img_buffer, int16_t w, uint16_t j) {
	int16_t w2 = w*2;
    8478:	b2a4      	uxth	r4, r4
    847a:	9401      	str	r4, [sp, #4]
	uint16_t *dest = preBufferLine;
	uint16_t *src = img_buffer + ((j * w) / 4);
    847c:	468c      	mov	ip, r1
	Color *index = Graphics::colorIndex;
    847e:	681c      	ldr	r4, [r3, #0]
	uint16_t length = w;
	for (uint16_t i = 0; i < length / 4; i++) {
    8480:	0881      	lsrs	r1, r0, #2
    8482:	1c33      	adds	r3, r6, #0
    8484:	2200      	movs	r2, #0
    8486:	b290      	uxth	r0, r2
    8488:	4288      	cmp	r0, r1
    848a:	d221      	bcs.n	84d0 <_ZN14Gamebuino_Meta21bufferIndexLineDoubleEPtS0_st+0x70>
    848c:	0050      	lsls	r0, r2, #1
		uint16_t index1 = (src[i] >> 4) & 0x000F;
    848e:	4667      	mov	r7, ip
    8490:	5a3d      	ldrh	r5, [r7, r0]
    8492:	200f      	movs	r0, #15
    8494:	112f      	asrs	r7, r5, #4
		uint16_t index2 = (src[i] >> 0) & 0x000F;
		uint16_t index3 = (src[i] >> 12) & 0x000F;
		uint16_t index4 = (src[i] >> 8) & 0x000F;
		//change pixel order (because of words endianness) at the same time
		// endians are swapped because SPI sends byte-by-byte instead of word-by-word
		*(dest++) = swap_endians_16((uint16_t)index[index1]);
    8496:	4007      	ands	r7, r0
    8498:	007f      	lsls	r7, r7, #1
    849a:	5b3f      	ldrh	r7, [r7, r4]
    849c:	3201      	adds	r2, #1
    849e:	ba7f      	rev16	r7, r7
    84a0:	801f      	strh	r7, [r3, #0]
		*(dest++) = swap_endians_16((uint16_t)index[index1]);
    84a2:	805f      	strh	r7, [r3, #2]
		*(dest++) = swap_endians_16((uint16_t)index[index2]);
    84a4:	1c2f      	adds	r7, r5, #0
    84a6:	4007      	ands	r7, r0
    84a8:	007f      	lsls	r7, r7, #1
    84aa:	5b3f      	ldrh	r7, [r7, r4]
    84ac:	ba7f      	rev16	r7, r7
    84ae:	809f      	strh	r7, [r3, #4]
		*(dest++) = swap_endians_16((uint16_t)index[index2]);
    84b0:	80df      	strh	r7, [r3, #6]
		*(dest++) = swap_endians_16((uint16_t)index[index3]);
    84b2:	0b2f      	lsrs	r7, r5, #12
	uint16_t length = w;
	for (uint16_t i = 0; i < length / 4; i++) {
		uint16_t index1 = (src[i] >> 4) & 0x000F;
		uint16_t index2 = (src[i] >> 0) & 0x000F;
		uint16_t index3 = (src[i] >> 12) & 0x000F;
		uint16_t index4 = (src[i] >> 8) & 0x000F;
    84b4:	122d      	asrs	r5, r5, #8
		*(dest++) = swap_endians_16((uint16_t)index[index1]);
		*(dest++) = swap_endians_16((uint16_t)index[index2]);
		*(dest++) = swap_endians_16((uint16_t)index[index2]);
		*(dest++) = swap_endians_16((uint16_t)index[index3]);
		*(dest++) = swap_endians_16((uint16_t)index[index3]);
		*(dest++) = swap_endians_16((uint16_t)index[index4]);
    84b6:	4028      	ands	r0, r5
		// endians are swapped because SPI sends byte-by-byte instead of word-by-word
		*(dest++) = swap_endians_16((uint16_t)index[index1]);
		*(dest++) = swap_endians_16((uint16_t)index[index1]);
		*(dest++) = swap_endians_16((uint16_t)index[index2]);
		*(dest++) = swap_endians_16((uint16_t)index[index2]);
		*(dest++) = swap_endians_16((uint16_t)index[index3]);
    84b8:	007f      	lsls	r7, r7, #1
		*(dest++) = swap_endians_16((uint16_t)index[index3]);
		*(dest++) = swap_endians_16((uint16_t)index[index4]);
    84ba:	0040      	lsls	r0, r0, #1
    84bc:	5b3f      	ldrh	r7, [r7, r4]
    84be:	5b00      	ldrh	r0, [r0, r4]
    84c0:	ba7f      	rev16	r7, r7
    84c2:	ba40      	rev16	r0, r0
		// endians are swapped because SPI sends byte-by-byte instead of word-by-word
		*(dest++) = swap_endians_16((uint16_t)index[index1]);
		*(dest++) = swap_endians_16((uint16_t)index[index1]);
		*(dest++) = swap_endians_16((uint16_t)index[index2]);
		*(dest++) = swap_endians_16((uint16_t)index[index2]);
		*(dest++) = swap_endians_16((uint16_t)index[index3]);
    84c4:	811f      	strh	r7, [r3, #8]
		*(dest++) = swap_endians_16((uint16_t)index[index3]);
    84c6:	815f      	strh	r7, [r3, #10]
		*(dest++) = swap_endians_16((uint16_t)index[index4]);
    84c8:	8198      	strh	r0, [r3, #12]
		*(dest++) = swap_endians_16((uint16_t)index[index4]);
    84ca:	81d8      	strh	r0, [r3, #14]
    84cc:	3310      	adds	r3, #16
    84ce:	e7da      	b.n	8486 <_ZN14Gamebuino_Meta21bufferIndexLineDoubleEPtS0_st+0x26>
	}
	
	memcpy(&preBufferLine[w2], preBufferLine, w2 * 2); //double the line on the second half of the buffer
    84d0:	9b01      	ldr	r3, [sp, #4]
    84d2:	1c31      	adds	r1, r6, #0
    84d4:	b21a      	sxth	r2, r3
    84d6:	0052      	lsls	r2, r2, #1
    84d8:	18b0      	adds	r0, r6, r2
    84da:	f009 f86e 	bl	115ba <memcpy>
}
    84de:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    84e0:	20000050 	.word	0x20000050

000084e4 <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh>:
#define MADCTL_ML	0x10
#define MADCTL_RGB 0x00
#define MADCTL_BGR 0x08
#define MADCTL_MH	0x04

void Display_ST7735::setRotation(uint8_t m) {
    84e4:	b538      	push	{r3, r4, r5, lr}
    84e6:	1c0d      	adds	r5, r1, #0
	writecommand(ST7735_MADCTL);
    84e8:	2136      	movs	r1, #54	; 0x36
#define MADCTL_ML	0x10
#define MADCTL_RGB 0x00
#define MADCTL_BGR 0x08
#define MADCTL_MH	0x04

void Display_ST7735::setRotation(uint8_t m) {
    84ea:	1c04      	adds	r4, r0, #0
	writecommand(ST7735_MADCTL);
    84ec:	f7ff fc96 	bl	7e1c <_ZN14Gamebuino_Meta14Display_ST773512writecommandEh>
	rotation = m % 4; // can't be higher than 3
    84f0:	4b21      	ldr	r3, [pc, #132]	; (8578 <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh+0x94>)
    84f2:	2103      	movs	r1, #3
    84f4:	4029      	ands	r1, r5
    84f6:	7019      	strb	r1, [r3, #0]
    84f8:	7d63      	ldrb	r3, [r4, #21]
		}
		_height = ST7735_TFTWIDTH;
		break;
	case 2:
		if (tabcolor == INITR_BLACKTAB) {
			writedata(MADCTL_RGB);
    84fa:	1c20      	adds	r0, r4, #0
#define MADCTL_MH	0x04

void Display_ST7735::setRotation(uint8_t m) {
	writecommand(ST7735_MADCTL);
	rotation = m % 4; // can't be higher than 3
	switch (rotation) {
    84fc:	2902      	cmp	r1, #2
    84fe:	d017      	beq.n	8530 <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh+0x4c>
    8500:	2903      	cmp	r1, #3
    8502:	d026      	beq.n	8552 <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh+0x6e>
    8504:	2901      	cmp	r1, #1
    8506:	d009      	beq.n	851c <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh+0x38>
	case 0:
		if (tabcolor == INITR_BLACKTAB) {
    8508:	2b02      	cmp	r3, #2
    850a:	d103      	bne.n	8514 <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh+0x30>
			writedata(MADCTL_MX | MADCTL_MY | MADCTL_RGB);
    850c:	21c0      	movs	r1, #192	; 0xc0
    850e:	f7ff fca9 	bl	7e64 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh>
    8512:	e016      	b.n	8542 <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh+0x5e>
		} else {
			writedata(MADCTL_MX | MADCTL_MY | MADCTL_BGR);
    8514:	21c8      	movs	r1, #200	; 0xc8
    8516:	f7ff fca5 	bl	7e64 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh>
    851a:	e012      	b.n	8542 <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh+0x5e>
		} else {
			_height = ST7735_TFTHEIGHT_18;
		}
		break;
	case 1:
		if (tabcolor == INITR_BLACKTAB) {
    851c:	2b02      	cmp	r3, #2
    851e:	d103      	bne.n	8528 <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh+0x44>
			writedata(MADCTL_MY | MADCTL_MV | MADCTL_RGB);
    8520:	21a0      	movs	r1, #160	; 0xa0
    8522:	f7ff fc9f 	bl	7e64 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh>
    8526:	e01d      	b.n	8564 <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh+0x80>
		} else {
			writedata(MADCTL_MY | MADCTL_MV | MADCTL_BGR);
    8528:	21a8      	movs	r1, #168	; 0xa8
    852a:	f7ff fc9b 	bl	7e64 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh>
    852e:	e019      	b.n	8564 <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh+0x80>
			_width = ST7735_TFTHEIGHT_18;
		}
		_height = ST7735_TFTWIDTH;
		break;
	case 2:
		if (tabcolor == INITR_BLACKTAB) {
    8530:	2b02      	cmp	r3, #2
    8532:	d103      	bne.n	853c <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh+0x58>
			writedata(MADCTL_RGB);
    8534:	2100      	movs	r1, #0
    8536:	f7ff fc95 	bl	7e64 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh>
    853a:	e002      	b.n	8542 <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh+0x5e>
		} else {
			writedata(MADCTL_BGR);
    853c:	2108      	movs	r1, #8
    853e:	f7ff fc91 	bl	7e64 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh>
		}
		_width	= ST7735_TFTWIDTH;
		if (tabcolor == INITR_144GREENTAB) {
    8542:	7d62      	ldrb	r2, [r4, #21]
		if (tabcolor == INITR_BLACKTAB) {
			writedata(MADCTL_RGB);
		} else {
			writedata(MADCTL_BGR);
		}
		_width	= ST7735_TFTWIDTH;
    8544:	2380      	movs	r3, #128	; 0x80
    8546:	8223      	strh	r3, [r4, #16]
		if (tabcolor == INITR_144GREENTAB) {
    8548:	2a01      	cmp	r2, #1
    854a:	d013      	beq.n	8574 <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh+0x90>
			_height = ST7735_TFTHEIGHT_144;
		} else {
			_height = ST7735_TFTHEIGHT_18;
    854c:	23a0      	movs	r3, #160	; 0xa0
    854e:	8263      	strh	r3, [r4, #18]
    8550:	e011      	b.n	8576 <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh+0x92>
		}
		break;
	case 3:
		if (tabcolor == INITR_BLACKTAB) {
    8552:	2b02      	cmp	r3, #2
    8554:	d103      	bne.n	855e <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh+0x7a>
			writedata(MADCTL_MX | MADCTL_MV | MADCTL_RGB);
    8556:	2160      	movs	r1, #96	; 0x60
    8558:	f7ff fc84 	bl	7e64 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh>
    855c:	e002      	b.n	8564 <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh+0x80>
		} else {
			writedata(MADCTL_MX | MADCTL_MV | MADCTL_BGR);
    855e:	2168      	movs	r1, #104	; 0x68
    8560:	f7ff fc80 	bl	7e64 <_ZN14Gamebuino_Meta14Display_ST77359writedataEh>
		}
		if (tabcolor == INITR_144GREENTAB) {
    8564:	7d62      	ldrb	r2, [r4, #21]
    8566:	2380      	movs	r3, #128	; 0x80
    8568:	2a01      	cmp	r2, #1
    856a:	d101      	bne.n	8570 <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh+0x8c>
			_width = ST7735_TFTHEIGHT_144;
    856c:	8223      	strh	r3, [r4, #16]
    856e:	e001      	b.n	8574 <_ZN14Gamebuino_Meta14Display_ST773511setRotationEh+0x90>
		} else {
			_width = ST7735_TFTHEIGHT_18;
    8570:	22a0      	movs	r2, #160	; 0xa0
    8572:	8222      	strh	r2, [r4, #16]
		}
		_height = ST7735_TFTWIDTH;
    8574:	8263      	strh	r3, [r4, #18]
		break;
	}
}
    8576:	bd38      	pop	{r3, r4, r5, pc}
    8578:	20000ccc 	.word	0x20000ccc

0000857c <_GLOBAL__sub_I__ZN14Gamebuino_Meta5myDMAE>:

void Display_ST7735::invertDisplay(boolean i) {
	writecommand(i ? ST7735_INVON : ST7735_INVOFF);
}

} // namespace Gamebuino_Meta
    857c:	b508      	push	{r3, lr}
#include "../Adafruit_ZeroDMA/utility/dma.h"

namespace Gamebuino_Meta {


Adafruit_ZeroDMA myDMA;
    857e:	4805      	ldr	r0, [pc, #20]	; (8594 <_GLOBAL__sub_I__ZN14Gamebuino_Meta5myDMAE+0x18>)
    8580:	f7ff f8d5 	bl	772e <_ZN14Gamebuino_Meta16Adafruit_ZeroDMAC1Ev>
    8584:	4b04      	ldr	r3, [pc, #16]	; (8598 <_GLOBAL__sub_I__ZN14Gamebuino_Meta5myDMAE+0x1c>)
    8586:	4a05      	ldr	r2, [pc, #20]	; (859c <_GLOBAL__sub_I__ZN14Gamebuino_Meta5myDMAE+0x20>)
    8588:	601a      	str	r2, [r3, #0]

    this->bitOrder = (bitOrder == MSBFIRST ? MSB_FIRST : LSB_FIRST);
    858a:	2200      	movs	r2, #0
    858c:	715a      	strb	r2, [r3, #5]

    switch (dataMode)
    {
      case SPI_MODE0:
        this->dataMode = SERCOM_SPI_MODE_0; break;
    858e:	711a      	strb	r2, [r3, #4]

void Display_ST7735::invertDisplay(boolean i) {
	writecommand(i ? ST7735_INVON : ST7735_INVOFF);
}

} // namespace Gamebuino_Meta
    8590:	bd08      	pop	{r3, pc}
    8592:	46c0      	nop			; (mov r8, r8)
    8594:	20000c70 	.word	0x20000c70
    8598:	20000c5c 	.word	0x20000c5c
    859c:	003d0900 	.word	0x003d0900

000085a0 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE>:

void Display_ST7735::idleMode() {
	*csport |= cspinmask;
}

void Display_ST7735::drawImage(int16_t x, int16_t y, Image& img){
    85a0:	b5f0      	push	{r4, r5, r6, r7, lr}
    85a2:	b08f      	sub	sp, #60	; 0x3c
    85a4:	af02      	add	r7, sp, #8
    85a6:	1c1e      	adds	r6, r3, #0
    85a8:	62f8      	str	r0, [r7, #44]	; 0x2c
	img.nextFrame();
    85aa:	1c18      	adds	r0, r3, #0

void Display_ST7735::idleMode() {
	*csport |= cspinmask;
}

void Display_ST7735::drawImage(int16_t x, int16_t y, Image& img){
    85ac:	1c15      	adds	r5, r2, #0
    85ae:	62b9      	str	r1, [r7, #40]	; 0x28
	img.nextFrame();
    85b0:	f002 fc46 	bl	ae40 <_ZN14Gamebuino_Meta5Image9nextFrameEv>
	int16_t w = img._width;
    85b4:	8a34      	ldrh	r4, [r6, #16]
	int16_t h = img._height;
    85b6:	8a72      	ldrh	r2, [r6, #18]
	if (w == 0 || h == 0) {
    85b8:	2c00      	cmp	r4, #0
    85ba:	d100      	bne.n	85be <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x1e>
    85bc:	e0c2      	b.n	8744 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x1a4>
    85be:	2a00      	cmp	r2, #0
    85c0:	d100      	bne.n	85c4 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x24>
    85c2:	e0bf      	b.n	8744 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x1a4>
		return;
	}

	if ((img.colorMode == ColorMode::index) && (w == _width) && (h == _height)) {
    85c4:	7ab3      	ldrb	r3, [r6, #10]
    85c6:	2b01      	cmp	r3, #1
    85c8:	d000      	beq.n	85cc <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x2c>
    85ca:	e0b5      	b.n	8738 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x198>
    85cc:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    85ce:	2310      	movs	r3, #16
    85d0:	5ec9      	ldrsh	r1, [r1, r3]
    85d2:	b223      	sxth	r3, r4
    85d4:	6239      	str	r1, [r7, #32]
    85d6:	4299      	cmp	r1, r3
    85d8:	d000      	beq.n	85dc <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x3c>
    85da:	e0ad      	b.n	8738 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x198>
    85dc:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    85de:	2312      	movs	r3, #18
    85e0:	5ecb      	ldrsh	r3, [r1, r3]
    85e2:	b211      	sxth	r1, r2
    85e4:	6179      	str	r1, [r7, #20]
    85e6:	428b      	cmp	r3, r1
    85e8:	d000      	beq.n	85ec <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x4c>
    85ea:	e0a5      	b.n	8738 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x198>
    85ec:	466d      	mov	r5, sp
    85ee:	613d      	str	r5, [r7, #16]

		uint16_t preBufferLineArray[w];
    85f0:	6a3d      	ldr	r5, [r7, #32]
    85f2:	4669      	mov	r1, sp
    85f4:	006b      	lsls	r3, r5, #1
    85f6:	3308      	adds	r3, #8
    85f8:	08db      	lsrs	r3, r3, #3
    85fa:	00db      	lsls	r3, r3, #3
    85fc:	1ac9      	subs	r1, r1, r3
    85fe:	468d      	mov	sp, r1
		uint16_t sendBufferLineArray[w];
    8600:	1ac9      	subs	r1, r1, r3
		return;
	}

	if ((img.colorMode == ColorMode::index) && (w == _width) && (h == _height)) {

		uint16_t preBufferLineArray[w];
    8602:	ad02      	add	r5, sp, #8
		uint16_t sendBufferLineArray[w];
		uint16_t *preBufferLine = preBufferLineArray;
		uint16_t *sendBufferLine = sendBufferLineArray;

		//set the window to the whole screen
		setAddrWindow(0, 0, _width - 1, _height - 1);
    8604:	3a01      	subs	r2, #1
	}

	if ((img.colorMode == ColorMode::index) && (w == _width) && (h == _height)) {

		uint16_t preBufferLineArray[w];
		uint16_t sendBufferLineArray[w];
    8606:	468d      	mov	sp, r1
		return;
	}

	if ((img.colorMode == ColorMode::index) && (w == _width) && (h == _height)) {

		uint16_t preBufferLineArray[w];
    8608:	62bd      	str	r5, [r7, #40]	; 0x28
		uint16_t sendBufferLineArray[w];
		uint16_t *preBufferLine = preBufferLineArray;
		uint16_t *sendBufferLine = sendBufferLineArray;

		//set the window to the whole screen
		setAddrWindow(0, 0, _width - 1, _height - 1);
    860a:	b2d2      	uxtb	r2, r2
	}

	if ((img.colorMode == ColorMode::index) && (w == _width) && (h == _height)) {

		uint16_t preBufferLineArray[w];
		uint16_t sendBufferLineArray[w];
    860c:	ad02      	add	r5, sp, #8
		uint16_t *preBufferLine = preBufferLineArray;
		uint16_t *sendBufferLine = sendBufferLineArray;

		//set the window to the whole screen
		setAddrWindow(0, 0, _width - 1, _height - 1);
    860e:	2100      	movs	r1, #0
	}

	if ((img.colorMode == ColorMode::index) && (w == _width) && (h == _height)) {

		uint16_t preBufferLineArray[w];
		uint16_t sendBufferLineArray[w];
    8610:	61fd      	str	r5, [r7, #28]
		uint16_t *preBufferLine = preBufferLineArray;
		uint16_t *sendBufferLine = sendBufferLineArray;

		//set the window to the whole screen
		setAddrWindow(0, 0, _width - 1, _height - 1);
    8612:	1e63      	subs	r3, r4, #1
    8614:	9200      	str	r2, [sp, #0]
    8616:	b2db      	uxtb	r3, r3
    8618:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    861a:	1c0a      	adds	r2, r1, #0
    861c:	f7ff fd46 	bl	80ac <_ZN14Gamebuino_Meta14Display_ST773513setAddrWindowEhhhh>

		//initiate SPI
		SPI.beginTransaction(mySPISettings);
    8620:	4b4a      	ldr	r3, [pc, #296]	; (874c <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x1ac>)
    8622:	484b      	ldr	r0, [pc, #300]	; (8750 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x1b0>)
    8624:	cb06      	ldmia	r3!, {r1, r2}
    8626:	f006 fd85 	bl	f134 <_ZN8SPIClass16beginTransactionE11SPISettings>
		dataMode();
    862a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    862c:	f7ff fbda 	bl	7de4 <_ZN14Gamebuino_Meta14Display_ST77358dataModeEv>

		//prepare the first line
		indexTo565(preBufferLine, (uint8_t*)img._buffer, Graphics::colorIndex, w, false);
    8630:	b2a4      	uxth	r4, r4
    8632:	4b48      	ldr	r3, [pc, #288]	; (8754 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x1b4>)
    8634:	627c      	str	r4, [r7, #36]	; 0x24
    8636:	2400      	movs	r4, #0
    8638:	681a      	ldr	r2, [r3, #0]
    863a:	6971      	ldr	r1, [r6, #20]
    863c:	9400      	str	r4, [sp, #0]
    863e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    8640:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    8642:	f000 fcf5 	bl	9030 <_ZN14Gamebuino_Meta8Graphics10indexTo565EPtPhPNS_5ColorEtb>
		for (uint16_t i = 0; i < w; i++) { //horizontal coordinate in source image
    8646:	6a3d      	ldr	r5, [r7, #32]
    8648:	42ac      	cmp	r4, r5
    864a:	da08      	bge.n	865e <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0xbe>
			uint16_t color = preBufferLine[i];
    864c:	6abd      	ldr	r5, [r7, #40]	; 0x28
    864e:	0063      	lsls	r3, r4, #1
    8650:	18eb      	adds	r3, r5, r3
    8652:	881a      	ldrh	r2, [r3, #0]
		SPI.beginTransaction(mySPISettings);
		dataMode();

		//prepare the first line
		indexTo565(preBufferLine, (uint8_t*)img._buffer, Graphics::colorIndex, w, false);
		for (uint16_t i = 0; i < w; i++) { //horizontal coordinate in source image
    8654:	3401      	adds	r4, #1
    8656:	ba52      	rev16	r2, r2
			uint16_t color = preBufferLine[i];
			preBufferLine[i] = swap_endians_16(color);
    8658:	801a      	strh	r2, [r3, #0]
		SPI.beginTransaction(mySPISettings);
		dataMode();

		//prepare the first line
		indexTo565(preBufferLine, (uint8_t*)img._buffer, Graphics::colorIndex, w, false);
		for (uint16_t i = 0; i < w; i++) { //horizontal coordinate in source image
    865a:	b2a4      	uxth	r4, r4
    865c:	e7f3      	b.n	8646 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0xa6>
			//length is the number of destination pixels
			uint16_t *dest = preBufferLine;
			uint16_t *src = img._buffer + ((j * w) / 4);
			Color *index = Graphics::colorIndex;
			uint16_t length = w;
			for (uint16_t i = 0; i < length / 4; i++) {
    865e:	6a7c      	ldr	r4, [r7, #36]	; 0x24
    8660:	2501      	movs	r5, #1
    8662:	08a4      	lsrs	r4, r4, #2
    8664:	60fc      	str	r4, [r7, #12]
    8666:	607d      	str	r5, [r7, #4]
			uint16_t color = preBufferLine[i];
			preBufferLine[i] = swap_endians_16(color);
		}

		//start sending lines and processing them in parallel using DMA
		for (uint16_t j = 1; j < h; j++) { //vertical coordinate in source image, start from the second line
    8668:	687d      	ldr	r5, [r7, #4]
    866a:	697c      	ldr	r4, [r7, #20]
    866c:	42a5      	cmp	r5, r4
    866e:	da4e      	bge.n	870e <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x16e>
			//swap buffers pointers
			uint16_t *temp = preBufferLine;
			preBufferLine = sendBufferLine;
			sendBufferLine = temp;
			
			PORT->Group[0].OUTSET.reg = (1 << 17); // set PORTA.17 high	"digitalWrite(13, HIGH)"
    8670:	4939      	ldr	r1, [pc, #228]	; (8758 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x1b8>)
    8672:	2380      	movs	r3, #128	; 0x80
    8674:	029b      	lsls	r3, r3, #10
    8676:	618b      	str	r3, [r1, #24]
			sendBuffer(sendBufferLine, w); //start DMA send
    8678:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    867a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    867c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    867e:	f7ff fb7b 	bl	7d78 <_ZN14Gamebuino_Meta14Display_ST773510sendBufferEPtt>

			//prepare the next line while the current one is being transferred

			//length is the number of destination pixels
			uint16_t *dest = preBufferLine;
			uint16_t *src = img._buffer + ((j * w) / 4);
    8682:	6a3b      	ldr	r3, [r7, #32]
    8684:	687c      	ldr	r4, [r7, #4]
    8686:	6975      	ldr	r5, [r6, #20]
    8688:	4363      	muls	r3, r4
    868a:	17da      	asrs	r2, r3, #31
    868c:	0f92      	lsrs	r2, r2, #30
    868e:	18d3      	adds	r3, r2, r3
    8690:	109b      	asrs	r3, r3, #2
    8692:	005b      	lsls	r3, r3, #1
    8694:	18eb      	adds	r3, r5, r3
    8696:	61bb      	str	r3, [r7, #24]
			Color *index = Graphics::colorIndex;
    8698:	4b2e      	ldr	r3, [pc, #184]	; (8754 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x1b4>)
			uint16_t length = w;
			for (uint16_t i = 0; i < length / 4; i++) {
    869a:	2200      	movs	r2, #0
			//prepare the next line while the current one is being transferred

			//length is the number of destination pixels
			uint16_t *dest = preBufferLine;
			uint16_t *src = img._buffer + ((j * w) / 4);
			Color *index = Graphics::colorIndex;
    869c:	6819      	ldr	r1, [r3, #0]
    869e:	69fb      	ldr	r3, [r7, #28]
			uint16_t length = w;
			for (uint16_t i = 0; i < length / 4; i++) {
    86a0:	68fd      	ldr	r5, [r7, #12]
    86a2:	b290      	uxth	r0, r2
    86a4:	42a8      	cmp	r0, r5
    86a6:	d21e      	bcs.n	86e6 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x146>
				uint16_t index1 = (src[i] >> 4) & 0x000F;
    86a8:	69bc      	ldr	r4, [r7, #24]
    86aa:	0050      	lsls	r0, r2, #1
    86ac:	5a20      	ldrh	r0, [r4, r0]
    86ae:	240f      	movs	r4, #15
    86b0:	1105      	asrs	r5, r0, #4
				uint16_t index2 = (src[i] >> 0) & 0x000F;
				uint16_t index3 = (src[i] >> 12) & 0x000F;
				uint16_t index4 = (src[i] >> 8) & 0x000F;
				//change pixel order (because of words endianness) at the same time
				dest[i * 4] = swap_endians_16((uint16_t)index[index1]);
    86b2:	4025      	ands	r5, r4
    86b4:	60bd      	str	r5, [r7, #8]
    86b6:	006d      	lsls	r5, r5, #1
    86b8:	5a6d      	ldrh	r5, [r5, r1]
    86ba:	3201      	adds	r2, #1
    86bc:	ba6d      	rev16	r5, r5
    86be:	801d      	strh	r5, [r3, #0]
				dest[(i * 4) + 1] = swap_endians_16((uint16_t)index[index2]);
    86c0:	1c25      	adds	r5, r4, #0
    86c2:	4005      	ands	r5, r0
    86c4:	006d      	lsls	r5, r5, #1
    86c6:	5a6d      	ldrh	r5, [r5, r1]
    86c8:	ba6d      	rev16	r5, r5
    86ca:	805d      	strh	r5, [r3, #2]
				dest[(i * 4) + 2] = swap_endians_16((uint16_t)index[index3]);
    86cc:	0b05      	lsrs	r5, r0, #12
			uint16_t length = w;
			for (uint16_t i = 0; i < length / 4; i++) {
				uint16_t index1 = (src[i] >> 4) & 0x000F;
				uint16_t index2 = (src[i] >> 0) & 0x000F;
				uint16_t index3 = (src[i] >> 12) & 0x000F;
				uint16_t index4 = (src[i] >> 8) & 0x000F;
    86ce:	1200      	asrs	r0, r0, #8
				//change pixel order (because of words endianness) at the same time
				dest[i * 4] = swap_endians_16((uint16_t)index[index1]);
				dest[(i * 4) + 1] = swap_endians_16((uint16_t)index[index2]);
				dest[(i * 4) + 2] = swap_endians_16((uint16_t)index[index3]);
				dest[(i * 4) + 3] = swap_endians_16((uint16_t)index[index4]);
    86d0:	4020      	ands	r0, r4
				uint16_t index3 = (src[i] >> 12) & 0x000F;
				uint16_t index4 = (src[i] >> 8) & 0x000F;
				//change pixel order (because of words endianness) at the same time
				dest[i * 4] = swap_endians_16((uint16_t)index[index1]);
				dest[(i * 4) + 1] = swap_endians_16((uint16_t)index[index2]);
				dest[(i * 4) + 2] = swap_endians_16((uint16_t)index[index3]);
    86d2:	006d      	lsls	r5, r5, #1
				dest[(i * 4) + 3] = swap_endians_16((uint16_t)index[index4]);
    86d4:	0040      	lsls	r0, r0, #1
    86d6:	5a6d      	ldrh	r5, [r5, r1]
    86d8:	5a40      	ldrh	r0, [r0, r1]
    86da:	ba6d      	rev16	r5, r5
    86dc:	ba40      	rev16	r0, r0
				uint16_t index3 = (src[i] >> 12) & 0x000F;
				uint16_t index4 = (src[i] >> 8) & 0x000F;
				//change pixel order (because of words endianness) at the same time
				dest[i * 4] = swap_endians_16((uint16_t)index[index1]);
				dest[(i * 4) + 1] = swap_endians_16((uint16_t)index[index2]);
				dest[(i * 4) + 2] = swap_endians_16((uint16_t)index[index3]);
    86de:	809d      	strh	r5, [r3, #4]
				dest[(i * 4) + 3] = swap_endians_16((uint16_t)index[index4]);
    86e0:	80d8      	strh	r0, [r3, #6]
    86e2:	3308      	adds	r3, #8
    86e4:	e7dc      	b.n	86a0 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x100>
			}

			PORT->Group[0].OUTCLR.reg = (1 << 17); // clear PORTA.17 high "digitalWrite(13, LOW)"
    86e6:	2380      	movs	r3, #128	; 0x80
    86e8:	491b      	ldr	r1, [pc, #108]	; (8758 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x1b8>)
    86ea:	029b      	lsls	r3, r3, #10
    86ec:	614b      	str	r3, [r1, #20]

			while (!transfer_is_done); //chill
    86ee:	4b1b      	ldr	r3, [pc, #108]	; (875c <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x1bc>)
    86f0:	781b      	ldrb	r3, [r3, #0]
    86f2:	2b00      	cmp	r3, #0
    86f4:	d0fb      	beq.n	86ee <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x14e>

			myDMA.free(); //free the DMA channel
    86f6:	481a      	ldr	r0, [pc, #104]	; (8760 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x1c0>)
    86f8:	f7ff f866 	bl	77c8 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA4freeEv>
			uint16_t color = preBufferLine[i];
			preBufferLine[i] = swap_endians_16(color);
		}

		//start sending lines and processing them in parallel using DMA
		for (uint16_t j = 1; j < h; j++) { //vertical coordinate in source image, start from the second line
    86fc:	687b      	ldr	r3, [r7, #4]

			//swap buffers pointers
			uint16_t *temp = preBufferLine;
			preBufferLine = sendBufferLine;
    86fe:	69fc      	ldr	r4, [r7, #28]
			uint16_t color = preBufferLine[i];
			preBufferLine[i] = swap_endians_16(color);
		}

		//start sending lines and processing them in parallel using DMA
		for (uint16_t j = 1; j < h; j++) { //vertical coordinate in source image, start from the second line
    8700:	3301      	adds	r3, #1
    8702:	b29b      	uxth	r3, r3
    8704:	607b      	str	r3, [r7, #4]

			//swap buffers pointers
			uint16_t *temp = preBufferLine;
			preBufferLine = sendBufferLine;
    8706:	6abb      	ldr	r3, [r7, #40]	; 0x28
    8708:	62bc      	str	r4, [r7, #40]	; 0x28
    870a:	61fb      	str	r3, [r7, #28]
    870c:	e7ac      	b.n	8668 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0xc8>

			myDMA.free(); //free the DMA channel
		}

		//send the last line
		sendBuffer(preBufferLine, w); //start DMA send
    870e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    8710:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    8712:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    8714:	f7ff fb30 	bl	7d78 <_ZN14Gamebuino_Meta14Display_ST773510sendBufferEPtt>
		while (!transfer_is_done); //chill
    8718:	4b10      	ldr	r3, [pc, #64]	; (875c <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x1bc>)
    871a:	781b      	ldrb	r3, [r3, #0]
    871c:	2b00      	cmp	r3, #0
    871e:	d0fb      	beq.n	8718 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x178>
		myDMA.free(); //free the DMA channel
    8720:	480f      	ldr	r0, [pc, #60]	; (8760 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x1c0>)
    8722:	f7ff f851 	bl	77c8 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA4freeEv>

		//finish SPI
		idleMode();
    8726:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    8728:	f7ff fb72 	bl	7e10 <_ZN14Gamebuino_Meta14Display_ST77358idleModeEv>
		SPI.endTransaction();
    872c:	4808      	ldr	r0, [pc, #32]	; (8750 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x1b0>)
    872e:	f006 fd1d 	bl	f16c <_ZN8SPIClass14endTransactionEv>
    8732:	693d      	ldr	r5, [r7, #16]
    8734:	46ad      	mov	sp, r5
    8736:	e005      	b.n	8744 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageE+0x1a4>

		return;
	}
	
	Graphics::drawImage(x, y, img); //fallback to the usual
    8738:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    873a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    873c:	1c2a      	adds	r2, r5, #0
    873e:	1c33      	adds	r3, r6, #0
    8740:	f000 fc92 	bl	9068 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE>
}
    8744:	46bd      	mov	sp, r7
    8746:	b00d      	add	sp, #52	; 0x34
    8748:	bdf0      	pop	{r4, r5, r6, r7, pc}
    874a:	46c0      	nop			; (mov r8, r8)
    874c:	20000c5c 	.word	0x20000c5c
    8750:	20000e40 	.word	0x20000e40
    8754:	20000050 	.word	0x20000050
    8758:	41004400 	.word	0x41004400
    875c:	20000c64 	.word	0x20000c64
    8760:	20000c70 	.word	0x20000c70

00008764 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss>:
	}
	
	memcpy(&preBufferLine[w2], preBufferLine, w2 * 2); //double the line on the second half of the buffer
}

void Display_ST7735::drawImage(int16_t x, int16_t y, Image& img, int16_t w2, int16_t h2) {
    8764:	b5f0      	push	{r4, r5, r6, r7, lr}
    8766:	b08b      	sub	sp, #44	; 0x2c
    8768:	af02      	add	r7, sp, #8
    876a:	61b9      	str	r1, [r7, #24]
    876c:	60fa      	str	r2, [r7, #12]
    876e:	223c      	movs	r2, #60	; 0x3c
    8770:	5eb9      	ldrsh	r1, [r7, r2]
    8772:	1c04      	adds	r4, r0, #0
    8774:	2038      	movs	r0, #56	; 0x38
    8776:	5e3d      	ldrsh	r5, [r7, r0]
	img.nextFrame();
    8778:	1c18      	adds	r0, r3, #0
	}
	
	memcpy(&preBufferLine[w2], preBufferLine, w2 * 2); //double the line on the second half of the buffer
}

void Display_ST7735::drawImage(int16_t x, int16_t y, Image& img, int16_t w2, int16_t h2) {
    877a:	1c1e      	adds	r6, r3, #0
    877c:	61f9      	str	r1, [r7, #28]
	img.nextFrame();
    877e:	f002 fb5f 	bl	ae40 <_ZN14Gamebuino_Meta5Image9nextFrameEv>
	//out of screen
	if ((x > _width) || ((x + abs(w2)) < 0) || (y > _height) || ((y + abs(h2)) < 0) || (w2 == 0) || (h2 == 0)) return;
    8782:	8a23      	ldrh	r3, [r4, #16]
    8784:	69b9      	ldr	r1, [r7, #24]
    8786:	b218      	sxth	r0, r3
    8788:	60b8      	str	r0, [r7, #8]
    878a:	4281      	cmp	r1, r0
    878c:	dd00      	ble.n	8790 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2c>
    878e:	e14f      	b.n	8a30 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2cc>
    8790:	17e8      	asrs	r0, r5, #31
    8792:	182a      	adds	r2, r5, r0
    8794:	4042      	eors	r2, r0
    8796:	42d1      	cmn	r1, r2
    8798:	d500      	bpl.n	879c <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x38>
    879a:	e149      	b.n	8a30 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2cc>
    879c:	8a62      	ldrh	r2, [r4, #18]
    879e:	68f8      	ldr	r0, [r7, #12]
    87a0:	b211      	sxth	r1, r2
    87a2:	6179      	str	r1, [r7, #20]
    87a4:	4288      	cmp	r0, r1
    87a6:	dd00      	ble.n	87aa <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x46>
    87a8:	e142      	b.n	8a30 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2cc>
    87aa:	69f9      	ldr	r1, [r7, #28]
    87ac:	17c8      	asrs	r0, r1, #31
    87ae:	1809      	adds	r1, r1, r0
    87b0:	4041      	eors	r1, r0
    87b2:	68f8      	ldr	r0, [r7, #12]
    87b4:	42c8      	cmn	r0, r1
    87b6:	d500      	bpl.n	87ba <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x56>
    87b8:	e13a      	b.n	8a30 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2cc>
    87ba:	2d00      	cmp	r5, #0
    87bc:	d100      	bne.n	87c0 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x5c>
    87be:	e137      	b.n	8a30 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2cc>
    87c0:	69f9      	ldr	r1, [r7, #28]
    87c2:	2900      	cmp	r1, #0
    87c4:	d100      	bne.n	87c8 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x64>
    87c6:	e133      	b.n	8a30 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2cc>

	int16_t w = img._width;
    87c8:	8a30      	ldrh	r0, [r6, #16]
	int16_t h = img._height;
    87ca:	8a71      	ldrh	r1, [r6, #18]
	if (w == 0 || h == 0) {
    87cc:	2800      	cmp	r0, #0
    87ce:	d100      	bne.n	87d2 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x6e>
    87d0:	e12e      	b.n	8a30 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2cc>
    87d2:	2900      	cmp	r1, #0
    87d4:	d100      	bne.n	87d8 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x74>
    87d6:	e12b      	b.n	8a30 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2cc>
		return;
	}

	//no scaling
	if ((w == w2) && (h == h2)) { 
    87d8:	b200      	sxth	r0, r0
    87da:	6138      	str	r0, [r7, #16]
    87dc:	42a8      	cmp	r0, r5
    87de:	d10c      	bne.n	87fa <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x96>
    87e0:	b208      	sxth	r0, r1
    87e2:	4684      	mov	ip, r0
    87e4:	69f8      	ldr	r0, [r7, #28]
    87e6:	4584      	cmp	ip, r0
    87e8:	d107      	bne.n	87fa <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x96>
		drawImage(x, y, img);
    87ea:	6823      	ldr	r3, [r4, #0]
    87ec:	1c20      	adds	r0, r4, #0
    87ee:	6b5d      	ldr	r5, [r3, #52]	; 0x34
    87f0:	69b9      	ldr	r1, [r7, #24]
    87f2:	68fa      	ldr	r2, [r7, #12]
    87f4:	1c33      	adds	r3, r6, #0
    87f6:	47a8      	blx	r5
		return;
    87f8:	e11a      	b.n	8a30 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2cc>
	}

	//x2 upscaling to full screen
	if ((w2 == (w * 2)) && (h2 == (h * 2)) && (_width == w2) && (_height == h2)) {
    87fa:	6938      	ldr	r0, [r7, #16]
    87fc:	0040      	lsls	r0, r0, #1
    87fe:	4285      	cmp	r5, r0
    8800:	d000      	beq.n	8804 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0xa0>
    8802:	e10c      	b.n	8a1e <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2ba>
    8804:	b208      	sxth	r0, r1
    8806:	6078      	str	r0, [r7, #4]
    8808:	0041      	lsls	r1, r0, #1
    880a:	69f8      	ldr	r0, [r7, #28]
    880c:	4288      	cmp	r0, r1
    880e:	d000      	beq.n	8812 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0xae>
    8810:	e105      	b.n	8a1e <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2ba>
    8812:	68b9      	ldr	r1, [r7, #8]
    8814:	42a9      	cmp	r1, r5
    8816:	d000      	beq.n	881a <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0xb6>
    8818:	e101      	b.n	8a1e <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2ba>
    881a:	6979      	ldr	r1, [r7, #20]
    881c:	4281      	cmp	r1, r0
    881e:	d000      	beq.n	8822 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0xbe>
    8820:	e0fd      	b.n	8a1e <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2ba>
		if (img.colorMode == ColorMode::rgb565) {
    8822:	7ab0      	ldrb	r0, [r6, #10]
    8824:	6178      	str	r0, [r7, #20]
    8826:	2800      	cmp	r0, #0
    8828:	d000      	beq.n	882c <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0xc8>
    882a:	e090      	b.n	894e <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x1ea>
    882c:	4668      	mov	r0, sp
			uint16_t preBufferLineArray[w2 * 2];
    882e:	6939      	ldr	r1, [r7, #16]
    8830:	6038      	str	r0, [r7, #0]
    8832:	6938      	ldr	r0, [r7, #16]
    8834:	0089      	lsls	r1, r1, #2
    8836:	60f9      	str	r1, [r7, #12]
    8838:	00c1      	lsls	r1, r0, #3
    883a:	3108      	adds	r1, #8
    883c:	4668      	mov	r0, sp
    883e:	1a40      	subs	r0, r0, r1
    8840:	4685      	mov	sp, r0
    8842:	a802      	add	r0, sp, #8
    8844:	61f8      	str	r0, [r7, #28]
			uint16_t sendBufferLineArray[w2 * 2];
    8846:	4668      	mov	r0, sp
    8848:	1a40      	subs	r0, r0, r1
    884a:	4685      	mov	sp, r0
			uint16_t *preBufferLine = preBufferLineArray;
			uint16_t *sendBufferLine = sendBufferLineArray;

			//set the window to the whole screen
			setAddrWindow(0, 0, _width - 1, _height - 1);
    884c:	3a01      	subs	r2, #1

	//x2 upscaling to full screen
	if ((w2 == (w * 2)) && (h2 == (h * 2)) && (_width == w2) && (_height == h2)) {
		if (img.colorMode == ColorMode::rgb565) {
			uint16_t preBufferLineArray[w2 * 2];
			uint16_t sendBufferLineArray[w2 * 2];
    884e:	a902      	add	r1, sp, #8
			uint16_t *preBufferLine = preBufferLineArray;
			uint16_t *sendBufferLine = sendBufferLineArray;

			//set the window to the whole screen
			setAddrWindow(0, 0, _width - 1, _height - 1);
    8850:	b2d2      	uxtb	r2, r2

	//x2 upscaling to full screen
	if ((w2 == (w * 2)) && (h2 == (h * 2)) && (_width == w2) && (_height == h2)) {
		if (img.colorMode == ColorMode::rgb565) {
			uint16_t preBufferLineArray[w2 * 2];
			uint16_t sendBufferLineArray[w2 * 2];
    8852:	61b9      	str	r1, [r7, #24]
			uint16_t *preBufferLine = preBufferLineArray;
			uint16_t *sendBufferLine = sendBufferLineArray;

			//set the window to the whole screen
			setAddrWindow(0, 0, _width - 1, _height - 1);
    8854:	9200      	str	r2, [sp, #0]
    8856:	6979      	ldr	r1, [r7, #20]
    8858:	3b01      	subs	r3, #1
    885a:	b2db      	uxtb	r3, r3
    885c:	1c20      	adds	r0, r4, #0
    885e:	1c0a      	adds	r2, r1, #0
    8860:	f7ff fc24 	bl	80ac <_ZN14Gamebuino_Meta14Display_ST773513setAddrWindowEhhhh>

			//initiate SPI
			SPI.beginTransaction(mySPISettings);
    8864:	4b74      	ldr	r3, [pc, #464]	; (8a38 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2d4>)
    8866:	4875      	ldr	r0, [pc, #468]	; (8a3c <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2d8>)
    8868:	cb06      	ldmia	r3!, {r1, r2}
    886a:	f006 fc63 	bl	f134 <_ZN8SPIClass16beginTransactionE11SPISettings>
			dataMode();
    886e:	1c20      	adds	r0, r4, #0
    8870:	f7ff fab8 	bl	7de4 <_ZN14Gamebuino_Meta14Display_ST77358dataModeEv>

			//prepare the first line
			for (uint16_t i = 0; i < w; i++) { //horizontal coordinate in source image
    8874:	697d      	ldr	r5, [r7, #20]
    8876:	693a      	ldr	r2, [r7, #16]
    8878:	4295      	cmp	r5, r2
    887a:	da0b      	bge.n	8894 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x130>
    887c:	6970      	ldr	r0, [r6, #20]
				uint16_t color = img._buffer[i];
    887e:	006a      	lsls	r2, r5, #1
    8880:	5a12      	ldrh	r2, [r2, r0]
				preBufferLine[i * 2] = preBufferLine[(i * 2) + 1] = swap_endians_16(color);
    8882:	69f8      	ldr	r0, [r7, #28]
    8884:	00ab      	lsls	r3, r5, #2
    8886:	ba52      	rev16	r2, r2
    8888:	18c1      	adds	r1, r0, r3
			//initiate SPI
			SPI.beginTransaction(mySPISettings);
			dataMode();

			//prepare the first line
			for (uint16_t i = 0; i < w; i++) { //horizontal coordinate in source image
    888a:	3501      	adds	r5, #1
				uint16_t color = img._buffer[i];
				preBufferLine[i * 2] = preBufferLine[(i * 2) + 1] = swap_endians_16(color);
    888c:	804a      	strh	r2, [r1, #2]
			//initiate SPI
			SPI.beginTransaction(mySPISettings);
			dataMode();

			//prepare the first line
			for (uint16_t i = 0; i < w; i++) { //horizontal coordinate in source image
    888e:	b2ad      	uxth	r5, r5
				uint16_t color = img._buffer[i];
				preBufferLine[i * 2] = preBufferLine[(i * 2) + 1] = swap_endians_16(color);
    8890:	52c2      	strh	r2, [r0, r3]
    8892:	e7f0      	b.n	8876 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x112>
			}
			memcpy(&preBufferLine[w2], preBufferLine, w2 * 2); //double the line on the second half of the buffer
    8894:	68bb      	ldr	r3, [r7, #8]
    8896:	69f9      	ldr	r1, [r7, #28]
    8898:	005b      	lsls	r3, r3, #1
    889a:	18c8      	adds	r0, r1, r3
    889c:	68fa      	ldr	r2, [r7, #12]
    889e:	617b      	str	r3, [r7, #20]
    88a0:	f008 fe8b 	bl	115ba <memcpy>

			//start sending lines and processing them in parallel using DMA
			for (uint16_t j = 1; j < h; j ++) { //vertical coordinate in source image, start from the second line
    88a4:	2501      	movs	r5, #1
    88a6:	687a      	ldr	r2, [r7, #4]
    88a8:	4295      	cmp	r5, r2
    88aa:	da39      	bge.n	8920 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x1bc>
				//swap buffers pointers
				uint16_t *temp = preBufferLine;
				preBufferLine = sendBufferLine;
				sendBufferLine = temp;

				PORT->Group[0].OUTSET.reg = (1 << 17); // set PORTA.17 high	"digitalWrite(13, HIGH)"
    88ac:	4a64      	ldr	r2, [pc, #400]	; (8a40 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2dc>)
    88ae:	2380      	movs	r3, #128	; 0x80
    88b0:	029b      	lsls	r3, r3, #10
    88b2:	6193      	str	r3, [r2, #24]

				sendBuffer(sendBufferLine, _width * 2); //start DMA send
    88b4:	8a22      	ldrh	r2, [r4, #16]
    88b6:	1c20      	adds	r0, r4, #0
    88b8:	0052      	lsls	r2, r2, #1
    88ba:	b292      	uxth	r2, r2
    88bc:	69f9      	ldr	r1, [r7, #28]
    88be:	f7ff fa5b 	bl	7d78 <_ZN14Gamebuino_Meta14Display_ST773510sendBufferEPtt>

				//prepare the next line while the current one is being transferred
				for (uint16_t i = 0; i < w; i ++) { //horizontal coordinate in source image
					uint16_t color = img._buffer[(j * w) + i];
    88c2:	693b      	ldr	r3, [r7, #16]
    88c4:	436b      	muls	r3, r5
    88c6:	60bb      	str	r3, [r7, #8]
				PORT->Group[0].OUTSET.reg = (1 << 17); // set PORTA.17 high	"digitalWrite(13, HIGH)"

				sendBuffer(sendBufferLine, _width * 2); //start DMA send

				//prepare the next line while the current one is being transferred
				for (uint16_t i = 0; i < w; i ++) { //horizontal coordinate in source image
    88c8:	2300      	movs	r3, #0
    88ca:	6939      	ldr	r1, [r7, #16]
    88cc:	428b      	cmp	r3, r1
    88ce:	da0e      	bge.n	88ee <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x18a>
					uint16_t color = img._buffer[(j * w) + i];
    88d0:	68b8      	ldr	r0, [r7, #8]
					preBufferLine[i * 2] = preBufferLine[(i * 2) + 1] = swap_endians_16(color);
    88d2:	009a      	lsls	r2, r3, #2

				sendBuffer(sendBufferLine, _width * 2); //start DMA send

				//prepare the next line while the current one is being transferred
				for (uint16_t i = 0; i < w; i ++) { //horizontal coordinate in source image
					uint16_t color = img._buffer[(j * w) + i];
    88d4:	18c1      	adds	r1, r0, r3
    88d6:	6970      	ldr	r0, [r6, #20]
    88d8:	0049      	lsls	r1, r1, #1
    88da:	5a09      	ldrh	r1, [r1, r0]
					preBufferLine[i * 2] = preBufferLine[(i * 2) + 1] = swap_endians_16(color);
    88dc:	69b8      	ldr	r0, [r7, #24]
    88de:	ba49      	rev16	r1, r1
    88e0:	1880      	adds	r0, r0, r2
    88e2:	8041      	strh	r1, [r0, #2]
    88e4:	69b8      	ldr	r0, [r7, #24]
				PORT->Group[0].OUTSET.reg = (1 << 17); // set PORTA.17 high	"digitalWrite(13, HIGH)"

				sendBuffer(sendBufferLine, _width * 2); //start DMA send

				//prepare the next line while the current one is being transferred
				for (uint16_t i = 0; i < w; i ++) { //horizontal coordinate in source image
    88e6:	3301      	adds	r3, #1
					uint16_t color = img._buffer[(j * w) + i];
					preBufferLine[i * 2] = preBufferLine[(i * 2) + 1] = swap_endians_16(color);
    88e8:	5281      	strh	r1, [r0, r2]
				PORT->Group[0].OUTSET.reg = (1 << 17); // set PORTA.17 high	"digitalWrite(13, HIGH)"

				sendBuffer(sendBufferLine, _width * 2); //start DMA send

				//prepare the next line while the current one is being transferred
				for (uint16_t i = 0; i < w; i ++) { //horizontal coordinate in source image
    88ea:	b29b      	uxth	r3, r3
    88ec:	e7ed      	b.n	88ca <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x166>
					uint16_t color = img._buffer[(j * w) + i];
					preBufferLine[i * 2] = preBufferLine[(i * 2) + 1] = swap_endians_16(color);
				}
				memcpy(&preBufferLine[w2], preBufferLine, w2 * 2); //double the line on the second half of the buffer
    88ee:	69ba      	ldr	r2, [r7, #24]
    88f0:	697b      	ldr	r3, [r7, #20]
    88f2:	1c11      	adds	r1, r2, #0
    88f4:	18d0      	adds	r0, r2, r3
    88f6:	68fa      	ldr	r2, [r7, #12]
    88f8:	f008 fe5f 	bl	115ba <memcpy>

				PORT->Group[0].OUTCLR.reg = (1 << 17); // clear PORTA.17 high "digitalWrite(13, LOW)"
    88fc:	2380      	movs	r3, #128	; 0x80
    88fe:	4850      	ldr	r0, [pc, #320]	; (8a40 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2dc>)
    8900:	029b      	lsls	r3, r3, #10
    8902:	6143      	str	r3, [r0, #20]

				while (!transfer_is_done); //chill
    8904:	4b4f      	ldr	r3, [pc, #316]	; (8a44 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2e0>)
    8906:	781b      	ldrb	r3, [r3, #0]
    8908:	2b00      	cmp	r3, #0
    890a:	d0fb      	beq.n	8904 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x1a0>

				myDMA.free(); //free the DMA channel
    890c:	484e      	ldr	r0, [pc, #312]	; (8a48 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2e4>)
    890e:	f7fe ff5b 	bl	77c8 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA4freeEv>
			//start sending lines and processing them in parallel using DMA
			for (uint16_t j = 1; j < h; j ++) { //vertical coordinate in source image, start from the second line

				//swap buffers pointers
				uint16_t *temp = preBufferLine;
				preBufferLine = sendBufferLine;
    8912:	69fb      	ldr	r3, [r7, #28]
    8914:	69b9      	ldr	r1, [r7, #24]
				preBufferLine[i * 2] = preBufferLine[(i * 2) + 1] = swap_endians_16(color);
			}
			memcpy(&preBufferLine[w2], preBufferLine, w2 * 2); //double the line on the second half of the buffer

			//start sending lines and processing them in parallel using DMA
			for (uint16_t j = 1; j < h; j ++) { //vertical coordinate in source image, start from the second line
    8916:	3501      	adds	r5, #1
    8918:	b2ad      	uxth	r5, r5

				//swap buffers pointers
				uint16_t *temp = preBufferLine;
				preBufferLine = sendBufferLine;
    891a:	61f9      	str	r1, [r7, #28]
    891c:	61bb      	str	r3, [r7, #24]
    891e:	e7c2      	b.n	88a6 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x142>

				myDMA.free(); //free the DMA channel
			}

			//send the last line
			sendBuffer(preBufferLine, _width * 2); //start DMA send
    8920:	8a22      	ldrh	r2, [r4, #16]
    8922:	1c20      	adds	r0, r4, #0
    8924:	0052      	lsls	r2, r2, #1
    8926:	b292      	uxth	r2, r2
    8928:	69f9      	ldr	r1, [r7, #28]
    892a:	f7ff fa25 	bl	7d78 <_ZN14Gamebuino_Meta14Display_ST773510sendBufferEPtt>
			while (!transfer_is_done); //chill
    892e:	4b45      	ldr	r3, [pc, #276]	; (8a44 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2e0>)
    8930:	781b      	ldrb	r3, [r3, #0]
    8932:	2b00      	cmp	r3, #0
    8934:	d0fb      	beq.n	892e <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x1ca>
			myDMA.free(); //free the DMA channel
    8936:	4844      	ldr	r0, [pc, #272]	; (8a48 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2e4>)
    8938:	f7fe ff46 	bl	77c8 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA4freeEv>

			//finish SPI
			idleMode();
    893c:	1c20      	adds	r0, r4, #0
    893e:	f7ff fa67 	bl	7e10 <_ZN14Gamebuino_Meta14Display_ST77358idleModeEv>
			SPI.endTransaction();
    8942:	483e      	ldr	r0, [pc, #248]	; (8a3c <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2d8>)
    8944:	f006 fc12 	bl	f16c <_ZN8SPIClass14endTransactionEv>
    8948:	683b      	ldr	r3, [r7, #0]
    894a:	469d      	mov	sp, r3
    894c:	e070      	b.n	8a30 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2cc>

			return;
		}
		if (img.colorMode == ColorMode::index) {
    894e:	6978      	ldr	r0, [r7, #20]
    8950:	2801      	cmp	r0, #1
    8952:	d164      	bne.n	8a1e <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2ba>
    8954:	4668      	mov	r0, sp
    8956:	60f8      	str	r0, [r7, #12]
			uint16_t preBufferLineArray[w2 * 2];
    8958:	6938      	ldr	r0, [r7, #16]
			uint16_t sendBufferLineArray[w2 * 2];
			uint16_t *preBufferLine = preBufferLineArray;
			uint16_t *sendBufferLine = sendBufferLineArray;

			//set the window to the whole screen
			setAddrWindow(0, 0, _width - 1, _height - 1);
    895a:	3a01      	subs	r2, #1
			SPI.endTransaction();

			return;
		}
		if (img.colorMode == ColorMode::index) {
			uint16_t preBufferLineArray[w2 * 2];
    895c:	00c1      	lsls	r1, r0, #3
    895e:	3108      	adds	r1, #8
    8960:	4668      	mov	r0, sp
    8962:	1a40      	subs	r0, r0, r1
    8964:	4685      	mov	sp, r0
    8966:	a802      	add	r0, sp, #8
    8968:	61f8      	str	r0, [r7, #28]
			uint16_t sendBufferLineArray[w2 * 2];
    896a:	4668      	mov	r0, sp
    896c:	1a40      	subs	r0, r0, r1
    896e:	4685      	mov	sp, r0
    8970:	a902      	add	r1, sp, #8
    8972:	61b9      	str	r1, [r7, #24]
			uint16_t *preBufferLine = preBufferLineArray;
			uint16_t *sendBufferLine = sendBufferLineArray;

			//set the window to the whole screen
			setAddrWindow(0, 0, _width - 1, _height - 1);
    8974:	b2d2      	uxtb	r2, r2
    8976:	2100      	movs	r1, #0
    8978:	3b01      	subs	r3, #1
    897a:	b2db      	uxtb	r3, r3
    897c:	9200      	str	r2, [sp, #0]
    897e:	1c20      	adds	r0, r4, #0
    8980:	1c0a      	adds	r2, r1, #0
    8982:	f7ff fb93 	bl	80ac <_ZN14Gamebuino_Meta14Display_ST773513setAddrWindowEhhhh>

			//initiate SPI
			SPI.beginTransaction(mySPISettings);
    8986:	4b2c      	ldr	r3, [pc, #176]	; (8a38 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2d4>)
    8988:	482c      	ldr	r0, [pc, #176]	; (8a3c <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2d8>)
    898a:	cb06      	ldmia	r3!, {r1, r2}
    898c:	f006 fbd2 	bl	f134 <_ZN8SPIClass16beginTransactionE11SPISettings>
			dataMode();
    8990:	1c20      	adds	r0, r4, #0
    8992:	f7ff fa27 	bl	7de4 <_ZN14Gamebuino_Meta14Display_ST77358dataModeEv>
			bufferIndexLineDouble(preBufferLine, img._buffer, w, 0);
    8996:	69f8      	ldr	r0, [r7, #28]
    8998:	6971      	ldr	r1, [r6, #20]
    899a:	693a      	ldr	r2, [r7, #16]
    899c:	2300      	movs	r3, #0
    899e:	f7ff fd5f 	bl	8460 <_ZN14Gamebuino_Meta21bufferIndexLineDoubleEPtS0_st>

			//start sending lines and processing them in parallel using DMA
			for (uint16_t j = 1; j < h; j++) { //vertical coordinate in source image, start from the second line
    89a2:	697d      	ldr	r5, [r7, #20]
    89a4:	687b      	ldr	r3, [r7, #4]
    89a6:	429d      	cmp	r5, r3
    89a8:	da22      	bge.n	89f0 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x28c>
				//swap buffers pointers
				uint16_t *temp = preBufferLine;
				preBufferLine = sendBufferLine;
				sendBufferLine = temp;
				
				PORT->Group[0].OUTSET.reg = (1 << 17); // set PORTA.17 high	"digitalWrite(13, HIGH)"
    89aa:	4b25      	ldr	r3, [pc, #148]	; (8a40 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2dc>)
    89ac:	2280      	movs	r2, #128	; 0x80
    89ae:	0292      	lsls	r2, r2, #10
    89b0:	619a      	str	r2, [r3, #24]

				sendBuffer(sendBufferLine, _width * 2); //start DMA send
    89b2:	8a22      	ldrh	r2, [r4, #16]
    89b4:	1c20      	adds	r0, r4, #0
    89b6:	0052      	lsls	r2, r2, #1
    89b8:	b292      	uxth	r2, r2
    89ba:	69f9      	ldr	r1, [r7, #28]
    89bc:	f7ff f9dc 	bl	7d78 <_ZN14Gamebuino_Meta14Display_ST773510sendBufferEPtt>

				// prepare the next line while we'r at it
				bufferIndexLineDouble(preBufferLine, img._buffer, w, j);
    89c0:	69b8      	ldr	r0, [r7, #24]
    89c2:	6971      	ldr	r1, [r6, #20]
    89c4:	693a      	ldr	r2, [r7, #16]
    89c6:	1c2b      	adds	r3, r5, #0
    89c8:	f7ff fd4a 	bl	8460 <_ZN14Gamebuino_Meta21bufferIndexLineDoubleEPtS0_st>

				PORT->Group[0].OUTCLR.reg = (1 << 17); // clear PORTA.17 high "digitalWrite(13, LOW)"
    89cc:	2080      	movs	r0, #128	; 0x80
    89ce:	491c      	ldr	r1, [pc, #112]	; (8a40 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2dc>)
    89d0:	0280      	lsls	r0, r0, #10
    89d2:	6148      	str	r0, [r1, #20]

				while (!transfer_is_done); //chill
    89d4:	4b1b      	ldr	r3, [pc, #108]	; (8a44 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2e0>)
    89d6:	781b      	ldrb	r3, [r3, #0]
    89d8:	2b00      	cmp	r3, #0
    89da:	d0fb      	beq.n	89d4 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x270>

				myDMA.free(); //free the DMA channel
    89dc:	481a      	ldr	r0, [pc, #104]	; (8a48 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2e4>)
    89de:	f7fe fef3 	bl	77c8 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA4freeEv>
			//start sending lines and processing them in parallel using DMA
			for (uint16_t j = 1; j < h; j++) { //vertical coordinate in source image, start from the second line

				//swap buffers pointers
				uint16_t *temp = preBufferLine;
				preBufferLine = sendBufferLine;
    89e2:	69fb      	ldr	r3, [r7, #28]
    89e4:	69ba      	ldr	r2, [r7, #24]
			SPI.beginTransaction(mySPISettings);
			dataMode();
			bufferIndexLineDouble(preBufferLine, img._buffer, w, 0);

			//start sending lines and processing them in parallel using DMA
			for (uint16_t j = 1; j < h; j++) { //vertical coordinate in source image, start from the second line
    89e6:	3501      	adds	r5, #1
    89e8:	b2ad      	uxth	r5, r5

				//swap buffers pointers
				uint16_t *temp = preBufferLine;
				preBufferLine = sendBufferLine;
    89ea:	61fa      	str	r2, [r7, #28]
    89ec:	61bb      	str	r3, [r7, #24]
    89ee:	e7d9      	b.n	89a4 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x240>

				myDMA.free(); //free the DMA channel
			}

			//send the last line
			sendBuffer(preBufferLine, _width * 2); //start DMA send
    89f0:	8a22      	ldrh	r2, [r4, #16]
    89f2:	1c20      	adds	r0, r4, #0
    89f4:	0052      	lsls	r2, r2, #1
    89f6:	b292      	uxth	r2, r2
    89f8:	69f9      	ldr	r1, [r7, #28]
    89fa:	f7ff f9bd 	bl	7d78 <_ZN14Gamebuino_Meta14Display_ST773510sendBufferEPtt>
			while (!transfer_is_done); //chill
    89fe:	4b11      	ldr	r3, [pc, #68]	; (8a44 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2e0>)
    8a00:	781b      	ldrb	r3, [r3, #0]
    8a02:	2b00      	cmp	r3, #0
    8a04:	d0fb      	beq.n	89fe <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x29a>
			myDMA.free(); //free the DMA channel
    8a06:	4810      	ldr	r0, [pc, #64]	; (8a48 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2e4>)
    8a08:	f7fe fede 	bl	77c8 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA4freeEv>

			//finish SPI
			idleMode();
    8a0c:	1c20      	adds	r0, r4, #0
    8a0e:	f7ff f9ff 	bl	7e10 <_ZN14Gamebuino_Meta14Display_ST77358idleModeEv>
			SPI.endTransaction();
    8a12:	480a      	ldr	r0, [pc, #40]	; (8a3c <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2d8>)
    8a14:	f006 fbaa 	bl	f16c <_ZN8SPIClass14endTransactionEv>
    8a18:	68f8      	ldr	r0, [r7, #12]
    8a1a:	4685      	mov	sp, r0
    8a1c:	e008      	b.n	8a30 <_ZN14Gamebuino_Meta14Display_ST77359drawImageEssRNS_5ImageEss+0x2cc>
			return;
		}
	}

	// fall back to most generic but slow resizing
	Graphics::drawImage(x, y, img, w2, h2);
    8a1e:	9500      	str	r5, [sp, #0]
    8a20:	69f9      	ldr	r1, [r7, #28]
    8a22:	1c20      	adds	r0, r4, #0
    8a24:	9101      	str	r1, [sp, #4]
    8a26:	69b9      	ldr	r1, [r7, #24]
    8a28:	68fa      	ldr	r2, [r7, #12]
    8a2a:	1c33      	adds	r3, r6, #0
    8a2c:	f000 f94c 	bl	8cc8 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss>
}
    8a30:	46bd      	mov	sp, r7
    8a32:	b009      	add	sp, #36	; 0x24
    8a34:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8a36:	46c0      	nop			; (mov r8, r8)
    8a38:	20000c5c 	.word	0x20000c5c
    8a3c:	20000e40 	.word	0x20000e40
    8a40:	41004400 	.word	0x41004400
    8a44:	20000c64 	.word	0x20000c64
    8a48:	20000c70 	.word	0x20000c70

00008a4c <_ZN14Gamebuino_Meta8GraphicsD1Ev>:
	gfxFont   = NULL;
	colorMode = ColorMode::rgb565;
	setFont(font3x5);
}

Graphics::~Graphics() {
    8a4c:	4b01      	ldr	r3, [pc, #4]	; (8a54 <_ZN14Gamebuino_Meta8GraphicsD1Ev+0x8>)
    8a4e:	3308      	adds	r3, #8
    8a50:	6003      	str	r3, [r0, #0]
	
}
    8a52:	4770      	bx	lr
    8a54:	000153c8 	.word	0x000153c8

00008a58 <_ZN14Gamebuino_Meta8Graphics8drawRectEssss>:
		}
	}
}

// Draw a rectangle
void Graphics::drawRect(int16_t x, int16_t y, int16_t w, int16_t h) {
    8a58:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    8a5a:	1c1f      	adds	r7, r3, #0
    8a5c:	ab08      	add	r3, sp, #32
    8a5e:	1c15      	adds	r5, r2, #0
    8a60:	1c0e      	adds	r6, r1, #0
    8a62:	2200      	movs	r2, #0
    8a64:	5e99      	ldrsh	r1, [r3, r2]
	drawFastHLine(x, y, w);
    8a66:	6803      	ldr	r3, [r0, #0]
		}
	}
}

// Draw a rectangle
void Graphics::drawRect(int16_t x, int16_t y, int16_t w, int16_t h) {
    8a68:	9101      	str	r1, [sp, #4]
	drawFastHLine(x, y, w);
    8a6a:	6a19      	ldr	r1, [r3, #32]
		}
	}
}

// Draw a rectangle
void Graphics::drawRect(int16_t x, int16_t y, int16_t w, int16_t h) {
    8a6c:	1c04      	adds	r4, r0, #0
	drawFastHLine(x, y, w);
    8a6e:	1c2a      	adds	r2, r5, #0
    8a70:	468c      	mov	ip, r1
    8a72:	1c3b      	adds	r3, r7, #0
    8a74:	1c31      	adds	r1, r6, #0
    8a76:	47e0      	blx	ip
	drawFastHLine(x, y+h-1, w);
    8a78:	6823      	ldr	r3, [r4, #0]
    8a7a:	9a01      	ldr	r2, [sp, #4]
    8a7c:	6a19      	ldr	r1, [r3, #32]
    8a7e:	3a01      	subs	r2, #1
    8a80:	1952      	adds	r2, r2, r5
    8a82:	468c      	mov	ip, r1
    8a84:	1c20      	adds	r0, r4, #0
    8a86:	1c31      	adds	r1, r6, #0
    8a88:	1c3b      	adds	r3, r7, #0
    8a8a:	b212      	sxth	r2, r2
    8a8c:	47e0      	blx	ip
	drawFastVLine(x, y, h);
    8a8e:	6823      	ldr	r3, [r4, #0]
    8a90:	1c20      	adds	r0, r4, #0
    8a92:	69da      	ldr	r2, [r3, #28]
    8a94:	1c31      	adds	r1, r6, #0
    8a96:	4694      	mov	ip, r2
    8a98:	9b01      	ldr	r3, [sp, #4]
    8a9a:	1c2a      	adds	r2, r5, #0
    8a9c:	47e0      	blx	ip
	drawFastVLine(x+w-1, y, h);
    8a9e:	3f01      	subs	r7, #1
    8aa0:	6823      	ldr	r3, [r4, #0]
    8aa2:	19be      	adds	r6, r7, r6
    8aa4:	b231      	sxth	r1, r6
    8aa6:	69df      	ldr	r7, [r3, #28]
    8aa8:	1c2a      	adds	r2, r5, #0
    8aaa:	1c20      	adds	r0, r4, #0
    8aac:	9b01      	ldr	r3, [sp, #4]
    8aae:	47b8      	blx	r7
}
    8ab0:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

00008ab2 <_ZN14Gamebuino_Meta8Graphics13drawFastVLineEsss>:

void Graphics::drawFastVLine(int16_t x, int16_t y, int16_t h) {
    8ab2:	b537      	push	{r0, r1, r2, r4, r5, lr}
	// Update in subclasses if desired!
	drawLine(x, y, x, y+h-1);
    8ab4:	3b01      	subs	r3, #1
    8ab6:	189b      	adds	r3, r3, r2
	drawFastHLine(x, y+h-1, w);
	drawFastVLine(x, y, h);
	drawFastVLine(x+w-1, y, h);
}

void Graphics::drawFastVLine(int16_t x, int16_t y, int16_t h) {
    8ab8:	1c0c      	adds	r4, r1, #0
	// Update in subclasses if desired!
	drawLine(x, y, x, y+h-1);
    8aba:	b21b      	sxth	r3, r3
    8abc:	6801      	ldr	r1, [r0, #0]
    8abe:	9300      	str	r3, [sp, #0]
    8ac0:	698d      	ldr	r5, [r1, #24]
    8ac2:	1c23      	adds	r3, r4, #0
    8ac4:	1c21      	adds	r1, r4, #0
    8ac6:	47a8      	blx	r5
}
    8ac8:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

00008aca <_ZN14Gamebuino_Meta8Graphics13drawFastHLineEsss>:

void Graphics::drawFastHLine(int16_t x, int16_t y, int16_t w) {
    8aca:	b513      	push	{r0, r1, r4, lr}
	// Update in subclasses if desired!
	drawLine(x, y, x+w-1, y);
    8acc:	3b01      	subs	r3, #1
    8ace:	6804      	ldr	r4, [r0, #0]
    8ad0:	185b      	adds	r3, r3, r1
    8ad2:	9200      	str	r2, [sp, #0]
    8ad4:	b21b      	sxth	r3, r3
    8ad6:	69a4      	ldr	r4, [r4, #24]
    8ad8:	47a0      	blx	r4
}
    8ada:	bd13      	pop	{r0, r1, r4, pc}

00008adc <_ZN14Gamebuino_Meta8Graphics8fillRectEssss>:

void Graphics::fillRect(int16_t x, int16_t y, int16_t w, int16_t h) {
    8adc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    8ade:	9300      	str	r3, [sp, #0]
    8ae0:	ab08      	add	r3, sp, #32
    8ae2:	1c0d      	adds	r5, r1, #0
    8ae4:	1c17      	adds	r7, r2, #0
    8ae6:	2200      	movs	r2, #0
    8ae8:	5e99      	ldrsh	r1, [r3, r2]
    8aea:	1c06      	adds	r6, r0, #0
    8aec:	9101      	str	r1, [sp, #4]
	// Update in subclasses if desired!
	for (int16_t i=x; i<x+w; i++) {
    8aee:	1c2c      	adds	r4, r5, #0
    8af0:	9a00      	ldr	r2, [sp, #0]
    8af2:	18ab      	adds	r3, r5, r2
    8af4:	429c      	cmp	r4, r3
    8af6:	da0a      	bge.n	8b0e <_ZN14Gamebuino_Meta8Graphics8fillRectEssss+0x32>
		drawFastVLine(i, y, h);
    8af8:	6833      	ldr	r3, [r6, #0]
    8afa:	1c30      	adds	r0, r6, #0
    8afc:	69d9      	ldr	r1, [r3, #28]
    8afe:	1c3a      	adds	r2, r7, #0
    8b00:	468c      	mov	ip, r1
    8b02:	9b01      	ldr	r3, [sp, #4]
    8b04:	1c21      	adds	r1, r4, #0
    8b06:	3401      	adds	r4, #1
    8b08:	47e0      	blx	ip
    8b0a:	b224      	sxth	r4, r4
    8b0c:	e7f0      	b.n	8af0 <_ZN14Gamebuino_Meta8Graphics8fillRectEssss+0x14>
	}
}
    8b0e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

00008b10 <_ZN14Gamebuino_Meta8Graphics5_fillEv>:

void Graphics::_fill() {
    8b10:	b513      	push	{r0, r1, r4, lr}
	fillRect(0, 0, _width, _height);
    8b12:	2110      	movs	r1, #16
    8b14:	5e43      	ldrsh	r3, [r0, r1]
    8b16:	2412      	movs	r4, #18
    8b18:	5f01      	ldrsh	r1, [r0, r4]
    8b1a:	6802      	ldr	r2, [r0, #0]
    8b1c:	9100      	str	r1, [sp, #0]
    8b1e:	2100      	movs	r1, #0
    8b20:	6a94      	ldr	r4, [r2, #40]	; 0x28
    8b22:	1c0a      	adds	r2, r1, #0
    8b24:	47a0      	blx	r4
}
    8b26:	bd13      	pop	{r0, r1, r4, pc}

00008b28 <_ZN14Gamebuino_Meta8Graphics5writeEh>:
	}
}


#if ARDUINO >= 100
size_t Graphics::write(uint8_t c) {
    8b28:	b5f0      	push	{r4, r5, r6, r7, lr}
#else
void Graphics::write(uint8_t c) {
#endif

	if(!gfxFont) { // 'Classic' built-in font
    8b2a:	4a59      	ldr	r2, [pc, #356]	; (8c90 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x168>)
	}
}


#if ARDUINO >= 100
size_t Graphics::write(uint8_t c) {
    8b2c:	b087      	sub	sp, #28
#else
void Graphics::write(uint8_t c) {
#endif

	if(!gfxFont) { // 'Classic' built-in font
    8b2e:	6812      	ldr	r2, [r2, #0]
	}
}


#if ARDUINO >= 100
size_t Graphics::write(uint8_t c) {
    8b30:	1c0b      	adds	r3, r1, #0
#else
void Graphics::write(uint8_t c) {
#endif

	if(!gfxFont) { // 'Classic' built-in font
    8b32:	2a00      	cmp	r2, #0
    8b34:	d14c      	bne.n	8bd0 <_ZN14Gamebuino_Meta8Graphics5writeEh+0xa8>

		if(c == '\n') {
    8b36:	290a      	cmp	r1, #10
    8b38:	d118      	bne.n	8b6c <_ZN14Gamebuino_Meta8Graphics5writeEh+0x44>
			cursorY += fontSize*fontHeight;
    8b3a:	4b56      	ldr	r3, [pc, #344]	; (8c94 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x16c>)
			if(textWrap && ((cursorY + fontSize * fontHeight) >= _height)) {//Heading off bottom edge ?
    8b3c:	4d56      	ldr	r5, [pc, #344]	; (8c98 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x170>)
#endif

	if(!gfxFont) { // 'Classic' built-in font

		if(c == '\n') {
			cursorY += fontSize*fontHeight;
    8b3e:	7819      	ldrb	r1, [r3, #0]
    8b40:	4b56      	ldr	r3, [pc, #344]	; (8c9c <_ZN14Gamebuino_Meta8Graphics5writeEh+0x174>)
			if(textWrap && ((cursorY + fontSize * fontHeight) >= _height)) {//Heading off bottom edge ?
    8b42:	782d      	ldrb	r5, [r5, #0]
#endif

	if(!gfxFont) { // 'Classic' built-in font

		if(c == '\n') {
			cursorY += fontSize*fontHeight;
    8b44:	781b      	ldrb	r3, [r3, #0]
    8b46:	4359      	muls	r1, r3
    8b48:	4b55      	ldr	r3, [pc, #340]	; (8ca0 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x178>)
    8b4a:	881c      	ldrh	r4, [r3, #0]
    8b4c:	190c      	adds	r4, r1, r4
    8b4e:	b2a4      	uxth	r4, r4
    8b50:	801c      	strh	r4, [r3, #0]
			if(textWrap && ((cursorY + fontSize * fontHeight) >= _height)) {//Heading off bottom edge ?
    8b52:	2d00      	cmp	r5, #0
    8b54:	d006      	beq.n	8b64 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x3c>
    8b56:	b224      	sxth	r4, r4
    8b58:	1861      	adds	r1, r4, r1
    8b5a:	2412      	movs	r4, #18
    8b5c:	5f00      	ldrsh	r0, [r0, r4]
    8b5e:	4281      	cmp	r1, r0
    8b60:	db00      	blt.n	8b64 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x3c>
				cursorY = 0;
    8b62:	801a      	strh	r2, [r3, #0]
			}
			cursorX  = 0;
    8b64:	4b4f      	ldr	r3, [pc, #316]	; (8ca4 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x17c>)
    8b66:	2200      	movs	r2, #0
    8b68:	801a      	strh	r2, [r3, #0]
    8b6a:	e08d      	b.n	8c88 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x160>
		} else if(c == '\r') {
    8b6c:	290d      	cmp	r1, #13
    8b6e:	d100      	bne.n	8b72 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x4a>
    8b70:	e08a      	b.n	8c88 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x160>
			// skip em
		} else {
			if(textWrap && ((cursorX + fontSize * fontWidth) > _width)) { // Heading off right edge?
    8b72:	4949      	ldr	r1, [pc, #292]	; (8c98 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x170>)
    8b74:	4c47      	ldr	r4, [pc, #284]	; (8c94 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x16c>)
    8b76:	7809      	ldrb	r1, [r1, #0]
    8b78:	4e49      	ldr	r6, [pc, #292]	; (8ca0 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x178>)
    8b7a:	2900      	cmp	r1, #0
    8b7c:	d016      	beq.n	8bac <_ZN14Gamebuino_Meta8Graphics5writeEh+0x84>
    8b7e:	7827      	ldrb	r7, [r4, #0]
    8b80:	4d48      	ldr	r5, [pc, #288]	; (8ca4 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x17c>)
    8b82:	9705      	str	r7, [sp, #20]
    8b84:	2700      	movs	r7, #0
    8b86:	5fe9      	ldrsh	r1, [r5, r7]
    8b88:	4f47      	ldr	r7, [pc, #284]	; (8ca8 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x180>)
    8b8a:	468c      	mov	ip, r1
    8b8c:	783f      	ldrb	r7, [r7, #0]
    8b8e:	9905      	ldr	r1, [sp, #20]
    8b90:	434f      	muls	r7, r1
    8b92:	44bc      	add	ip, r7
    8b94:	2110      	movs	r1, #16
    8b96:	5e47      	ldrsh	r7, [r0, r1]
    8b98:	45bc      	cmp	ip, r7
    8b9a:	dd07      	ble.n	8bac <_ZN14Gamebuino_Meta8Graphics5writeEh+0x84>
				cursorX  = 0;            // Reset x to zero
    8b9c:	802a      	strh	r2, [r5, #0]
				cursorY += fontSize * fontHeight; // Advance y one line
    8b9e:	4a3f      	ldr	r2, [pc, #252]	; (8c9c <_ZN14Gamebuino_Meta8Graphics5writeEh+0x174>)
    8ba0:	9905      	ldr	r1, [sp, #20]
    8ba2:	7812      	ldrb	r2, [r2, #0]
    8ba4:	4351      	muls	r1, r2
    8ba6:	8832      	ldrh	r2, [r6, #0]
    8ba8:	1889      	adds	r1, r1, r2
    8baa:	8031      	strh	r1, [r6, #0]
			}
			drawChar(cursorX, cursorY, c, fontSize);
    8bac:	4d3d      	ldr	r5, [pc, #244]	; (8ca4 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x17c>)
    8bae:	2200      	movs	r2, #0
    8bb0:	5ea9      	ldrsh	r1, [r5, r2]
    8bb2:	2700      	movs	r7, #0
    8bb4:	5ff2      	ldrsh	r2, [r6, r7]
    8bb6:	7826      	ldrb	r6, [r4, #0]
    8bb8:	9600      	str	r6, [sp, #0]
    8bba:	6807      	ldr	r7, [r0, #0]
    8bbc:	6c7e      	ldr	r6, [r7, #68]	; 0x44
    8bbe:	47b0      	blx	r6
			cursorX += fontSize * fontWidth;
    8bc0:	4b39      	ldr	r3, [pc, #228]	; (8ca8 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x180>)
    8bc2:	781a      	ldrb	r2, [r3, #0]
    8bc4:	7823      	ldrb	r3, [r4, #0]
    8bc6:	4353      	muls	r3, r2
    8bc8:	882a      	ldrh	r2, [r5, #0]
    8bca:	189b      	adds	r3, r3, r2
    8bcc:	802b      	strh	r3, [r5, #0]
    8bce:	e05b      	b.n	8c88 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x160>
		}

	} else { // Custom font

		if(c == '\n') {
    8bd0:	290a      	cmp	r1, #10
    8bd2:	d10b      	bne.n	8bec <_ZN14Gamebuino_Meta8Graphics5writeEh+0xc4>
			cursorX  = 0;
    8bd4:	4b33      	ldr	r3, [pc, #204]	; (8ca4 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x17c>)
    8bd6:	2100      	movs	r1, #0
    8bd8:	8019      	strh	r1, [r3, #0]
			cursorY += (int16_t)fontSize * (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
    8bda:	7a91      	ldrb	r1, [r2, #10]
    8bdc:	4a2d      	ldr	r2, [pc, #180]	; (8c94 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x16c>)
    8bde:	4b30      	ldr	r3, [pc, #192]	; (8ca0 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x178>)
    8be0:	7812      	ldrb	r2, [r2, #0]
    8be2:	434a      	muls	r2, r1
    8be4:	8819      	ldrh	r1, [r3, #0]
    8be6:	1852      	adds	r2, r2, r1
    8be8:	801a      	strh	r2, [r3, #0]
    8bea:	e04d      	b.n	8c88 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x160>
		} else if(c != '\r') {
    8bec:	290d      	cmp	r1, #13
    8bee:	d04b      	beq.n	8c88 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x160>
			uint8_t first = pgm_read_byte(&gfxFont->first);
    8bf0:	7a15      	ldrb	r5, [r2, #8]
			if((c >= first) && (c <= (uint8_t)pgm_read_byte(&gfxFont->last))) {
    8bf2:	42a9      	cmp	r1, r5
    8bf4:	d348      	bcc.n	8c88 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x160>
    8bf6:	7a51      	ldrb	r1, [r2, #9]
    8bf8:	4299      	cmp	r1, r3
    8bfa:	d345      	bcc.n	8c88 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x160>
				uint8_t   c2    = c - pgm_read_byte(&gfxFont->first);
    8bfc:	1b5d      	subs	r5, r3, r5
				GFXglyph *glyph = &(((GFXglyph *)pgm_read_pointer(&gfxFont->glyph))[c2]);
    8bfe:	6851      	ldr	r1, [r2, #4]
    8c00:	b2ed      	uxtb	r5, r5
    8c02:	00ed      	lsls	r5, r5, #3
    8c04:	186d      	adds	r5, r5, r1
				uint8_t   w     = pgm_read_byte(&glyph->width),
    8c06:	78ac      	ldrb	r4, [r5, #2]
						h     = pgm_read_byte(&glyph->height);
    8c08:	78e9      	ldrb	r1, [r5, #3]
		} else if(c != '\r') {
			uint8_t first = pgm_read_byte(&gfxFont->first);
			if((c >= first) && (c <= (uint8_t)pgm_read_byte(&gfxFont->last))) {
				uint8_t   c2    = c - pgm_read_byte(&gfxFont->first);
				GFXglyph *glyph = &(((GFXglyph *)pgm_read_pointer(&gfxFont->glyph))[c2]);
				uint8_t   w     = pgm_read_byte(&glyph->width),
    8c0a:	9404      	str	r4, [sp, #16]
						h     = pgm_read_byte(&glyph->height);
				if((w > 0) && (h > 0)) { // Is there an associated bitmap?
    8c0c:	9f04      	ldr	r7, [sp, #16]
    8c0e:	4e21      	ldr	r6, [pc, #132]	; (8c94 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x16c>)
    8c10:	4c24      	ldr	r4, [pc, #144]	; (8ca4 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x17c>)
    8c12:	2f00      	cmp	r7, #0
    8c14:	d032      	beq.n	8c7c <_ZN14Gamebuino_Meta8Graphics5writeEh+0x154>
    8c16:	2900      	cmp	r1, #0
    8c18:	d030      	beq.n	8c7c <_ZN14Gamebuino_Meta8Graphics5writeEh+0x154>
					int16_t xo = (int8_t)pgm_read_byte(&glyph->xOffset); // sic
    8c1a:	7969      	ldrb	r1, [r5, #5]
    8c1c:	468c      	mov	ip, r1
					if(textWrap && ((cursorX + fontSize * (xo + w)) >= _width)) {
    8c1e:	491e      	ldr	r1, [pc, #120]	; (8c98 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x170>)
    8c20:	7809      	ldrb	r1, [r1, #0]
    8c22:	2900      	cmp	r1, #0
    8c24:	d01c      	beq.n	8c60 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x138>
    8c26:	7837      	ldrb	r7, [r6, #0]
    8c28:	9703      	str	r7, [sp, #12]
    8c2a:	2700      	movs	r7, #0
    8c2c:	5fe1      	ldrsh	r1, [r4, r7]
    8c2e:	9105      	str	r1, [sp, #20]
    8c30:	4661      	mov	r1, ip
    8c32:	b249      	sxtb	r1, r1
    8c34:	468c      	mov	ip, r1
    8c36:	9904      	ldr	r1, [sp, #16]
    8c38:	1c0f      	adds	r7, r1, #0
    8c3a:	9903      	ldr	r1, [sp, #12]
    8c3c:	4467      	add	r7, ip
    8c3e:	434f      	muls	r7, r1
    8c40:	9905      	ldr	r1, [sp, #20]
    8c42:	19c9      	adds	r1, r1, r7
    8c44:	468c      	mov	ip, r1
    8c46:	2110      	movs	r1, #16
    8c48:	5e47      	ldrsh	r7, [r0, r1]
    8c4a:	45bc      	cmp	ip, r7
    8c4c:	db08      	blt.n	8c60 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x138>
						// Drawing character would go off right edge; textWrap to new line
						cursorX  = 0;
						cursorY += (int16_t)fontSize * (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
    8c4e:	7a92      	ldrb	r2, [r2, #10]
    8c50:	9903      	ldr	r1, [sp, #12]
						h     = pgm_read_byte(&glyph->height);
				if((w > 0) && (h > 0)) { // Is there an associated bitmap?
					int16_t xo = (int8_t)pgm_read_byte(&glyph->xOffset); // sic
					if(textWrap && ((cursorX + fontSize * (xo + w)) >= _width)) {
						// Drawing character would go off right edge; textWrap to new line
						cursorX  = 0;
    8c52:	2700      	movs	r7, #0
						cursorY += (int16_t)fontSize * (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
    8c54:	4351      	muls	r1, r2
						h     = pgm_read_byte(&glyph->height);
				if((w > 0) && (h > 0)) { // Is there an associated bitmap?
					int16_t xo = (int8_t)pgm_read_byte(&glyph->xOffset); // sic
					if(textWrap && ((cursorX + fontSize * (xo + w)) >= _width)) {
						// Drawing character would go off right edge; textWrap to new line
						cursorX  = 0;
    8c56:	8027      	strh	r7, [r4, #0]
						cursorY += (int16_t)fontSize * (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
    8c58:	4f11      	ldr	r7, [pc, #68]	; (8ca0 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x178>)
    8c5a:	883a      	ldrh	r2, [r7, #0]
    8c5c:	1889      	adds	r1, r1, r2
    8c5e:	8039      	strh	r1, [r7, #0]
					}
					drawChar(cursorX, cursorY, c, fontSize);
    8c60:	4f0f      	ldr	r7, [pc, #60]	; (8ca0 <_ZN14Gamebuino_Meta8Graphics5writeEh+0x178>)
    8c62:	2200      	movs	r2, #0
    8c64:	5ea1      	ldrsh	r1, [r4, r2]
    8c66:	1c3a      	adds	r2, r7, #0
    8c68:	2700      	movs	r7, #0
    8c6a:	5fd2      	ldrsh	r2, [r2, r7]
    8c6c:	7837      	ldrb	r7, [r6, #0]
    8c6e:	9205      	str	r2, [sp, #20]
    8c70:	9700      	str	r7, [sp, #0]
    8c72:	6807      	ldr	r7, [r0, #0]
    8c74:	6c7a      	ldr	r2, [r7, #68]	; 0x44
    8c76:	4694      	mov	ip, r2
    8c78:	9a05      	ldr	r2, [sp, #20]
    8c7a:	47e0      	blx	ip
				}
				cursorX += pgm_read_byte(&glyph->xAdvance) * (int16_t)fontSize;
    8c7c:	792a      	ldrb	r2, [r5, #4]
    8c7e:	7833      	ldrb	r3, [r6, #0]
    8c80:	4353      	muls	r3, r2
    8c82:	8822      	ldrh	r2, [r4, #0]
    8c84:	189b      	adds	r3, r3, r2
    8c86:	8023      	strh	r3, [r4, #0]

	}
#if ARDUINO >= 100
	return 1;
#endif
}
    8c88:	2001      	movs	r0, #1
    8c8a:	b007      	add	sp, #28
    8c8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8c8e:	46c0      	nop			; (mov r8, r8)
    8c90:	20000cd0 	.word	0x20000cd0
    8c94:	20000cd4 	.word	0x20000cd4
    8c98:	20000077 	.word	0x20000077
    8c9c:	20000cd5 	.word	0x20000cd5
    8ca0:	20000cc4 	.word	0x20000cc4
    8ca4:	20000cdc 	.word	0x20000cdc
    8ca8:	20000cc0 	.word	0x20000cc0

00008cac <_ZN14Gamebuino_Meta8Graphics13invertDisplayEb>:
#endif
}

void Graphics::invertDisplay(boolean i) {
	// Do nothing, must be subclassed if supported by hardware
}
    8cac:	4770      	bx	lr
	...

00008cb0 <_ZN14Gamebuino_Meta8GraphicsD0Ev>:
	gfxFont   = NULL;
	colorMode = ColorMode::rgb565;
	setFont(font3x5);
}

Graphics::~Graphics() {
    8cb0:	b510      	push	{r4, lr}
    8cb2:	4b04      	ldr	r3, [pc, #16]	; (8cc4 <_ZN14Gamebuino_Meta8GraphicsD0Ev+0x14>)
    8cb4:	1c04      	adds	r4, r0, #0
    8cb6:	3308      	adds	r3, #8
    8cb8:	6003      	str	r3, [r0, #0]
	
}
    8cba:	f007 fac1 	bl	10240 <_ZdlPv>
    8cbe:	1c20      	adds	r0, r4, #0
    8cc0:	bd10      	pop	{r4, pc}
    8cc2:	46c0      	nop			; (mov r8, r8)
    8cc4:	000153c8 	.word	0x000153c8

00008cc8 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss>:
			drawPixel(x + i, y + j);
		}
	}*/
}

void Graphics::drawImage(int16_t x, int16_t y, Image& img, int16_t w2, int16_t h2) {
    8cc8:	b5f0      	push	{r4, r5, r6, r7, lr}
    8cca:	b09b      	sub	sp, #108	; 0x6c
    8ccc:	af02      	add	r7, sp, #8
    8cce:	65b8      	str	r0, [r7, #88]	; 0x58
    8cd0:	2078      	movs	r0, #120	; 0x78
    8cd2:	65f9      	str	r1, [r7, #92]	; 0x5c
    8cd4:	5fc6      	ldrsh	r6, [r0, r7]
    8cd6:	217c      	movs	r1, #124	; 0x7c
	img.nextFrame();
    8cd8:	1c18      	adds	r0, r3, #0
			drawPixel(x + i, y + j);
		}
	}*/
}

void Graphics::drawImage(int16_t x, int16_t y, Image& img, int16_t w2, int16_t h2) {
    8cda:	657a      	str	r2, [r7, #84]	; 0x54
    8cdc:	1c1c      	adds	r4, r3, #0
    8cde:	5fcd      	ldrsh	r5, [r1, r7]
	img.nextFrame();
    8ce0:	f002 f8ae 	bl	ae40 <_ZN14Gamebuino_Meta5Image9nextFrameEv>
	if ((x > _width) || ((x + abs(w2)) < 0) || (y > _height) || ((y + abs(h2)) < 0) || (w2 == 0) || (h2 == 0)) return;
    8ce4:	6dba      	ldr	r2, [r7, #88]	; 0x58
    8ce6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    8ce8:	8a12      	ldrh	r2, [r2, #16]
    8cea:	b210      	sxth	r0, r2
    8cec:	647a      	str	r2, [r7, #68]	; 0x44
    8cee:	4283      	cmp	r3, r0
    8cf0:	dd00      	ble.n	8cf4 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x2c>
    8cf2:	e198      	b.n	9026 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x35e>
    8cf4:	17f1      	asrs	r1, r6, #31
    8cf6:	1872      	adds	r2, r6, r1
    8cf8:	404a      	eors	r2, r1
    8cfa:	42d3      	cmn	r3, r2
    8cfc:	d500      	bpl.n	8d00 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x38>
    8cfe:	e192      	b.n	9026 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x35e>
    8d00:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    8d02:	8a5b      	ldrh	r3, [r3, #18]
    8d04:	b219      	sxth	r1, r3
    8d06:	469c      	mov	ip, r3
    8d08:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    8d0a:	6539      	str	r1, [r7, #80]	; 0x50
    8d0c:	428b      	cmp	r3, r1
    8d0e:	dd00      	ble.n	8d12 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x4a>
    8d10:	e189      	b.n	9026 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x35e>
    8d12:	17e9      	asrs	r1, r5, #31
    8d14:	186b      	adds	r3, r5, r1
    8d16:	404b      	eors	r3, r1
    8d18:	6d79      	ldr	r1, [r7, #84]	; 0x54
    8d1a:	42d9      	cmn	r1, r3
    8d1c:	d500      	bpl.n	8d20 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x58>
    8d1e:	e182      	b.n	9026 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x35e>
    8d20:	2e00      	cmp	r6, #0
    8d22:	d100      	bne.n	8d26 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x5e>
    8d24:	e17f      	b.n	9026 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x35e>
    8d26:	2d00      	cmp	r5, #0
    8d28:	d100      	bne.n	8d2c <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x64>
    8d2a:	e17c      	b.n	9026 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x35e>

	int16_t w = img._width;
    8d2c:	8a21      	ldrh	r1, [r4, #16]
    8d2e:	6239      	str	r1, [r7, #32]
	int16_t h = img._height;
    8d30:	8a61      	ldrh	r1, [r4, #18]
    8d32:	6379      	str	r1, [r7, #52]	; 0x34

	//no scaling, fall back to the regular function
	if ((w == w2) && (h == h2)) {
    8d34:	6a39      	ldr	r1, [r7, #32]
    8d36:	b209      	sxth	r1, r1
    8d38:	64b9      	str	r1, [r7, #72]	; 0x48
    8d3a:	42b1      	cmp	r1, r6
    8d3c:	d10c      	bne.n	8d58 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x90>
    8d3e:	6b79      	ldr	r1, [r7, #52]	; 0x34
    8d40:	b209      	sxth	r1, r1
    8d42:	42a9      	cmp	r1, r5
    8d44:	d108      	bne.n	8d58 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x90>
		drawImage(x, y, img);
    8d46:	6dbd      	ldr	r5, [r7, #88]	; 0x58
    8d48:	6db8      	ldr	r0, [r7, #88]	; 0x58
    8d4a:	682b      	ldr	r3, [r5, #0]
    8d4c:	6df9      	ldr	r1, [r7, #92]	; 0x5c
    8d4e:	6b5d      	ldr	r5, [r3, #52]	; 0x34
    8d50:	6d7a      	ldr	r2, [r7, #84]	; 0x54
    8d52:	1c23      	adds	r3, r4, #0
    8d54:	47a8      	blx	r5
		return;
    8d56:	e166      	b.n	9026 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x35e>
	}

	boolean invertX = (w2 < 0);
    8d58:	0ff6      	lsrs	r6, r6, #31
    8d5a:	60fe      	str	r6, [r7, #12]
	boolean invertY = (h2 < 0);
	w2 = abs(w2);
    8d5c:	b216      	sxth	r6, r2
		drawImage(x, y, img);
		return;
	}

	boolean invertX = (w2 < 0);
	boolean invertY = (h2 < 0);
    8d5e:	0fed      	lsrs	r5, r5, #31
	w2 = abs(w2);
    8d60:	63fe      	str	r6, [r7, #60]	; 0x3c


	//horizontal cropping
	int16_t w2cropped = w2; //width of the cropped buffer
	int16_t i2offset = 0;
	if (x < 0) {
    8d62:	6dfe      	ldr	r6, [r7, #92]	; 0x5c
		drawImage(x, y, img);
		return;
	}

	boolean invertX = (w2 < 0);
	boolean invertY = (h2 < 0);
    8d64:	60bd      	str	r5, [r7, #8]
	w2 = abs(w2);
	h2 = abs(h2);
    8d66:	b21d      	sxth	r5, r3
    8d68:	62fd      	str	r5, [r7, #44]	; 0x2c


	//horizontal cropping
	int16_t w2cropped = w2; //width of the cropped buffer
	int16_t i2offset = 0;
	if (x < 0) {
    8d6a:	2e00      	cmp	r6, #0
    8d6c:	da07      	bge.n	8d7e <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0xb6>
		i2offset = -x;
    8d6e:	b2b1      	uxth	r1, r6
    8d70:	4248      	negs	r0, r1
		w2cropped = w2 + x;
    8d72:	1889      	adds	r1, r1, r2

	//horizontal cropping
	int16_t w2cropped = w2; //width of the cropped buffer
	int16_t i2offset = 0;
	if (x < 0) {
		i2offset = -x;
    8d74:	b280      	uxth	r0, r0
		w2cropped = w2 + x;
    8d76:	b20d      	sxth	r5, r1

	//horizontal cropping
	int16_t w2cropped = w2; //width of the cropped buffer
	int16_t i2offset = 0;
	if (x < 0) {
		i2offset = -x;
    8d78:	6438      	str	r0, [r7, #64]	; 0x40
		w2cropped = w2 + x;
    8d7a:	64fd      	str	r5, [r7, #76]	; 0x4c
    8d7c:	e00f      	b.n	8d9e <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0xd6>
	} else if ((x + w2) > _width) {
    8d7e:	6dfe      	ldr	r6, [r7, #92]	; 0x5c
    8d80:	6bfd      	ldr	r5, [r7, #60]	; 0x3c
    8d82:	1972      	adds	r2, r6, r5
    8d84:	4282      	cmp	r2, r0
    8d86:	dd06      	ble.n	8d96 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0xce>
		w2cropped = _width - x;
    8d88:	6c78      	ldr	r0, [r7, #68]	; 0x44
    8d8a:	1b81      	subs	r1, r0, r6
    8d8c:	b20d      	sxth	r5, r1
	h2 = abs(h2);


	//horizontal cropping
	int16_t w2cropped = w2; //width of the cropped buffer
	int16_t i2offset = 0;
    8d8e:	2600      	movs	r6, #0
	if (x < 0) {
		i2offset = -x;
		w2cropped = w2 + x;
	} else if ((x + w2) > _width) {
		w2cropped = _width - x;
    8d90:	64fd      	str	r5, [r7, #76]	; 0x4c
	h2 = abs(h2);


	//horizontal cropping
	int16_t w2cropped = w2; //width of the cropped buffer
	int16_t i2offset = 0;
    8d92:	643e      	str	r6, [r7, #64]	; 0x40
    8d94:	e003      	b.n	8d9e <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0xd6>
	w2 = abs(w2);
	h2 = abs(h2);


	//horizontal cropping
	int16_t w2cropped = w2; //width of the cropped buffer
    8d96:	6bfd      	ldr	r5, [r7, #60]	; 0x3c
	int16_t i2offset = 0;
    8d98:	2600      	movs	r6, #0
	w2 = abs(w2);
	h2 = abs(h2);


	//horizontal cropping
	int16_t w2cropped = w2; //width of the cropped buffer
    8d9a:	64fd      	str	r5, [r7, #76]	; 0x4c
	int16_t i2offset = 0;
    8d9c:	643e      	str	r6, [r7, #64]	; 0x40
	}

	//vertical cropping
	int16_t h2cropped = h2;
	int16_t j2offset = 0;
	if (y < 0) {
    8d9e:	6d7d      	ldr	r5, [r7, #84]	; 0x54
    8da0:	2d00      	cmp	r5, #0
    8da2:	da07      	bge.n	8db4 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0xec>
		j2offset = -y;
    8da4:	b2aa      	uxth	r2, r5
    8da6:	4251      	negs	r1, r2
		h2cropped = h2 + y;
    8da8:	18d3      	adds	r3, r2, r3

	//vertical cropping
	int16_t h2cropped = h2;
	int16_t j2offset = 0;
	if (y < 0) {
		j2offset = -y;
    8daa:	b289      	uxth	r1, r1
		h2cropped = h2 + y;
    8dac:	b21e      	sxth	r6, r3

	//vertical cropping
	int16_t h2cropped = h2;
	int16_t j2offset = 0;
	if (y < 0) {
		j2offset = -y;
    8dae:	6539      	str	r1, [r7, #80]	; 0x50
		h2cropped = h2 + y;
    8db0:	633e      	str	r6, [r7, #48]	; 0x30
    8db2:	e010      	b.n	8dd6 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x10e>
	} else if ((y + h2) > _height) {
    8db4:	6d7d      	ldr	r5, [r7, #84]	; 0x54
    8db6:	6afe      	ldr	r6, [r7, #44]	; 0x2c
    8db8:	6d38      	ldr	r0, [r7, #80]	; 0x50
    8dba:	19ab      	adds	r3, r5, r6
    8dbc:	4283      	cmp	r3, r0
    8dbe:	dd06      	ble.n	8dce <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x106>
		h2cropped = _height - y;
    8dc0:	4661      	mov	r1, ip
    8dc2:	1b4b      	subs	r3, r1, r5
    8dc4:	b21d      	sxth	r5, r3
		w2cropped = _width - x;
	}

	//vertical cropping
	int16_t h2cropped = h2;
	int16_t j2offset = 0;
    8dc6:	2600      	movs	r6, #0
	if (y < 0) {
		j2offset = -y;
		h2cropped = h2 + y;
	} else if ((y + h2) > _height) {
		h2cropped = _height - y;
    8dc8:	633d      	str	r5, [r7, #48]	; 0x30
		w2cropped = _width - x;
	}

	//vertical cropping
	int16_t h2cropped = h2;
	int16_t j2offset = 0;
    8dca:	653e      	str	r6, [r7, #80]	; 0x50
    8dcc:	e003      	b.n	8dd6 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x10e>
	} else if ((x + w2) > _width) {
		w2cropped = _width - x;
	}

	//vertical cropping
	int16_t h2cropped = h2;
    8dce:	6afd      	ldr	r5, [r7, #44]	; 0x2c
	int16_t j2offset = 0;
    8dd0:	2600      	movs	r6, #0
	} else if ((x + w2) > _width) {
		w2cropped = _width - x;
	}

	//vertical cropping
	int16_t h2cropped = h2;
    8dd2:	633d      	str	r5, [r7, #48]	; 0x30
	int16_t j2offset = 0;
    8dd4:	653e      	str	r6, [r7, #80]	; 0x50
		h2cropped = h2 + y;
	} else if ((y + h2) > _height) {
		h2cropped = _height - y;
	}
	
	if (colorMode == ColorMode::rgb565) {
    8dd6:	6dbd      	ldr	r5, [r7, #88]	; 0x58
    8dd8:	7aab      	ldrb	r3, [r5, #10]
    8dda:	2b00      	cmp	r3, #0
    8ddc:	d000      	beq.n	8de0 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x118>
    8dde:	e096      	b.n	8f0e <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x246>
		uint16_t bufferLine[w2];
    8de0:	6bfe      	ldr	r6, [r7, #60]	; 0x3c
    8de2:	466d      	mov	r5, sp
    8de4:	0073      	lsls	r3, r6, #1
    8de6:	3308      	adds	r3, #8
    8de8:	08db      	lsrs	r3, r3, #3
    8dea:	00db      	lsls	r3, r3, #3
    8dec:	1ae8      	subs	r0, r5, r3
    8dee:	4685      	mov	sp, r0
		uint16_t transparent_backup = img.transparentColor;
    8df0:	8926      	ldrh	r6, [r4, #8]
		if (img.colorMode == ColorMode::index) {
    8df2:	7aa3      	ldrb	r3, [r4, #10]
    8df4:	62bd      	str	r5, [r7, #40]	; 0x28
	} else if ((y + h2) > _height) {
		h2cropped = _height - y;
	}
	
	if (colorMode == ColorMode::rgb565) {
		uint16_t bufferLine[w2];
    8df6:	ad02      	add	r5, sp, #8
    8df8:	63bd      	str	r5, [r7, #56]	; 0x38
		uint16_t transparent_backup = img.transparentColor;
    8dfa:	627e      	str	r6, [r7, #36]	; 0x24
		if (img.colorMode == ColorMode::index) {
    8dfc:	2b01      	cmp	r3, #1
    8dfe:	d10a      	bne.n	8e16 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x14e>
			if (img.useTransparentIndex) {
    8e00:	7a62      	ldrb	r2, [r4, #9]
    8e02:	2a00      	cmp	r2, #0
    8e04:	d006      	beq.n	8e14 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x14c>
				img.transparentColor = (uint16_t)colorIndex[img.transparentColorIndex];
    8e06:	4b89      	ldr	r3, [pc, #548]	; (902c <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x364>)
    8e08:	7a22      	ldrb	r2, [r4, #8]
    8e0a:	681b      	ldr	r3, [r3, #0]
    8e0c:	0052      	lsls	r2, r2, #1
    8e0e:	5ad3      	ldrh	r3, [r2, r3]
    8e10:	8123      	strh	r3, [r4, #8]
    8e12:	e000      	b.n	8e16 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x14e>
			} else {
				img.transparentColor = 1;
    8e14:	8123      	strh	r3, [r4, #8]
				if (img.colorMode == ColorMode::rgb565) {
					// draw RGB => RGB
					bufferLine[i2] = img._buffer[(j * w) + i];
				} else if (img.colorMode == ColorMode::index) {
					//draw INDEX => RGB
					uint8_t b = ((uint8_t*)img._buffer)[((w+1)/2)*j + (i/2)];
    8e16:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    8e18:	2500      	movs	r5, #0
    8e1a:	3301      	adds	r3, #1
    8e1c:	0fda      	lsrs	r2, r3, #31
    8e1e:	18d3      	adds	r3, r2, r3
    8e20:	105b      	asrs	r3, r3, #1
    8e22:	61bb      	str	r3, [r7, #24]
    8e24:	647d      	str	r5, [r7, #68]	; 0x44
			} else {
				img.transparentColor = 1;
			}
			
		}
		for (int16_t j2 = 0; j2 < h2cropped; j2++) { //j2: offseted vertical coordinate in destination
    8e26:	6c7d      	ldr	r5, [r7, #68]	; 0x44
    8e28:	6b3e      	ldr	r6, [r7, #48]	; 0x30
    8e2a:	b22b      	sxth	r3, r5
    8e2c:	42b3      	cmp	r3, r6
    8e2e:	da69      	bge.n	8f04 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x23c>
			uint16_t j = h * (j2 + j2offset) / h2; //j: vertical coordinate in source image
    8e30:	6d3d      	ldr	r5, [r7, #80]	; 0x50
    8e32:	6b7e      	ldr	r6, [r7, #52]	; 0x34
    8e34:	b228      	sxth	r0, r5
    8e36:	181b      	adds	r3, r3, r0
    8e38:	b232      	sxth	r2, r6
    8e3a:	1c18      	adds	r0, r3, #0
    8e3c:	4350      	muls	r0, r2
    8e3e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    8e40:	f008 faf8 	bl	11434 <__aeabi_idiv>
			j = invertY ? h - 1 - j : j;
    8e44:	68be      	ldr	r6, [r7, #8]
				img.transparentColor = 1;
			}
			
		}
		for (int16_t j2 = 0; j2 < h2cropped; j2++) { //j2: offseted vertical coordinate in destination
			uint16_t j = h * (j2 + j2offset) / h2; //j: vertical coordinate in source image
    8e46:	b280      	uxth	r0, r0
			j = invertY ? h - 1 - j : j;
    8e48:	2e00      	cmp	r6, #0
    8e4a:	d003      	beq.n	8e54 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x18c>
    8e4c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8e4e:	3b01      	subs	r3, #1
    8e50:	1a18      	subs	r0, r3, r0
    8e52:	b280      	uxth	r0, r0
				if (img.colorMode == ColorMode::rgb565) {
					// draw RGB => RGB
					bufferLine[i2] = img._buffer[(j * w) + i];
				} else if (img.colorMode == ColorMode::index) {
					//draw INDEX => RGB
					uint8_t b = ((uint8_t*)img._buffer)[((w+1)/2)*j + (i/2)];
    8e54:	69be      	ldr	r6, [r7, #24]
			for (int16_t i2 = 0; i2 < w2cropped; i2++) { //i2: offseted horizontal coordinate in desination
				uint16_t i = w * (i2 + i2offset) / w2; //i: horizontal coordinate in original image
				i = invertX ? w - 1 - i : i;
				if (img.colorMode == ColorMode::rgb565) {
					// draw RGB => RGB
					bufferLine[i2] = img._buffer[(j * w) + i];
    8e56:	6cbd      	ldr	r5, [r7, #72]	; 0x48
				} else if (img.colorMode == ColorMode::index) {
					//draw INDEX => RGB
					uint8_t b = ((uint8_t*)img._buffer)[((w+1)/2)*j + (i/2)];
    8e58:	4346      	muls	r6, r0
			for (int16_t i2 = 0; i2 < w2cropped; i2++) { //i2: offseted horizontal coordinate in desination
				uint16_t i = w * (i2 + i2offset) / w2; //i: horizontal coordinate in original image
				i = invertX ? w - 1 - i : i;
				if (img.colorMode == ColorMode::rgb565) {
					// draw RGB => RGB
					bufferLine[i2] = img._buffer[(j * w) + i];
    8e5a:	4345      	muls	r5, r0
					//draw INDEX => RGB
					uint8_t b = ((uint8_t*)img._buffer)[((w+1)/2)*j + (i/2)];
					if (!(i % 2)) {
						b >>= 4;
					}
					bufferLine[i2] = (uint16_t)colorIndex[b & 0x0F];
    8e5c:	4b73      	ldr	r3, [pc, #460]	; (902c <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x364>)
				if (img.colorMode == ColorMode::rgb565) {
					// draw RGB => RGB
					bufferLine[i2] = img._buffer[(j * w) + i];
				} else if (img.colorMode == ColorMode::index) {
					//draw INDEX => RGB
					uint8_t b = ((uint8_t*)img._buffer)[((w+1)/2)*j + (i/2)];
    8e5e:	617e      	str	r6, [r7, #20]
					if (!(i % 2)) {
						b >>= 4;
					}
					bufferLine[i2] = (uint16_t)colorIndex[b & 0x0F];
    8e60:	681b      	ldr	r3, [r3, #0]
    8e62:	6bbe      	ldr	r6, [r7, #56]	; 0x38
			for (int16_t i2 = 0; i2 < w2cropped; i2++) { //i2: offseted horizontal coordinate in desination
				uint16_t i = w * (i2 + i2offset) / w2; //i: horizontal coordinate in original image
				i = invertX ? w - 1 - i : i;
				if (img.colorMode == ColorMode::rgb565) {
					// draw RGB => RGB
					bufferLine[i2] = img._buffer[(j * w) + i];
    8e64:	61fd      	str	r5, [r7, #28]
					//draw INDEX => RGB
					uint8_t b = ((uint8_t*)img._buffer)[((w+1)/2)*j + (i/2)];
					if (!(i % 2)) {
						b >>= 4;
					}
					bufferLine[i2] = (uint16_t)colorIndex[b & 0x0F];
    8e66:	613b      	str	r3, [r7, #16]
			
		}
		for (int16_t j2 = 0; j2 < h2cropped; j2++) { //j2: offseted vertical coordinate in destination
			uint16_t j = h * (j2 + j2offset) / h2; //j: vertical coordinate in source image
			j = invertY ? h - 1 - j : j;
			for (int16_t i2 = 0; i2 < w2cropped; i2++) { //i2: offseted horizontal coordinate in desination
    8e68:	2500      	movs	r5, #0
    8e6a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
    8e6c:	b22b      	sxth	r3, r5
    8e6e:	4283      	cmp	r3, r0
    8e70:	da2f      	bge.n	8ed2 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x20a>
				uint16_t i = w * (i2 + i2offset) / w2; //i: horizontal coordinate in original image
    8e72:	6c39      	ldr	r1, [r7, #64]	; 0x40
    8e74:	6cba      	ldr	r2, [r7, #72]	; 0x48
    8e76:	b208      	sxth	r0, r1
    8e78:	1828      	adds	r0, r5, r0
    8e7a:	4350      	muls	r0, r2
    8e7c:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
    8e7e:	f008 fad9 	bl	11434 <__aeabi_idiv>
				i = invertX ? w - 1 - i : i;
    8e82:	68fb      	ldr	r3, [r7, #12]
		}
		for (int16_t j2 = 0; j2 < h2cropped; j2++) { //j2: offseted vertical coordinate in destination
			uint16_t j = h * (j2 + j2offset) / h2; //j: vertical coordinate in source image
			j = invertY ? h - 1 - j : j;
			for (int16_t i2 = 0; i2 < w2cropped; i2++) { //i2: offseted horizontal coordinate in desination
				uint16_t i = w * (i2 + i2offset) / w2; //i: horizontal coordinate in original image
    8e84:	b280      	uxth	r0, r0
				i = invertX ? w - 1 - i : i;
    8e86:	2b00      	cmp	r3, #0
    8e88:	d003      	beq.n	8e92 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x1ca>
    8e8a:	6a3b      	ldr	r3, [r7, #32]
    8e8c:	3b01      	subs	r3, #1
    8e8e:	1a18      	subs	r0, r3, r0
    8e90:	b280      	uxth	r0, r0
				if (img.colorMode == ColorMode::rgb565) {
    8e92:	7aa1      	ldrb	r1, [r4, #10]
    8e94:	6039      	str	r1, [r7, #0]
    8e96:	2900      	cmp	r1, #0
    8e98:	d106      	bne.n	8ea8 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x1e0>
					// draw RGB => RGB
					bufferLine[i2] = img._buffer[(j * w) + i];
    8e9a:	69fa      	ldr	r2, [r7, #28]
    8e9c:	6961      	ldr	r1, [r4, #20]
    8e9e:	1810      	adds	r0, r2, r0
    8ea0:	0040      	lsls	r0, r0, #1
    8ea2:	5a43      	ldrh	r3, [r0, r1]
    8ea4:	8033      	strh	r3, [r6, #0]
    8ea6:	e011      	b.n	8ecc <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x204>
				} else if (img.colorMode == ColorMode::index) {
    8ea8:	683a      	ldr	r2, [r7, #0]
    8eaa:	2a01      	cmp	r2, #1
    8eac:	d10e      	bne.n	8ecc <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x204>
					//draw INDEX => RGB
					uint8_t b = ((uint8_t*)img._buffer)[((w+1)/2)*j + (i/2)];
    8eae:	6961      	ldr	r1, [r4, #20]
    8eb0:	697a      	ldr	r2, [r7, #20]
    8eb2:	0843      	lsrs	r3, r0, #1
    8eb4:	1889      	adds	r1, r1, r2
    8eb6:	5ccb      	ldrb	r3, [r1, r3]
					if (!(i % 2)) {
    8eb8:	6839      	ldr	r1, [r7, #0]
    8eba:	4208      	tst	r0, r1
    8ebc:	d100      	bne.n	8ec0 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x1f8>
						b >>= 4;
    8ebe:	091b      	lsrs	r3, r3, #4
					}
					bufferLine[i2] = (uint16_t)colorIndex[b & 0x0F];
    8ec0:	220f      	movs	r2, #15
    8ec2:	4013      	ands	r3, r2
    8ec4:	693a      	ldr	r2, [r7, #16]
    8ec6:	005b      	lsls	r3, r3, #1
    8ec8:	5a9b      	ldrh	r3, [r3, r2]
    8eca:	8033      	strh	r3, [r6, #0]
    8ecc:	3501      	adds	r5, #1
    8ece:	3602      	adds	r6, #2
    8ed0:	e7cb      	b.n	8e6a <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x1a2>
				}
			}
			drawBufferedLine(x + i2offset, y + j2 + j2offset, bufferLine, w2cropped, img);
    8ed2:	6c7e      	ldr	r6, [r7, #68]	; 0x44
    8ed4:	6df8      	ldr	r0, [r7, #92]	; 0x5c
    8ed6:	b2b5      	uxth	r5, r6
    8ed8:	6dbe      	ldr	r6, [r7, #88]	; 0x58
    8eda:	6833      	ldr	r3, [r6, #0]
    8edc:	6c3e      	ldr	r6, [r7, #64]	; 0x40
    8ede:	1831      	adds	r1, r6, r0
    8ee0:	6d3e      	ldr	r6, [r7, #80]	; 0x50
    8ee2:	6d78      	ldr	r0, [r7, #84]	; 0x54
    8ee4:	b209      	sxth	r1, r1
    8ee6:	1832      	adds	r2, r6, r0
    8ee8:	6cfe      	ldr	r6, [r7, #76]	; 0x4c
    8eea:	18aa      	adds	r2, r5, r2
    8eec:	b2b0      	uxth	r0, r6
    8eee:	9000      	str	r0, [sp, #0]
    8ef0:	9401      	str	r4, [sp, #4]
			} else {
				img.transparentColor = 1;
			}
			
		}
		for (int16_t j2 = 0; j2 < h2cropped; j2++) { //j2: offseted vertical coordinate in destination
    8ef2:	3501      	adds	r5, #1
						b >>= 4;
					}
					bufferLine[i2] = (uint16_t)colorIndex[b & 0x0F];
				}
			}
			drawBufferedLine(x + i2offset, y + j2 + j2offset, bufferLine, w2cropped, img);
    8ef4:	695e      	ldr	r6, [r3, #20]
    8ef6:	b212      	sxth	r2, r2
    8ef8:	6db8      	ldr	r0, [r7, #88]	; 0x58
    8efa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
			} else {
				img.transparentColor = 1;
			}
			
		}
		for (int16_t j2 = 0; j2 < h2cropped; j2++) { //j2: offseted vertical coordinate in destination
    8efc:	b2ad      	uxth	r5, r5
						b >>= 4;
					}
					bufferLine[i2] = (uint16_t)colorIndex[b & 0x0F];
				}
			}
			drawBufferedLine(x + i2offset, y + j2 + j2offset, bufferLine, w2cropped, img);
    8efe:	47b0      	blx	r6
			} else {
				img.transparentColor = 1;
			}
			
		}
		for (int16_t j2 = 0; j2 < h2cropped; j2++) { //j2: offseted vertical coordinate in destination
    8f00:	647d      	str	r5, [r7, #68]	; 0x44
    8f02:	e790      	b.n	8e26 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x15e>
					bufferLine[i2] = (uint16_t)colorIndex[b & 0x0F];
				}
			}
			drawBufferedLine(x + i2offset, y + j2 + j2offset, bufferLine, w2cropped, img);
		}
		img.transparentColor = transparent_backup;
    8f04:	6a7d      	ldr	r5, [r7, #36]	; 0x24
    8f06:	8125      	strh	r5, [r4, #8]
    8f08:	6abe      	ldr	r6, [r7, #40]	; 0x28
    8f0a:	46b5      	mov	sp, r6
    8f0c:	e08b      	b.n	9026 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x35e>
		return;
	}
	if (colorMode == ColorMode::index) {
    8f0e:	2b01      	cmp	r3, #1
    8f10:	d000      	beq.n	8f14 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x24c>
    8f12:	e088      	b.n	9026 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x35e>
		if (img.colorMode == ColorMode::rgb565) {
    8f14:	7aa3      	ldrb	r3, [r4, #10]
    8f16:	466d      	mov	r5, sp
    8f18:	61fd      	str	r5, [r7, #28]
    8f1a:	2b00      	cmp	r3, #0
    8f1c:	d102      	bne.n	8f24 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x25c>
    8f1e:	69fe      	ldr	r6, [r7, #28]
    8f20:	46b5      	mov	sp, r6
    8f22:	e080      	b.n	9026 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x35e>
			return;
		}
		uint8_t bufferLine[w2 + 1];
    8f24:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    8f26:	6c3e      	ldr	r6, [r7, #64]	; 0x40
    8f28:	3308      	adds	r3, #8
    8f2a:	08db      	lsrs	r3, r3, #3
    8f2c:	00db      	lsls	r3, r3, #3
    8f2e:	1ae8      	subs	r0, r5, r3
    8f30:	4685      	mov	sp, r0
    8f32:	ad02      	add	r5, sp, #8
    8f34:	62bd      	str	r5, [r7, #40]	; 0x28
			for (int16_t i2 = 0; i2 < w2cropped; i2++) { //i2: offseted horizontal coordinate in desination
				uint16_t i = w * (i2 + i2offset) / w2; //i: horizontal coordinate in original image
				i = invertX ? w - 1 - i : i;
				
				//draw INDEX => INDEX
				uint8_t b = ((uint8_t*)img._buffer)[((w+1)/2)*j + (i/2)];
    8f36:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    8f38:	6cbd      	ldr	r5, [r7, #72]	; 0x48
    8f3a:	b236      	sxth	r6, r6
    8f3c:	3301      	adds	r3, #1
    8f3e:	4375      	muls	r5, r6
    8f40:	0fda      	lsrs	r2, r3, #31
    8f42:	18d3      	adds	r3, r2, r3
    8f44:	105b      	asrs	r3, r3, #1
    8f46:	627e      	str	r6, [r7, #36]	; 0x24
	if (colorMode == ColorMode::index) {
		if (img.colorMode == ColorMode::rgb565) {
			return;
		}
		uint8_t bufferLine[w2 + 1];
		for (int16_t j2 = 0; j2 < h2cropped; j2++) { //j2: offseted vertical coordinate in destination
    8f48:	2600      	movs	r6, #0
			for (int16_t i2 = 0; i2 < w2cropped; i2++) { //i2: offseted horizontal coordinate in desination
				uint16_t i = w * (i2 + i2offset) / w2; //i: horizontal coordinate in original image
				i = invertX ? w - 1 - i : i;
				
				//draw INDEX => INDEX
				uint8_t b = ((uint8_t*)img._buffer)[((w+1)/2)*j + (i/2)];
    8f4a:	61bb      	str	r3, [r7, #24]
    8f4c:	613d      	str	r5, [r7, #16]
	if (colorMode == ColorMode::index) {
		if (img.colorMode == ColorMode::rgb565) {
			return;
		}
		uint8_t bufferLine[w2 + 1];
		for (int16_t j2 = 0; j2 < h2cropped; j2++) { //j2: offseted vertical coordinate in destination
    8f4e:	647e      	str	r6, [r7, #68]	; 0x44
    8f50:	6c7d      	ldr	r5, [r7, #68]	; 0x44
    8f52:	6b3e      	ldr	r6, [r7, #48]	; 0x30
    8f54:	b22b      	sxth	r3, r5
    8f56:	42b3      	cmp	r3, r6
    8f58:	dae1      	bge.n	8f1e <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x256>
			uint8_t* dst = bufferLine;
			uint16_t j = h * (j2 + j2offset) / h2; //j: vertical coordinate in source image
    8f5a:	6d3e      	ldr	r6, [r7, #80]	; 0x50
    8f5c:	6b7d      	ldr	r5, [r7, #52]	; 0x34
    8f5e:	b230      	sxth	r0, r6
    8f60:	181b      	adds	r3, r3, r0
    8f62:	b22a      	sxth	r2, r5
    8f64:	1c18      	adds	r0, r3, #0
    8f66:	4350      	muls	r0, r2
    8f68:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    8f6a:	f008 fa63 	bl	11434 <__aeabi_idiv>
			j = invertY ? h - 1 - j : j;
    8f6e:	68bd      	ldr	r5, [r7, #8]
			return;
		}
		uint8_t bufferLine[w2 + 1];
		for (int16_t j2 = 0; j2 < h2cropped; j2++) { //j2: offseted vertical coordinate in destination
			uint8_t* dst = bufferLine;
			uint16_t j = h * (j2 + j2offset) / h2; //j: vertical coordinate in source image
    8f70:	b280      	uxth	r0, r0
			j = invertY ? h - 1 - j : j;
    8f72:	2d00      	cmp	r5, #0
    8f74:	d003      	beq.n	8f7e <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x2b6>
    8f76:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    8f78:	3b01      	subs	r3, #1
    8f7a:	1a18      	subs	r0, r3, r0
    8f7c:	b280      	uxth	r0, r0
			for (int16_t i2 = 0; i2 < w2cropped; i2++) { //i2: offseted horizontal coordinate in desination
				uint16_t i = w * (i2 + i2offset) / w2; //i: horizontal coordinate in original image
				i = invertX ? w - 1 - i : i;
				
				//draw INDEX => INDEX
				uint8_t b = ((uint8_t*)img._buffer)[((w+1)/2)*j + (i/2)];
    8f7e:	69be      	ldr	r6, [r7, #24]
		uint8_t bufferLine[w2 + 1];
		for (int16_t j2 = 0; j2 < h2cropped; j2++) { //j2: offseted vertical coordinate in destination
			uint8_t* dst = bufferLine;
			uint16_t j = h * (j2 + j2offset) / h2; //j: vertical coordinate in source image
			j = invertY ? h - 1 - j : j;
			for (int16_t i2 = 0; i2 < w2cropped; i2++) { //i2: offseted horizontal coordinate in desination
    8f80:	693d      	ldr	r5, [r7, #16]
				uint16_t i = w * (i2 + i2offset) / w2; //i: horizontal coordinate in original image
				i = invertX ? w - 1 - i : i;
				
				//draw INDEX => INDEX
				uint8_t b = ((uint8_t*)img._buffer)[((w+1)/2)*j + (i/2)];
    8f82:	4346      	muls	r6, r0
		uint8_t bufferLine[w2 + 1];
		for (int16_t j2 = 0; j2 < h2cropped; j2++) { //j2: offseted vertical coordinate in destination
			uint8_t* dst = bufferLine;
			uint16_t j = h * (j2 + j2offset) / h2; //j: vertical coordinate in source image
			j = invertY ? h - 1 - j : j;
			for (int16_t i2 = 0; i2 < w2cropped; i2++) { //i2: offseted horizontal coordinate in desination
    8f84:	63bd      	str	r5, [r7, #56]	; 0x38
		if (img.colorMode == ColorMode::rgb565) {
			return;
		}
		uint8_t bufferLine[w2 + 1];
		for (int16_t j2 = 0; j2 < h2cropped; j2++) { //j2: offseted vertical coordinate in destination
			uint8_t* dst = bufferLine;
    8f86:	6abd      	ldr	r5, [r7, #40]	; 0x28
			for (int16_t i2 = 0; i2 < w2cropped; i2++) { //i2: offseted horizontal coordinate in desination
				uint16_t i = w * (i2 + i2offset) / w2; //i: horizontal coordinate in original image
				i = invertX ? w - 1 - i : i;
				
				//draw INDEX => INDEX
				uint8_t b = ((uint8_t*)img._buffer)[((w+1)/2)*j + (i/2)];
    8f88:	617e      	str	r6, [r7, #20]
		uint8_t bufferLine[w2 + 1];
		for (int16_t j2 = 0; j2 < h2cropped; j2++) { //j2: offseted vertical coordinate in destination
			uint8_t* dst = bufferLine;
			uint16_t j = h * (j2 + j2offset) / h2; //j: vertical coordinate in source image
			j = invertY ? h - 1 - j : j;
			for (int16_t i2 = 0; i2 < w2cropped; i2++) { //i2: offseted horizontal coordinate in desination
    8f8a:	2600      	movs	r6, #0
    8f8c:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
    8f8e:	b233      	sxth	r3, r6
    8f90:	4283      	cmp	r3, r0
    8f92:	da2f      	bge.n	8ff4 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x32c>
				uint16_t i = w * (i2 + i2offset) / w2; //i: horizontal coordinate in original image
    8f94:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
    8f96:	6bb8      	ldr	r0, [r7, #56]	; 0x38
    8f98:	f008 fa4c 	bl	11434 <__aeabi_idiv>
				i = invertX ? w - 1 - i : i;
    8f9c:	68f9      	ldr	r1, [r7, #12]
		for (int16_t j2 = 0; j2 < h2cropped; j2++) { //j2: offseted vertical coordinate in destination
			uint8_t* dst = bufferLine;
			uint16_t j = h * (j2 + j2offset) / h2; //j: vertical coordinate in source image
			j = invertY ? h - 1 - j : j;
			for (int16_t i2 = 0; i2 < w2cropped; i2++) { //i2: offseted horizontal coordinate in desination
				uint16_t i = w * (i2 + i2offset) / w2; //i: horizontal coordinate in original image
    8f9e:	b280      	uxth	r0, r0
				i = invertX ? w - 1 - i : i;
    8fa0:	2900      	cmp	r1, #0
    8fa2:	d003      	beq.n	8fac <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x2e4>
    8fa4:	6a3b      	ldr	r3, [r7, #32]
    8fa6:	3b01      	subs	r3, #1
    8fa8:	1a18      	subs	r0, r3, r0
    8faa:	b280      	uxth	r0, r0
				
				//draw INDEX => INDEX
				uint8_t b = ((uint8_t*)img._buffer)[((w+1)/2)*j + (i/2)];
    8fac:	0842      	lsrs	r2, r0, #1
    8fae:	6963      	ldr	r3, [r4, #20]
    8fb0:	6979      	ldr	r1, [r7, #20]
    8fb2:	4694      	mov	ip, r2
    8fb4:	185a      	adds	r2, r3, r1
    8fb6:	4663      	mov	r3, ip
    8fb8:	5cd2      	ldrb	r2, [r2, r3]
				if (!(i % 2)) {
    8fba:	07c1      	lsls	r1, r0, #31
    8fbc:	d400      	bmi.n	8fc0 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x2f8>
					b >>= 4;
    8fbe:	0912      	lsrs	r2, r2, #4
    8fc0:	6a78      	ldr	r0, [r7, #36]	; 0x24
				}
				b &= 0x0F;
    8fc2:	230f      	movs	r3, #15
    8fc4:	4684      	mov	ip, r0
    8fc6:	6df8      	ldr	r0, [r7, #92]	; 0x5c
    8fc8:	401a      	ands	r2, r3
    8fca:	4484      	add	ip, r0
    8fcc:	44b4      	add	ip, r6
				if ((x + i2 + i2offset) % 2) {
    8fce:	4660      	mov	r0, ip
    8fd0:	7829      	ldrb	r1, [r5, #0]
    8fd2:	07c0      	lsls	r0, r0, #31
    8fd4:	d504      	bpl.n	8fe0 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x318>
					*dst = (*dst & 0xF0) | b;
    8fd6:	4399      	bics	r1, r3
    8fd8:	430a      	orrs	r2, r1
    8fda:	702a      	strb	r2, [r5, #0]
					dst++;
    8fdc:	3501      	adds	r5, #1
    8fde:	e003      	b.n	8fe8 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x320>
				} else {
					*dst = (*dst & 0x0F) | (b << 4);
    8fe0:	0112      	lsls	r2, r2, #4
    8fe2:	400b      	ands	r3, r1
    8fe4:	4313      	orrs	r3, r2
    8fe6:	702b      	strb	r3, [r5, #0]
    8fe8:	6bb9      	ldr	r1, [r7, #56]	; 0x38
    8fea:	6cba      	ldr	r2, [r7, #72]	; 0x48
    8fec:	3601      	adds	r6, #1
    8fee:	1889      	adds	r1, r1, r2
    8ff0:	63b9      	str	r1, [r7, #56]	; 0x38
    8ff2:	e7cb      	b.n	8f8c <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x2c4>
				}
			}
			drawBufferedLine(x + i2offset, y + j2 + j2offset, (uint16_t*)bufferLine, w2cropped, img);
    8ff4:	6c7e      	ldr	r6, [r7, #68]	; 0x44
    8ff6:	6df8      	ldr	r0, [r7, #92]	; 0x5c
    8ff8:	b2b5      	uxth	r5, r6
    8ffa:	6dbe      	ldr	r6, [r7, #88]	; 0x58
    8ffc:	6833      	ldr	r3, [r6, #0]
    8ffe:	6c3e      	ldr	r6, [r7, #64]	; 0x40
    9000:	1831      	adds	r1, r6, r0
    9002:	6d3e      	ldr	r6, [r7, #80]	; 0x50
    9004:	6d78      	ldr	r0, [r7, #84]	; 0x54
    9006:	b209      	sxth	r1, r1
    9008:	1832      	adds	r2, r6, r0
    900a:	6cfe      	ldr	r6, [r7, #76]	; 0x4c
    900c:	18aa      	adds	r2, r5, r2
    900e:	b2b0      	uxth	r0, r6
    9010:	9000      	str	r0, [sp, #0]
    9012:	9401      	str	r4, [sp, #4]
	if (colorMode == ColorMode::index) {
		if (img.colorMode == ColorMode::rgb565) {
			return;
		}
		uint8_t bufferLine[w2 + 1];
		for (int16_t j2 = 0; j2 < h2cropped; j2++) { //j2: offseted vertical coordinate in destination
    9014:	3501      	adds	r5, #1
					dst++;
				} else {
					*dst = (*dst & 0x0F) | (b << 4);
				}
			}
			drawBufferedLine(x + i2offset, y + j2 + j2offset, (uint16_t*)bufferLine, w2cropped, img);
    9016:	695e      	ldr	r6, [r3, #20]
    9018:	b212      	sxth	r2, r2
    901a:	6db8      	ldr	r0, [r7, #88]	; 0x58
    901c:	6abb      	ldr	r3, [r7, #40]	; 0x28
	if (colorMode == ColorMode::index) {
		if (img.colorMode == ColorMode::rgb565) {
			return;
		}
		uint8_t bufferLine[w2 + 1];
		for (int16_t j2 = 0; j2 < h2cropped; j2++) { //j2: offseted vertical coordinate in destination
    901e:	b2ad      	uxth	r5, r5
					dst++;
				} else {
					*dst = (*dst & 0x0F) | (b << 4);
				}
			}
			drawBufferedLine(x + i2offset, y + j2 + j2offset, (uint16_t*)bufferLine, w2cropped, img);
    9020:	47b0      	blx	r6
	if (colorMode == ColorMode::index) {
		if (img.colorMode == ColorMode::rgb565) {
			return;
		}
		uint8_t bufferLine[w2 + 1];
		for (int16_t j2 = 0; j2 < h2cropped; j2++) { //j2: offseted vertical coordinate in destination
    9022:	647d      	str	r5, [r7, #68]	; 0x44
    9024:	e794      	b.n	8f50 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss+0x288>
			}
			drawBufferedLine(x + i2offset, y + j2 + j2offset, (uint16_t*)bufferLine, w2cropped, img);
		}
		return;
	}
}
    9026:	46bd      	mov	sp, r7
    9028:	b019      	add	sp, #100	; 0x64
    902a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    902c:	20000050 	.word	0x20000050

00009030 <_ZN14Gamebuino_Meta8Graphics10indexTo565EPtPhPNS_5ColorEtb>:
GFXfont* Graphics::gfxFont = 0;
uint8_t* Graphics::font = 0;
uint8_t Graphics::fontWidth = 0;
uint8_t Graphics::fontHeight = 0;

void Graphics::indexTo565(uint16_t *dest, uint8_t *src, Color *index, uint16_t length, bool skipFirst) {
    9030:	b570      	push	{r4, r5, r6, lr}
    9032:	ac04      	add	r4, sp, #16
    9034:	7825      	ldrb	r5, [r4, #0]
    9036:	005b      	lsls	r3, r3, #1
	// length is the number of destination pixels
	// +1 for cieling rather than flooring
	uint8_t b = *(src++);
    9038:	1c4c      	adds	r4, r1, #1
    903a:	7809      	ldrb	r1, [r1, #0]
    903c:	18c3      	adds	r3, r0, r3
	for (uint16_t i = 0; i < length; i++) {
    903e:	4298      	cmp	r0, r3
    9040:	d011      	beq.n	9066 <_ZN14Gamebuino_Meta8Graphics10indexTo565EPtPhPNS_5ColorEtb+0x36>
		if (skipFirst) {
    9042:	2d00      	cmp	r5, #0
    9044:	d007      	beq.n	9056 <_ZN14Gamebuino_Meta8Graphics10indexTo565EPtPhPNS_5ColorEtb+0x26>
			dest[i] = (uint16_t)index[b&0x0F];
    9046:	260f      	movs	r6, #15
    9048:	4031      	ands	r1, r6
    904a:	0049      	lsls	r1, r1, #1
    904c:	5a89      	ldrh	r1, [r1, r2]
    904e:	8001      	strh	r1, [r0, #0]
			b = *(src++);
    9050:	7821      	ldrb	r1, [r4, #0]
    9052:	3401      	adds	r4, #1
    9054:	e003      	b.n	905e <_ZN14Gamebuino_Meta8Graphics10indexTo565EPtPhPNS_5ColorEtb+0x2e>
		} else {
			dest[i] = (uint16_t)index[b >> 4];
    9056:	110e      	asrs	r6, r1, #4
    9058:	0076      	lsls	r6, r6, #1
    905a:	5ab6      	ldrh	r6, [r6, r2]
    905c:	8006      	strh	r6, [r0, #0]
		}
		skipFirst = !skipFirst;
    905e:	2601      	movs	r6, #1
    9060:	4075      	eors	r5, r6
    9062:	3002      	adds	r0, #2
    9064:	e7eb      	b.n	903e <_ZN14Gamebuino_Meta8Graphics10indexTo565EPtPhPNS_5ColorEtb+0xe>
	}
}
    9066:	bd70      	pop	{r4, r5, r6, pc}

00009068 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE>:

boolean Graphics::getBitmapPixel(const uint8_t* bitmap, uint8_t x, uint8_t y) {
	return pgm_read_byte(bitmap + 2 + y * ((pgm_read_byte(bitmap) + 7) / 8) + (x >> 3)) & (B10000000 >> (x % 8));
}

void Graphics::drawImage(int16_t x, int16_t y, Image& img) {
    9068:	b5f0      	push	{r4, r5, r6, r7, lr}
    906a:	b093      	sub	sp, #76	; 0x4c
    906c:	af02      	add	r7, sp, #8
    906e:	1c1e      	adds	r6, r3, #0
    9070:	6378      	str	r0, [r7, #52]	; 0x34
	img.nextFrame();
    9072:	1c18      	adds	r0, r3, #0

boolean Graphics::getBitmapPixel(const uint8_t* bitmap, uint8_t x, uint8_t y) {
	return pgm_read_byte(bitmap + 2 + y * ((pgm_read_byte(bitmap) + 7) / 8) + (x >> 3)) & (B10000000 >> (x % 8));
}

void Graphics::drawImage(int16_t x, int16_t y, Image& img) {
    9074:	62b9      	str	r1, [r7, #40]	; 0x28
    9076:	633a      	str	r2, [r7, #48]	; 0x30
	img.nextFrame();
    9078:	f001 fee2 	bl	ae40 <_ZN14Gamebuino_Meta5Image9nextFrameEv>
	int16_t w1 = img._width; //width of the source image
	int16_t h1 = img._height; //height of the source image
    907c:	8a74      	ldrh	r4, [r6, #18]
	if ((x > _width) || ((x + w1) < 0) || (y > _height) || ((y + h1) < 0)) return;
    907e:	6b7d      	ldr	r5, [r7, #52]	; 0x34
}

void Graphics::drawImage(int16_t x, int16_t y, Image& img) {
	img.nextFrame();
	int16_t w1 = img._width; //width of the source image
	int16_t h1 = img._height; //height of the source image
    9080:	61fc      	str	r4, [r7, #28]
	if ((x > _width) || ((x + w1) < 0) || (y > _height) || ((y + h1) < 0)) return;
    9082:	8a28      	ldrh	r0, [r5, #16]
    9084:	6abd      	ldr	r5, [r7, #40]	; 0x28
    9086:	b204      	sxth	r4, r0
	return pgm_read_byte(bitmap + 2 + y * ((pgm_read_byte(bitmap) + 7) / 8) + (x >> 3)) & (B10000000 >> (x % 8));
}

void Graphics::drawImage(int16_t x, int16_t y, Image& img) {
	img.nextFrame();
	int16_t w1 = img._width; //width of the source image
    9088:	8a31      	ldrh	r1, [r6, #16]
	int16_t h1 = img._height; //height of the source image
	if ((x > _width) || ((x + w1) < 0) || (y > _height) || ((y + h1) < 0)) return;
    908a:	42a5      	cmp	r5, r4
    908c:	dd00      	ble.n	9090 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x28>
    908e:	e165      	b.n	935c <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x2f4>
    9090:	b20a      	sxth	r2, r1
    9092:	4694      	mov	ip, r2
    9094:	18ad      	adds	r5, r5, r2
    9096:	63fd      	str	r5, [r7, #60]	; 0x3c
    9098:	d500      	bpl.n	909c <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x34>
    909a:	e15f      	b.n	935c <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x2f4>
    909c:	6b7d      	ldr	r5, [r7, #52]	; 0x34
    909e:	8a6d      	ldrh	r5, [r5, #18]
    90a0:	61bd      	str	r5, [r7, #24]
    90a2:	b22a      	sxth	r2, r5
    90a4:	6b3d      	ldr	r5, [r7, #48]	; 0x30
    90a6:	4295      	cmp	r5, r2
    90a8:	dd00      	ble.n	90ac <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x44>
    90aa:	e157      	b.n	935c <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x2f4>
    90ac:	69fb      	ldr	r3, [r7, #28]
    90ae:	b21b      	sxth	r3, r3
    90b0:	18ed      	adds	r5, r5, r3
    90b2:	63bd      	str	r5, [r7, #56]	; 0x38
    90b4:	d500      	bpl.n	90b8 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x50>
    90b6:	e151      	b.n	935c <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x2f4>
	//horizontal cropping
	int16_t i2offset = 0;
	int16_t w2cropped = w1;
	if (x < 0) {
    90b8:	6abd      	ldr	r5, [r7, #40]	; 0x28
    90ba:	2d00      	cmp	r5, #0
    90bc:	da0d      	bge.n	90da <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x72>
		i2offset = -x;
    90be:	b2ab      	uxth	r3, r5
    90c0:	425d      	negs	r5, r3
		w2cropped = w1 + x;
    90c2:	1859      	adds	r1, r3, r1
	if ((x > _width) || ((x + w1) < 0) || (y > _height) || ((y + h1) < 0)) return;
	//horizontal cropping
	int16_t i2offset = 0;
	int16_t w2cropped = w1;
	if (x < 0) {
		i2offset = -x;
    90c4:	b2ad      	uxth	r5, r5
		w2cropped = w1 + x;
    90c6:	b289      	uxth	r1, r1
	if ((x > _width) || ((x + w1) < 0) || (y > _height) || ((y + h1) < 0)) return;
	//horizontal cropping
	int16_t i2offset = 0;
	int16_t w2cropped = w1;
	if (x < 0) {
		i2offset = -x;
    90c8:	63fd      	str	r5, [r7, #60]	; 0x3c
    90ca:	1c0d      	adds	r5, r1, #0
    90cc:	b209      	sxth	r1, r1
    90ce:	42a1      	cmp	r1, r4
    90d0:	dd00      	ble.n	90d4 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x6c>
    90d2:	1c05      	adds	r5, r0, #0
    90d4:	b2ad      	uxth	r5, r5
    90d6:	627d      	str	r5, [r7, #36]	; 0x24
    90d8:	e00c      	b.n	90f4 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x8c>
		w2cropped = w1 + x;
		if (w2cropped > _width) {
			w2cropped = _width;
		}
	} else if ((x + w1) > _width) {
    90da:	6bfd      	ldr	r5, [r7, #60]	; 0x3c
    90dc:	42a5      	cmp	r5, r4
    90de:	dd06      	ble.n	90ee <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x86>
		w2cropped = _width - x;
    90e0:	6abc      	ldr	r4, [r7, #40]	; 0x28
	img.nextFrame();
	int16_t w1 = img._width; //width of the source image
	int16_t h1 = img._height; //height of the source image
	if ((x > _width) || ((x + w1) < 0) || (y > _height) || ((y + h1) < 0)) return;
	//horizontal cropping
	int16_t i2offset = 0;
    90e2:	2500      	movs	r5, #0
		w2cropped = w1 + x;
		if (w2cropped > _width) {
			w2cropped = _width;
		}
	} else if ((x + w1) > _width) {
		w2cropped = _width - x;
    90e4:	1b00      	subs	r0, r0, r4
    90e6:	b280      	uxth	r0, r0
    90e8:	6278      	str	r0, [r7, #36]	; 0x24
	img.nextFrame();
	int16_t w1 = img._width; //width of the source image
	int16_t h1 = img._height; //height of the source image
	if ((x > _width) || ((x + w1) < 0) || (y > _height) || ((y + h1) < 0)) return;
	//horizontal cropping
	int16_t i2offset = 0;
    90ea:	63fd      	str	r5, [r7, #60]	; 0x3c
    90ec:	e002      	b.n	90f4 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x8c>
    90ee:	2400      	movs	r4, #0
	int16_t w2cropped = w1;
    90f0:	6279      	str	r1, [r7, #36]	; 0x24
	img.nextFrame();
	int16_t w1 = img._width; //width of the source image
	int16_t h1 = img._height; //height of the source image
	if ((x > _width) || ((x + w1) < 0) || (y > _height) || ((y + h1) < 0)) return;
	//horizontal cropping
	int16_t i2offset = 0;
    90f2:	63fc      	str	r4, [r7, #60]	; 0x3c
	}

	//vertical cropping
	int16_t j2offset = 0;
	int16_t h2cropped = h1;
	if (y < 0) {
    90f4:	6b3d      	ldr	r5, [r7, #48]	; 0x30
    90f6:	2d00      	cmp	r5, #0
    90f8:	da0f      	bge.n	911a <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0xb2>
		j2offset = -y;
		h2cropped = h1 + y;
    90fa:	69fc      	ldr	r4, [r7, #28]

	//vertical cropping
	int16_t j2offset = 0;
	int16_t h2cropped = h1;
	if (y < 0) {
		j2offset = -y;
    90fc:	b2a8      	uxth	r0, r5
    90fe:	4241      	negs	r1, r0
		h2cropped = h1 + y;
    9100:	1900      	adds	r0, r0, r4

	//vertical cropping
	int16_t j2offset = 0;
	int16_t h2cropped = h1;
	if (y < 0) {
		j2offset = -y;
    9102:	b289      	uxth	r1, r1
		h2cropped = h1 + y;
    9104:	b280      	uxth	r0, r0

	//vertical cropping
	int16_t j2offset = 0;
	int16_t h2cropped = h1;
	if (y < 0) {
		j2offset = -y;
    9106:	6239      	str	r1, [r7, #32]
    9108:	1c01      	adds	r1, r0, #0
    910a:	b200      	sxth	r0, r0
    910c:	4290      	cmp	r0, r2
    910e:	dd01      	ble.n	9114 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0xac>
    9110:	69bd      	ldr	r5, [r7, #24]
    9112:	1c29      	adds	r1, r5, #0
    9114:	b289      	uxth	r1, r1
    9116:	61f9      	str	r1, [r7, #28]
    9118:	e009      	b.n	912e <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0xc6>
		h2cropped = h1 + y;
		if (h2cropped > _height) {
			h2cropped = _height;
		}
	} else if ((y + h1) > _height) {
    911a:	6bbd      	ldr	r5, [r7, #56]	; 0x38
	} else if ((x + w1) > _width) {
		w2cropped = _width - x;
	}

	//vertical cropping
	int16_t j2offset = 0;
    911c:	2400      	movs	r4, #0
    911e:	623c      	str	r4, [r7, #32]
		j2offset = -y;
		h2cropped = h1 + y;
		if (h2cropped > _height) {
			h2cropped = _height;
		}
	} else if ((y + h1) > _height) {
    9120:	4295      	cmp	r5, r2
    9122:	dd04      	ble.n	912e <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0xc6>
		h2cropped = _height - y;
    9124:	69b8      	ldr	r0, [r7, #24]
    9126:	6b3c      	ldr	r4, [r7, #48]	; 0x30
    9128:	1b03      	subs	r3, r0, r4
    912a:	b29b      	uxth	r3, r3
    912c:	61fb      	str	r3, [r7, #28]
	}

	//draw INDEX => RGB
	if ((img.colorMode == ColorMode::index) && (colorMode == ColorMode::rgb565)) {
    912e:	7ab3      	ldrb	r3, [r6, #10]
    9130:	2b01      	cmp	r3, #1
    9132:	d163      	bne.n	91fc <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x194>
    9134:	6b7d      	ldr	r5, [r7, #52]	; 0x34
    9136:	7aaa      	ldrb	r2, [r5, #10]
    9138:	2a00      	cmp	r2, #0
    913a:	d000      	beq.n	913e <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0xd6>
    913c:	e090      	b.n	9260 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x1f8>
		uint16_t transparent_backup = img.transparentColor;
    913e:	8934      	ldrh	r4, [r6, #8]
		if (img.useTransparentIndex) {
    9140:	7a72      	ldrb	r2, [r6, #9]
		h2cropped = _height - y;
	}

	//draw INDEX => RGB
	if ((img.colorMode == ColorMode::index) && (colorMode == ColorMode::rgb565)) {
		uint16_t transparent_backup = img.transparentColor;
    9142:	613c      	str	r4, [r7, #16]
		if (img.useTransparentIndex) {
    9144:	2a00      	cmp	r2, #0
    9146:	d006      	beq.n	9156 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0xee>
			img.transparentColor = (uint16_t)colorIndex[img.transparentColorIndex];
    9148:	4b86      	ldr	r3, [pc, #536]	; (9364 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x2fc>)
    914a:	7a32      	ldrb	r2, [r6, #8]
    914c:	681b      	ldr	r3, [r3, #0]
    914e:	0052      	lsls	r2, r2, #1
    9150:	5ad3      	ldrh	r3, [r2, r3]
    9152:	8133      	strh	r3, [r6, #8]
    9154:	e000      	b.n	9158 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0xf0>
		} else {
			img.transparentColor = 1;
    9156:	8133      	strh	r3, [r6, #8]
    9158:	6a7d      	ldr	r5, [r7, #36]	; 0x24
    915a:	6a3c      	ldr	r4, [r7, #32]
    915c:	b22b      	sxth	r3, r5
		}
		for (int j2 = 0; j2 < h2cropped; j2++) {
			uint16_t destLineArray[w2cropped];
    915e:	005b      	lsls	r3, r3, #1
    9160:	60fb      	str	r3, [r7, #12]
			uint16_t *destLine = destLineArray;
			uint8_t *srcLine;
			
			// w1+1 for ceiling rather than flooring
			srcLine = (uint8_t*)img._buffer + ((w1 + 1) / 2) * (j2 + j2offset) + (i2offset/2);
    9162:	4663      	mov	r3, ip
    9164:	3301      	adds	r3, #1
    9166:	0fda      	lsrs	r2, r3, #31
    9168:	18d3      	adds	r3, r2, r3
    916a:	6bfd      	ldr	r5, [r7, #60]	; 0x3c
    916c:	105b      	asrs	r3, r3, #1
    916e:	b222      	sxth	r2, r4
    9170:	435a      	muls	r2, r3
    9172:	61bb      	str	r3, [r7, #24]
    9174:	b22b      	sxth	r3, r5
    9176:	0fd9      	lsrs	r1, r3, #31
    9178:	18cb      	adds	r3, r1, r3
    917a:	105b      	asrs	r3, r3, #1
    917c:	18d3      	adds	r3, r2, r3
    917e:	63bb      	str	r3, [r7, #56]	; 0x38
    9180:	2400      	movs	r4, #0
		if (img.useTransparentIndex) {
			img.transparentColor = (uint16_t)colorIndex[img.transparentColorIndex];
		} else {
			img.transparentColor = 1;
		}
		for (int j2 = 0; j2 < h2cropped; j2++) {
    9182:	69fd      	ldr	r5, [r7, #28]
    9184:	b22b      	sxth	r3, r5
    9186:	429c      	cmp	r4, r3
    9188:	da35      	bge.n	91f6 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x18e>
			uint16_t destLineArray[w2cropped];
    918a:	68fb      	ldr	r3, [r7, #12]
    918c:	466d      	mov	r5, sp
    918e:	3308      	adds	r3, #8
    9190:	08db      	lsrs	r3, r3, #3
    9192:	00db      	lsls	r3, r3, #3
    9194:	1ae8      	subs	r0, r5, r3
    9196:	4685      	mov	sp, r0
			// w1+1 for ceiling rather than flooring
			srcLine = (uint8_t*)img._buffer + ((w1 + 1) / 2) * (j2 + j2offset) + (i2offset/2);
			
//			srcLine = (uint8_t*)img._buffer + (((j2 + j2offset) * w1) + i2offset) / 2;

			indexTo565(destLine, srcLine, colorIndex, w2cropped, i2offset%2);
    9198:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
    919a:	6a78      	ldr	r0, [r7, #36]	; 0x24
			uint16_t destLineArray[w2cropped];
			uint16_t *destLine = destLineArray;
			uint8_t *srcLine;
			
			// w1+1 for ceiling rather than flooring
			srcLine = (uint8_t*)img._buffer + ((w1 + 1) / 2) * (j2 + j2offset) + (i2offset/2);
    919c:	6972      	ldr	r2, [r6, #20]
    919e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    91a0:	60bd      	str	r5, [r7, #8]
			img.transparentColor = (uint16_t)colorIndex[img.transparentColorIndex];
		} else {
			img.transparentColor = 1;
		}
		for (int j2 = 0; j2 < h2cropped; j2++) {
			uint16_t destLineArray[w2cropped];
    91a2:	ad02      	add	r5, sp, #8
    91a4:	617d      	str	r5, [r7, #20]
			// w1+1 for ceiling rather than flooring
			srcLine = (uint8_t*)img._buffer + ((w1 + 1) / 2) * (j2 + j2offset) + (i2offset/2);
			
//			srcLine = (uint8_t*)img._buffer + (((j2 + j2offset) * w1) + i2offset) / 2;

			indexTo565(destLine, srcLine, colorIndex, w2cropped, i2offset%2);
    91a6:	b285      	uxth	r5, r0
    91a8:	b288      	uxth	r0, r1
			uint16_t destLineArray[w2cropped];
			uint16_t *destLine = destLineArray;
			uint8_t *srcLine;
			
			// w1+1 for ceiling rather than flooring
			srcLine = (uint8_t*)img._buffer + ((w1 + 1) / 2) * (j2 + j2offset) + (i2offset/2);
    91aa:	18d1      	adds	r1, r2, r3
			
//			srcLine = (uint8_t*)img._buffer + (((j2 + j2offset) * w1) + i2offset) / 2;

			indexTo565(destLine, srcLine, colorIndex, w2cropped, i2offset%2);
    91ac:	4b6d      	ldr	r3, [pc, #436]	; (9364 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x2fc>)
    91ae:	62f8      	str	r0, [r7, #44]	; 0x2c
    91b0:	681a      	ldr	r2, [r3, #0]
    91b2:	2301      	movs	r3, #1
    91b4:	4003      	ands	r3, r0
    91b6:	9300      	str	r3, [sp, #0]
    91b8:	6978      	ldr	r0, [r7, #20]
    91ba:	1c2b      	adds	r3, r5, #0
    91bc:	f7ff ff38 	bl	9030 <_ZN14Gamebuino_Meta8Graphics10indexTo565EPtPhPNS_5ColorEtb>
				x + i2offset,
				y + j2offset + j2,
				destLine,
				w2cropped,
				img
			);
    91c0:	6b78      	ldr	r0, [r7, #52]	; 0x34
    91c2:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    91c4:	6803      	ldr	r3, [r0, #0]
    91c6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    91c8:	180a      	adds	r2, r1, r0
    91ca:	b211      	sxth	r1, r2
    91cc:	6a3a      	ldr	r2, [r7, #32]
    91ce:	4694      	mov	ip, r2
    91d0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    91d2:	9500      	str	r5, [sp, #0]
    91d4:	4494      	add	ip, r2
    91d6:	4660      	mov	r0, ip
    91d8:	9601      	str	r6, [sp, #4]
    91da:	1902      	adds	r2, r0, r4
    91dc:	695d      	ldr	r5, [r3, #20]
    91de:	6b78      	ldr	r0, [r7, #52]	; 0x34
    91e0:	b212      	sxth	r2, r2
    91e2:	697b      	ldr	r3, [r7, #20]
    91e4:	47a8      	blx	r5
    91e6:	68bd      	ldr	r5, [r7, #8]
    91e8:	69b8      	ldr	r0, [r7, #24]
    91ea:	46ad      	mov	sp, r5
    91ec:	6bbd      	ldr	r5, [r7, #56]	; 0x38
		if (img.useTransparentIndex) {
			img.transparentColor = (uint16_t)colorIndex[img.transparentColorIndex];
		} else {
			img.transparentColor = 1;
		}
		for (int j2 = 0; j2 < h2cropped; j2++) {
    91ee:	3401      	adds	r4, #1
    91f0:	182d      	adds	r5, r5, r0
    91f2:	63bd      	str	r5, [r7, #56]	; 0x38
    91f4:	e7c5      	b.n	9182 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x11a>
				destLine,
				w2cropped,
				img
			);
		}
		img.transparentColor = transparent_backup;
    91f6:	693c      	ldr	r4, [r7, #16]
    91f8:	8134      	strh	r4, [r6, #8]
		return;
    91fa:	e0af      	b.n	935c <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x2f4>
	}

	//draw RGB => RGB
	if ((img.colorMode == ColorMode::rgb565) && (colorMode == ColorMode::rgb565)) {
    91fc:	2b00      	cmp	r3, #0
    91fe:	d000      	beq.n	9202 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x19a>
    9200:	e0ac      	b.n	935c <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x2f4>
    9202:	6b7d      	ldr	r5, [r7, #52]	; 0x34
    9204:	7aac      	ldrb	r4, [r5, #10]
    9206:	2c00      	cmp	r4, #0
    9208:	d000      	beq.n	920c <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x1a4>
    920a:	e0a7      	b.n	935c <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x2f4>
    920c:	4665      	mov	r5, ip
    920e:	6a38      	ldr	r0, [r7, #32]
    9210:	006d      	lsls	r5, r5, #1
    9212:	63bd      	str	r5, [r7, #56]	; 0x38
    9214:	4661      	mov	r1, ip
    9216:	b205      	sxth	r5, r0
    9218:	434d      	muls	r5, r1
    921a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    921c:	b213      	sxth	r3, r2
    921e:	18ed      	adds	r5, r5, r3
    9220:	006d      	lsls	r5, r5, #1
		for (int j2 = 0; j2 < h2cropped; j2++) { //j2 : offseted vertical coordinate in the destination image
    9222:	69f8      	ldr	r0, [r7, #28]
    9224:	b203      	sxth	r3, r0
    9226:	429c      	cmp	r4, r3
    9228:	db00      	blt.n	922c <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x1c4>
    922a:	e097      	b.n	935c <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x2f4>
				x + i2offset,
				y + j2offset + j2,
				img._buffer + ((j2 + j2offset) * w1) + i2offset,
				w2cropped,
				img
			);
    922c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    922e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    9230:	6818      	ldr	r0, [r3, #0]
    9232:	6abb      	ldr	r3, [r7, #40]	; 0x28
    9234:	18d1      	adds	r1, r2, r3
    9236:	b20a      	sxth	r2, r1
    9238:	62fa      	str	r2, [r7, #44]	; 0x2c
    923a:	6a3b      	ldr	r3, [r7, #32]
    923c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    923e:	1899      	adds	r1, r3, r2
    9240:	190a      	adds	r2, r1, r4
    9242:	6971      	ldr	r1, [r6, #20]
    9244:	b212      	sxth	r2, r2
    9246:	194b      	adds	r3, r1, r5
    9248:	6a79      	ldr	r1, [r7, #36]	; 0x24
    924a:	9601      	str	r6, [sp, #4]
    924c:	9100      	str	r1, [sp, #0]
    924e:	6941      	ldr	r1, [r0, #20]
    9250:	6b78      	ldr	r0, [r7, #52]	; 0x34
    9252:	468c      	mov	ip, r1
    9254:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    9256:	47e0      	blx	ip
    9258:	6bba      	ldr	r2, [r7, #56]	; 0x38
		return;
	}

	//draw RGB => RGB
	if ((img.colorMode == ColorMode::rgb565) && (colorMode == ColorMode::rgb565)) {
		for (int j2 = 0; j2 < h2cropped; j2++) { //j2 : offseted vertical coordinate in the destination image
    925a:	3401      	adds	r4, #1
    925c:	18ad      	adds	r5, r5, r2
    925e:	e7e0      	b.n	9222 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x1ba>
		}
		return;
	}

	//draw INDEX => INDEX
	if ((img.colorMode == ColorMode::index) && (colorMode == ColorMode::index)) {
    9260:	2a01      	cmp	r2, #1
    9262:	d17b      	bne.n	935c <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x2f4>
		for (int j2 = 0; j2 < h2cropped; j2++) {
			
			if (x % 2) {
				uint8_t *src = (uint8_t*)img._buffer + ((j2 + j2offset) * ((w1 + 1)/2)) + ((i2offset + 1) / 2);
    9264:	4663      	mov	r3, ip
    9266:	3301      	adds	r3, #1
    9268:	0fda      	lsrs	r2, r3, #31
    926a:	18d3      	adds	r3, r2, r3
    926c:	6a7c      	ldr	r4, [r7, #36]	; 0x24
    926e:	105b      	asrs	r3, r3, #1
    9270:	617b      	str	r3, [r7, #20]
    9272:	b223      	sxth	r3, r4
				uint8_t destLineArray[((w2cropped+1) / 2) + 1];
    9274:	3301      	adds	r3, #1
    9276:	0fda      	lsrs	r2, r3, #31
    9278:	6a3d      	ldr	r5, [r7, #32]
    927a:	18d3      	adds	r3, r2, r3
    927c:	105b      	asrs	r3, r3, #1
    927e:	b22a      	sxth	r2, r5
    9280:	697c      	ldr	r4, [r7, #20]
					(uint16_t*)destLine,
					w2cropped,
					img
				);
			} else {
				uint8_t *destLine = (uint8_t*)img._buffer + ((j2 + j2offset) * ((w1 + 1)/2)) + (i2offset / 2);
    9282:	6bfd      	ldr	r5, [r7, #60]	; 0x3c
	if ((img.colorMode == ColorMode::index) && (colorMode == ColorMode::index)) {
		for (int j2 = 0; j2 < h2cropped; j2++) {
			
			if (x % 2) {
				uint8_t *src = (uint8_t*)img._buffer + ((j2 + j2offset) * ((w1 + 1)/2)) + ((i2offset + 1) / 2);
				uint8_t destLineArray[((w2cropped+1) / 2) + 1];
    9284:	613b      	str	r3, [r7, #16]
    9286:	3301      	adds	r3, #1
    9288:	4362      	muls	r2, r4
    928a:	60bb      	str	r3, [r7, #8]
					(uint16_t*)destLine,
					w2cropped,
					img
				);
			} else {
				uint8_t *destLine = (uint8_t*)img._buffer + ((j2 + j2offset) * ((w1 + 1)/2)) + (i2offset / 2);
    928c:	b22b      	sxth	r3, r5
    928e:	0fd9      	lsrs	r1, r3, #31
    9290:	18c9      	adds	r1, r1, r3
    9292:	1049      	asrs	r1, r1, #1
    9294:	1851      	adds	r1, r2, r1
	//draw INDEX => INDEX
	if ((img.colorMode == ColorMode::index) && (colorMode == ColorMode::index)) {
		for (int j2 = 0; j2 < h2cropped; j2++) {
			
			if (x % 2) {
				uint8_t *src = (uint8_t*)img._buffer + ((j2 + j2offset) * ((w1 + 1)/2)) + ((i2offset + 1) / 2);
    9296:	3301      	adds	r3, #1
    9298:	62f9      	str	r1, [r7, #44]	; 0x2c
    929a:	0fd9      	lsrs	r1, r3, #31
    929c:	18cb      	adds	r3, r1, r3
    929e:	105b      	asrs	r3, r3, #1
    92a0:	18d3      	adds	r3, r2, r3
					(uint16_t*)destLine,
					w2cropped,
					img
				);
			} else {
				uint8_t *destLine = (uint8_t*)img._buffer + ((j2 + j2offset) * ((w1 + 1)/2)) + (i2offset / 2);
    92a2:	2400      	movs	r4, #0
    92a4:	61bb      	str	r3, [r7, #24]
    92a6:	63bc      	str	r4, [r7, #56]	; 0x38
		return;
	}

	//draw INDEX => INDEX
	if ((img.colorMode == ColorMode::index) && (colorMode == ColorMode::index)) {
		for (int j2 = 0; j2 < h2cropped; j2++) {
    92a8:	69fd      	ldr	r5, [r7, #28]
    92aa:	6bbc      	ldr	r4, [r7, #56]	; 0x38
    92ac:	b22b      	sxth	r3, r5
    92ae:	429c      	cmp	r4, r3
    92b0:	da54      	bge.n	935c <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x2f4>
			
			if (x % 2) {
    92b2:	6abd      	ldr	r5, [r7, #40]	; 0x28
    92b4:	6974      	ldr	r4, [r6, #20]
    92b6:	b2a9      	uxth	r1, r5
    92b8:	07c8      	lsls	r0, r1, #31
    92ba:	d531      	bpl.n	9320 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x2b8>
				uint8_t *src = (uint8_t*)img._buffer + ((j2 + j2offset) * ((w1 + 1)/2)) + ((i2offset + 1) / 2);
				uint8_t destLineArray[((w2cropped+1) / 2) + 1];
    92bc:	68bb      	ldr	r3, [r7, #8]
    92be:	466d      	mov	r5, sp
    92c0:	60fd      	str	r5, [r7, #12]
    92c2:	3307      	adds	r3, #7
	//draw INDEX => INDEX
	if ((img.colorMode == ColorMode::index) && (colorMode == ColorMode::index)) {
		for (int j2 = 0; j2 < h2cropped; j2++) {
			
			if (x % 2) {
				uint8_t *src = (uint8_t*)img._buffer + ((j2 + j2offset) * ((w1 + 1)/2)) + ((i2offset + 1) / 2);
    92c4:	69bd      	ldr	r5, [r7, #24]
				uint8_t destLineArray[((w2cropped+1) / 2) + 1];
    92c6:	08db      	lsrs	r3, r3, #3
    92c8:	466a      	mov	r2, sp
	//draw INDEX => INDEX
	if ((img.colorMode == ColorMode::index) && (colorMode == ColorMode::index)) {
		for (int j2 = 0; j2 < h2cropped; j2++) {
			
			if (x % 2) {
				uint8_t *src = (uint8_t*)img._buffer + ((j2 + j2offset) * ((w1 + 1)/2)) + ((i2offset + 1) / 2);
    92ca:	1964      	adds	r4, r4, r5
				uint8_t destLineArray[((w2cropped+1) / 2) + 1];
    92cc:	00db      	lsls	r3, r3, #3
    92ce:	1ad0      	subs	r0, r2, r3
				uint8_t* destLine = destLineArray;
				uint8_t b;
				uint8_t b_2 = src[-1];
    92d0:	1c22      	adds	r2, r4, #0
	if ((img.colorMode == ColorMode::index) && (colorMode == ColorMode::index)) {
		for (int j2 = 0; j2 < h2cropped; j2++) {
			
			if (x % 2) {
				uint8_t *src = (uint8_t*)img._buffer + ((j2 + j2offset) * ((w1 + 1)/2)) + ((i2offset + 1) / 2);
				uint8_t destLineArray[((w2cropped+1) / 2) + 1];
    92d2:	4685      	mov	sp, r0
				uint8_t* destLine = destLineArray;
				uint8_t b;
				uint8_t b_2 = src[-1];
    92d4:	3a01      	subs	r2, #1
    92d6:	7810      	ldrb	r0, [r2, #0]
	//draw INDEX => INDEX
	if ((img.colorMode == ColorMode::index) && (colorMode == ColorMode::index)) {
		for (int j2 = 0; j2 < h2cropped; j2++) {
			
			if (x % 2) {
				uint8_t *src = (uint8_t*)img._buffer + ((j2 + j2offset) * ((w1 + 1)/2)) + ((i2offset + 1) / 2);
    92d8:	607c      	str	r4, [r7, #4]
				uint8_t destLineArray[((w2cropped+1) / 2) + 1];
    92da:	ab02      	add	r3, sp, #8
				uint8_t* destLine = destLineArray;
				uint8_t b;
				uint8_t b_2 = src[-1];
				for (uint8_t i = 0; i < ((w2cropped + 1) / 2) + 1; i++) {
    92dc:	2200      	movs	r2, #0
    92de:	693d      	ldr	r5, [r7, #16]
    92e0:	4295      	cmp	r5, r2
    92e2:	db09      	blt.n	92f8 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x290>
					b = src[i];
    92e4:	687c      	ldr	r4, [r7, #4]
					destLine[i] = (b >> 4) | (b_2 << 4);
    92e6:	0100      	lsls	r0, r0, #4
				uint8_t destLineArray[((w2cropped+1) / 2) + 1];
				uint8_t* destLine = destLineArray;
				uint8_t b;
				uint8_t b_2 = src[-1];
				for (uint8_t i = 0; i < ((w2cropped + 1) / 2) + 1; i++) {
					b = src[i];
    92e8:	5ca5      	ldrb	r5, [r4, r2]
					destLine[i] = (b >> 4) | (b_2 << 4);
    92ea:	112c      	asrs	r4, r5, #4
    92ec:	4320      	orrs	r0, r4
    92ee:	5498      	strb	r0, [r3, r2]
				uint8_t *src = (uint8_t*)img._buffer + ((j2 + j2offset) * ((w1 + 1)/2)) + ((i2offset + 1) / 2);
				uint8_t destLineArray[((w2cropped+1) / 2) + 1];
				uint8_t* destLine = destLineArray;
				uint8_t b;
				uint8_t b_2 = src[-1];
				for (uint8_t i = 0; i < ((w2cropped + 1) / 2) + 1; i++) {
    92f0:	3201      	adds	r2, #1
    92f2:	b2d2      	uxtb	r2, r2
					b = src[i];
					destLine[i] = (b >> 4) | (b_2 << 4);
					b_2 = b;
    92f4:	1c28      	adds	r0, r5, #0
    92f6:	e7f2      	b.n	92de <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x276>
					x + i2offset,
					y + j2offset + j2,
					(uint16_t*)destLine,
					w2cropped,
					img
				);
    92f8:	6b7c      	ldr	r4, [r7, #52]	; 0x34
    92fa:	6bfd      	ldr	r5, [r7, #60]	; 0x3c
    92fc:	6820      	ldr	r0, [r4, #0]
    92fe:	1949      	adds	r1, r1, r5
    9300:	6a3c      	ldr	r4, [r7, #32]
    9302:	6b3d      	ldr	r5, [r7, #48]	; 0x30
    9304:	b209      	sxth	r1, r1
    9306:	1962      	adds	r2, r4, r5
    9308:	6bbc      	ldr	r4, [r7, #56]	; 0x38
    930a:	6a7d      	ldr	r5, [r7, #36]	; 0x24
    930c:	1912      	adds	r2, r2, r4
    930e:	9500      	str	r5, [sp, #0]
    9310:	9601      	str	r6, [sp, #4]
    9312:	6944      	ldr	r4, [r0, #20]
    9314:	b212      	sxth	r2, r2
    9316:	6b78      	ldr	r0, [r7, #52]	; 0x34
    9318:	47a0      	blx	r4
    931a:	68fc      	ldr	r4, [r7, #12]
    931c:	46a5      	mov	sp, r4
    931e:	e012      	b.n	9346 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x2de>
					x + i2offset,
					y + j2offset + j2,
					(uint16_t*)destLine,
					w2cropped,
					img
				);
    9320:	6b7d      	ldr	r5, [r7, #52]	; 0x34
    9322:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    9324:	6828      	ldr	r0, [r5, #0]
    9326:	6bfd      	ldr	r5, [r7, #60]	; 0x3c
    9328:	1949      	adds	r1, r1, r5
    932a:	6a3d      	ldr	r5, [r7, #32]
    932c:	b209      	sxth	r1, r1
    932e:	18ea      	adds	r2, r5, r3
    9330:	6bbd      	ldr	r5, [r7, #56]	; 0x38
    9332:	1952      	adds	r2, r2, r5
					(uint16_t*)destLine,
					w2cropped,
					img
				);
			} else {
				uint8_t *destLine = (uint8_t*)img._buffer + ((j2 + j2offset) * ((w1 + 1)/2)) + (i2offset / 2);
    9334:	6afd      	ldr	r5, [r7, #44]	; 0x2c
					x + i2offset,
					y + j2offset + j2,
					(uint16_t*)destLine,
					w2cropped,
					img
				);
    9336:	b212      	sxth	r2, r2
					(uint16_t*)destLine,
					w2cropped,
					img
				);
			} else {
				uint8_t *destLine = (uint8_t*)img._buffer + ((j2 + j2offset) * ((w1 + 1)/2)) + (i2offset / 2);
    9338:	1963      	adds	r3, r4, r5
					x + i2offset,
					y + j2offset + j2,
					(uint16_t*)destLine,
					w2cropped,
					img
				);
    933a:	6a7c      	ldr	r4, [r7, #36]	; 0x24
    933c:	9601      	str	r6, [sp, #4]
    933e:	9400      	str	r4, [sp, #0]
    9340:	6945      	ldr	r5, [r0, #20]
    9342:	6b78      	ldr	r0, [r7, #52]	; 0x34
    9344:	47a8      	blx	r5
		return;
	}

	//draw INDEX => INDEX
	if ((img.colorMode == ColorMode::index) && (colorMode == ColorMode::index)) {
		for (int j2 = 0; j2 < h2cropped; j2++) {
    9346:	6bbd      	ldr	r5, [r7, #56]	; 0x38
    9348:	6afc      	ldr	r4, [r7, #44]	; 0x2c
    934a:	3501      	adds	r5, #1
    934c:	63bd      	str	r5, [r7, #56]	; 0x38
    934e:	697d      	ldr	r5, [r7, #20]
    9350:	1964      	adds	r4, r4, r5
    9352:	62fc      	str	r4, [r7, #44]	; 0x2c
    9354:	69bc      	ldr	r4, [r7, #24]
    9356:	1964      	adds	r4, r4, r5
    9358:	61bc      	str	r4, [r7, #24]
    935a:	e7a5      	b.n	92a8 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE+0x240>
		for (int j = 0; j < img._height; j++) {
			setColor(img._buffer[i + img._width*j]);
			drawPixel(x + i, y + j);
		}
	}*/
}
    935c:	46bd      	mov	sp, r7
    935e:	b011      	add	sp, #68	; 0x44
    9360:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9362:	46c0      	nop			; (mov r8, r8)
    9364:	20000050 	.word	0x20000050

00009368 <_ZN14Gamebuino_Meta8Graphics13rgb565ToIndexENS_5ColorE>:
		}
		skipFirst = !skipFirst;
	}
}

ColorIndex Graphics::rgb565ToIndex(Color rgb) {
    9368:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (uint8_t i = 0; i < 16; i++) {
		if (rgb == colorIndex[i]) {
    936a:	4b24      	ldr	r3, [pc, #144]	; (93fc <_ZN14Gamebuino_Meta8Graphics13rgb565ToIndexENS_5ColorE+0x94>)
		}
		skipFirst = !skipFirst;
	}
}

ColorIndex Graphics::rgb565ToIndex(Color rgb) {
    936c:	b085      	sub	sp, #20
	for (uint8_t i = 0; i < 16; i++) {
		if (rgb == colorIndex[i]) {
    936e:	681d      	ldr	r5, [r3, #0]
    9370:	2300      	movs	r3, #0
    9372:	0059      	lsls	r1, r3, #1
    9374:	5a69      	ldrh	r1, [r5, r1]
    9376:	b2da      	uxtb	r2, r3
    9378:	4281      	cmp	r1, r0
    937a:	d03b      	beq.n	93f4 <_ZN14Gamebuino_Meta8Graphics13rgb565ToIndexENS_5ColorE+0x8c>
    937c:	3301      	adds	r3, #1
		skipFirst = !skipFirst;
	}
}

ColorIndex Graphics::rgb565ToIndex(Color rgb) {
	for (uint8_t i = 0; i < 16; i++) {
    937e:	2b10      	cmp	r3, #16
    9380:	d1f7      	bne.n	9372 <_ZN14Gamebuino_Meta8Graphics13rgb565ToIndexENS_5ColorE+0xa>
			return (ColorIndex)i;
		}
	}
	// ok not part of the index, let's try to find the closest match!
	uint16_t max_diff = 0xFFFF;
	uint8_t b = (uint8_t)((uint16_t)rgb << 3);
    9382:	00c3      	lsls	r3, r0, #3
    9384:	b2db      	uxtb	r3, r3
	uint8_t g = (uint8_t)(((uint16_t)rgb >> 3) & 0xFC);
    9386:	10c2      	asrs	r2, r0, #3
			return (ColorIndex)i;
		}
	}
	// ok not part of the index, let's try to find the closest match!
	uint16_t max_diff = 0xFFFF;
	uint8_t b = (uint8_t)((uint16_t)rgb << 3);
    9388:	9301      	str	r3, [sp, #4]
	uint8_t g = (uint8_t)(((uint16_t)rgb >> 3) & 0xFC);
    938a:	23fc      	movs	r3, #252	; 0xfc
    938c:	401a      	ands	r2, r3
	uint8_t r = (uint8_t)(((uint16_t)rgb >> 8) & 0xF8);
    938e:	1200      	asrs	r0, r0, #8
    9390:	2307      	movs	r3, #7
    9392:	4398      	bics	r0, r3
		}
	}
	// ok not part of the index, let's try to find the closest match!
	uint16_t max_diff = 0xFFFF;
	uint8_t b = (uint8_t)((uint16_t)rgb << 3);
	uint8_t g = (uint8_t)(((uint16_t)rgb >> 3) & 0xFC);
    9394:	9202      	str	r2, [sp, #8]
	uint8_t r = (uint8_t)(((uint16_t)rgb >> 8) & 0xF8);
    9396:	2300      	movs	r3, #0
	
	uint8_t min_index = 0;
	uint16_t min_diff = 0xFFFF;
    9398:	4a19      	ldr	r2, [pc, #100]	; (9400 <_ZN14Gamebuino_Meta8Graphics13rgb565ToIndexENS_5ColorE+0x98>)
	}
	// ok not part of the index, let's try to find the closest match!
	uint16_t max_diff = 0xFFFF;
	uint8_t b = (uint8_t)((uint16_t)rgb << 3);
	uint8_t g = (uint8_t)(((uint16_t)rgb >> 3) & 0xFC);
	uint8_t r = (uint8_t)(((uint16_t)rgb >> 8) & 0xF8);
    939a:	9003      	str	r0, [sp, #12]
	
	uint8_t min_index = 0;
    939c:	1c1c      	adds	r4, r3, #0
    939e:	0059      	lsls	r1, r3, #1
	uint16_t min_diff = 0xFFFF;
	uint8_t i = 0;
	for (; i < 16; i++) {
		uint16_t rgb2 = (uint16_t)colorIndex[i];
    93a0:	5a69      	ldrh	r1, [r5, r1]
		uint8_t b2 = (uint8_t)(rgb2 << 3);
		uint8_t g2 = (uint8_t)((rgb2 >> 3) & 0xFC);
    93a2:	26fc      	movs	r6, #252	; 0xfc
    93a4:	10cf      	asrs	r7, r1, #3
		uint8_t r2 = (uint8_t)((rgb2 >> 8) & 0xF8);
		
		uint16_t diff = abs(b - b2) + abs(g - g2) + abs(r - r2);
    93a6:	403e      	ands	r6, r7
    93a8:	9f02      	ldr	r7, [sp, #8]
    93aa:	b2d8      	uxtb	r0, r3
    93ac:	1bbf      	subs	r7, r7, r6
    93ae:	17fe      	asrs	r6, r7, #31
    93b0:	19bf      	adds	r7, r7, r6
    93b2:	4077      	eors	r7, r6
    93b4:	9700      	str	r7, [sp, #0]
    93b6:	2607      	movs	r6, #7
	uint8_t i = 0;
	for (; i < 16; i++) {
		uint16_t rgb2 = (uint16_t)colorIndex[i];
		uint8_t b2 = (uint8_t)(rgb2 << 3);
		uint8_t g2 = (uint8_t)((rgb2 >> 3) & 0xFC);
		uint8_t r2 = (uint8_t)((rgb2 >> 8) & 0xF8);
    93b8:	120f      	asrs	r7, r1, #8
		
		uint16_t diff = abs(b - b2) + abs(g - g2) + abs(r - r2);
    93ba:	43b7      	bics	r7, r6
    93bc:	9e03      	ldr	r6, [sp, #12]
    93be:	1bf7      	subs	r7, r6, r7
    93c0:	17fe      	asrs	r6, r7, #31
    93c2:	19bf      	adds	r7, r7, r6
    93c4:	4077      	eors	r7, r6
    93c6:	9e00      	ldr	r6, [sp, #0]
    93c8:	19f6      	adds	r6, r6, r7
	uint8_t min_index = 0;
	uint16_t min_diff = 0xFFFF;
	uint8_t i = 0;
	for (; i < 16; i++) {
		uint16_t rgb2 = (uint16_t)colorIndex[i];
		uint8_t b2 = (uint8_t)(rgb2 << 3);
    93ca:	00cf      	lsls	r7, r1, #3
		uint8_t g2 = (uint8_t)((rgb2 >> 3) & 0xFC);
		uint8_t r2 = (uint8_t)((rgb2 >> 8) & 0xF8);
		
		uint16_t diff = abs(b - b2) + abs(g - g2) + abs(r - r2);
    93cc:	9901      	ldr	r1, [sp, #4]
    93ce:	b2ff      	uxtb	r7, r7
    93d0:	1bcf      	subs	r7, r1, r7
    93d2:	46b4      	mov	ip, r6
    93d4:	17fe      	asrs	r6, r7, #31
    93d6:	19bf      	adds	r7, r7, r6
    93d8:	4077      	eors	r7, r6
    93da:	4661      	mov	r1, ip
    93dc:	19ce      	adds	r6, r1, r7
    93de:	b2b6      	uxth	r6, r6
		if (diff < min_diff) {
    93e0:	4296      	cmp	r6, r2
    93e2:	d301      	bcc.n	93e8 <_ZN14Gamebuino_Meta8Graphics13rgb565ToIndexENS_5ColorE+0x80>
    93e4:	1c16      	adds	r6, r2, #0
    93e6:	1c20      	adds	r0, r4, #0
    93e8:	3301      	adds	r3, #1
	uint8_t r = (uint8_t)(((uint16_t)rgb >> 8) & 0xF8);
	
	uint8_t min_index = 0;
	uint16_t min_diff = 0xFFFF;
	uint8_t i = 0;
	for (; i < 16; i++) {
    93ea:	2b10      	cmp	r3, #16
    93ec:	d003      	beq.n	93f6 <_ZN14Gamebuino_Meta8Graphics13rgb565ToIndexENS_5ColorE+0x8e>
    93ee:	1c04      	adds	r4, r0, #0
    93f0:	1c32      	adds	r2, r6, #0
    93f2:	e7d4      	b.n	939e <_ZN14Gamebuino_Meta8Graphics13rgb565ToIndexENS_5ColorE+0x36>
    93f4:	1c10      	adds	r0, r2, #0
			min_diff = diff;
			min_index = i;
		}
	}
	return (ColorIndex)min_index;
} 
    93f6:	b005      	add	sp, #20
    93f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    93fa:	46c0      	nop			; (mov r8, r8)
    93fc:	20000050 	.word	0x20000050
    9400:	0000ffff 	.word	0x0000ffff

00009404 <_ZN14Gamebuino_Meta8Graphics16fillCircleHelperEssshs>:
	fillCircleHelper(x0, y0, r, 3, 0);
}

// Used to do circles and roundrects
void Graphics::fillCircleHelper(int16_t x0, int16_t y0, int16_t r,
 uint8_t cornername, int16_t delta) {
    9404:	b5f0      	push	{r4, r5, r6, r7, lr}
    9406:	b08d      	sub	sp, #52	; 0x34
    9408:	9301      	str	r3, [sp, #4]
    940a:	ab12      	add	r3, sp, #72	; 0x48
    940c:	781b      	ldrb	r3, [r3, #0]
    940e:	9209      	str	r2, [sp, #36]	; 0x24
    9410:	930a      	str	r3, [sp, #40]	; 0x28
    9412:	ab13      	add	r3, sp, #76	; 0x4c
    9414:	2700      	movs	r7, #0
    9416:	5fdd      	ldrsh	r5, [r3, r7]

	int16_t f     = 1 - r;
    9418:	2201      	movs	r2, #1
	fillCircleHelper(x0, y0, r, 3, 0);
}

// Used to do circles and roundrects
void Graphics::fillCircleHelper(int16_t x0, int16_t y0, int16_t r,
 uint8_t cornername, int16_t delta) {
    941a:	950b      	str	r5, [sp, #44]	; 0x2c

	int16_t f     = 1 - r;
    941c:	9d01      	ldr	r5, [sp, #4]
	int16_t ddF_x = 1;
	int16_t ddF_y = -2 * r;
	int16_t x     = 0;
	int16_t y     = r;

	while (x<y) {
    941e:	2700      	movs	r7, #0

// Used to do circles and roundrects
void Graphics::fillCircleHelper(int16_t x0, int16_t y0, int16_t r,
 uint8_t cornername, int16_t delta) {

	int16_t f     = 1 - r;
    9420:	b2ab      	uxth	r3, r5
    9422:	1ad2      	subs	r2, r2, r3
	int16_t ddF_x = 1;
	int16_t ddF_y = -2 * r;
    9424:	005b      	lsls	r3, r3, #1
    9426:	425b      	negs	r3, r3

// Used to do circles and roundrects
void Graphics::fillCircleHelper(int16_t x0, int16_t y0, int16_t r,
 uint8_t cornername, int16_t delta) {

	int16_t f     = 1 - r;
    9428:	b292      	uxth	r2, r2
	int16_t ddF_x = 1;
	int16_t ddF_y = -2 * r;
    942a:	b29b      	uxth	r3, r3
	fillCircleHelper(x0, y0, r, 3, 0);
}

// Used to do circles and roundrects
void Graphics::fillCircleHelper(int16_t x0, int16_t y0, int16_t r,
 uint8_t cornername, int16_t delta) {
    942c:	1c04      	adds	r4, r0, #0
    942e:	9108      	str	r1, [sp, #32]

	int16_t f     = 1 - r;
    9430:	9202      	str	r2, [sp, #8]
	int16_t ddF_x = 1;
	int16_t ddF_y = -2 * r;
    9432:	9307      	str	r3, [sp, #28]
	int16_t x     = 0;
	int16_t y     = r;

	while (x<y) {
    9434:	9705      	str	r7, [sp, #20]
    9436:	9f05      	ldr	r7, [sp, #20]
    9438:	9d01      	ldr	r5, [sp, #4]
    943a:	b23b      	sxth	r3, r7
    943c:	42ab      	cmp	r3, r5
    943e:	da78      	bge.n	9532 <_ZN14Gamebuino_Meta8Graphics16fillCircleHelperEssshs+0x12e>
		if (f >= 0) {
    9440:	9d02      	ldr	r5, [sp, #8]
    9442:	b22b      	sxth	r3, r5
    9444:	2b00      	cmp	r3, #0
    9446:	db0c      	blt.n	9462 <_ZN14Gamebuino_Meta8Graphics16fillCircleHelperEssshs+0x5e>
			y--;
    9448:	9b01      	ldr	r3, [sp, #4]
    944a:	3b01      	subs	r3, #1
    944c:	b21f      	sxth	r7, r3
			ddF_y += 2;
    944e:	9b07      	ldr	r3, [sp, #28]
	int16_t x     = 0;
	int16_t y     = r;

	while (x<y) {
		if (f >= 0) {
			y--;
    9450:	9701      	str	r7, [sp, #4]
			ddF_y += 2;
    9452:	3302      	adds	r3, #2
			f     += ddF_y;
    9454:	9f02      	ldr	r7, [sp, #8]
	int16_t y     = r;

	while (x<y) {
		if (f >= 0) {
			y--;
			ddF_y += 2;
    9456:	b29b      	uxth	r3, r3
    9458:	b29d      	uxth	r5, r3
			f     += ddF_y;
    945a:	19db      	adds	r3, r3, r7
    945c:	b29b      	uxth	r3, r3
	int16_t y     = r;

	while (x<y) {
		if (f >= 0) {
			y--;
			ddF_y += 2;
    945e:	9507      	str	r5, [sp, #28]
			f     += ddF_y;
    9460:	9302      	str	r3, [sp, #8]
    9462:	9d05      	ldr	r5, [sp, #20]
		}
		x++;
		ddF_x += 2;
		f     += ddF_x;
    9464:	9f02      	ldr	r7, [sp, #8]
    9466:	b2ad      	uxth	r5, r5
    9468:	006e      	lsls	r6, r5, #1
    946a:	b2b6      	uxth	r6, r6
    946c:	1c33      	adds	r3, r6, #0
    946e:	3303      	adds	r3, #3
    9470:	9503      	str	r5, [sp, #12]
    9472:	18fb      	adds	r3, r7, r3

		if (cornername & 0x1) {
    9474:	9d0a      	ldr	r5, [sp, #40]	; 0x28
			ddF_y += 2;
			f     += ddF_y;
		}
		x++;
		ddF_x += 2;
		f     += ddF_x;
    9476:	b29b      	uxth	r3, r3
    9478:	9606      	str	r6, [sp, #24]
    947a:	9302      	str	r3, [sp, #8]

		if (cornername & 0x1) {
    947c:	07ed      	lsls	r5, r5, #31
    947e:	d528      	bpl.n	94d2 <_ZN14Gamebuino_Meta8Graphics16fillCircleHelperEssshs+0xce>
			drawFastVLine(x0+x, y0-y, 2*y+1+delta);
    9480:	9f08      	ldr	r7, [sp, #32]
    9482:	9d09      	ldr	r5, [sp, #36]	; 0x24
    9484:	9801      	ldr	r0, [sp, #4]
    9486:	990b      	ldr	r1, [sp, #44]	; 0x2c
    9488:	b2bb      	uxth	r3, r7
    948a:	b28e      	uxth	r6, r1
    948c:	b2af      	uxth	r7, r5
    948e:	b285      	uxth	r5, r0
    9490:	9a03      	ldr	r2, [sp, #12]
    9492:	1c70      	adds	r0, r6, #1
    9494:	9304      	str	r3, [sp, #16]
    9496:	1c19      	adds	r1, r3, #0
    9498:	006b      	lsls	r3, r5, #1
    949a:	18c3      	adds	r3, r0, r3
    949c:	3101      	adds	r1, #1
    949e:	6820      	ldr	r0, [r4, #0]
    94a0:	1851      	adds	r1, r2, r1
    94a2:	1b7a      	subs	r2, r7, r5
    94a4:	b209      	sxth	r1, r1
    94a6:	9700      	str	r7, [sp, #0]
    94a8:	b212      	sxth	r2, r2
    94aa:	69c7      	ldr	r7, [r0, #28]
    94ac:	b21b      	sxth	r3, r3
    94ae:	1c20      	adds	r0, r4, #0
    94b0:	47b8      	blx	r7
			drawFastVLine(x0+y, y0-x, 2*x+1+delta);
    94b2:	9f04      	ldr	r7, [sp, #16]
    94b4:	9a00      	ldr	r2, [sp, #0]
    94b6:	19ed      	adds	r5, r5, r7
    94b8:	b229      	sxth	r1, r5
    94ba:	9f06      	ldr	r7, [sp, #24]
    94bc:	9d03      	ldr	r5, [sp, #12]
    94be:	6820      	ldr	r0, [r4, #0]
    94c0:	1cf3      	adds	r3, r6, #3
    94c2:	3a01      	subs	r2, #1
    94c4:	1b52      	subs	r2, r2, r5
    94c6:	18fb      	adds	r3, r7, r3
    94c8:	69c6      	ldr	r6, [r0, #28]
    94ca:	b212      	sxth	r2, r2
    94cc:	b21b      	sxth	r3, r3
    94ce:	1c20      	adds	r0, r4, #0
    94d0:	47b0      	blx	r6
		}
		if (cornername & 0x2) {
    94d2:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    94d4:	07ad      	lsls	r5, r5, #30
    94d6:	d528      	bpl.n	952a <_ZN14Gamebuino_Meta8Graphics16fillCircleHelperEssshs+0x126>
			drawFastVLine(x0-x, y0-y, 2*y+1+delta);
    94d8:	9f08      	ldr	r7, [sp, #32]
    94da:	9d09      	ldr	r5, [sp, #36]	; 0x24
    94dc:	9801      	ldr	r0, [sp, #4]
    94de:	990b      	ldr	r1, [sp, #44]	; 0x2c
    94e0:	b2bb      	uxth	r3, r7
    94e2:	b28e      	uxth	r6, r1
    94e4:	b2af      	uxth	r7, r5
    94e6:	b285      	uxth	r5, r0
    94e8:	9a03      	ldr	r2, [sp, #12]
    94ea:	1c70      	adds	r0, r6, #1
    94ec:	9304      	str	r3, [sp, #16]
    94ee:	1c19      	adds	r1, r3, #0
    94f0:	006b      	lsls	r3, r5, #1
    94f2:	18c3      	adds	r3, r0, r3
    94f4:	3901      	subs	r1, #1
    94f6:	6820      	ldr	r0, [r4, #0]
    94f8:	1a89      	subs	r1, r1, r2
    94fa:	1b7a      	subs	r2, r7, r5
    94fc:	b209      	sxth	r1, r1
    94fe:	9700      	str	r7, [sp, #0]
    9500:	b212      	sxth	r2, r2
    9502:	69c7      	ldr	r7, [r0, #28]
    9504:	b21b      	sxth	r3, r3
    9506:	1c20      	adds	r0, r4, #0
    9508:	47b8      	blx	r7
			drawFastVLine(x0-y, y0-x, 2*x+1+delta);
    950a:	9f04      	ldr	r7, [sp, #16]
    950c:	9a00      	ldr	r2, [sp, #0]
    950e:	1b7d      	subs	r5, r7, r5
    9510:	b229      	sxth	r1, r5
    9512:	9f06      	ldr	r7, [sp, #24]
    9514:	9d03      	ldr	r5, [sp, #12]
    9516:	6820      	ldr	r0, [r4, #0]
    9518:	1cf3      	adds	r3, r6, #3
    951a:	3a01      	subs	r2, #1
    951c:	1b52      	subs	r2, r2, r5
    951e:	18fb      	adds	r3, r7, r3
    9520:	69c6      	ldr	r6, [r0, #28]
    9522:	b212      	sxth	r2, r2
    9524:	b21b      	sxth	r3, r3
    9526:	1c20      	adds	r0, r4, #0
    9528:	47b0      	blx	r6
    952a:	9d05      	ldr	r5, [sp, #20]
    952c:	3501      	adds	r5, #1
    952e:	9505      	str	r5, [sp, #20]
    9530:	e781      	b.n	9436 <_ZN14Gamebuino_Meta8Graphics16fillCircleHelperEssshs+0x32>
		}
	}
}
    9532:	b00d      	add	sp, #52	; 0x34
    9534:	bdf0      	pop	{r4, r5, r6, r7, pc}

00009536 <_ZN14Gamebuino_Meta8Graphics4fillEv>:

void Graphics::_fill() {
	fillRect(0, 0, _width, _height);
}

void Graphics::fill() {
    9536:	b508      	push	{r3, lr}
	_fill();
    9538:	6803      	ldr	r3, [r0, #0]
    953a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    953c:	4798      	blx	r3
}
    953e:	bd08      	pop	{r3, pc}

00009540 <_ZN14Gamebuino_Meta8Graphics13fillRoundRectEsssss>:
	drawCircleHelper(x+w-r-1, y+h-r-1, r, 4);
	drawCircleHelper(x+r    , y+h-r-1, r, 8);
}

// Fill a rounded rectangle
void Graphics::fillRoundRect(int16_t x, int16_t y, int16_t w, int16_t h, int16_t r) {
    9540:	b5f0      	push	{r4, r5, r6, r7, lr}
    9542:	b089      	sub	sp, #36	; 0x24
    9544:	1c17      	adds	r7, r2, #0
    9546:	aa0e      	add	r2, sp, #56	; 0x38
    9548:	1c04      	adds	r4, r0, #0
    954a:	2000      	movs	r0, #0
    954c:	5e15      	ldrsh	r5, [r2, r0]
    954e:	aa0f      	add	r2, sp, #60	; 0x3c
    9550:	9506      	str	r5, [sp, #24]
    9552:	2000      	movs	r0, #0
    9554:	5e15      	ldrsh	r5, [r2, r0]
	// smarter version
	fillRect(x+r, y, w-2*r, h);
    9556:	b29b      	uxth	r3, r3
    9558:	b2ae      	uxth	r6, r5
    955a:	9304      	str	r3, [sp, #16]
    955c:	0073      	lsls	r3, r6, #1
    955e:	425b      	negs	r3, r3
    9560:	b289      	uxth	r1, r1
    9562:	b29b      	uxth	r3, r3
    9564:	9305      	str	r3, [sp, #20]
    9566:	9103      	str	r1, [sp, #12]
    9568:	1989      	adds	r1, r1, r6
    956a:	9805      	ldr	r0, [sp, #20]
    956c:	b20b      	sxth	r3, r1
    956e:	9904      	ldr	r1, [sp, #16]
    9570:	9307      	str	r3, [sp, #28]
    9572:	1843      	adds	r3, r0, r1
    9574:	9806      	ldr	r0, [sp, #24]
    9576:	6822      	ldr	r2, [r4, #0]
    9578:	9000      	str	r0, [sp, #0]
    957a:	6a91      	ldr	r1, [r2, #40]	; 0x28
    957c:	1c20      	adds	r0, r4, #0
    957e:	468c      	mov	ip, r1
    9580:	1c3a      	adds	r2, r7, #0
    9582:	9907      	ldr	r1, [sp, #28]
    9584:	b21b      	sxth	r3, r3
    9586:	47e0      	blx	ip

	// draw four corners
	fillCircleHelper(x+w-r-1, y+r, r, 1, h-2*r-1);
    9588:	9904      	ldr	r1, [sp, #16]
    958a:	19f3      	adds	r3, r6, r7
    958c:	9803      	ldr	r0, [sp, #12]
    958e:	9f06      	ldr	r7, [sp, #24]
    9590:	9a05      	ldr	r2, [sp, #20]
    9592:	3901      	subs	r1, #1
    9594:	1841      	adds	r1, r0, r1
    9596:	3f01      	subs	r7, #1
    9598:	19d7      	adds	r7, r2, r7
    959a:	1b8e      	subs	r6, r1, r6
    959c:	b231      	sxth	r1, r6
    959e:	b23f      	sxth	r7, r7
    95a0:	b21e      	sxth	r6, r3
    95a2:	2301      	movs	r3, #1
    95a4:	9300      	str	r3, [sp, #0]
    95a6:	1c20      	adds	r0, r4, #0
    95a8:	1c32      	adds	r2, r6, #0
    95aa:	1c2b      	adds	r3, r5, #0
    95ac:	9701      	str	r7, [sp, #4]
    95ae:	f7ff ff29 	bl	9404 <_ZN14Gamebuino_Meta8Graphics16fillCircleHelperEssshs>
	fillCircleHelper(x+r    , y+r, r, 2, h-2*r-1);
    95b2:	2302      	movs	r3, #2
    95b4:	9300      	str	r3, [sp, #0]
    95b6:	9701      	str	r7, [sp, #4]
    95b8:	1c20      	adds	r0, r4, #0
    95ba:	9907      	ldr	r1, [sp, #28]
    95bc:	1c32      	adds	r2, r6, #0
    95be:	1c2b      	adds	r3, r5, #0
    95c0:	f7ff ff20 	bl	9404 <_ZN14Gamebuino_Meta8Graphics16fillCircleHelperEssshs>
}
    95c4:	b009      	add	sp, #36	; 0x24
    95c6:	bdf0      	pop	{r4, r5, r6, r7, pc}

000095c8 <_ZNK14Gamebuino_Meta8Graphics13getFontHeightEv>:
uint8_t Graphics::getFontWidth(void) const {
	return fontWidth;
}

uint8_t Graphics::getFontHeight(void) const {
	return fontHeight;
    95c8:	4b01      	ldr	r3, [pc, #4]	; (95d0 <_ZNK14Gamebuino_Meta8Graphics13getFontHeightEv+0x8>)
    95ca:	7818      	ldrb	r0, [r3, #0]
}
    95cc:	4770      	bx	lr
    95ce:	46c0      	nop			; (mov r8, r8)
    95d0:	20000cd5 	.word	0x20000cd5

000095d4 <_ZN14Gamebuino_Meta8Graphics11setFontSizeEh>:

void Graphics::setFontSize(uint8_t s) {
	fontSize = (s > 0) ? s : 1;
    95d4:	2900      	cmp	r1, #0
    95d6:	d100      	bne.n	95da <_ZN14Gamebuino_Meta8Graphics11setFontSizeEh+0x6>
    95d8:	2101      	movs	r1, #1
    95da:	4b01      	ldr	r3, [pc, #4]	; (95e0 <_ZN14Gamebuino_Meta8Graphics11setFontSizeEh+0xc>)
    95dc:	7019      	strb	r1, [r3, #0]
}
    95de:	4770      	bx	lr
    95e0:	20000cd4 	.word	0x20000cd4

000095e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>:

void Graphics::drawPixel(int16_t x, int16_t y) {
    95e4:	b508      	push	{r3, lr}
	_drawPixel(x, y);
    95e6:	6803      	ldr	r3, [r0, #0]
    95e8:	691b      	ldr	r3, [r3, #16]
    95ea:	4798      	blx	r3
}
    95ec:	bd08      	pop	{r3, pc}

000095ee <_ZN14Gamebuino_Meta8Graphics16drawCircleHelperEsssh>:
		drawPixel(x0 + y, y0 - x);
		drawPixel(x0 - y, y0 - x);
	}
}

void Graphics::drawCircleHelper( int16_t x0, int16_t y0, int16_t r, uint8_t cornername) {
    95ee:	b5f0      	push	{r4, r5, r6, r7, lr}
    95f0:	b089      	sub	sp, #36	; 0x24
    95f2:	9301      	str	r3, [sp, #4]
    95f4:	ab0e      	add	r3, sp, #56	; 0x38
    95f6:	781b      	ldrb	r3, [r3, #0]
    95f8:	9205      	str	r2, [sp, #20]
	int16_t f     = 1 - r;
    95fa:	9a01      	ldr	r2, [sp, #4]
		drawPixel(x0 + y, y0 - x);
		drawPixel(x0 - y, y0 - x);
	}
}

void Graphics::drawCircleHelper( int16_t x0, int16_t y0, int16_t r, uint8_t cornername) {
    95fc:	9306      	str	r3, [sp, #24]
	int16_t f     = 1 - r;
    95fe:	b293      	uxth	r3, r2
    9600:	2201      	movs	r2, #1
    9602:	1ad2      	subs	r2, r2, r3
	int16_t ddF_x = 1;
	int16_t ddF_y = -2 * r;
    9604:	005b      	lsls	r3, r3, #1
    9606:	425b      	negs	r3, r3
    9608:	b29b      	uxth	r3, r3
		drawPixel(x0 - y, y0 - x);
	}
}

void Graphics::drawCircleHelper( int16_t x0, int16_t y0, int16_t r, uint8_t cornername) {
	int16_t f     = 1 - r;
    960a:	b292      	uxth	r2, r2
	int16_t ddF_x = 1;
	int16_t ddF_y = -2 * r;
    960c:	9307      	str	r3, [sp, #28]
	int16_t x     = 0;
	int16_t y     = r;

	while (x<y) {
    960e:	2300      	movs	r3, #0
		drawPixel(x0 + y, y0 - x);
		drawPixel(x0 - y, y0 - x);
	}
}

void Graphics::drawCircleHelper( int16_t x0, int16_t y0, int16_t r, uint8_t cornername) {
    9610:	9000      	str	r0, [sp, #0]
    9612:	9104      	str	r1, [sp, #16]
	int16_t f     = 1 - r;
    9614:	9202      	str	r2, [sp, #8]
	int16_t ddF_x = 1;
	int16_t ddF_y = -2 * r;
	int16_t x     = 0;
	int16_t y     = r;

	while (x<y) {
    9616:	9303      	str	r3, [sp, #12]
    9618:	9a03      	ldr	r2, [sp, #12]
    961a:	b213      	sxth	r3, r2
    961c:	9a01      	ldr	r2, [sp, #4]
    961e:	4293      	cmp	r3, r2
    9620:	db00      	blt.n	9624 <_ZN14Gamebuino_Meta8Graphics16drawCircleHelperEsssh+0x36>
    9622:	e080      	b.n	9726 <_ZN14Gamebuino_Meta8Graphics16drawCircleHelperEsssh+0x138>
		if (f >= 0) {
    9624:	9a02      	ldr	r2, [sp, #8]
    9626:	b213      	sxth	r3, r2
    9628:	2b00      	cmp	r3, #0
    962a:	db0c      	blt.n	9646 <_ZN14Gamebuino_Meta8Graphics16drawCircleHelperEsssh+0x58>
			y--;
    962c:	9b01      	ldr	r3, [sp, #4]
    962e:	3b01      	subs	r3, #1
    9630:	b21a      	sxth	r2, r3
			ddF_y += 2;
    9632:	9b07      	ldr	r3, [sp, #28]
	int16_t x     = 0;
	int16_t y     = r;

	while (x<y) {
		if (f >= 0) {
			y--;
    9634:	9201      	str	r2, [sp, #4]
			ddF_y += 2;
    9636:	3302      	adds	r3, #2
    9638:	b29b      	uxth	r3, r3
    963a:	b29a      	uxth	r2, r3
    963c:	9207      	str	r2, [sp, #28]
			f     += ddF_y;
    963e:	9a02      	ldr	r2, [sp, #8]
    9640:	189b      	adds	r3, r3, r2
    9642:	b29b      	uxth	r3, r3
    9644:	9302      	str	r3, [sp, #8]
    9646:	9b03      	ldr	r3, [sp, #12]
		}
		x++;
		ddF_x += 2;
		f     += ddF_x;
    9648:	9a02      	ldr	r2, [sp, #8]
    964a:	b29c      	uxth	r4, r3
    964c:	0063      	lsls	r3, r4, #1
    964e:	3303      	adds	r3, #3
    9650:	18d3      	adds	r3, r2, r3
    9652:	b29b      	uxth	r3, r3
    9654:	9302      	str	r3, [sp, #8]
		if (cornername & 0x4) {
    9656:	9b06      	ldr	r3, [sp, #24]
    9658:	075b      	lsls	r3, r3, #29
    965a:	d515      	bpl.n	9688 <_ZN14Gamebuino_Meta8Graphics16drawCircleHelperEsssh+0x9a>
			drawPixel(x0 + x, y0 + y);
    965c:	9a04      	ldr	r2, [sp, #16]
    965e:	9b05      	ldr	r3, [sp, #20]
    9660:	b296      	uxth	r6, r2
    9662:	9a01      	ldr	r2, [sp, #4]
    9664:	b29d      	uxth	r5, r3
    9666:	b297      	uxth	r7, r2
    9668:	1c71      	adds	r1, r6, #1
    966a:	1861      	adds	r1, r4, r1
    966c:	197a      	adds	r2, r7, r5
    966e:	b209      	sxth	r1, r1
    9670:	b212      	sxth	r2, r2
    9672:	9800      	ldr	r0, [sp, #0]
    9674:	f7ff ffb6 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
    9678:	1c6a      	adds	r2, r5, #1
			drawPixel(x0 + y, y0 + x);
    967a:	19be      	adds	r6, r7, r6
    967c:	18a2      	adds	r2, r4, r2
    967e:	b231      	sxth	r1, r6
    9680:	b212      	sxth	r2, r2
    9682:	9800      	ldr	r0, [sp, #0]
    9684:	f7ff ffae 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
		}
		if (cornername & 0x2) {
    9688:	9b06      	ldr	r3, [sp, #24]
    968a:	079b      	lsls	r3, r3, #30
    968c:	d515      	bpl.n	96ba <_ZN14Gamebuino_Meta8Graphics16drawCircleHelperEsssh+0xcc>
			drawPixel(x0 + x, y0 - y);
    968e:	9a04      	ldr	r2, [sp, #16]
    9690:	9b05      	ldr	r3, [sp, #20]
    9692:	b296      	uxth	r6, r2
    9694:	9a01      	ldr	r2, [sp, #4]
    9696:	b29d      	uxth	r5, r3
    9698:	b297      	uxth	r7, r2
    969a:	1c71      	adds	r1, r6, #1
    969c:	1861      	adds	r1, r4, r1
    969e:	1bea      	subs	r2, r5, r7
    96a0:	b209      	sxth	r1, r1
    96a2:	b212      	sxth	r2, r2
    96a4:	9800      	ldr	r0, [sp, #0]
    96a6:	f7ff ff9d 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
    96aa:	1e6a      	subs	r2, r5, #1
			drawPixel(x0 + y, y0 - x);
    96ac:	19be      	adds	r6, r7, r6
    96ae:	1b12      	subs	r2, r2, r4
    96b0:	b231      	sxth	r1, r6
    96b2:	b212      	sxth	r2, r2
    96b4:	9800      	ldr	r0, [sp, #0]
    96b6:	f7ff ff95 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
		}
		if (cornername & 0x8) {
    96ba:	9b06      	ldr	r3, [sp, #24]
    96bc:	071b      	lsls	r3, r3, #28
    96be:	d515      	bpl.n	96ec <_ZN14Gamebuino_Meta8Graphics16drawCircleHelperEsssh+0xfe>
			drawPixel(x0 - y, y0 + x);
    96c0:	9a04      	ldr	r2, [sp, #16]
    96c2:	9b01      	ldr	r3, [sp, #4]
    96c4:	b297      	uxth	r7, r2
    96c6:	9a05      	ldr	r2, [sp, #20]
    96c8:	b29e      	uxth	r6, r3
    96ca:	b295      	uxth	r5, r2
    96cc:	1c6a      	adds	r2, r5, #1
    96ce:	1bb9      	subs	r1, r7, r6
    96d0:	18a2      	adds	r2, r4, r2
    96d2:	b209      	sxth	r1, r1
    96d4:	b212      	sxth	r2, r2
    96d6:	9800      	ldr	r0, [sp, #0]
    96d8:	f7ff ff84 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
    96dc:	1e79      	subs	r1, r7, #1
    96de:	1b09      	subs	r1, r1, r4
			drawPixel(x0 - x, y0 + y);
    96e0:	1975      	adds	r5, r6, r5
    96e2:	b209      	sxth	r1, r1
    96e4:	b22a      	sxth	r2, r5
    96e6:	9800      	ldr	r0, [sp, #0]
    96e8:	f7ff ff7c 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
		}
		if (cornername & 0x1) {
    96ec:	9b06      	ldr	r3, [sp, #24]
    96ee:	07db      	lsls	r3, r3, #31
    96f0:	d515      	bpl.n	971e <_ZN14Gamebuino_Meta8Graphics16drawCircleHelperEsssh+0x130>
			drawPixel(x0 - y, y0 - x);
    96f2:	9a04      	ldr	r2, [sp, #16]
    96f4:	9b01      	ldr	r3, [sp, #4]
    96f6:	b297      	uxth	r7, r2
    96f8:	9a05      	ldr	r2, [sp, #20]
    96fa:	b29d      	uxth	r5, r3
    96fc:	b296      	uxth	r6, r2
    96fe:	1e72      	subs	r2, r6, #1
    9700:	1b79      	subs	r1, r7, r5
    9702:	1b12      	subs	r2, r2, r4
    9704:	b209      	sxth	r1, r1
    9706:	b212      	sxth	r2, r2
    9708:	9800      	ldr	r0, [sp, #0]
    970a:	f7ff ff6b 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
    970e:	1e79      	subs	r1, r7, #1
    9710:	1b09      	subs	r1, r1, r4
			drawPixel(x0 - x, y0 - y);
    9712:	1b75      	subs	r5, r6, r5
    9714:	b209      	sxth	r1, r1
    9716:	b22a      	sxth	r2, r5
    9718:	9800      	ldr	r0, [sp, #0]
    971a:	f7ff ff63 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
    971e:	9b03      	ldr	r3, [sp, #12]
    9720:	3301      	adds	r3, #1
    9722:	9303      	str	r3, [sp, #12]
    9724:	e778      	b.n	9618 <_ZN14Gamebuino_Meta8Graphics16drawCircleHelperEsssh+0x2a>
		}
	}
}
    9726:	b009      	add	sp, #36	; 0x24
    9728:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000972a <_ZN14Gamebuino_Meta8Graphics13drawRoundRectEsssss>:
	fill();
	color.c = tmpColor;
}

// Draw a rounded rectangle
void Graphics::drawRoundRect(int16_t x, int16_t y, int16_t w, int16_t h, int16_t r) {
    972a:	b5f0      	push	{r4, r5, r6, r7, lr}
    972c:	b08b      	sub	sp, #44	; 0x2c
    972e:	1c15      	adds	r5, r2, #0
    9730:	aa10      	add	r2, sp, #64	; 0x40
    9732:	1c04      	adds	r4, r0, #0
    9734:	2000      	movs	r0, #0
    9736:	5e17      	ldrsh	r7, [r2, r0]
    9738:	aa11      	add	r2, sp, #68	; 0x44
    973a:	9109      	str	r1, [sp, #36]	; 0x24
    973c:	2000      	movs	r0, #0
    973e:	5e11      	ldrsh	r1, [r2, r0]
	// smarter version
	drawFastHLine(x+r  , y    , w-2*r); // Top
    9740:	b29b      	uxth	r3, r3
	fill();
	color.c = tmpColor;
}

// Draw a rounded rectangle
void Graphics::drawRoundRect(int16_t x, int16_t y, int16_t w, int16_t h, int16_t r) {
    9742:	9103      	str	r1, [sp, #12]
	// smarter version
	drawFastHLine(x+r  , y    , w-2*r); // Top
    9744:	9a03      	ldr	r2, [sp, #12]
    9746:	9909      	ldr	r1, [sp, #36]	; 0x24
    9748:	b292      	uxth	r2, r2
    974a:	9202      	str	r2, [sp, #8]
    974c:	9802      	ldr	r0, [sp, #8]
    974e:	9306      	str	r3, [sp, #24]
    9750:	b289      	uxth	r1, r1
    9752:	0043      	lsls	r3, r0, #1
    9754:	9105      	str	r1, [sp, #20]
    9756:	188a      	adds	r2, r1, r2
    9758:	425b      	negs	r3, r3
    975a:	9906      	ldr	r1, [sp, #24]
    975c:	b29b      	uxth	r3, r3
    975e:	9307      	str	r3, [sp, #28]
    9760:	185e      	adds	r6, r3, r1
    9762:	6823      	ldr	r3, [r4, #0]
    9764:	b210      	sxth	r0, r2
    9766:	6a19      	ldr	r1, [r3, #32]
    9768:	9004      	str	r0, [sp, #16]
    976a:	b236      	sxth	r6, r6
    976c:	468c      	mov	ip, r1
    976e:	1c20      	adds	r0, r4, #0
    9770:	9904      	ldr	r1, [sp, #16]
    9772:	1c2a      	adds	r2, r5, #0
    9774:	1c33      	adds	r3, r6, #0
	drawFastHLine(x+r  , y+h-1, w-2*r); // Bottom
    9776:	b2bf      	uxth	r7, r7
}

// Draw a rounded rectangle
void Graphics::drawRoundRect(int16_t x, int16_t y, int16_t w, int16_t h, int16_t r) {
	// smarter version
	drawFastHLine(x+r  , y    , w-2*r); // Top
    9778:	47e0      	blx	ip
	drawFastHLine(x+r  , y+h-1, w-2*r); // Bottom
    977a:	b2ad      	uxth	r5, r5
    977c:	1e7b      	subs	r3, r7, #1
    977e:	18eb      	adds	r3, r5, r3
    9780:	b29b      	uxth	r3, r3
    9782:	9308      	str	r3, [sp, #32]
    9784:	6823      	ldr	r3, [r4, #0]
    9786:	9808      	ldr	r0, [sp, #32]
    9788:	6a19      	ldr	r1, [r3, #32]
    978a:	b202      	sxth	r2, r0
    978c:	468c      	mov	ip, r1
    978e:	1c20      	adds	r0, r4, #0
    9790:	9904      	ldr	r1, [sp, #16]
    9792:	1c33      	adds	r3, r6, #0
    9794:	47e0      	blx	ip
	drawFastVLine(x    , y+r  , h-2*r); // Left
    9796:	9a02      	ldr	r2, [sp, #8]
    9798:	9b07      	ldr	r3, [sp, #28]
    979a:	1955      	adds	r5, r2, r5
    979c:	19df      	adds	r7, r3, r7
    979e:	6823      	ldr	r3, [r4, #0]
    97a0:	b22d      	sxth	r5, r5
    97a2:	b23f      	sxth	r7, r7
    97a4:	69de      	ldr	r6, [r3, #28]
    97a6:	1c20      	adds	r0, r4, #0
    97a8:	9909      	ldr	r1, [sp, #36]	; 0x24
    97aa:	1c2a      	adds	r2, r5, #0
    97ac:	1c3b      	adds	r3, r7, #0
    97ae:	47b0      	blx	r6
	drawFastVLine(x+w-1, y+r  , h-2*r); // Right
    97b0:	9805      	ldr	r0, [sp, #20]
    97b2:	9906      	ldr	r1, [sp, #24]
    97b4:	6823      	ldr	r3, [r4, #0]
    97b6:	1846      	adds	r6, r0, r1
    97b8:	69da      	ldr	r2, [r3, #28]
    97ba:	b2b6      	uxth	r6, r6
    97bc:	1e71      	subs	r1, r6, #1
    97be:	4694      	mov	ip, r2
    97c0:	1c20      	adds	r0, r4, #0
    97c2:	1c2a      	adds	r2, r5, #0
    97c4:	1c3b      	adds	r3, r7, #0
    97c6:	b209      	sxth	r1, r1
    97c8:	47e0      	blx	ip
	// draw four corners
	drawCircleHelper(x+r    , y+r    , r, 1);
    97ca:	2301      	movs	r3, #1
    97cc:	9300      	str	r3, [sp, #0]
    97ce:	1c20      	adds	r0, r4, #0
    97d0:	9904      	ldr	r1, [sp, #16]
    97d2:	1c2a      	adds	r2, r5, #0
    97d4:	9b03      	ldr	r3, [sp, #12]
    97d6:	f7ff ff0a 	bl	95ee <_ZN14Gamebuino_Meta8Graphics16drawCircleHelperEsssh>
	drawCircleHelper(x+w-r-1, y+r    , r, 2);
    97da:	9802      	ldr	r0, [sp, #8]
    97dc:	1c2a      	adds	r2, r5, #0
    97de:	43c3      	mvns	r3, r0
    97e0:	18f6      	adds	r6, r6, r3
    97e2:	b236      	sxth	r6, r6
    97e4:	2302      	movs	r3, #2
    97e6:	9300      	str	r3, [sp, #0]
    97e8:	1c20      	adds	r0, r4, #0
    97ea:	1c31      	adds	r1, r6, #0
    97ec:	9b03      	ldr	r3, [sp, #12]
    97ee:	f7ff fefe 	bl	95ee <_ZN14Gamebuino_Meta8Graphics16drawCircleHelperEsssh>
	drawCircleHelper(x+w-r-1, y+h-r-1, r, 4);
    97f2:	9908      	ldr	r1, [sp, #32]
    97f4:	9a02      	ldr	r2, [sp, #8]
    97f6:	2304      	movs	r3, #4
    97f8:	1a8d      	subs	r5, r1, r2
    97fa:	b22d      	sxth	r5, r5
    97fc:	9300      	str	r3, [sp, #0]
    97fe:	1c20      	adds	r0, r4, #0
    9800:	1c31      	adds	r1, r6, #0
    9802:	1c2a      	adds	r2, r5, #0
    9804:	9b03      	ldr	r3, [sp, #12]
    9806:	f7ff fef2 	bl	95ee <_ZN14Gamebuino_Meta8Graphics16drawCircleHelperEsssh>
	drawCircleHelper(x+r    , y+h-r-1, r, 8);
    980a:	2308      	movs	r3, #8
    980c:	9300      	str	r3, [sp, #0]
    980e:	1c20      	adds	r0, r4, #0
    9810:	9904      	ldr	r1, [sp, #16]
    9812:	1c2a      	adds	r2, r5, #0
    9814:	9b03      	ldr	r3, [sp, #12]
    9816:	f7ff feea 	bl	95ee <_ZN14Gamebuino_Meta8Graphics16drawCircleHelperEsssh>
}
    981a:	b00b      	add	sp, #44	; 0x2c
    981c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

00009820 <_ZN14Gamebuino_Meta8Graphics8drawLineEssss>:
		}
	}
}

// Bresenham's algorithm - thx wikpedia
void Graphics::drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1) {
    9820:	b5f0      	push	{r4, r5, r6, r7, lr}
    9822:	b087      	sub	sp, #28
    9824:	1c1e      	adds	r6, r3, #0
    9826:	ab0c      	add	r3, sp, #48	; 0x30
    9828:	9004      	str	r0, [sp, #16]
    982a:	2000      	movs	r0, #0
    982c:	5e1b      	ldrsh	r3, [r3, r0]
    982e:	1c0c      	adds	r4, r1, #0
	int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    9830:	1a99      	subs	r1, r3, r2
		}
	}
}

// Bresenham's algorithm - thx wikpedia
void Graphics::drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1) {
    9832:	1c15      	adds	r5, r2, #0
	int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    9834:	17ca      	asrs	r2, r1, #31
    9836:	1889      	adds	r1, r1, r2
    9838:	4051      	eors	r1, r2
    983a:	1b32      	subs	r2, r6, r4
    983c:	17d0      	asrs	r0, r2, #31
    983e:	1812      	adds	r2, r2, r0
    9840:	4042      	eors	r2, r0
    9842:	4291      	cmp	r1, r2
    9844:	dd08      	ble.n	9858 <_ZN14Gamebuino_Meta8Graphics8drawLineEssss+0x38>
    9846:	1c32      	adds	r2, r6, #0
    9848:	2101      	movs	r1, #1
	if (steep) {
		_swap_int16_t(x0, y0);
		_swap_int16_t(x1, y1);
    984a:	1c1e      	adds	r6, r3, #0
    984c:	1c13      	adds	r3, r2, #0
    984e:	1c22      	adds	r2, r4, #0
    9850:	9101      	str	r1, [sp, #4]

// Bresenham's algorithm - thx wikpedia
void Graphics::drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1) {
	int16_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
		_swap_int16_t(x0, y0);
    9852:	1c2c      	adds	r4, r5, #0
    9854:	1c15      	adds	r5, r2, #0
    9856:	e001      	b.n	985c <_ZN14Gamebuino_Meta8Graphics8drawLineEssss+0x3c>
    9858:	2200      	movs	r2, #0
    985a:	9201      	str	r2, [sp, #4]
		_swap_int16_t(x1, y1);
	}

	if (x0 > x1) {
    985c:	42b4      	cmp	r4, r6
    985e:	dd05      	ble.n	986c <_ZN14Gamebuino_Meta8Graphics8drawLineEssss+0x4c>
    9860:	1c2a      	adds	r2, r5, #0
		_swap_int16_t(x0, x1);
		_swap_int16_t(y0, y1);
    9862:	1c1d      	adds	r5, r3, #0
    9864:	1c13      	adds	r3, r2, #0
    9866:	1c22      	adds	r2, r4, #0
    9868:	1c34      	adds	r4, r6, #0
    986a:	1c16      	adds	r6, r2, #0
	}

	int16_t dx, dy;
	dx = x1 - x0;
    986c:	1b32      	subs	r2, r6, r4
    986e:	b292      	uxth	r2, r2
    9870:	9202      	str	r2, [sp, #8]
	dy = abs(y1 - y0);
    9872:	1b5a      	subs	r2, r3, r5
    9874:	17d1      	asrs	r1, r2, #31
    9876:	1850      	adds	r0, r2, r1
    9878:	4048      	eors	r0, r1
    987a:	9005      	str	r0, [sp, #20]

	int16_t err = dx / 2;
    987c:	9802      	ldr	r0, [sp, #8]
    987e:	b202      	sxth	r2, r0
    9880:	0fd7      	lsrs	r7, r2, #31
    9882:	18bf      	adds	r7, r7, r2
    9884:	107f      	asrs	r7, r7, #1
    9886:	b2bf      	uxth	r7, r7
	int16_t ystep;

	if (y0 < y1) {
    9888:	429d      	cmp	r5, r3
    988a:	da02      	bge.n	9892 <_ZN14Gamebuino_Meta8Graphics8drawLineEssss+0x72>
		ystep = 1;
    988c:	2101      	movs	r1, #1
    988e:	9103      	str	r1, [sp, #12]
    9890:	e019      	b.n	98c6 <_ZN14Gamebuino_Meta8Graphics8drawLineEssss+0xa6>
	} else {
		ystep = -1;
    9892:	4a12      	ldr	r2, [pc, #72]	; (98dc <_ZN14Gamebuino_Meta8Graphics8drawLineEssss+0xbc>)
    9894:	9203      	str	r2, [sp, #12]
    9896:	e016      	b.n	98c6 <_ZN14Gamebuino_Meta8Graphics8drawLineEssss+0xa6>
	}

	for (; x0<=x1; x0++) {
		if (steep) {
    9898:	9b01      	ldr	r3, [sp, #4]
			drawPixel(y0, x0);
    989a:	9804      	ldr	r0, [sp, #16]
	} else {
		ystep = -1;
	}

	for (; x0<=x1; x0++) {
		if (steep) {
    989c:	2b00      	cmp	r3, #0
    989e:	d015      	beq.n	98cc <_ZN14Gamebuino_Meta8Graphics8drawLineEssss+0xac>
			drawPixel(y0, x0);
    98a0:	1c29      	adds	r1, r5, #0
    98a2:	1c22      	adds	r2, r4, #0
    98a4:	f7ff fe9e 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
		} else {
			drawPixel(x0, y0);
		}
		err -= dy;
    98a8:	9805      	ldr	r0, [sp, #20]
    98aa:	1a3f      	subs	r7, r7, r0
    98ac:	b2bb      	uxth	r3, r7
    98ae:	b29f      	uxth	r7, r3
		if (err < 0) {
    98b0:	b23a      	sxth	r2, r7
    98b2:	2a00      	cmp	r2, #0
    98b4:	da05      	bge.n	98c2 <_ZN14Gamebuino_Meta8Graphics8drawLineEssss+0xa2>
			y0 += ystep;
    98b6:	9903      	ldr	r1, [sp, #12]
			err += dx;
    98b8:	9a02      	ldr	r2, [sp, #8]
		} else {
			drawPixel(x0, y0);
		}
		err -= dy;
		if (err < 0) {
			y0 += ystep;
    98ba:	186d      	adds	r5, r5, r1
			err += dx;
    98bc:	189f      	adds	r7, r3, r2
		} else {
			drawPixel(x0, y0);
		}
		err -= dy;
		if (err < 0) {
			y0 += ystep;
    98be:	b22d      	sxth	r5, r5
			err += dx;
    98c0:	b2bf      	uxth	r7, r7
    98c2:	3401      	adds	r4, #1
    98c4:	b224      	sxth	r4, r4
		ystep = 1;
	} else {
		ystep = -1;
	}

	for (; x0<=x1; x0++) {
    98c6:	42b4      	cmp	r4, r6
    98c8:	dde6      	ble.n	9898 <_ZN14Gamebuino_Meta8Graphics8drawLineEssss+0x78>
    98ca:	e004      	b.n	98d6 <_ZN14Gamebuino_Meta8Graphics8drawLineEssss+0xb6>
		if (steep) {
			drawPixel(y0, x0);
		} else {
			drawPixel(x0, y0);
    98cc:	1c21      	adds	r1, r4, #0
    98ce:	1c2a      	adds	r2, r5, #0
    98d0:	f7ff fe88 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
    98d4:	e7e8      	b.n	98a8 <_ZN14Gamebuino_Meta8Graphics8drawLineEssss+0x88>
		if (err < 0) {
			y0 += ystep;
			err += dx;
		}
	}
}
    98d6:	b007      	add	sp, #28
    98d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    98da:	46c0      	nop			; (mov r8, r8)
    98dc:	0000ffff 	.word	0x0000ffff

000098e0 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKh>:
		if(a > b) _swap_int16_t(a,b);
		drawFastHLine(a, y, b-a+1);
	}
}

void Graphics::drawBitmap(int8_t x, int8_t y, const uint8_t *bitmap) {
    98e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    98e2:	b08b      	sub	sp, #44	; 0x2c
    98e4:	9109      	str	r1, [sp, #36]	; 0x24
	uint8_t w = *(bitmap++);
    98e6:	7819      	ldrb	r1, [r3, #0]
		if(a > b) _swap_int16_t(a,b);
		drawFastHLine(a, y, b-a+1);
	}
}

void Graphics::drawBitmap(int8_t x, int8_t y, const uint8_t *bitmap) {
    98e8:	9008      	str	r0, [sp, #32]
	uint8_t w = *(bitmap++);
	uint8_t h = *(bitmap++);
	
	uint8_t byteWidth = (w + 7) / 8;
    98ea:	1dc8      	adds	r0, r1, #7
    98ec:	08c0      	lsrs	r0, r0, #3
    98ee:	9003      	str	r0, [sp, #12]
	uint8_t _x = x;
	uint8_t dw = 8 - (w%8);
    98f0:	2007      	movs	r0, #7
    98f2:	4001      	ands	r1, r0
    98f4:	9104      	str	r1, [sp, #16]
		if(a > b) _swap_int16_t(a,b);
		drawFastHLine(a, y, b-a+1);
	}
}

void Graphics::drawBitmap(int8_t x, int8_t y, const uint8_t *bitmap) {
    98f6:	1c14      	adds	r4, r2, #0
	uint8_t w = *(bitmap++);
	uint8_t h = *(bitmap++);
	
	uint8_t byteWidth = (w + 7) / 8;
	uint8_t _x = x;
	uint8_t dw = 8 - (w%8);
    98f8:	9804      	ldr	r0, [sp, #16]
	}
}

void Graphics::drawBitmap(int8_t x, int8_t y, const uint8_t *bitmap) {
	uint8_t w = *(bitmap++);
	uint8_t h = *(bitmap++);
    98fa:	1c9a      	adds	r2, r3, #2
    98fc:	785b      	ldrb	r3, [r3, #1]
	
	uint8_t byteWidth = (w + 7) / 8;
	uint8_t _x = x;
	uint8_t dw = 8 - (w%8);
    98fe:	2108      	movs	r1, #8
    9900:	1a09      	subs	r1, r1, r0
    9902:	18e3      	adds	r3, r4, r3
    9904:	b2c9      	uxtb	r1, r1
    9906:	b2db      	uxtb	r3, r3
    9908:	9106      	str	r1, [sp, #24]
    990a:	9307      	str	r3, [sp, #28]
	for (uint8_t j = 0; j < h; j++) {
    990c:	9807      	ldr	r0, [sp, #28]
    990e:	b243      	sxtb	r3, r0
    9910:	429c      	cmp	r4, r3
    9912:	d037      	beq.n	9984 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKh+0xa4>
    9914:	9909      	ldr	r1, [sp, #36]	; 0x24
    9916:	1c16      	adds	r6, r2, #0
    9918:	9102      	str	r1, [sp, #8]
    991a:	2700      	movs	r7, #0
		x = _x;
		for (uint8_t i = 0; i < byteWidth;) {
    991c:	9b03      	ldr	r3, [sp, #12]
    991e:	1c32      	adds	r2, r6, #0
    9920:	429f      	cmp	r7, r3
    9922:	d22c      	bcs.n	997e <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKh+0x9e>
			uint8_t b = *(bitmap++);
    9924:	7831      	ldrb	r1, [r6, #0]
			i++;
    9926:	1c7b      	adds	r3, r7, #1
	uint8_t _x = x;
	uint8_t dw = 8 - (w%8);
	for (uint8_t j = 0; j < h; j++) {
		x = _x;
		for (uint8_t i = 0; i < byteWidth;) {
			uint8_t b = *(bitmap++);
    9928:	9101      	str	r1, [sp, #4]
			i++;
    992a:	b2df      	uxtb	r7, r3
    992c:	2500      	movs	r5, #0
    992e:	9a02      	ldr	r2, [sp, #8]
    9930:	b2eb      	uxtb	r3, r5
    9932:	b2d2      	uxtb	r2, r2
			for (uint8_t k = 0; k < 8; k++) {
				if (i == byteWidth && k == dw) {
    9934:	9803      	ldr	r0, [sp, #12]
    9936:	1899      	adds	r1, r3, r2
    9938:	9205      	str	r2, [sp, #20]
    993a:	9300      	str	r3, [sp, #0]
    993c:	b249      	sxtb	r1, r1
    993e:	4287      	cmp	r7, r0
    9940:	d106      	bne.n	9950 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKh+0x70>
    9942:	9a06      	ldr	r2, [sp, #24]
    9944:	4293      	cmp	r3, r2
    9946:	d103      	bne.n	9950 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKh+0x70>
					x += (w%8);
    9948:	9b04      	ldr	r3, [sp, #16]
    994a:	1859      	adds	r1, r3, r1
    994c:	b249      	sxtb	r1, r1
					break;
    994e:	e013      	b.n	9978 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKh+0x98>
				}
				if (b&0x80) {
    9950:	9801      	ldr	r0, [sp, #4]
    9952:	b243      	sxtb	r3, r0
    9954:	2b00      	cmp	r3, #0
    9956:	da03      	bge.n	9960 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKh+0x80>
					drawPixel(x, y);
    9958:	9808      	ldr	r0, [sp, #32]
    995a:	1c22      	adds	r2, r4, #0
    995c:	f7ff fe42 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
				}
				b <<= 1;
    9960:	9901      	ldr	r1, [sp, #4]
    9962:	9a00      	ldr	r2, [sp, #0]
    9964:	004b      	lsls	r3, r1, #1
    9966:	9905      	ldr	r1, [sp, #20]
    9968:	b2db      	uxtb	r3, r3
    996a:	3101      	adds	r1, #1
    996c:	1851      	adds	r1, r2, r1
    996e:	3501      	adds	r5, #1
    9970:	9301      	str	r3, [sp, #4]
    9972:	b249      	sxtb	r1, r1
	for (uint8_t j = 0; j < h; j++) {
		x = _x;
		for (uint8_t i = 0; i < byteWidth;) {
			uint8_t b = *(bitmap++);
			i++;
			for (uint8_t k = 0; k < 8; k++) {
    9974:	2d08      	cmp	r5, #8
    9976:	d1da      	bne.n	992e <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKh+0x4e>
    9978:	3601      	adds	r6, #1
	uint8_t h = *(bitmap++);
	
	uint8_t byteWidth = (w + 7) / 8;
	uint8_t _x = x;
	uint8_t dw = 8 - (w%8);
	for (uint8_t j = 0; j < h; j++) {
    997a:	9102      	str	r1, [sp, #8]
    997c:	e7ce      	b.n	991c <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKh+0x3c>
    997e:	3401      	adds	r4, #1
    9980:	b264      	sxtb	r4, r4
    9982:	e7c3      	b.n	990c <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKh+0x2c>
				x++;
			}
		}
		y++;
	}
}
    9984:	b00b      	add	sp, #44	; 0x2c
    9986:	bdf0      	pop	{r4, r5, r6, r7, pc}

00009988 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh>:

void Graphics::drawBitmap(int8_t x, int8_t y, const uint8_t *bitmap,
	uint8_t rotation, uint8_t flip) {
    9988:	b5f0      	push	{r4, r5, r6, r7, lr}
    998a:	b08b      	sub	sp, #44	; 0x2c
    998c:	9104      	str	r1, [sp, #16]
    998e:	9205      	str	r2, [sp, #20]
    9990:	a911      	add	r1, sp, #68	; 0x44
    9992:	aa10      	add	r2, sp, #64	; 0x40
    9994:	7809      	ldrb	r1, [r1, #0]
    9996:	7812      	ldrb	r2, [r2, #0]
    9998:	9101      	str	r1, [sp, #4]
    999a:	1c07      	adds	r7, r0, #0
	if ((rotation == NOROT) && (flip == NOFLIP)) {
    999c:	4311      	orrs	r1, r2
    999e:	d105      	bne.n	99ac <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh+0x24>
		drawBitmap(x, y, bitmap); //use the faster algorithm
    99a0:	6802      	ldr	r2, [r0, #0]
    99a2:	9904      	ldr	r1, [sp, #16]
    99a4:	6bd4      	ldr	r4, [r2, #60]	; 0x3c
    99a6:	9a05      	ldr	r2, [sp, #20]
    99a8:	47a0      	blx	r4
		return;
    99aa:	e068      	b.n	9a7e <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh+0xf6>
	}
	uint8_t w = pgm_read_byte(bitmap);
    99ac:	781c      	ldrb	r4, [r3, #0]
	uint8_t h = pgm_read_byte(bitmap + 1);
    99ae:	7858      	ldrb	r0, [r3, #1]
	bitmap = bitmap + 2; //add an offset to the pointer to start after the width and height
    99b0:	3302      	adds	r3, #2
    99b2:	9306      	str	r3, [sp, #24]
	int8_t i, j, //coordinates in the raw bitmap
			k, l, //coordinates in the rotated/flipped bitmap
			byteNum, bitNum, byteWidth = (w + 7) >> 3;
    99b4:	1de3      	adds	r3, r4, #7
    99b6:	10db      	asrs	r3, r3, #3
    99b8:	9307      	str	r3, [sp, #28]

	rotation %= 4;
    99ba:	2303      	movs	r3, #3
    99bc:	401a      	ands	r2, r3
	if ((rotation == NOROT) && (flip == NOFLIP)) {
		drawBitmap(x, y, bitmap); //use the faster algorithm
		return;
	}
	uint8_t w = pgm_read_byte(bitmap);
	uint8_t h = pgm_read_byte(bitmap + 1);
    99be:	9000      	str	r0, [sp, #0]
	bitmap = bitmap + 2; //add an offset to the pointer to start after the width and height
	int8_t i, j, //coordinates in the raw bitmap
			k, l, //coordinates in the rotated/flipped bitmap
			byteNum, bitNum, byteWidth = (w + 7) >> 3;

	rotation %= 4;
    99c0:	9203      	str	r2, [sp, #12]

	for (i = 0; i < w; i++) {
    99c2:	2500      	movs	r5, #0
    99c4:	b2ea      	uxtb	r2, r5
    99c6:	b253      	sxtb	r3, r2
    99c8:	9202      	str	r2, [sp, #8]
    99ca:	42a3      	cmp	r3, r4
    99cc:	da57      	bge.n	9a7e <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh+0xf6>
		byteNum = i / 8;
    99ce:	17da      	asrs	r2, r3, #31
    99d0:	0f52      	lsrs	r2, r2, #29
    99d2:	18d2      	adds	r2, r2, r3
    99d4:	10d2      	asrs	r2, r2, #3
    99d6:	b2d2      	uxtb	r2, r2
    99d8:	9208      	str	r2, [sp, #32]
		bitNum = i % 8;
    99da:	4a2a      	ldr	r2, [pc, #168]	; (9a84 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh+0xfc>)
    99dc:	4013      	ands	r3, r2
    99de:	d504      	bpl.n	99ea <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh+0x62>
    99e0:	2208      	movs	r2, #8
    99e2:	3b01      	subs	r3, #1
    99e4:	4252      	negs	r2, r2
    99e6:	4313      	orrs	r3, r2
    99e8:	3301      	adds	r3, #1
		for (j = 0; j < h; j++) {
			if (pgm_read_byte(bitmap + j * byteWidth + byteNum) & (B10000000 >> bitNum)) {
    99ea:	b25b      	sxtb	r3, r3
    99ec:	2280      	movs	r2, #128	; 0x80
    99ee:	411a      	asrs	r2, r3
    99f0:	9209      	str	r2, [sp, #36]	; 0x24
	rotation %= 4;

	for (i = 0; i < w; i++) {
		byteNum = i / 8;
		bitNum = i % 8;
		for (j = 0; j < h; j++) {
    99f2:	2600      	movs	r6, #0
    99f4:	b2f2      	uxtb	r2, r6
    99f6:	9900      	ldr	r1, [sp, #0]
    99f8:	b253      	sxtb	r3, r2
    99fa:	428b      	cmp	r3, r1
    99fc:	da3d      	bge.n	9a7a <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh+0xf2>
			if (pgm_read_byte(bitmap + j * byteWidth + byteNum) & (B10000000 >> bitNum)) {
    99fe:	9907      	ldr	r1, [sp, #28]
    9a00:	9808      	ldr	r0, [sp, #32]
    9a02:	434b      	muls	r3, r1
    9a04:	b241      	sxtb	r1, r0
    9a06:	9806      	ldr	r0, [sp, #24]
    9a08:	18c3      	adds	r3, r0, r3
    9a0a:	5c5b      	ldrb	r3, [r3, r1]
    9a0c:	9909      	ldr	r1, [sp, #36]	; 0x24
    9a0e:	4219      	tst	r1, r3
    9a10:	d031      	beq.n	9a76 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh+0xee>
				switch (rotation) {
    9a12:	9b03      	ldr	r3, [sp, #12]
    9a14:	2b02      	cmp	r3, #2
    9a16:	d008      	beq.n	9a2a <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh+0xa2>
    9a18:	2b03      	cmp	r3, #3
    9a1a:	d00e      	beq.n	9a3a <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh+0xb2>
    9a1c:	2b01      	cmp	r3, #1
    9a1e:	d112      	bne.n	9a46 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh+0xbe>
					k = i;
					l = j;
					break;
				case ROTCCW: //90 counter-clockwise
					k = j;
					l = w - i - 1;
    9a20:	1e63      	subs	r3, r4, #1
    9a22:	1b5b      	subs	r3, r3, r5
				case NOROT: //no rotation
					k = i;
					l = j;
					break;
				case ROTCCW: //90 counter-clockwise
					k = j;
    9a24:	1c11      	adds	r1, r2, #0
					l = w - i - 1;
    9a26:	b2da      	uxtb	r2, r3
					break;
    9a28:	e00e      	b.n	9a48 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh+0xc0>
				case ROT180: //180
					k = w - i - 1;
					l = h - j - 1;
    9a2a:	9a00      	ldr	r2, [sp, #0]
				case ROTCCW: //90 counter-clockwise
					k = j;
					l = w - i - 1;
					break;
				case ROT180: //180
					k = w - i - 1;
    9a2c:	1e61      	subs	r1, r4, #1
					l = h - j - 1;
    9a2e:	3a01      	subs	r2, #1
    9a30:	1b49      	subs	r1, r1, r5
    9a32:	1b92      	subs	r2, r2, r6
    9a34:	b2c9      	uxtb	r1, r1
    9a36:	b2d2      	uxtb	r2, r2
					break;
    9a38:	e006      	b.n	9a48 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh+0xc0>
				case ROTCW: //90 clockwise
					k = h - j - 1;
    9a3a:	9900      	ldr	r1, [sp, #0]
					l = i;
    9a3c:	9a02      	ldr	r2, [sp, #8]
				case ROT180: //180
					k = w - i - 1;
					l = h - j - 1;
					break;
				case ROTCW: //90 clockwise
					k = h - j - 1;
    9a3e:	3901      	subs	r1, #1
    9a40:	1b89      	subs	r1, r1, r6
    9a42:	b2c9      	uxtb	r1, r1
					l = i;
					break;
    9a44:	e000      	b.n	9a48 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh+0xc0>
		bitNum = i % 8;
		for (j = 0; j < h; j++) {
			if (pgm_read_byte(bitmap + j * byteWidth + byteNum) & (B10000000 >> bitNum)) {
				switch (rotation) {
				case NOROT: //no rotation
					k = i;
    9a46:	9902      	ldr	r1, [sp, #8]
				case ROTCW: //90 clockwise
					k = h - j - 1;
					l = i;
					break;
				}
				if (flip) {
    9a48:	9801      	ldr	r0, [sp, #4]
    9a4a:	2800      	cmp	r0, #0
    9a4c:	d00a      	beq.n	9a64 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh+0xdc>
					if (flip & B00000001) { //horizontal flip
    9a4e:	07c0      	lsls	r0, r0, #31
    9a50:	d502      	bpl.n	9a58 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh+0xd0>
						k = w - k - 1;
    9a52:	1e63      	subs	r3, r4, #1
    9a54:	1a59      	subs	r1, r3, r1
    9a56:	b2c9      	uxtb	r1, r1
					}
					if (flip & B00000010) { //vertical flip
    9a58:	9b01      	ldr	r3, [sp, #4]
    9a5a:	079b      	lsls	r3, r3, #30
    9a5c:	d502      	bpl.n	9a64 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh+0xdc>
						l = h - l;
    9a5e:	9800      	ldr	r0, [sp, #0]
    9a60:	1a82      	subs	r2, r0, r2
    9a62:	b2d2      	uxtb	r2, r2
					}
				}
				k += x; //place the bitmap on the screen
				l += y;
    9a64:	9805      	ldr	r0, [sp, #20]
					}
					if (flip & B00000010) { //vertical flip
						l = h - l;
					}
				}
				k += x; //place the bitmap on the screen
    9a66:	9b04      	ldr	r3, [sp, #16]
				l += y;
    9a68:	1812      	adds	r2, r2, r0
					}
					if (flip & B00000010) { //vertical flip
						l = h - l;
					}
				}
				k += x; //place the bitmap on the screen
    9a6a:	18c9      	adds	r1, r1, r3
				l += y;
				drawPixel(k, l);
    9a6c:	b249      	sxtb	r1, r1
    9a6e:	b252      	sxtb	r2, r2
    9a70:	1c38      	adds	r0, r7, #0
    9a72:	f7ff fdb7 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
    9a76:	3601      	adds	r6, #1
    9a78:	e7bc      	b.n	99f4 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh+0x6c>
    9a7a:	3501      	adds	r5, #1
    9a7c:	e7a2      	b.n	99c4 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh+0x3c>
			}
		}
	}
}
    9a7e:	b00b      	add	sp, #44	; 0x2c
    9a80:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9a82:	46c0      	nop			; (mov r8, r8)
    9a84:	80000007 	.word	0x80000007

00009a88 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh>:
	return 1;
#endif
}

// Draw a character
void Graphics::drawChar(int16_t x, int16_t y, unsigned char c, uint8_t size) {
    9a88:	b5f0      	push	{r4, r5, r6, r7, lr}
    9a8a:	b093      	sub	sp, #76	; 0x4c
    9a8c:	1c1e      	adds	r6, r3, #0
    9a8e:	ab18      	add	r3, sp, #96	; 0x60
    9a90:	781c      	ldrb	r4, [r3, #0]
	if(!gfxFont) { // 'Classic' built-in font
    9a92:	4b8e      	ldr	r3, [pc, #568]	; (9ccc <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x244>)
	return 1;
#endif
}

// Draw a character
void Graphics::drawChar(int16_t x, int16_t y, unsigned char c, uint8_t size) {
    9a94:	1c05      	adds	r5, r0, #0
	if(!gfxFont) { // 'Classic' built-in font
    9a96:	681b      	ldr	r3, [r3, #0]
	return 1;
#endif
}

// Draw a character
void Graphics::drawChar(int16_t x, int16_t y, unsigned char c, uint8_t size) {
    9a98:	9104      	str	r1, [sp, #16]
    9a9a:	9205      	str	r2, [sp, #20]
	if(!gfxFont) { // 'Classic' built-in font
    9a9c:	2b00      	cmp	r3, #0
    9a9e:	d000      	beq.n	9aa2 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x1a>
    9aa0:	e09b      	b.n	9bda <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x152>

		if((x >= _width)            || // Clip right
    9aa2:	2010      	movs	r0, #16
    9aa4:	5e2b      	ldrsh	r3, [r5, r0]
    9aa6:	428b      	cmp	r3, r1
    9aa8:	dc00      	bgt.n	9aac <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x24>
    9aaa:	e10d      	b.n	9cc8 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x240>
    9aac:	2112      	movs	r1, #18
    9aae:	5e6b      	ldrsh	r3, [r5, r1]
    9ab0:	4293      	cmp	r3, r2
    9ab2:	dc00      	bgt.n	9ab6 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x2e>
    9ab4:	e108      	b.n	9cc8 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x240>
			 (y >= _height)           || // Clip bottom
			 ((x + fontWidth * size - 1) < 0) || // Clip left
    9ab6:	4b86      	ldr	r3, [pc, #536]	; (9cd0 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x248>)
    9ab8:	9a04      	ldr	r2, [sp, #16]
    9aba:	781b      	ldrb	r3, [r3, #0]
    9abc:	4363      	muls	r3, r4
    9abe:	18d3      	adds	r3, r2, r3
// Draw a character
void Graphics::drawChar(int16_t x, int16_t y, unsigned char c, uint8_t size) {
	if(!gfxFont) { // 'Classic' built-in font

		if((x >= _width)            || // Clip right
			 (y >= _height)           || // Clip bottom
    9ac0:	2b00      	cmp	r3, #0
    9ac2:	dc00      	bgt.n	9ac6 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x3e>
    9ac4:	e100      	b.n	9cc8 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x240>
			 ((x + fontWidth * size - 1) < 0) || // Clip left
			 ((y + fontHeight * size - 1) < 0))   // Clip top
    9ac6:	4b83      	ldr	r3, [pc, #524]	; (9cd4 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x24c>)
    9ac8:	9805      	ldr	r0, [sp, #20]
    9aca:	781b      	ldrb	r3, [r3, #0]
    9acc:	4363      	muls	r3, r4
    9ace:	18c3      	adds	r3, r0, r3
void Graphics::drawChar(int16_t x, int16_t y, unsigned char c, uint8_t size) {
	if(!gfxFont) { // 'Classic' built-in font

		if((x >= _width)            || // Clip right
			 (y >= _height)           || // Clip bottom
			 ((x + fontWidth * size - 1) < 0) || // Clip left
    9ad0:	2b00      	cmp	r3, #0
    9ad2:	dc00      	bgt.n	9ad6 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x4e>
    9ad4:	e0f8      	b.n	9cc8 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x240>
			 ((y + fontHeight * size - 1) < 0))   // Clip top
			return;

		if(!_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior
    9ad6:	4b80      	ldr	r3, [pc, #512]	; (9cd8 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x250>)
    9ad8:	781b      	ldrb	r3, [r3, #0]
    9ada:	2b00      	cmp	r3, #0
    9adc:	d103      	bne.n	9ae6 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x5e>
    9ade:	2eaf      	cmp	r6, #175	; 0xaf
    9ae0:	d901      	bls.n	9ae6 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x5e>
    9ae2:	3601      	adds	r6, #1
    9ae4:	b2f6      	uxtb	r6, r6

		if (c >= 0x80) {
    9ae6:	b273      	sxtb	r3, r6
    9ae8:	2b00      	cmp	r3, #0
    9aea:	da01      	bge.n	9af0 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x68>
			c -= 0x20;
    9aec:	3e20      	subs	r6, #32
    9aee:	b2f6      	uxtb	r6, r6
		}

		for (int8_t i = 0; i < fontWidth; i++) {
    9af0:	2100      	movs	r1, #0
    9af2:	9106      	str	r1, [sp, #24]
    9af4:	4a76      	ldr	r2, [pc, #472]	; (9cd0 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x248>)
    9af6:	9806      	ldr	r0, [sp, #24]
    9af8:	7812      	ldrb	r2, [r2, #0]
    9afa:	b243      	sxtb	r3, r0
    9afc:	4293      	cmp	r3, r2
    9afe:	db00      	blt.n	9b02 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x7a>
    9b00:	e0e2      	b.n	9cc8 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x240>
			uint8_t line;
			if (i == (fontWidth - 1))
    9b02:	3a01      	subs	r2, #1
    9b04:	4293      	cmp	r3, r2
    9b06:	d006      	beq.n	9b16 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x8e>
				line = 0x0;
			else
				line = pgm_read_byte(font + (c * (fontWidth - 1)) + i);
    9b08:	4974      	ldr	r1, [pc, #464]	; (9cdc <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x254>)
    9b0a:	4372      	muls	r2, r6
    9b0c:	6809      	ldr	r1, [r1, #0]
    9b0e:	18c9      	adds	r1, r1, r3
    9b10:	5c89      	ldrb	r1, [r1, r2]
    9b12:	9103      	str	r1, [sp, #12]
    9b14:	e001      	b.n	9b1a <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x92>
		}

		for (int8_t i = 0; i < fontWidth; i++) {
			uint8_t line;
			if (i == (fontWidth - 1))
				line = 0x0;
    9b16:	2200      	movs	r2, #0
    9b18:	9203      	str	r2, [sp, #12]
			for (int8_t j = 0; j < fontHeight; j++) {
				if (line & 0x1) {
					if (size == 1) // default size
						drawPixel(x + i, y + j);
					else { // big size
						fillRect(x + (i * size), y + (j * size), size, size);
    9b1a:	b29b      	uxth	r3, r3
    9b1c:	9309      	str	r3, [sp, #36]	; 0x24
    9b1e:	4363      	muls	r3, r4
    9b20:	9804      	ldr	r0, [sp, #16]
    9b22:	2100      	movs	r1, #0
    9b24:	b280      	uxth	r0, r0
    9b26:	18c3      	adds	r3, r0, r3
    9b28:	b29b      	uxth	r3, r3
    9b2a:	9008      	str	r0, [sp, #32]
    9b2c:	930a      	str	r3, [sp, #40]	; 0x28
    9b2e:	9107      	str	r1, [sp, #28]
			uint8_t line;
			if (i == (fontWidth - 1))
				line = 0x0;
			else
				line = pgm_read_byte(font + (c * (fontWidth - 1)) + i);
			for (int8_t j = 0; j < fontHeight; j++) {
    9b30:	9b07      	ldr	r3, [sp, #28]
    9b32:	b25a      	sxtb	r2, r3
    9b34:	4b67      	ldr	r3, [pc, #412]	; (9cd4 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x24c>)
    9b36:	781b      	ldrb	r3, [r3, #0]
    9b38:	429a      	cmp	r2, r3
    9b3a:	da49      	bge.n	9bd0 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x148>
				if (line & 0x1) {
    9b3c:	9b03      	ldr	r3, [sp, #12]
    9b3e:	07db      	lsls	r3, r3, #31
    9b40:	d519      	bpl.n	9b76 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0xee>
					if (size == 1) // default size
    9b42:	2c01      	cmp	r4, #1
    9b44:	d10a      	bne.n	9b5c <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0xd4>
						drawPixel(x + i, y + j);
    9b46:	9809      	ldr	r0, [sp, #36]	; 0x24
    9b48:	9b08      	ldr	r3, [sp, #32]
    9b4a:	18c1      	adds	r1, r0, r3
    9b4c:	9805      	ldr	r0, [sp, #20]
    9b4e:	b209      	sxth	r1, r1
    9b50:	1812      	adds	r2, r2, r0
    9b52:	b212      	sxth	r2, r2
    9b54:	1c28      	adds	r0, r5, #0
    9b56:	f7ff fd45 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
    9b5a:	e031      	b.n	9bc0 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x138>
					else { // big size
						fillRect(x + (i * size), y + (j * size), size, size);
    9b5c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    9b5e:	4362      	muls	r2, r4
    9b60:	b219      	sxth	r1, r3
    9b62:	9b05      	ldr	r3, [sp, #20]
    9b64:	6828      	ldr	r0, [r5, #0]
    9b66:	18d2      	adds	r2, r2, r3
    9b68:	b223      	sxth	r3, r4
    9b6a:	9300      	str	r3, [sp, #0]
    9b6c:	6a87      	ldr	r7, [r0, #40]	; 0x28
    9b6e:	b212      	sxth	r2, r2
    9b70:	1c28      	adds	r0, r5, #0
    9b72:	47b8      	blx	r7
    9b74:	e024      	b.n	9bc0 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x138>
					}
				}
				else if (bgcolor.c != color.c) {
    9b76:	4b5a      	ldr	r3, [pc, #360]	; (9ce0 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x258>)
    9b78:	8819      	ldrh	r1, [r3, #0]
    9b7a:	4b5a      	ldr	r3, [pc, #360]	; (9ce4 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x25c>)
    9b7c:	881f      	ldrh	r7, [r3, #0]
    9b7e:	42b9      	cmp	r1, r7
    9b80:	d01e      	beq.n	9bc0 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x138>
					Color tempcolor = color.c;
					color.c = bgcolor.c;
    9b82:	8019      	strh	r1, [r3, #0]
					if (size == 1) // default size
    9b84:	2c01      	cmp	r4, #1
    9b86:	d10a      	bne.n	9b9e <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x116>
						drawPixel(x + i, y + j);
    9b88:	9809      	ldr	r0, [sp, #36]	; 0x24
    9b8a:	9b08      	ldr	r3, [sp, #32]
    9b8c:	18c1      	adds	r1, r0, r3
    9b8e:	9805      	ldr	r0, [sp, #20]
    9b90:	b209      	sxth	r1, r1
    9b92:	1812      	adds	r2, r2, r0
    9b94:	b212      	sxth	r2, r2
    9b96:	1c28      	adds	r0, r5, #0
    9b98:	f7ff fd24 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
    9b9c:	e00e      	b.n	9bbc <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x134>
					else { // big size
						fillRect(x + i*size, y + j*size, size, size);
    9b9e:	4362      	muls	r2, r4
    9ba0:	990a      	ldr	r1, [sp, #40]	; 0x28
    9ba2:	9b05      	ldr	r3, [sp, #20]
    9ba4:	b209      	sxth	r1, r1
    9ba6:	910b      	str	r1, [sp, #44]	; 0x2c
    9ba8:	18d2      	adds	r2, r2, r3
    9baa:	6829      	ldr	r1, [r5, #0]
    9bac:	b223      	sxth	r3, r4
    9bae:	9300      	str	r3, [sp, #0]
    9bb0:	6a88      	ldr	r0, [r1, #40]	; 0x28
    9bb2:	b212      	sxth	r2, r2
    9bb4:	4684      	mov	ip, r0
    9bb6:	990b      	ldr	r1, [sp, #44]	; 0x2c
    9bb8:	1c28      	adds	r0, r5, #0
    9bba:	47e0      	blx	ip
					}
					color.c = tempcolor; //restore color to its initial value
    9bbc:	4b49      	ldr	r3, [pc, #292]	; (9ce4 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x25c>)
    9bbe:	801f      	strh	r7, [r3, #0]
    9bc0:	9b07      	ldr	r3, [sp, #28]
				}
				line >>= 1;
    9bc2:	9a03      	ldr	r2, [sp, #12]
    9bc4:	3301      	adds	r3, #1
    9bc6:	0852      	lsrs	r2, r2, #1
    9bc8:	b2db      	uxtb	r3, r3
    9bca:	9203      	str	r2, [sp, #12]
    9bcc:	9307      	str	r3, [sp, #28]
    9bce:	e7af      	b.n	9b30 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0xa8>
    9bd0:	9b06      	ldr	r3, [sp, #24]
    9bd2:	3301      	adds	r3, #1
    9bd4:	b2db      	uxtb	r3, r3
    9bd6:	9306      	str	r3, [sp, #24]
    9bd8:	e78c      	b.n	9af4 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x6c>

		// Character is assumed previously filtered by write() to eliminate
		// newlines, returns, non-printable characters, etc.  Calling drawChar()
		// directly with 'bad' characters of font may cause mayhem!

		c -= pgm_read_byte(&gfxFont->first);
    9bda:	7a1a      	ldrb	r2, [r3, #8]
		GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&gfxFont->glyph))[c]);
    9bdc:	6859      	ldr	r1, [r3, #4]

		// Character is assumed previously filtered by write() to eliminate
		// newlines, returns, non-printable characters, etc.  Calling drawChar()
		// directly with 'bad' characters of font may cause mayhem!

		c -= pgm_read_byte(&gfxFont->first);
    9bde:	1ab6      	subs	r6, r6, r2
		GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&gfxFont->glyph))[c]);
    9be0:	b2f6      	uxtb	r6, r6
		uint8_t  *bitmap = (uint8_t *)pgm_read_pointer(&gfxFont->bitmap);
    9be2:	681b      	ldr	r3, [r3, #0]
		// Character is assumed previously filtered by write() to eliminate
		// newlines, returns, non-printable characters, etc.  Calling drawChar()
		// directly with 'bad' characters of font may cause mayhem!

		c -= pgm_read_byte(&gfxFont->first);
		GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&gfxFont->glyph))[c]);
    9be4:	00f6      	lsls	r6, r6, #3
    9be6:	1876      	adds	r6, r6, r1
		uint8_t  *bitmap = (uint8_t *)pgm_read_pointer(&gfxFont->bitmap);

		uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
    9be8:	8832      	ldrh	r2, [r6, #0]
		uint8_t  w  = pgm_read_byte(&glyph->width),
					 h  = pgm_read_byte(&glyph->height),
    9bea:	78f0      	ldrb	r0, [r6, #3]
					 xa = pgm_read_byte(&glyph->xAdvance);
		int8_t   xo = pgm_read_byte(&glyph->xOffset),
    9bec:	7971      	ldrb	r1, [r6, #5]
		// newlines, returns, non-printable characters, etc.  Calling drawChar()
		// directly with 'bad' characters of font may cause mayhem!

		c -= pgm_read_byte(&gfxFont->first);
		GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&gfxFont->glyph))[c]);
		uint8_t  *bitmap = (uint8_t *)pgm_read_pointer(&gfxFont->bitmap);
    9bee:	930e      	str	r3, [sp, #56]	; 0x38

		uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
		uint8_t  w  = pgm_read_byte(&glyph->width),
    9bf0:	78b3      	ldrb	r3, [r6, #2]
					 h  = pgm_read_byte(&glyph->height),
					 xa = pgm_read_byte(&glyph->xAdvance);
		int8_t   xo = pgm_read_byte(&glyph->xOffset),
					 yo = pgm_read_byte(&glyph->yOffset);
    9bf2:	79b6      	ldrb	r6, [r6, #6]

		c -= pgm_read_byte(&gfxFont->first);
		GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&gfxFont->glyph))[c]);
		uint8_t  *bitmap = (uint8_t *)pgm_read_pointer(&gfxFont->bitmap);

		uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
    9bf4:	9203      	str	r2, [sp, #12]
		uint8_t  w  = pgm_read_byte(&glyph->width),
    9bf6:	9308      	str	r3, [sp, #32]
					 h  = pgm_read_byte(&glyph->height),
    9bf8:	900f      	str	r0, [sp, #60]	; 0x3c
					 xa = pgm_read_byte(&glyph->xAdvance);
		int8_t   xo = pgm_read_byte(&glyph->xOffset),
    9bfa:	9109      	str	r1, [sp, #36]	; 0x24
					 yo = pgm_read_byte(&glyph->yOffset);
    9bfc:	960a      	str	r6, [sp, #40]	; 0x28
		uint8_t  xx, yy, bits, bit = 0;
		int16_t  xo16, yo16;

		if(size > 1) {
    9bfe:	2c01      	cmp	r4, #1
    9c00:	d904      	bls.n	9c0c <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x184>
			xo16 = xo;
			yo16 = yo;
    9c02:	b273      	sxtb	r3, r6
					 yo = pgm_read_byte(&glyph->yOffset);
		uint8_t  xx, yy, bits, bit = 0;
		int16_t  xo16, yo16;

		if(size > 1) {
			xo16 = xo;
    9c04:	b24f      	sxtb	r7, r1
			yo16 = yo;
    9c06:	b29b      	uxth	r3, r3
					 yo = pgm_read_byte(&glyph->yOffset);
		uint8_t  xx, yy, bits, bit = 0;
		int16_t  xo16, yo16;

		if(size > 1) {
			xo16 = xo;
    9c08:	b2bf      	uxth	r7, r7
			yo16 = yo;
    9c0a:	930d      	str	r3, [sp, #52]	; 0x34
    9c0c:	4367      	muls	r7, r4
    9c0e:	9a04      	ldr	r2, [sp, #16]
		// only creates a new set of problems.  Have an idea to work around
		// this (a canvas object type for MCUs that can afford the RAM and
		// displays supporting setAddrWindow() and pushColors()), but haven't
		// implemented this yet.

		for(yy=0; yy<h; yy++) {
    9c10:	2600      	movs	r6, #0
    9c12:	b292      	uxth	r2, r2
    9c14:	19d7      	adds	r7, r2, r7
    9c16:	b2bf      	uxth	r7, r7
    9c18:	920c      	str	r2, [sp, #48]	; 0x30
    9c1a:	9710      	str	r7, [sp, #64]	; 0x40
		uint8_t  w  = pgm_read_byte(&glyph->width),
					 h  = pgm_read_byte(&glyph->height),
					 xa = pgm_read_byte(&glyph->xAdvance);
		int8_t   xo = pgm_read_byte(&glyph->xOffset),
					 yo = pgm_read_byte(&glyph->yOffset);
		uint8_t  xx, yy, bits, bit = 0;
    9c1c:	9604      	str	r6, [sp, #16]
		// only creates a new set of problems.  Have an idea to work around
		// this (a canvas object type for MCUs that can afford the RAM and
		// displays supporting setAddrWindow() and pushColors()), but haven't
		// implemented this yet.

		for(yy=0; yy<h; yy++) {
    9c1e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    9c20:	b2f3      	uxtb	r3, r6
    9c22:	4293      	cmp	r3, r2
    9c24:	d250      	bcs.n	9cc8 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x240>
				}
				if(bits & 0x80) {
					if(size == 1) {
						drawPixel(x+xo+xx, y+yo+yy);
					} else {
						fillRect(x+(xo16+xx)*size, y+(yo16+yy)*size, size, size);
    9c26:	9b05      	ldr	r3, [sp, #20]
    9c28:	980d      	ldr	r0, [sp, #52]	; 0x34
    9c2a:	b29b      	uxth	r3, r3
    9c2c:	930b      	str	r3, [sp, #44]	; 0x2c
    9c2e:	1833      	adds	r3, r6, r0
    9c30:	4363      	muls	r3, r4
    9c32:	990b      	ldr	r1, [sp, #44]	; 0x2c
    9c34:	9a10      	ldr	r2, [sp, #64]	; 0x40
    9c36:	18cb      	adds	r3, r1, r3
    9c38:	b29b      	uxth	r3, r3
    9c3a:	9311      	str	r3, [sp, #68]	; 0x44
    9c3c:	9207      	str	r2, [sp, #28]
    9c3e:	2700      	movs	r7, #0
    9c40:	9804      	ldr	r0, [sp, #16]
    9c42:	b2fb      	uxtb	r3, r7
		// this (a canvas object type for MCUs that can afford the RAM and
		// displays supporting setAddrWindow() and pushColors()), but haven't
		// implemented this yet.

		for(yy=0; yy<h; yy++) {
			for(xx=0; xx<w; xx++) {
    9c44:	9908      	ldr	r1, [sp, #32]
    9c46:	181a      	adds	r2, r3, r0
    9c48:	b2d2      	uxtb	r2, r2
    9c4a:	428b      	cmp	r3, r1
    9c4c:	d236      	bcs.n	9cbc <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x234>
				if(!(bit++ & 7)) {
    9c4e:	0753      	lsls	r3, r2, #29
    9c50:	d107      	bne.n	9c62 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x1da>
					bits = pgm_read_byte(&bitmap[bo++]);
    9c52:	9b03      	ldr	r3, [sp, #12]
    9c54:	9903      	ldr	r1, [sp, #12]
    9c56:	980e      	ldr	r0, [sp, #56]	; 0x38
    9c58:	3301      	adds	r3, #1
    9c5a:	5c40      	ldrb	r0, [r0, r1]
    9c5c:	b29b      	uxth	r3, r3
    9c5e:	9006      	str	r0, [sp, #24]
    9c60:	9303      	str	r3, [sp, #12]
				}
				if(bits & 0x80) {
    9c62:	9906      	ldr	r1, [sp, #24]
    9c64:	0609      	lsls	r1, r1, #24
    9c66:	d51e      	bpl.n	9ca6 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x21e>
					if(size == 1) {
    9c68:	2c01      	cmp	r4, #1
    9c6a:	d10f      	bne.n	9c8c <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x204>
						drawPixel(x+xo+xx, y+yo+yy);
    9c6c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    9c6e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9c70:	980a      	ldr	r0, [sp, #40]	; 0x28
    9c72:	b251      	sxtb	r1, r2
    9c74:	1859      	adds	r1, r3, r1
    9c76:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    9c78:	b242      	sxtb	r2, r0
    9c7a:	189a      	adds	r2, r3, r2
    9c7c:	1879      	adds	r1, r7, r1
    9c7e:	18b2      	adds	r2, r6, r2
    9c80:	b209      	sxth	r1, r1
    9c82:	b212      	sxth	r2, r2
    9c84:	1c28      	adds	r0, r5, #0
    9c86:	f7ff fcad 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
    9c8a:	e00c      	b.n	9ca6 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x21e>
					} else {
						fillRect(x+(xo16+xx)*size, y+(yo16+yy)*size, size, size);
    9c8c:	9a11      	ldr	r2, [sp, #68]	; 0x44
    9c8e:	9807      	ldr	r0, [sp, #28]
    9c90:	b212      	sxth	r2, r2
    9c92:	9202      	str	r2, [sp, #8]
    9c94:	b223      	sxth	r3, r4
    9c96:	682a      	ldr	r2, [r5, #0]
    9c98:	9300      	str	r3, [sp, #0]
    9c9a:	b201      	sxth	r1, r0
    9c9c:	6a90      	ldr	r0, [r2, #40]	; 0x28
    9c9e:	9a02      	ldr	r2, [sp, #8]
    9ca0:	4684      	mov	ip, r0
    9ca2:	1c28      	adds	r0, r5, #0
    9ca4:	47e0      	blx	ip
					}
				}
				bits <<= 1;
    9ca6:	9806      	ldr	r0, [sp, #24]
    9ca8:	9907      	ldr	r1, [sp, #28]
    9caa:	0043      	lsls	r3, r0, #1
    9cac:	b2db      	uxtb	r3, r3
    9cae:	9306      	str	r3, [sp, #24]
    9cb0:	190b      	adds	r3, r1, r4
    9cb2:	b29b      	uxth	r3, r3
    9cb4:	3701      	adds	r7, #1
    9cb6:	9307      	str	r3, [sp, #28]
    9cb8:	b2bf      	uxth	r7, r7
    9cba:	e7c1      	b.n	9c40 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x1b8>
    9cbc:	1843      	adds	r3, r0, r1
    9cbe:	b2db      	uxtb	r3, r3
    9cc0:	3601      	adds	r6, #1
    9cc2:	9304      	str	r3, [sp, #16]
    9cc4:	b2b6      	uxth	r6, r6
    9cc6:	e7aa      	b.n	9c1e <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh+0x196>
			}
		}

	} // End classic vs custom font
}
    9cc8:	b013      	add	sp, #76	; 0x4c
    9cca:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9ccc:	20000cd0 	.word	0x20000cd0
    9cd0:	20000cc0 	.word	0x20000cc0
    9cd4:	20000cd5 	.word	0x20000cd5
    9cd8:	20000cda 	.word	0x20000cda
    9cdc:	20000cc8 	.word	0x20000cc8
    9ce0:	20000cc2 	.word	0x20000cc2
    9ce4:	20000cd8 	.word	0x20000cd8

00009ce8 <_ZN14Gamebuino_Meta8Graphics11setTmpColorENS_10ColorIndexE>:
	Color tmpColor = color.c;
	color.c = c;
	return tmpColor;
}

Color Graphics::setTmpColor(ColorIndex c) {
    9ce8:	b508      	push	{r3, lr}
	if (colorMode == ColorMode::index) {
    9cea:	7a83      	ldrb	r3, [r0, #10]
    9cec:	2b01      	cmp	r3, #1
    9cee:	d107      	bne.n	9d00 <_ZN14Gamebuino_Meta8Graphics11setTmpColorENS_10ColorIndexE+0x18>
		Color tmpColor = color.c;
    9cf0:	4b07      	ldr	r3, [pc, #28]	; (9d10 <_ZN14Gamebuino_Meta8Graphics11setTmpColorENS_10ColorIndexE+0x28>)
		color.i = (uint8_t)c & 0x0F;
    9cf2:	220f      	movs	r2, #15
    9cf4:	4011      	ands	r1, r2
	return tmpColor;
}

Color Graphics::setTmpColor(ColorIndex c) {
	if (colorMode == ColorMode::index) {
		Color tmpColor = color.c;
    9cf6:	8818      	ldrh	r0, [r3, #0]
		color.i = (uint8_t)c & 0x0F;
    9cf8:	7059      	strb	r1, [r3, #1]
		color.iu = color.i << 4;
    9cfa:	0109      	lsls	r1, r1, #4
    9cfc:	7019      	strb	r1, [r3, #0]
    9cfe:	e005      	b.n	9d0c <_ZN14Gamebuino_Meta8Graphics11setTmpColorENS_10ColorIndexE+0x24>
		return tmpColor;
	}
	return setTmpColor(colorIndex[(uint8_t)c]);
    9d00:	4b04      	ldr	r3, [pc, #16]	; (9d14 <_ZN14Gamebuino_Meta8Graphics11setTmpColorENS_10ColorIndexE+0x2c>)
    9d02:	0049      	lsls	r1, r1, #1
    9d04:	681b      	ldr	r3, [r3, #0]
    9d06:	5ac9      	ldrh	r1, [r1, r3]
    9d08:	f000 f814 	bl	9d34 <_ZN14Gamebuino_Meta8Graphics11setTmpColorENS_5ColorE>
}
    9d0c:	bd08      	pop	{r3, pc}
    9d0e:	46c0      	nop			; (mov r8, r8)
    9d10:	20000cd8 	.word	0x20000cd8
    9d14:	20000050 	.word	0x20000050

00009d18 <_ZN14Gamebuino_Meta8Graphics4fillENS_10ColorIndexE>:
	fill(c);
	setColor(complimentary[(uint8_t)c]);
	clearTextVars();
}

void Graphics::fill(ColorIndex c) {
    9d18:	b538      	push	{r3, r4, r5, lr}
    9d1a:	1c04      	adds	r4, r0, #0
	Color tmpColor = setTmpColor(c);
    9d1c:	f7ff ffe4 	bl	9ce8 <_ZN14Gamebuino_Meta8Graphics11setTmpColorENS_10ColorIndexE>
    9d20:	1c05      	adds	r5, r0, #0
	fill();
    9d22:	1c20      	adds	r0, r4, #0
    9d24:	f7ff fc07 	bl	9536 <_ZN14Gamebuino_Meta8Graphics4fillEv>
	color.c = tmpColor;
    9d28:	4b01      	ldr	r3, [pc, #4]	; (9d30 <_ZN14Gamebuino_Meta8Graphics4fillENS_10ColorIndexE+0x18>)
    9d2a:	801d      	strh	r5, [r3, #0]
}
    9d2c:	bd38      	pop	{r3, r4, r5, pc}
    9d2e:	46c0      	nop			; (mov r8, r8)
    9d30:	20000cd8 	.word	0x20000cd8

00009d34 <_ZN14Gamebuino_Meta8Graphics11setTmpColorENS_5ColorE>:
	Color tmpColor = setTmpColor(c);
	drawPixel(x, y);
	color.c = tmpColor;
}

Color Graphics::setTmpColor(Color c) {
    9d34:	b510      	push	{r4, lr}
	if (colorMode == ColorMode::index) {
    9d36:	7a83      	ldrb	r3, [r0, #10]
	Color tmpColor = setTmpColor(c);
	drawPixel(x, y);
	color.c = tmpColor;
}

Color Graphics::setTmpColor(Color c) {
    9d38:	1c04      	adds	r4, r0, #0
	if (colorMode == ColorMode::index) {
    9d3a:	2b01      	cmp	r3, #1
    9d3c:	d107      	bne.n	9d4e <_ZN14Gamebuino_Meta8Graphics11setTmpColorENS_5ColorE+0x1a>
		return setTmpColor(rgb565ToIndex(c));
    9d3e:	1c08      	adds	r0, r1, #0
    9d40:	f7ff fb12 	bl	9368 <_ZN14Gamebuino_Meta8Graphics13rgb565ToIndexENS_5ColorE>
    9d44:	1c01      	adds	r1, r0, #0
    9d46:	1c20      	adds	r0, r4, #0
    9d48:	f7ff ffce 	bl	9ce8 <_ZN14Gamebuino_Meta8Graphics11setTmpColorENS_10ColorIndexE>
    9d4c:	e002      	b.n	9d54 <_ZN14Gamebuino_Meta8Graphics11setTmpColorENS_5ColorE+0x20>
	}
	Color tmpColor = color.c;
    9d4e:	4b02      	ldr	r3, [pc, #8]	; (9d58 <_ZN14Gamebuino_Meta8Graphics11setTmpColorENS_5ColorE+0x24>)
    9d50:	8818      	ldrh	r0, [r3, #0]
	color.c = c;
    9d52:	8019      	strh	r1, [r3, #0]
	return tmpColor;
}
    9d54:	bd10      	pop	{r4, pc}
    9d56:	46c0      	nop			; (mov r8, r8)
    9d58:	20000cd8 	.word	0x20000cd8

00009d5c <_ZN14Gamebuino_Meta8Graphics4fillENS_5ColorE>:

void Graphics::fill() {
	_fill();
}

void Graphics::fill(Color c) {
    9d5c:	b538      	push	{r3, r4, r5, lr}
    9d5e:	1c04      	adds	r4, r0, #0
	Color tmpColor = setTmpColor(c);
    9d60:	f7ff ffe8 	bl	9d34 <_ZN14Gamebuino_Meta8Graphics11setTmpColorENS_5ColorE>
    9d64:	1c05      	adds	r5, r0, #0
	fill();
    9d66:	1c20      	adds	r0, r4, #0
    9d68:	f7ff fbe5 	bl	9536 <_ZN14Gamebuino_Meta8Graphics4fillEv>
	color.c = tmpColor;
    9d6c:	4b01      	ldr	r3, [pc, #4]	; (9d74 <_ZN14Gamebuino_Meta8Graphics4fillENS_5ColorE+0x18>)
    9d6e:	801d      	strh	r5, [r3, #0]
}
    9d70:	bd38      	pop	{r3, r4, r5, pc}
    9d72:	46c0      	nop			; (mov r8, r8)
    9d74:	20000cd8 	.word	0x20000cd8

00009d78 <_ZN14Gamebuino_Meta8Graphics9drawPixelEssNS_5ColorE>:

void Graphics::drawPixel(int16_t x, int16_t y) {
	_drawPixel(x, y);
}

void Graphics::drawPixel(int16_t x, int16_t y, Color c) {
    9d78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9d7a:	1c0f      	adds	r7, r1, #0
	Color tmpColor = setTmpColor(c);
    9d7c:	1c19      	adds	r1, r3, #0

void Graphics::drawPixel(int16_t x, int16_t y) {
	_drawPixel(x, y);
}

void Graphics::drawPixel(int16_t x, int16_t y, Color c) {
    9d7e:	1c16      	adds	r6, r2, #0
    9d80:	1c04      	adds	r4, r0, #0
	Color tmpColor = setTmpColor(c);
    9d82:	f7ff ffd7 	bl	9d34 <_ZN14Gamebuino_Meta8Graphics11setTmpColorENS_5ColorE>
	drawPixel(x, y);
    9d86:	1c39      	adds	r1, r7, #0
void Graphics::drawPixel(int16_t x, int16_t y) {
	_drawPixel(x, y);
}

void Graphics::drawPixel(int16_t x, int16_t y, Color c) {
	Color tmpColor = setTmpColor(c);
    9d88:	1c05      	adds	r5, r0, #0
	drawPixel(x, y);
    9d8a:	1c32      	adds	r2, r6, #0
    9d8c:	1c20      	adds	r0, r4, #0
    9d8e:	f7ff fc29 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
	color.c = tmpColor;
    9d92:	4b01      	ldr	r3, [pc, #4]	; (9d98 <_ZN14Gamebuino_Meta8Graphics9drawPixelEssNS_5ColorE+0x20>)
    9d94:	801d      	strh	r5, [r3, #0]
}
    9d96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9d98:	20000cd8 	.word	0x20000cd8

00009d9c <_ZN14Gamebuino_Meta8Graphics8setColorENS_10ColorIndexE>:
		color.c = c;
		bgcolor.c = b;
	}
}

void Graphics::setColor(ColorIndex c) {
    9d9c:	b508      	push	{r3, lr}
	if (colorMode == ColorMode::index) {
    9d9e:	7a83      	ldrb	r3, [r0, #10]
    9da0:	2b01      	cmp	r3, #1
    9da2:	d109      	bne.n	9db8 <_ZN14Gamebuino_Meta8Graphics8setColorENS_10ColorIndexE+0x1c>
		color.i = (uint8_t)c & 0x0F;
    9da4:	230f      	movs	r3, #15
    9da6:	4019      	ands	r1, r3
    9da8:	4b07      	ldr	r3, [pc, #28]	; (9dc8 <_ZN14Gamebuino_Meta8Graphics8setColorENS_10ColorIndexE+0x2c>)
    9daa:	7059      	strb	r1, [r3, #1]
		color.iu = color.i << 4;
    9dac:	0109      	lsls	r1, r1, #4
    9dae:	7019      	strb	r1, [r3, #0]
		bgcolor.c = color.c; // simpler to just have them be the same
    9db0:	881a      	ldrh	r2, [r3, #0]
    9db2:	4b06      	ldr	r3, [pc, #24]	; (9dcc <_ZN14Gamebuino_Meta8Graphics8setColorENS_10ColorIndexE+0x30>)
    9db4:	801a      	strh	r2, [r3, #0]
    9db6:	e005      	b.n	9dc4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_10ColorIndexE+0x28>
	} else {
		setColor(colorIndex[(uint8_t)c]);
    9db8:	4b05      	ldr	r3, [pc, #20]	; (9dd0 <_ZN14Gamebuino_Meta8Graphics8setColorENS_10ColorIndexE+0x34>)
    9dba:	0049      	lsls	r1, r1, #1
    9dbc:	681b      	ldr	r3, [r3, #0]
    9dbe:	5ac9      	ldrh	r1, [r1, r3]
    9dc0:	f000 f808 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
	}
}
    9dc4:	bd08      	pop	{r3, pc}
    9dc6:	46c0      	nop			; (mov r8, r8)
    9dc8:	20000cd8 	.word	0x20000cd8
    9dcc:	20000cc2 	.word	0x20000cc2
    9dd0:	20000050 	.word	0x20000050

00009dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>:
		return tmpColor;
	}
	return setTmpColor(colorIndex[(uint8_t)c]);
}

void Graphics::setColor(Color c) {
    9dd4:	b510      	push	{r4, lr}
	// For 'transparent' background, we'll set the bg
	// to the same as fg instead of using a flag
	if (colorMode == ColorMode::index) {
    9dd6:	7a83      	ldrb	r3, [r0, #10]
		return tmpColor;
	}
	return setTmpColor(colorIndex[(uint8_t)c]);
}

void Graphics::setColor(Color c) {
    9dd8:	1c04      	adds	r4, r0, #0
	// For 'transparent' background, we'll set the bg
	// to the same as fg instead of using a flag
	if (colorMode == ColorMode::index) {
    9dda:	2b01      	cmp	r3, #1
    9ddc:	d107      	bne.n	9dee <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE+0x1a>
		setColor(rgb565ToIndex(c));
    9dde:	1c08      	adds	r0, r1, #0
    9de0:	f7ff fac2 	bl	9368 <_ZN14Gamebuino_Meta8Graphics13rgb565ToIndexENS_5ColorE>
    9de4:	1c01      	adds	r1, r0, #0
    9de6:	1c20      	adds	r0, r4, #0
    9de8:	f7ff ffd8 	bl	9d9c <_ZN14Gamebuino_Meta8Graphics8setColorENS_10ColorIndexE>
    9dec:	e003      	b.n	9df6 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE+0x22>
	} else {
		color.c = bgcolor.c = c;
    9dee:	4b02      	ldr	r3, [pc, #8]	; (9df8 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE+0x24>)
    9df0:	8019      	strh	r1, [r3, #0]
    9df2:	4b02      	ldr	r3, [pc, #8]	; (9dfc <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE+0x28>)
    9df4:	8019      	strh	r1, [r3, #0]
	}
}
    9df6:	bd10      	pop	{r4, pc}
    9df8:	20000cc2 	.word	0x20000cc2
    9dfc:	20000cd8 	.word	0x20000cd8

00009e00 <_ZN14Gamebuino_Meta8Graphics8setColorENS_10ColorIndexES1_>:
		bgcolor.c = color.c; // simpler to just have them be the same
	} else {
		setColor(colorIndex[(uint8_t)c]);
	}
}
void Graphics::setColor(ColorIndex c, ColorIndex bg) {
    9e00:	b508      	push	{r3, lr}
	if (colorMode == ColorMode::index) {
    9e02:	7a83      	ldrb	r3, [r0, #10]
    9e04:	2b01      	cmp	r3, #1
    9e06:	d10b      	bne.n	9e20 <_ZN14Gamebuino_Meta8Graphics8setColorENS_10ColorIndexES1_+0x20>
		color.i = (uint8_t)c & 0x0F;
    9e08:	230f      	movs	r3, #15
    9e0a:	4019      	ands	r1, r3
		color.iu = color.i << 4;
		bgcolor.i = (uint8_t)bg & 0x0F;
    9e0c:	401a      	ands	r2, r3
		setColor(colorIndex[(uint8_t)c]);
	}
}
void Graphics::setColor(ColorIndex c, ColorIndex bg) {
	if (colorMode == ColorMode::index) {
		color.i = (uint8_t)c & 0x0F;
    9e0e:	4809      	ldr	r0, [pc, #36]	; (9e34 <_ZN14Gamebuino_Meta8Graphics8setColorENS_10ColorIndexES1_+0x34>)
		color.iu = color.i << 4;
		bgcolor.i = (uint8_t)bg & 0x0F;
    9e10:	4b09      	ldr	r3, [pc, #36]	; (9e38 <_ZN14Gamebuino_Meta8Graphics8setColorENS_10ColorIndexES1_+0x38>)
		setColor(colorIndex[(uint8_t)c]);
	}
}
void Graphics::setColor(ColorIndex c, ColorIndex bg) {
	if (colorMode == ColorMode::index) {
		color.i = (uint8_t)c & 0x0F;
    9e12:	7041      	strb	r1, [r0, #1]
		color.iu = color.i << 4;
		bgcolor.i = (uint8_t)bg & 0x0F;
    9e14:	705a      	strb	r2, [r3, #1]
	}
}
void Graphics::setColor(ColorIndex c, ColorIndex bg) {
	if (colorMode == ColorMode::index) {
		color.i = (uint8_t)c & 0x0F;
		color.iu = color.i << 4;
    9e16:	0109      	lsls	r1, r1, #4
		bgcolor.i = (uint8_t)bg & 0x0F;
		bgcolor.iu = bgcolor.i << 4;
    9e18:	0112      	lsls	r2, r2, #4
	}
}
void Graphics::setColor(ColorIndex c, ColorIndex bg) {
	if (colorMode == ColorMode::index) {
		color.i = (uint8_t)c & 0x0F;
		color.iu = color.i << 4;
    9e1a:	7001      	strb	r1, [r0, #0]
		bgcolor.i = (uint8_t)bg & 0x0F;
		bgcolor.iu = bgcolor.i << 4;
    9e1c:	701a      	strb	r2, [r3, #0]
    9e1e:	e007      	b.n	9e30 <_ZN14Gamebuino_Meta8Graphics8setColorENS_10ColorIndexES1_+0x30>
	} else {
		setColor(colorIndex[(uint8_t)c], colorIndex[(uint8_t)bg]);
    9e20:	4b06      	ldr	r3, [pc, #24]	; (9e3c <_ZN14Gamebuino_Meta8Graphics8setColorENS_10ColorIndexES1_+0x3c>)
    9e22:	0049      	lsls	r1, r1, #1
    9e24:	681b      	ldr	r3, [r3, #0]
    9e26:	0052      	lsls	r2, r2, #1
    9e28:	5ac9      	ldrh	r1, [r1, r3]
    9e2a:	5ad2      	ldrh	r2, [r2, r3]
    9e2c:	f000 f808 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
	}
}
    9e30:	bd08      	pop	{r3, pc}
    9e32:	46c0      	nop			; (mov r8, r8)
    9e34:	20000cd8 	.word	0x20000cd8
    9e38:	20000cc2 	.word	0x20000cc2
    9e3c:	20000050 	.word	0x20000050

00009e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>:
	} else {
		color.c = bgcolor.c = c;
	}
}

void Graphics::setColor(Color c, Color b) {
    9e40:	b570      	push	{r4, r5, r6, lr}
	if (colorMode == ColorMode::index) {
    9e42:	7a83      	ldrb	r3, [r0, #10]
	} else {
		color.c = bgcolor.c = c;
	}
}

void Graphics::setColor(Color c, Color b) {
    9e44:	1c05      	adds	r5, r0, #0
    9e46:	1c14      	adds	r4, r2, #0
	if (colorMode == ColorMode::index) {
    9e48:	2b01      	cmp	r3, #1
    9e4a:	d10c      	bne.n	9e66 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_+0x26>
		setColor(rgb565ToIndex(c), rgb565ToIndex(b));
    9e4c:	1c08      	adds	r0, r1, #0
    9e4e:	f7ff fa8b 	bl	9368 <_ZN14Gamebuino_Meta8Graphics13rgb565ToIndexENS_5ColorE>
    9e52:	1c06      	adds	r6, r0, #0
    9e54:	1c20      	adds	r0, r4, #0
    9e56:	f7ff fa87 	bl	9368 <_ZN14Gamebuino_Meta8Graphics13rgb565ToIndexENS_5ColorE>
    9e5a:	1c31      	adds	r1, r6, #0
    9e5c:	1c02      	adds	r2, r0, #0
    9e5e:	1c28      	adds	r0, r5, #0
    9e60:	f7ff ffce 	bl	9e00 <_ZN14Gamebuino_Meta8Graphics8setColorENS_10ColorIndexES1_>
    9e64:	e003      	b.n	9e6e <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_+0x2e>
	} else {
		color.c = c;
    9e66:	4b02      	ldr	r3, [pc, #8]	; (9e70 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_+0x30>)
    9e68:	8019      	strh	r1, [r3, #0]
		bgcolor.c = b;
    9e6a:	4b02      	ldr	r3, [pc, #8]	; (9e74 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_+0x34>)
    9e6c:	801a      	strh	r2, [r3, #0]
	}
}
    9e6e:	bd70      	pop	{r4, r5, r6, pc}
    9e70:	20000cd8 	.word	0x20000cd8
    9e74:	20000cc2 	.word	0x20000cc2

00009e78 <_ZN14Gamebuino_Meta8Graphics19setTransparentColorENS_5ColorE>:

void Graphics::setColor(uint8_t c, uint8_t bg) {
	setColor((ColorIndex)c, (ColorIndex)bg);
}

void Graphics::setTransparentColor(Color c) {
    9e78:	b510      	push	{r4, lr}
	if (colorMode == ColorMode::index) {
    9e7a:	7a83      	ldrb	r3, [r0, #10]

void Graphics::setColor(uint8_t c, uint8_t bg) {
	setColor((ColorIndex)c, (ColorIndex)bg);
}

void Graphics::setTransparentColor(Color c) {
    9e7c:	1c04      	adds	r4, r0, #0
	if (colorMode == ColorMode::index) {
    9e7e:	2b01      	cmp	r3, #1
    9e80:	d105      	bne.n	9e8e <_ZN14Gamebuino_Meta8Graphics19setTransparentColorENS_5ColorE+0x16>
		useTransparentIndex = true;
    9e82:	7243      	strb	r3, [r0, #9]
		transparentColorIndex = (uint8_t)rgb565ToIndex(c);
    9e84:	1c08      	adds	r0, r1, #0
    9e86:	f7ff fa6f 	bl	9368 <_ZN14Gamebuino_Meta8Graphics13rgb565ToIndexENS_5ColorE>
    9e8a:	7220      	strb	r0, [r4, #8]
    9e8c:	e000      	b.n	9e90 <_ZN14Gamebuino_Meta8Graphics19setTransparentColorENS_5ColorE+0x18>
	} else {
		transparentColor = (uint16_t)c;
    9e8e:	8101      	strh	r1, [r0, #8]
	}
}
    9e90:	bd10      	pop	{r4, pc}
	...

00009e94 <_ZN14Gamebuino_Meta8Graphics9setCursorEss>:
void Graphics::setCursorY(int16_t y) {
	cursorY = y;
}

void Graphics::setCursor(int16_t x, int16_t y) {
	cursorX = x;
    9e94:	4b02      	ldr	r3, [pc, #8]	; (9ea0 <_ZN14Gamebuino_Meta8Graphics9setCursorEss+0xc>)
    9e96:	8019      	strh	r1, [r3, #0]
	cursorY = y;
    9e98:	4b02      	ldr	r3, [pc, #8]	; (9ea4 <_ZN14Gamebuino_Meta8Graphics9setCursorEss+0x10>)
    9e9a:	801a      	strh	r2, [r3, #0]
}
    9e9c:	4770      	bx	lr
    9e9e:	46c0      	nop			; (mov r8, r8)
    9ea0:	20000cdc 	.word	0x20000cdc
    9ea4:	20000cc4 	.word	0x20000cc4

00009ea8 <_ZN14Gamebuino_Meta8Graphics7setFontEPKh>:
	gfxFont = (GFXfont *)f;
}

//gamebuino legacy font
void Graphics::setFont(const uint8_t *f) {
	font = (uint8_t*)f;
    9ea8:	4b07      	ldr	r3, [pc, #28]	; (9ec8 <_ZN14Gamebuino_Meta8Graphics7setFontEPKh+0x20>)
	fontWidth = pgm_read_byte(font) + 1;
    9eaa:	4a08      	ldr	r2, [pc, #32]	; (9ecc <_ZN14Gamebuino_Meta8Graphics7setFontEPKh+0x24>)
	gfxFont = (GFXfont *)f;
}

//gamebuino legacy font
void Graphics::setFont(const uint8_t *f) {
	font = (uint8_t*)f;
    9eac:	6019      	str	r1, [r3, #0]
	fontWidth = pgm_read_byte(font) + 1;
    9eae:	7808      	ldrb	r0, [r1, #0]
    9eb0:	3001      	adds	r0, #1
    9eb2:	7010      	strb	r0, [r2, #0]
	fontHeight = pgm_read_byte(font + 1) + 1;
    9eb4:	7848      	ldrb	r0, [r1, #1]
    9eb6:	4a06      	ldr	r2, [pc, #24]	; (9ed0 <_ZN14Gamebuino_Meta8Graphics7setFontEPKh+0x28>)
	font += 2; //offset the pointer to start after the width and height bytes
    9eb8:	3102      	adds	r1, #2
    9eba:	6019      	str	r1, [r3, #0]

//gamebuino legacy font
void Graphics::setFont(const uint8_t *f) {
	font = (uint8_t*)f;
	fontWidth = pgm_read_byte(font) + 1;
	fontHeight = pgm_read_byte(font + 1) + 1;
    9ebc:	3001      	adds	r0, #1
	font += 2; //offset the pointer to start after the width and height bytes
	_cp437 = true; // disable the old compatibility mode
    9ebe:	4b05      	ldr	r3, [pc, #20]	; (9ed4 <_ZN14Gamebuino_Meta8Graphics7setFontEPKh+0x2c>)

//gamebuino legacy font
void Graphics::setFont(const uint8_t *f) {
	font = (uint8_t*)f;
	fontWidth = pgm_read_byte(font) + 1;
	fontHeight = pgm_read_byte(font + 1) + 1;
    9ec0:	7010      	strb	r0, [r2, #0]
	font += 2; //offset the pointer to start after the width and height bytes
	_cp437 = true; // disable the old compatibility mode
    9ec2:	2201      	movs	r2, #1
    9ec4:	701a      	strb	r2, [r3, #0]
}
    9ec6:	4770      	bx	lr
    9ec8:	20000cc8 	.word	0x20000cc8
    9ecc:	20000cc0 	.word	0x20000cc0
    9ed0:	20000cd5 	.word	0x20000cd5
    9ed4:	20000cda 	.word	0x20000cda

00009ed8 <_ZN14Gamebuino_Meta8GraphicsC1Ess>:

#ifndef _swap_int16_t
#define _swap_int16_t(a, b) { int16_t t = a; a = b; b = t; }
#endif

Graphics::Graphics(int16_t w, int16_t h) : WIDTH(w), HEIGHT(h) {
    9ed8:	4b11      	ldr	r3, [pc, #68]	; (9f20 <_ZN14Gamebuino_Meta8GraphicsC1Ess+0x48>)
    9eda:	b570      	push	{r4, r5, r6, lr}
    9edc:	3308      	adds	r3, #8
    9ede:	6003      	str	r3, [r0, #0]
	_width    = WIDTH;
	_height   = HEIGHT;
	rotation  = 0;
    9ee0:	4b10      	ldr	r3, [pc, #64]	; (9f24 <_ZN14Gamebuino_Meta8GraphicsC1Ess+0x4c>)
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    9ee2:	2500      	movs	r5, #0
    9ee4:	701d      	strb	r5, [r3, #0]
	cursorY  = cursorX    = 0;
    9ee6:	4b10      	ldr	r3, [pc, #64]	; (9f28 <_ZN14Gamebuino_Meta8GraphicsC1Ess+0x50>)
    9ee8:	6045      	str	r5, [r0, #4]
    9eea:	801d      	strh	r5, [r3, #0]
    9eec:	4b0f      	ldr	r3, [pc, #60]	; (9f2c <_ZN14Gamebuino_Meta8GraphicsC1Ess+0x54>)

#ifndef _swap_int16_t
#define _swap_int16_t(a, b) { int16_t t = a; a = b; b = t; }
#endif

Graphics::Graphics(int16_t w, int16_t h) : WIDTH(w), HEIGHT(h) {
    9eee:	81c2      	strh	r2, [r0, #14]
	_width    = WIDTH;
	_height   = HEIGHT;
	rotation  = 0;
	cursorY  = cursorX    = 0;
    9ef0:	801d      	strh	r5, [r3, #0]
	fontSize  = 1;
    9ef2:	4b0f      	ldr	r3, [pc, #60]	; (9f30 <_ZN14Gamebuino_Meta8GraphicsC1Ess+0x58>)
#define _swap_int16_t(a, b) { int16_t t = a; a = b; b = t; }
#endif

Graphics::Graphics(int16_t w, int16_t h) : WIDTH(w), HEIGHT(h) {
	_width    = WIDTH;
	_height   = HEIGHT;
    9ef4:	8242      	strh	r2, [r0, #18]
	rotation  = 0;
	cursorY  = cursorX    = 0;
	fontSize  = 1;
    9ef6:	2601      	movs	r6, #1

#ifndef _swap_int16_t
#define _swap_int16_t(a, b) { int16_t t = a; a = b; b = t; }
#endif

Graphics::Graphics(int16_t w, int16_t h) : WIDTH(w), HEIGHT(h) {
    9ef8:	8181      	strh	r1, [r0, #12]
	_width    = WIDTH;
    9efa:	8201      	strh	r1, [r0, #16]
	_height   = HEIGHT;
	rotation  = 0;
	cursorY  = cursorX    = 0;
	fontSize  = 1;
	setColor(Color::white);
    9efc:	490d      	ldr	r1, [pc, #52]	; (9f34 <_ZN14Gamebuino_Meta8GraphicsC1Ess+0x5c>)

#ifndef _swap_int16_t
#define _swap_int16_t(a, b) { int16_t t = a; a = b; b = t; }
#endif

Graphics::Graphics(int16_t w, int16_t h) : WIDTH(w), HEIGHT(h) {
    9efe:	1c04      	adds	r4, r0, #0
	_width    = WIDTH;
	_height   = HEIGHT;
	rotation  = 0;
	cursorY  = cursorX    = 0;
	fontSize  = 1;
    9f00:	701e      	strb	r6, [r3, #0]
	setColor(Color::white);
    9f02:	f7ff ff67 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
	textWrap      = true;
    9f06:	4b0c      	ldr	r3, [pc, #48]	; (9f38 <_ZN14Gamebuino_Meta8GraphicsC1Ess+0x60>)
	_cp437    = false;
	gfxFont   = NULL;
	colorMode = ColorMode::rgb565;
    9f08:	72a5      	strb	r5, [r4, #10]
	_height   = HEIGHT;
	rotation  = 0;
	cursorY  = cursorX    = 0;
	fontSize  = 1;
	setColor(Color::white);
	textWrap      = true;
    9f0a:	701e      	strb	r6, [r3, #0]
	_cp437    = false;
    9f0c:	4b0b      	ldr	r3, [pc, #44]	; (9f3c <_ZN14Gamebuino_Meta8GraphicsC1Ess+0x64>)
	gfxFont   = NULL;
	colorMode = ColorMode::rgb565;
	setFont(font3x5);
    9f0e:	1c20      	adds	r0, r4, #0
	rotation  = 0;
	cursorY  = cursorX    = 0;
	fontSize  = 1;
	setColor(Color::white);
	textWrap      = true;
	_cp437    = false;
    9f10:	701d      	strb	r5, [r3, #0]
	gfxFont   = NULL;
    9f12:	4b0b      	ldr	r3, [pc, #44]	; (9f40 <_ZN14Gamebuino_Meta8GraphicsC1Ess+0x68>)
	colorMode = ColorMode::rgb565;
	setFont(font3x5);
    9f14:	490b      	ldr	r1, [pc, #44]	; (9f44 <_ZN14Gamebuino_Meta8GraphicsC1Ess+0x6c>)
	cursorY  = cursorX    = 0;
	fontSize  = 1;
	setColor(Color::white);
	textWrap      = true;
	_cp437    = false;
	gfxFont   = NULL;
    9f16:	601d      	str	r5, [r3, #0]
	colorMode = ColorMode::rgb565;
	setFont(font3x5);
    9f18:	f7ff ffc6 	bl	9ea8 <_ZN14Gamebuino_Meta8Graphics7setFontEPKh>
}
    9f1c:	1c20      	adds	r0, r4, #0
    9f1e:	bd70      	pop	{r4, r5, r6, pc}
    9f20:	000153c8 	.word	0x000153c8
    9f24:	20000ccc 	.word	0x20000ccc
    9f28:	20000cdc 	.word	0x20000cdc
    9f2c:	20000cc4 	.word	0x20000cc4
    9f30:	20000cd4 	.word	0x20000cd4
    9f34:	0000ffff 	.word	0x0000ffff
    9f38:	20000077 	.word	0x20000077
    9f3c:	20000cda 	.word	0x20000cda
    9f40:	20000cd0 	.word	0x20000cd0
    9f44:	00015110 	.word	0x00015110

00009f48 <_ZN14Gamebuino_Meta8Graphics13clearTextVarsEv>:
void Graphics::setCursorY(int16_t y) {
	cursorY = y;
}

void Graphics::setCursor(int16_t x, int16_t y) {
	cursorX = x;
    9f48:	4a07      	ldr	r2, [pc, #28]	; (9f68 <_ZN14Gamebuino_Meta8Graphics13clearTextVarsEv+0x20>)
	Color tmpColor = setTmpColor(c);
	fill();
	color.c = tmpColor;
}

void Graphics::clearTextVars() {
    9f4a:	b508      	push	{r3, lr}
void Graphics::setCursorY(int16_t y) {
	cursorY = y;
}

void Graphics::setCursor(int16_t x, int16_t y) {
	cursorX = x;
    9f4c:	2300      	movs	r3, #0
    9f4e:	8013      	strh	r3, [r2, #0]
	cursorY = y;
    9f50:	4a06      	ldr	r2, [pc, #24]	; (9f6c <_ZN14Gamebuino_Meta8Graphics13clearTextVarsEv+0x24>)
	color.c = tmpColor;
}

void Graphics::clearTextVars() {
	setCursor(0, 0);
	setFont(font3x5);
    9f52:	4907      	ldr	r1, [pc, #28]	; (9f70 <_ZN14Gamebuino_Meta8Graphics13clearTextVarsEv+0x28>)
	cursorY = y;
}

void Graphics::setCursor(int16_t x, int16_t y) {
	cursorX = x;
	cursorY = y;
    9f54:	8013      	strh	r3, [r2, #0]
	color.c = tmpColor;
}

void Graphics::clearTextVars() {
	setCursor(0, 0);
	setFont(font3x5);
    9f56:	f7ff ffa7 	bl	9ea8 <_ZN14Gamebuino_Meta8Graphics7setFontEPKh>
	fontSize = DEFAULT_FONT_SIZE;
    9f5a:	4a06      	ldr	r2, [pc, #24]	; (9f74 <_ZN14Gamebuino_Meta8Graphics13clearTextVarsEv+0x2c>)
    9f5c:	2301      	movs	r3, #1
    9f5e:	7013      	strb	r3, [r2, #0]
	textWrap = true;
    9f60:	4a05      	ldr	r2, [pc, #20]	; (9f78 <_ZN14Gamebuino_Meta8Graphics13clearTextVarsEv+0x30>)
    9f62:	7013      	strb	r3, [r2, #0]
}
    9f64:	bd08      	pop	{r3, pc}
    9f66:	46c0      	nop			; (mov r8, r8)
    9f68:	20000cdc 	.word	0x20000cdc
    9f6c:	20000cc4 	.word	0x20000cc4
    9f70:	00015110 	.word	0x00015110
    9f74:	20000cd4 	.word	0x20000cd4
    9f78:	20000077 	.word	0x20000077

00009f7c <_ZN14Gamebuino_Meta8Graphics5clearENS_5ColorE>:

void Graphics::clear() {
	clear(Color::black);
}

void Graphics::clear(Color c) {
    9f7c:	b538      	push	{r3, r4, r5, lr}
	if (colorMode == ColorMode::index) {
    9f7e:	7a83      	ldrb	r3, [r0, #10]

void Graphics::clear() {
	clear(Color::black);
}

void Graphics::clear(Color c) {
    9f80:	1c04      	adds	r4, r0, #0
    9f82:	1c0d      	adds	r5, r1, #0
	if (colorMode == ColorMode::index) {
    9f84:	2b01      	cmp	r3, #1
    9f86:	d107      	bne.n	9f98 <_ZN14Gamebuino_Meta8Graphics5clearENS_5ColorE+0x1c>
		clear(rgb565ToIndex(c));
    9f88:	1c08      	adds	r0, r1, #0
    9f8a:	f7ff f9ed 	bl	9368 <_ZN14Gamebuino_Meta8Graphics13rgb565ToIndexENS_5ColorE>
    9f8e:	1c01      	adds	r1, r0, #0
    9f90:	1c20      	adds	r0, r4, #0
    9f92:	f000 f80d 	bl	9fb0 <_ZN14Gamebuino_Meta8Graphics5clearENS_10ColorIndexE>
    9f96:	e009      	b.n	9fac <_ZN14Gamebuino_Meta8Graphics5clearENS_5ColorE+0x30>
		return;
	}
	fill(c);
	setColor((Color)(0xFFFF ^ (uint16_t)c));
    9f98:	43ed      	mvns	r5, r5
void Graphics::clear(Color c) {
	if (colorMode == ColorMode::index) {
		clear(rgb565ToIndex(c));
		return;
	}
	fill(c);
    9f9a:	f7ff fedf 	bl	9d5c <_ZN14Gamebuino_Meta8Graphics4fillENS_5ColorE>
	setColor((Color)(0xFFFF ^ (uint16_t)c));
    9f9e:	1c20      	adds	r0, r4, #0
    9fa0:	b2a9      	uxth	r1, r5
    9fa2:	f7ff ff17 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
	clearTextVars();
    9fa6:	1c20      	adds	r0, r4, #0
    9fa8:	f7ff ffce 	bl	9f48 <_ZN14Gamebuino_Meta8Graphics13clearTextVarsEv>
}
    9fac:	bd38      	pop	{r3, r4, r5, pc}
	...

00009fb0 <_ZN14Gamebuino_Meta8Graphics5clearENS_10ColorIndexE>:

void Graphics::clear(ColorIndex c) {
    9fb0:	b530      	push	{r4, r5, lr}
    9fb2:	b085      	sub	sp, #20
    9fb4:	1c04      	adds	r4, r0, #0
    9fb6:	1c0d      	adds	r5, r1, #0
		ColorIndex::purple, // lightgreen
		ColorIndex::pink, // lightblue
		ColorIndex::beige, // blue
		ColorIndex::lightblue, // pink
		ColorIndex::blue, // beige
	};
    9fb8:	4668      	mov	r0, sp
    9fba:	490e      	ldr	r1, [pc, #56]	; (9ff4 <_ZN14Gamebuino_Meta8Graphics5clearENS_10ColorIndexE+0x44>)
    9fbc:	2210      	movs	r2, #16
    9fbe:	f007 fafc 	bl	115ba <memcpy>
	if (colorMode == ColorMode::rgb565) {
    9fc2:	7aa3      	ldrb	r3, [r4, #10]
    9fc4:	2b00      	cmp	r3, #0
    9fc6:	d107      	bne.n	9fd8 <_ZN14Gamebuino_Meta8Graphics5clearENS_10ColorIndexE+0x28>
		clear(colorIndex[(uint8_t)c]);
    9fc8:	4b0b      	ldr	r3, [pc, #44]	; (9ff8 <_ZN14Gamebuino_Meta8Graphics5clearENS_10ColorIndexE+0x48>)
    9fca:	006d      	lsls	r5, r5, #1
    9fcc:	681b      	ldr	r3, [r3, #0]
    9fce:	1c20      	adds	r0, r4, #0
    9fd0:	5ae9      	ldrh	r1, [r5, r3]
    9fd2:	f7ff ffd3 	bl	9f7c <_ZN14Gamebuino_Meta8Graphics5clearENS_5ColorE>
    9fd6:	e00b      	b.n	9ff0 <_ZN14Gamebuino_Meta8Graphics5clearENS_10ColorIndexE+0x40>
		return;
	}
	fill(c);
    9fd8:	1c20      	adds	r0, r4, #0
    9fda:	1c29      	adds	r1, r5, #0
    9fdc:	f7ff fe9c 	bl	9d18 <_ZN14Gamebuino_Meta8Graphics4fillENS_10ColorIndexE>
	setColor(complimentary[(uint8_t)c]);
    9fe0:	466b      	mov	r3, sp
    9fe2:	1c20      	adds	r0, r4, #0
    9fe4:	5d59      	ldrb	r1, [r3, r5]
    9fe6:	f7ff fed9 	bl	9d9c <_ZN14Gamebuino_Meta8Graphics8setColorENS_10ColorIndexE>
	clearTextVars();
    9fea:	1c20      	adds	r0, r4, #0
    9fec:	f7ff ffac 	bl	9f48 <_ZN14Gamebuino_Meta8Graphics13clearTextVarsEv>
}
    9ff0:	b005      	add	sp, #20
    9ff2:	bd30      	pop	{r4, r5, pc}
    9ff4:	000153b2 	.word	0x000153b2
    9ff8:	20000050 	.word	0x20000050

00009ffc <_ZN14Gamebuino_Meta8Graphics5clearEv>:
	setFont(font3x5);
	fontSize = DEFAULT_FONT_SIZE;
	textWrap = true;
}

void Graphics::clear() {
    9ffc:	b508      	push	{r3, lr}
	clear(Color::black);
    9ffe:	2100      	movs	r1, #0
    a000:	f7ff ffbc 	bl	9f7c <_ZN14Gamebuino_Meta8Graphics5clearENS_5ColorE>
}
    a004:	bd08      	pop	{r3, pc}
	...

0000a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>:
	} // End classic vs custom font
}

// Return the size of the display (per current rotation)
int16_t Graphics::width(void) const {
	if (gb.inited || _width) {
    a008:	23b6      	movs	r3, #182	; 0xb6
    a00a:	4a06      	ldr	r2, [pc, #24]	; (a024 <_ZNK14Gamebuino_Meta8Graphics5widthEv+0x1c>)
    a00c:	005b      	lsls	r3, r3, #1
    a00e:	5cd3      	ldrb	r3, [r2, r3]
    a010:	2b00      	cmp	r3, #0
    a012:	d104      	bne.n	a01e <_ZNK14Gamebuino_Meta8Graphics5widthEv+0x16>
    a014:	2310      	movs	r3, #16
    a016:	5ec2      	ldrsh	r2, [r0, r3]
	}
	// we aren't inited, so let's try our best guess
#if DISPLAY_MODE == DISPLAY_MODE_INDEX
	return 160;
#else
	return 80;
    a018:	2350      	movs	r3, #80	; 0x50
	} // End classic vs custom font
}

// Return the size of the display (per current rotation)
int16_t Graphics::width(void) const {
	if (gb.inited || _width) {
    a01a:	2a00      	cmp	r2, #0
    a01c:	d000      	beq.n	a020 <_ZNK14Gamebuino_Meta8Graphics5widthEv+0x18>
		// we are inited
		return _width;
    a01e:	8a03      	ldrh	r3, [r0, #16]
    a020:	b218      	sxth	r0, r3
#if DISPLAY_MODE == DISPLAY_MODE_INDEX
	return 160;
#else
	return 80;
#endif
}
    a022:	4770      	bx	lr
    a024:	20000a3c 	.word	0x20000a3c

0000a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>:

int16_t Graphics::height(void) const {
	if (gb.inited || _height) {
    a028:	23b6      	movs	r3, #182	; 0xb6
    a02a:	4a06      	ldr	r2, [pc, #24]	; (a044 <_ZNK14Gamebuino_Meta8Graphics6heightEv+0x1c>)
    a02c:	005b      	lsls	r3, r3, #1
    a02e:	5cd3      	ldrb	r3, [r2, r3]
    a030:	2b00      	cmp	r3, #0
    a032:	d104      	bne.n	a03e <_ZNK14Gamebuino_Meta8Graphics6heightEv+0x16>
    a034:	2312      	movs	r3, #18
    a036:	5ec2      	ldrsh	r2, [r0, r3]
	}
	// we aren't inited, so let's try our best guess
#if DISPLAY_MODE == DISPLAY_MODE_INDEX
	return 128;
#else
	return 64;
    a038:	2340      	movs	r3, #64	; 0x40
	return 80;
#endif
}

int16_t Graphics::height(void) const {
	if (gb.inited || _height) {
    a03a:	2a00      	cmp	r2, #0
    a03c:	d000      	beq.n	a040 <_ZNK14Gamebuino_Meta8Graphics6heightEv+0x18>
		// we are inited
		return _height;
    a03e:	8a43      	ldrh	r3, [r0, #18]
    a040:	b218      	sxth	r0, r3
#if DISPLAY_MODE == DISPLAY_MODE_INDEX
	return 128;
#else
	return 64;
#endif
}
    a042:	4770      	bx	lr
    a044:	20000a3c 	.word	0x20000a3c

0000a048 <_ZN14Gamebuino_Meta13Frame_HandlerD1Ev>:
	img = _img;
	buf = img->_buffer;
	bufferSize = img->bufferSize;
}

Frame_Handler::~Frame_Handler() {
    a048:	4b05      	ldr	r3, [pc, #20]	; (a060 <_ZN14Gamebuino_Meta13Frame_HandlerD1Ev+0x18>)
	if (buf) {
    a04a:	6882      	ldr	r2, [r0, #8]
	img = _img;
	buf = img->_buffer;
	bufferSize = img->bufferSize;
}

Frame_Handler::~Frame_Handler() {
    a04c:	3308      	adds	r3, #8
    a04e:	6003      	str	r3, [r0, #0]
	if (buf) {
    a050:	2a00      	cmp	r2, #0
    a052:	d003      	beq.n	a05c <_ZN14Gamebuino_Meta13Frame_HandlerD1Ev+0x14>
		img->_buffer = buf;
    a054:	6843      	ldr	r3, [r0, #4]
    a056:	615a      	str	r2, [r3, #20]
		img->bufferSize = bufferSize;
    a058:	8982      	ldrh	r2, [r0, #12]
    a05a:	845a      	strh	r2, [r3, #34]	; 0x22
	}
}
    a05c:	4770      	bx	lr
    a05e:	46c0      	nop			; (mov r8, r8)
    a060:	00015458 	.word	0x00015458

0000a064 <_ZN14Gamebuino_Meta13Frame_Handler5firstEv>:

void Frame_Handler::first() {
    a064:	b508      	push	{r3, lr}
	set(0);
    a066:	6803      	ldr	r3, [r0, #0]
    a068:	2100      	movs	r1, #0
    a06a:	68db      	ldr	r3, [r3, #12]
    a06c:	4798      	blx	r3
}
    a06e:	bd08      	pop	{r3, pc}

0000a070 <_ZN14Gamebuino_Meta17Frame_Handler_MemD1Ev>:

Frame_Handler_Mem::Frame_Handler_Mem(Image* _img) : Frame_Handler(_img) {
	
}

Frame_Handler_Mem::~Frame_Handler_Mem() {
    a070:	4b08      	ldr	r3, [pc, #32]	; (a094 <_ZN14Gamebuino_Meta17Frame_Handler_MemD1Ev+0x24>)
	if (buf) {
    a072:	6882      	ldr	r2, [r0, #8]

Frame_Handler_Mem::Frame_Handler_Mem(Image* _img) : Frame_Handler(_img) {
	
}

Frame_Handler_Mem::~Frame_Handler_Mem() {
    a074:	3308      	adds	r3, #8
    a076:	b510      	push	{r4, lr}
    a078:	1c04      	adds	r4, r0, #0
    a07a:	6003      	str	r3, [r0, #0]
	if (buf) {
    a07c:	2a00      	cmp	r2, #0
    a07e:	d003      	beq.n	a088 <_ZN14Gamebuino_Meta17Frame_Handler_MemD1Ev+0x18>
		img->_buffer = buf;
    a080:	6843      	ldr	r3, [r0, #4]
    a082:	615a      	str	r2, [r3, #20]
		img->bufferSize = 0;
    a084:	2200      	movs	r2, #0
    a086:	845a      	strh	r2, [r3, #34]	; 0x22
	}
}
    a088:	1c20      	adds	r0, r4, #0
    a08a:	f7ff ffdd 	bl	a048 <_ZN14Gamebuino_Meta13Frame_HandlerD1Ev>
    a08e:	1c20      	adds	r0, r4, #0
    a090:	bd10      	pop	{r4, pc}
    a092:	46c0      	nop			; (mov r8, r8)
    a094:	00015438 	.word	0x00015438

0000a098 <_ZN14Gamebuino_Meta17Frame_Handler_RAMD1Ev>:

Frame_Handler_RAM::Frame_Handler_RAM(Image* _img) : Frame_Handler_Mem(_img) {
	allocateBuffer();
}

Frame_Handler_RAM::~Frame_Handler_RAM() {
    a098:	4b08      	ldr	r3, [pc, #32]	; (a0bc <_ZN14Gamebuino_Meta17Frame_Handler_RAMD1Ev+0x24>)
	if (buf) {
    a09a:	6882      	ldr	r2, [r0, #8]

Frame_Handler_RAM::Frame_Handler_RAM(Image* _img) : Frame_Handler_Mem(_img) {
	allocateBuffer();
}

Frame_Handler_RAM::~Frame_Handler_RAM() {
    a09c:	3308      	adds	r3, #8
    a09e:	b510      	push	{r4, lr}
    a0a0:	1c04      	adds	r4, r0, #0
    a0a2:	6003      	str	r3, [r0, #0]
	if (buf) {
    a0a4:	2a00      	cmp	r2, #0
    a0a6:	d003      	beq.n	a0b0 <_ZN14Gamebuino_Meta17Frame_Handler_RAMD1Ev+0x18>
		img->_buffer = buf;
    a0a8:	6843      	ldr	r3, [r0, #4]
    a0aa:	615a      	str	r2, [r3, #20]
		img->bufferSize = bufferSize;
    a0ac:	8982      	ldrh	r2, [r0, #12]
    a0ae:	845a      	strh	r2, [r3, #34]	; 0x22
	}
}
    a0b0:	1c20      	adds	r0, r4, #0
    a0b2:	f7ff ffdd 	bl	a070 <_ZN14Gamebuino_Meta17Frame_Handler_MemD1Ev>
    a0b6:	1c20      	adds	r0, r4, #0
    a0b8:	bd10      	pop	{r4, pc}
    a0ba:	46c0      	nop			; (mov r8, r8)
    a0bc:	00015418 	.word	0x00015418

0000a0c0 <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss>:
		free(_buffer);
		_buffer = 0;
	}
}

void Image::drawFastHLine(int16_t x, int16_t y, int16_t w) {
    a0c0:	b5f0      	push	{r4, r5, r6, r7, lr}
	// Don't draw if we are outside the screen
	if (x + w <= 0 || x >= _width || y < 0 || y >= _height) return;
    a0c2:	18cc      	adds	r4, r1, r3
		free(_buffer);
		_buffer = 0;
	}
}

void Image::drawFastHLine(int16_t x, int16_t y, int16_t w) {
    a0c4:	b083      	sub	sp, #12
	// Don't draw if we are outside the screen
	if (x + w <= 0 || x >= _width || y < 0 || y >= _height) return;
    a0c6:	2c00      	cmp	r4, #0
    a0c8:	dd39      	ble.n	a13e <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss+0x7e>
    a0ca:	2510      	movs	r5, #16
    a0cc:	5f44      	ldrsh	r4, [r0, r5]
    a0ce:	42a1      	cmp	r1, r4
    a0d0:	da35      	bge.n	a13e <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss+0x7e>
    a0d2:	2a00      	cmp	r2, #0
    a0d4:	db33      	blt.n	a13e <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss+0x7e>
    a0d6:	2612      	movs	r6, #18
    a0d8:	5f85      	ldrsh	r5, [r0, r6]
    a0da:	4295      	cmp	r5, r2
    a0dc:	dd2f      	ble.n	a13e <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss+0x7e>
	
	if (colorMode == ColorMode::rgb565) {
    a0de:	7a85      	ldrb	r5, [r0, #10]
    a0e0:	2d00      	cmp	r5, #0
    a0e2:	d12e      	bne.n	a142 <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss+0x82>

		
		// Clamp value so we don't go outside the buffer
		uint16_t new_x = max(x,0);
    a0e4:	43cf      	mvns	r7, r1
    a0e6:	17ff      	asrs	r7, r7, #31
    a0e8:	400f      	ands	r7, r1
		uint32_t bound = new_x + min(w - (new_x - x),_width-new_x);
    a0ea:	b23d      	sxth	r5, r7
    a0ec:	1b49      	subs	r1, r1, r5
    a0ee:	185b      	adds	r3, r3, r1
	
	if (colorMode == ColorMode::rgb565) {

		
		// Clamp value so we don't go outside the buffer
		uint16_t new_x = max(x,0);
    a0f0:	b2bf      	uxth	r7, r7
		uint32_t bound = new_x + min(w - (new_x - x),_width-new_x);
    a0f2:	1b61      	subs	r1, r4, r5
    a0f4:	46a4      	mov	ip, r4
    a0f6:	428b      	cmp	r3, r1
    a0f8:	dd00      	ble.n	a0fc <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss+0x3c>
    a0fa:	1c0b      	adds	r3, r1, #0
    a0fc:	18eb      	adds	r3, r5, r3

		if (new_x%2 == 1){
    a0fe:	07f9      	lsls	r1, r7, #31
    a100:	d427      	bmi.n	a152 <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss+0x92>
    a102:	6946      	ldr	r6, [r0, #20]
    a104:	4919      	ldr	r1, [pc, #100]	; (a16c <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss+0xac>)
			_buffer[y * _width + new_x] = (uint16_t)color.c;
			new_x ++;
		}
		
		_buffer[y * _width + bound-1] = (uint16_t)color.c;
    a106:	4664      	mov	r4, ip
    a108:	4354      	muls	r4, r2
    a10a:	4d19      	ldr	r5, [pc, #100]	; (a170 <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss+0xb0>)
    a10c:	191c      	adds	r4, r3, r4
    a10e:	1964      	adds	r4, r4, r5
    a110:	880d      	ldrh	r5, [r1, #0]
    a112:	0064      	lsls	r4, r4, #1
		for (uint32_t i = new_x>>1; i < (bound>>1); i++){
    a114:	107f      	asrs	r7, r7, #1
    a116:	085b      	lsrs	r3, r3, #1
		if (new_x%2 == 1){
			_buffer[y * _width + new_x] = (uint16_t)color.c;
			new_x ++;
		}
		
		_buffer[y * _width + bound-1] = (uint16_t)color.c;
    a118:	53a5      	strh	r5, [r4, r6]
		for (uint32_t i = new_x>>1; i < (bound>>1); i++){
    a11a:	429f      	cmp	r7, r3
    a11c:	d20f      	bcs.n	a13e <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss+0x7e>
    a11e:	2410      	movs	r4, #16
    a120:	5f00      	ldrsh	r0, [r0, r4]
    a122:	8809      	ldrh	r1, [r1, #0]
    a124:	1040      	asrs	r0, r0, #1
    a126:	4342      	muls	r2, r0
    a128:	18bf      	adds	r7, r7, r2
    a12a:	189a      	adds	r2, r3, r2
    a12c:	00bf      	lsls	r7, r7, #2
    a12e:	0092      	lsls	r2, r2, #2
    a130:	0408      	lsls	r0, r1, #16
    a132:	19f3      	adds	r3, r6, r7
    a134:	18b2      	adds	r2, r6, r2
    a136:	4301      	orrs	r1, r0
			((uint32_t*)_buffer)[(y * (_width>>1)) + i] = ((uint16_t)color.c << 16) | (uint16_t)color.c;
    a138:	c302      	stmia	r3!, {r1}
			_buffer[y * _width + new_x] = (uint16_t)color.c;
			new_x ++;
		}
		
		_buffer[y * _width + bound-1] = (uint16_t)color.c;
		for (uint32_t i = new_x>>1; i < (bound>>1); i++){
    a13a:	4293      	cmp	r3, r2
    a13c:	d1fc      	bne.n	a138 <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss+0x78>
			((uint32_t*)_buffer)[(y * (_width>>1)) + i] = ((uint16_t)color.c << 16) | (uint16_t)color.c;
		}
		return;
	}
	drawLine(x, y, x+w-1, y);
}
    a13e:	b003      	add	sp, #12
    a140:	bdf0      	pop	{r4, r5, r6, r7, pc}
		for (uint32_t i = new_x>>1; i < (bound>>1); i++){
			((uint32_t*)_buffer)[(y * (_width>>1)) + i] = ((uint16_t)color.c << 16) | (uint16_t)color.c;
		}
		return;
	}
	drawLine(x, y, x+w-1, y);
    a142:	6804      	ldr	r4, [r0, #0]
    a144:	3b01      	subs	r3, #1
    a146:	185b      	adds	r3, r3, r1
    a148:	9200      	str	r2, [sp, #0]
    a14a:	b21b      	sxth	r3, r3
    a14c:	69a4      	ldr	r4, [r4, #24]
    a14e:	47a0      	blx	r4
    a150:	e7f5      	b.n	a13e <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss+0x7e>
		// Clamp value so we don't go outside the buffer
		uint16_t new_x = max(x,0);
		uint32_t bound = new_x + min(w - (new_x - x),_width-new_x);

		if (new_x%2 == 1){
			_buffer[y * _width + new_x] = (uint16_t)color.c;
    a152:	4354      	muls	r4, r2
    a154:	4905      	ldr	r1, [pc, #20]	; (a16c <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss+0xac>)
    a156:	192d      	adds	r5, r5, r4
    a158:	6946      	ldr	r6, [r0, #20]
    a15a:	880c      	ldrh	r4, [r1, #0]
    a15c:	006d      	lsls	r5, r5, #1
    a15e:	53ac      	strh	r4, [r5, r6]
    a160:	2510      	movs	r5, #16
    a162:	5f44      	ldrsh	r4, [r0, r5]
			new_x ++;
    a164:	3701      	adds	r7, #1
    a166:	46a4      	mov	ip, r4
    a168:	b2bf      	uxth	r7, r7
    a16a:	e7cc      	b.n	a106 <_ZN14Gamebuino_Meta5Image13drawFastHLineEsss+0x46>
    a16c:	20000cd8 	.word	0x20000cd8
    a170:	7fffffff 	.word	0x7fffffff

0000a174 <_ZN14Gamebuino_Meta5Image10_drawPixelEss>:
	frame_handler->set(frame);
	last_frame = gb.frameCount & 0xFF; // we already loaded this frame!
	frame_loopcounter = 0;
}

void Image::_drawPixel(int16_t x, int16_t y) {
    a174:	b570      	push	{r4, r5, r6, lr}
	if (!_buffer) {
    a176:	6944      	ldr	r4, [r0, #20]
    a178:	2c00      	cmp	r4, #0
    a17a:	d032      	beq.n	a1e2 <_ZN14Gamebuino_Meta5Image10_drawPixelEss+0x6e>
		return;
	}
	if ((x < 0) || (y < 0) || (x >= _width) || (y >= _height)) {
    a17c:	2900      	cmp	r1, #0
    a17e:	db30      	blt.n	a1e2 <_ZN14Gamebuino_Meta5Image10_drawPixelEss+0x6e>
    a180:	2a00      	cmp	r2, #0
    a182:	db2e      	blt.n	a1e2 <_ZN14Gamebuino_Meta5Image10_drawPixelEss+0x6e>
    a184:	2310      	movs	r3, #16
    a186:	5ec5      	ldrsh	r5, [r0, r3]
    a188:	42a9      	cmp	r1, r5
    a18a:	da2a      	bge.n	a1e2 <_ZN14Gamebuino_Meta5Image10_drawPixelEss+0x6e>
    a18c:	2612      	movs	r6, #18
    a18e:	5f83      	ldrsh	r3, [r0, r6]
    a190:	4293      	cmp	r3, r2
    a192:	dd26      	ble.n	a1e2 <_ZN14Gamebuino_Meta5Image10_drawPixelEss+0x6e>
		return;
	}
	if (colorMode == ColorMode::rgb565) {
    a194:	7a80      	ldrb	r0, [r0, #10]
    a196:	2800      	cmp	r0, #0
    a198:	d106      	bne.n	a1a8 <_ZN14Gamebuino_Meta5Image10_drawPixelEss+0x34>
		_buffer[x + y * _width] = (uint16_t)color.c;
    a19a:	436a      	muls	r2, r5
    a19c:	4b11      	ldr	r3, [pc, #68]	; (a1e4 <_ZN14Gamebuino_Meta5Image10_drawPixelEss+0x70>)
    a19e:	1889      	adds	r1, r1, r2
    a1a0:	8818      	ldrh	r0, [r3, #0]
    a1a2:	0049      	lsls	r1, r1, #1
    a1a4:	5308      	strh	r0, [r1, r4]
		return;
    a1a6:	e01c      	b.n	a1e2 <_ZN14Gamebuino_Meta5Image10_drawPixelEss+0x6e>
	}
	if (colorMode == ColorMode::index) {
    a1a8:	2801      	cmp	r0, #1
    a1aa:	d11a      	bne.n	a1e2 <_ZN14Gamebuino_Meta5Image10_drawPixelEss+0x6e>
		uint16_t addr = ((_width + 1) / 2) * y + x / 2;
    a1ac:	3501      	adds	r5, #1
    a1ae:	0fee      	lsrs	r6, r5, #31
    a1b0:	1975      	adds	r5, r6, r5
    a1b2:	106d      	asrs	r5, r5, #1
    a1b4:	436a      	muls	r2, r5
    a1b6:	0fcb      	lsrs	r3, r1, #31
    a1b8:	185b      	adds	r3, r3, r1
    a1ba:	105b      	asrs	r3, r3, #1
    a1bc:	189b      	adds	r3, r3, r2
    a1be:	b29b      	uxth	r3, r3
    a1c0:	18e3      	adds	r3, r4, r3
    a1c2:	4d08      	ldr	r5, [pc, #32]	; (a1e4 <_ZN14Gamebuino_Meta5Image10_drawPixelEss+0x70>)
    a1c4:	240f      	movs	r4, #15
		uint8_t* buf = (uint8_t*)_buffer;
		if (!(x % 2)) { //odd pixels
			buf[addr] &= 0x0F; //clear
    a1c6:	781a      	ldrb	r2, [r3, #0]
		return;
	}
	if (colorMode == ColorMode::index) {
		uint16_t addr = ((_width + 1) / 2) * y + x / 2;
		uint8_t* buf = (uint8_t*)_buffer;
		if (!(x % 2)) { //odd pixels
    a1c8:	4201      	tst	r1, r0
    a1ca:	d105      	bne.n	a1d8 <_ZN14Gamebuino_Meta5Image10_drawPixelEss+0x64>
			buf[addr] &= 0x0F; //clear
    a1cc:	4014      	ands	r4, r2
    a1ce:	701c      	strb	r4, [r3, #0]
			buf[addr] |= (uint8_t)color.iu; //set
    a1d0:	782a      	ldrb	r2, [r5, #0]
    a1d2:	4314      	orrs	r4, r2
    a1d4:	701c      	strb	r4, [r3, #0]
    a1d6:	e004      	b.n	a1e2 <_ZN14Gamebuino_Meta5Image10_drawPixelEss+0x6e>
		} else { //even pixels
			buf[addr] &= 0xF0; //clear
    a1d8:	43a2      	bics	r2, r4
    a1da:	701a      	strb	r2, [r3, #0]
			buf[addr] |= (uint8_t)color.i; //set
    a1dc:	7869      	ldrb	r1, [r5, #1]
    a1de:	430a      	orrs	r2, r1
    a1e0:	701a      	strb	r2, [r3, #0]
		}
		return;
	}
}
    a1e2:	bd70      	pop	{r4, r5, r6, pc}
    a1e4:	20000cd8 	.word	0x20000cd8

0000a1e8 <_ZN14Gamebuino_Meta13Frame_HandlerD0Ev>:
	img = _img;
	buf = img->_buffer;
	bufferSize = img->bufferSize;
}

Frame_Handler::~Frame_Handler() {
    a1e8:	b510      	push	{r4, lr}
    a1ea:	1c04      	adds	r4, r0, #0
	if (buf) {
		img->_buffer = buf;
		img->bufferSize = bufferSize;
	}
}
    a1ec:	f7ff ff2c 	bl	a048 <_ZN14Gamebuino_Meta13Frame_HandlerD1Ev>
    a1f0:	1c20      	adds	r0, r4, #0
    a1f2:	f006 f825 	bl	10240 <_ZdlPv>
    a1f6:	1c20      	adds	r0, r4, #0
    a1f8:	bd10      	pop	{r4, pc}

0000a1fa <_ZN14Gamebuino_Meta17Frame_Handler_MemD0Ev>:

Frame_Handler_Mem::Frame_Handler_Mem(Image* _img) : Frame_Handler(_img) {
	
}

Frame_Handler_Mem::~Frame_Handler_Mem() {
    a1fa:	b510      	push	{r4, lr}
    a1fc:	1c04      	adds	r4, r0, #0
	if (buf) {
		img->_buffer = buf;
		img->bufferSize = 0;
	}
}
    a1fe:	f7ff ff37 	bl	a070 <_ZN14Gamebuino_Meta17Frame_Handler_MemD1Ev>
    a202:	1c20      	adds	r0, r4, #0
    a204:	f006 f81c 	bl	10240 <_ZdlPv>
    a208:	1c20      	adds	r0, r4, #0
    a20a:	bd10      	pop	{r4, pc}

0000a20c <_ZN14Gamebuino_Meta17Frame_Handler_RAMD0Ev>:

Frame_Handler_RAM::Frame_Handler_RAM(Image* _img) : Frame_Handler_Mem(_img) {
	allocateBuffer();
}

Frame_Handler_RAM::~Frame_Handler_RAM() {
    a20c:	b510      	push	{r4, lr}
    a20e:	1c04      	adds	r4, r0, #0
	if (buf) {
		img->_buffer = buf;
		img->bufferSize = bufferSize;
	}
}
    a210:	f7ff ff42 	bl	a098 <_ZN14Gamebuino_Meta17Frame_Handler_RAMD1Ev>
    a214:	1c20      	adds	r0, r4, #0
    a216:	f006 f813 	bl	10240 <_ZdlPv>
    a21a:	1c20      	adds	r0, r4, #0
    a21c:	bd10      	pop	{r4, pc}
	...

0000a220 <_ZN14Gamebuino_Meta5ImageD1Ev>:
	frame_loopcounter = 0;
	last_frame = (gb.frameCount & 0xFF) - 1;
}


Image::~Image() {
    a220:	b510      	push	{r4, lr}
    a222:	4b0e      	ldr	r3, [pc, #56]	; (a25c <_ZN14Gamebuino_Meta5ImageD1Ev+0x3c>)
    a224:	1c04      	adds	r4, r0, #0
    a226:	3308      	adds	r3, #8
    a228:	6003      	str	r3, [r0, #0]
	if (isObjectCopy) {
    a22a:	1d43      	adds	r3, r0, #5
    a22c:	7fdb      	ldrb	r3, [r3, #31]
    a22e:	2b00      	cmp	r3, #0
    a230:	d10f      	bne.n	a252 <_ZN14Gamebuino_Meta5ImageD1Ev+0x32>
		return;
	}
	delete frame_handler;
    a232:	69c0      	ldr	r0, [r0, #28]
    a234:	2800      	cmp	r0, #0
    a236:	d002      	beq.n	a23e <_ZN14Gamebuino_Meta5ImageD1Ev+0x1e>
    a238:	6803      	ldr	r3, [r0, #0]
    a23a:	685b      	ldr	r3, [r3, #4]
    a23c:	4798      	blx	r3
	if (_buffer && (uint32_t)_buffer >= 0x20000000) {
    a23e:	6960      	ldr	r0, [r4, #20]
    a240:	2800      	cmp	r0, #0
    a242:	d006      	beq.n	a252 <_ZN14Gamebuino_Meta5ImageD1Ev+0x32>
    a244:	4b06      	ldr	r3, [pc, #24]	; (a260 <_ZN14Gamebuino_Meta5ImageD1Ev+0x40>)
    a246:	4298      	cmp	r0, r3
    a248:	d903      	bls.n	a252 <_ZN14Gamebuino_Meta5ImageD1Ev+0x32>
		free(_buffer);
    a24a:	f007 f99d 	bl	11588 <free>
		_buffer = 0;
    a24e:	2300      	movs	r3, #0
    a250:	6163      	str	r3, [r4, #20]
	}
}
    a252:	1c20      	adds	r0, r4, #0
    a254:	f7fe fbfa 	bl	8a4c <_ZN14Gamebuino_Meta8GraphicsD1Ev>
    a258:	1c20      	adds	r0, r4, #0
    a25a:	bd10      	pop	{r4, pc}
    a25c:	00015478 	.word	0x00015478
    a260:	1fffffff 	.word	0x1fffffff

0000a264 <_ZN14Gamebuino_Meta5ImageD0Ev>:
	frame_loopcounter = 0;
	last_frame = (gb.frameCount & 0xFF) - 1;
}


Image::~Image() {
    a264:	b510      	push	{r4, lr}
    a266:	1c04      	adds	r4, r0, #0
	delete frame_handler;
	if (_buffer && (uint32_t)_buffer >= 0x20000000) {
		free(_buffer);
		_buffer = 0;
	}
}
    a268:	f7ff ffda 	bl	a220 <_ZN14Gamebuino_Meta5ImageD1Ev>
    a26c:	1c20      	adds	r0, r4, #0
    a26e:	f005 ffe7 	bl	10240 <_ZdlPv>
    a272:	1c20      	adds	r0, r4, #0
    a274:	bd10      	pop	{r4, pc}
	...

0000a278 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_>:
			memset(_buffer, pack, _width * _height / 2);
		}
	}
}

void Image::drawBufferedLine(int16_t x, int16_t y, uint16_t *buffer, uint16_t w, Image& img) {
    a278:	b5f0      	push	{r4, r5, r6, r7, lr}
    a27a:	b089      	sub	sp, #36	; 0x24
    a27c:	af00      	add	r7, sp, #0
    a27e:	8f3c      	ldrh	r4, [r7, #56]	; 0x38
    a280:	61fb      	str	r3, [r7, #28]
    a282:	61bc      	str	r4, [r7, #24]
    a284:	466c      	mov	r4, sp
    a286:	60bc      	str	r4, [r7, #8]
	if (colorMode == ColorMode::index) {
    a288:	7a85      	ldrb	r5, [r0, #10]
    a28a:	2310      	movs	r3, #16
    a28c:	5ec4      	ldrsh	r4, [r0, r3]
    a28e:	6943      	ldr	r3, [r0, #20]
    a290:	2d01      	cmp	r5, #1
    a292:	d000      	beq.n	a296 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x1e>
    a294:	e080      	b.n	a398 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x120>
		// TODO: transparent index color
		uint8_t *src = (uint8_t*)buffer;
		uint8_t *dst = (uint8_t*)_buffer + y*((_width + 1) / 2) + x/2;
    a296:	3401      	adds	r4, #1
    a298:	0fe0      	lsrs	r0, r4, #31
    a29a:	1904      	adds	r4, r0, r4
    a29c:	1064      	asrs	r4, r4, #1
    a29e:	4362      	muls	r2, r4
    a2a0:	0fce      	lsrs	r6, r1, #31
    a2a2:	1876      	adds	r6, r6, r1
    a2a4:	1076      	asrs	r6, r6, #1
    a2a6:	1992      	adds	r2, r2, r6
    a2a8:	189c      	adds	r4, r3, r2
		if (!img.useTransparentIndex) {
    a2aa:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    a2ac:	4029      	ands	r1, r5
    a2ae:	7a53      	ldrb	r3, [r2, #9]
    a2b0:	2b00      	cmp	r3, #0
    a2b2:	d11f      	bne.n	a2f4 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x7c>
			if (x % 2) {
    a2b4:	2900      	cmp	r1, #0
    a2b6:	d00e      	beq.n	a2d6 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x5e>
				*dst = (*dst & 0xF0) | (*(src++) & 0x0F);
    a2b8:	69fd      	ldr	r5, [r7, #28]
    a2ba:	7822      	ldrb	r2, [r4, #0]
    a2bc:	7829      	ldrb	r1, [r5, #0]
    a2be:	230f      	movs	r3, #15
    a2c0:	439a      	bics	r2, r3
    a2c2:	400b      	ands	r3, r1
    a2c4:	4313      	orrs	r3, r2
    a2c6:	7023      	strb	r3, [r4, #0]
				dst++;
				w--;
    a2c8:	69bb      	ldr	r3, [r7, #24]
		// TODO: transparent index color
		uint8_t *src = (uint8_t*)buffer;
		uint8_t *dst = (uint8_t*)_buffer + y*((_width + 1) / 2) + x/2;
		if (!img.useTransparentIndex) {
			if (x % 2) {
				*dst = (*dst & 0xF0) | (*(src++) & 0x0F);
    a2ca:	3501      	adds	r5, #1
				dst++;
				w--;
    a2cc:	3b01      	subs	r3, #1
    a2ce:	b29b      	uxth	r3, r3
		uint8_t *src = (uint8_t*)buffer;
		uint8_t *dst = (uint8_t*)_buffer + y*((_width + 1) / 2) + x/2;
		if (!img.useTransparentIndex) {
			if (x % 2) {
				*dst = (*dst & 0xF0) | (*(src++) & 0x0F);
				dst++;
    a2d0:	3401      	adds	r4, #1
				w--;
    a2d2:	61bb      	str	r3, [r7, #24]
		// TODO: transparent index color
		uint8_t *src = (uint8_t*)buffer;
		uint8_t *dst = (uint8_t*)_buffer + y*((_width + 1) / 2) + x/2;
		if (!img.useTransparentIndex) {
			if (x % 2) {
				*dst = (*dst & 0xF0) | (*(src++) & 0x0F);
    a2d4:	61fd      	str	r5, [r7, #28]
				dst++;
				w--;
			}
			memcpy(dst, src, w / 2);
    a2d6:	69b8      	ldr	r0, [r7, #24]
    a2d8:	69f9      	ldr	r1, [r7, #28]
    a2da:	0845      	lsrs	r5, r0, #1
    a2dc:	1c2a      	adds	r2, r5, #0
    a2de:	1c20      	adds	r0, r4, #0
    a2e0:	f007 f96b 	bl	115ba <memcpy>
			if (w % 2) {
    a2e4:	69b9      	ldr	r1, [r7, #24]
    a2e6:	07c9      	lsls	r1, r1, #31
    a2e8:	d400      	bmi.n	a2ec <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x74>
    a2ea:	e263      	b.n	a7b4 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x53c>
				dst += (w/2);
				*dst = (*dst & 0x0F) | (src[w/2] & 0xF0);
    a2ec:	69fb      	ldr	r3, [r7, #28]
				dst++;
				w--;
			}
			memcpy(dst, src, w / 2);
			if (w % 2) {
				dst += (w/2);
    a2ee:	1964      	adds	r4, r4, r5
				*dst = (*dst & 0x0F) | (src[w/2] & 0xF0);
    a2f0:	5d5a      	ldrb	r2, [r3, r5]
    a2f2:	e04a      	b.n	a38a <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x112>
			}
		} else {
			if (x % 2) {
    a2f4:	2900      	cmp	r1, #0
    a2f6:	d013      	beq.n	a320 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0xa8>
				uint8_t p = *(src++) & 0x0F;
    a2f8:	69fd      	ldr	r5, [r7, #28]
    a2fa:	69f9      	ldr	r1, [r7, #28]
    a2fc:	782b      	ldrb	r3, [r5, #0]
				if (p != img.transparentColorIndex) {
    a2fe:	6bfd      	ldr	r5, [r7, #60]	; 0x3c
				dst += (w/2);
				*dst = (*dst & 0x0F) | (src[w/2] & 0xF0);
			}
		} else {
			if (x % 2) {
				uint8_t p = *(src++) & 0x0F;
    a300:	220f      	movs	r2, #15
				if (p != img.transparentColorIndex) {
    a302:	7a28      	ldrb	r0, [r5, #8]
				dst += (w/2);
				*dst = (*dst & 0x0F) | (src[w/2] & 0xF0);
			}
		} else {
			if (x % 2) {
				uint8_t p = *(src++) & 0x0F;
    a304:	3101      	adds	r1, #1
    a306:	4013      	ands	r3, r2
				if (p != img.transparentColorIndex) {
    a308:	4298      	cmp	r0, r3
    a30a:	d003      	beq.n	a314 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x9c>
					*dst = (*dst & 0xF0) | p;
    a30c:	7820      	ldrb	r0, [r4, #0]
    a30e:	4390      	bics	r0, r2
    a310:	4303      	orrs	r3, r0
    a312:	7023      	strb	r3, [r4, #0]
				}
				dst++;
				w--;
    a314:	69bb      	ldr	r3, [r7, #24]
			if (x % 2) {
				uint8_t p = *(src++) & 0x0F;
				if (p != img.transparentColorIndex) {
					*dst = (*dst & 0xF0) | p;
				}
				dst++;
    a316:	3401      	adds	r4, #1
				w--;
    a318:	3b01      	subs	r3, #1
    a31a:	b29b      	uxth	r3, r3
    a31c:	61bb      	str	r3, [r7, #24]
				dst += (w/2);
				*dst = (*dst & 0x0F) | (src[w/2] & 0xF0);
			}
		} else {
			if (x % 2) {
				uint8_t p = *(src++) & 0x0F;
    a31e:	61f9      	str	r1, [r7, #28]
					*dst = (*dst & 0xF0) | p;
				}
				dst++;
				w--;
			}
			for (uint16_t i = 0; i < (w / 2); i++) {
    a320:	69bd      	ldr	r5, [r7, #24]
    a322:	2300      	movs	r3, #0
    a324:	086e      	lsrs	r6, r5, #1
    a326:	b29a      	uxth	r2, r3
				uint8_t px = *(src++);
    a328:	69fd      	ldr	r5, [r7, #28]
					*dst = (*dst & 0xF0) | p;
				}
				dst++;
				w--;
			}
			for (uint16_t i = 0; i < (w / 2); i++) {
    a32a:	42b2      	cmp	r2, r6
    a32c:	d220      	bcs.n	a370 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0xf8>
				uint8_t px = *(src++);
    a32e:	5cea      	ldrb	r2, [r5, r3]
				uint8_t hi = px >> 4;
				uint8_t lo = px & 0x0F;
				if (hi == img.transparentColorIndex && lo == img.transparentColorIndex) {
    a330:	6bfd      	ldr	r5, [r7, #60]	; 0x3c
				dst++;
				w--;
			}
			for (uint16_t i = 0; i < (w / 2); i++) {
				uint8_t px = *(src++);
				uint8_t hi = px >> 4;
    a332:	1110      	asrs	r0, r2, #4
    a334:	6138      	str	r0, [r7, #16]
				uint8_t lo = px & 0x0F;
				if (hi == img.transparentColorIndex && lo == img.transparentColorIndex) {
    a336:	7a2d      	ldrb	r5, [r5, #8]
				dst++;
				w--;
			}
			for (uint16_t i = 0; i < (w / 2); i++) {
				uint8_t px = *(src++);
				uint8_t hi = px >> 4;
    a338:	b2c0      	uxtb	r0, r0
    a33a:	4684      	mov	ip, r0
				uint8_t lo = px & 0x0F;
    a33c:	210f      	movs	r1, #15
    a33e:	1c10      	adds	r0, r2, #0
    a340:	4008      	ands	r0, r1
				if (hi == img.transparentColorIndex && lo == img.transparentColorIndex) {
    a342:	617d      	str	r5, [r7, #20]
    a344:	45ac      	cmp	ip, r5
    a346:	d106      	bne.n	a356 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0xde>
    a348:	4560      	cmp	r0, ip
    a34a:	d00f      	beq.n	a36c <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0xf4>
					// both are transparent, nothing to do
				} else if (hi == img.transparentColorIndex) {
					*dst = (*dst & 0xF0) | lo;
    a34c:	5ce2      	ldrb	r2, [r4, r3]
    a34e:	438a      	bics	r2, r1
    a350:	4310      	orrs	r0, r2
    a352:	54e0      	strb	r0, [r4, r3]
    a354:	e00a      	b.n	a36c <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0xf4>
				} else if (lo == img.transparentColorIndex) {
    a356:	697d      	ldr	r5, [r7, #20]
    a358:	42a8      	cmp	r0, r5
    a35a:	d106      	bne.n	a36a <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0xf2>
					*dst = (*dst & 0x0F) | (hi << 4);
    a35c:	5ce2      	ldrb	r2, [r4, r3]
    a35e:	6938      	ldr	r0, [r7, #16]
    a360:	4011      	ands	r1, r2
    a362:	0105      	lsls	r5, r0, #4
    a364:	430d      	orrs	r5, r1
    a366:	54e5      	strb	r5, [r4, r3]
    a368:	e000      	b.n	a36c <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0xf4>
				} else {
					*dst = px;
    a36a:	54e2      	strb	r2, [r4, r3]
    a36c:	3301      	adds	r3, #1
    a36e:	e7da      	b.n	a326 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0xae>
    a370:	19ab      	adds	r3, r5, r6
				}
				dst++;
			}
			if (w % 2) {
    a372:	69bd      	ldr	r5, [r7, #24]
    a374:	19a4      	adds	r4, r4, r6
    a376:	07ed      	lsls	r5, r5, #31
    a378:	d400      	bmi.n	a37c <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x104>
    a37a:	e21b      	b.n	a7b4 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x53c>
				uint8_t hi = *src >> 4;
    a37c:	781a      	ldrb	r2, [r3, #0]
				if (hi != img.transparentColorIndex) {
    a37e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    a380:	7a19      	ldrb	r1, [r3, #8]
    a382:	0913      	lsrs	r3, r2, #4
    a384:	4299      	cmp	r1, r3
    a386:	d100      	bne.n	a38a <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x112>
    a388:	e214      	b.n	a7b4 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x53c>
					*dst = (*dst & 0x0F) | (*src & 0xF0);
    a38a:	7821      	ldrb	r1, [r4, #0]
    a38c:	230f      	movs	r3, #15
    a38e:	439a      	bics	r2, r3
    a390:	400b      	ands	r3, r1
    a392:	4313      	orrs	r3, r2
    a394:	7023      	strb	r3, [r4, #0]
    a396:	e20d      	b.n	a7b4 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x53c>
				}
			}
		}
		return;
	}
	if ((alpha == 255) && (tint == 0xFFFF)) { //no alpha blending and not tinting
    a398:	48b9      	ldr	r0, [pc, #740]	; (a680 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x408>)
    a39a:	7805      	ldrb	r5, [r0, #0]
    a39c:	2dff      	cmp	r5, #255	; 0xff
    a39e:	d12b      	bne.n	a3f8 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x180>
    a3a0:	48b8      	ldr	r0, [pc, #736]	; (a684 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x40c>)
    a3a2:	8806      	ldrh	r6, [r0, #0]
    a3a4:	48b8      	ldr	r0, [pc, #736]	; (a688 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x410>)
    a3a6:	4286      	cmp	r6, r0
    a3a8:	d126      	bne.n	a3f8 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x180>
		if ((!img.transparentColor && img.colorMode == ColorMode::rgb565) || (img.transparentColor == 1 && img.colorMode == ColorMode::index)) { //no transparent color set
    a3aa:	6bfd      	ldr	r5, [r7, #60]	; 0x3c
    a3ac:	68ad      	ldr	r5, [r5, #8]
    a3ae:	0228      	lsls	r0, r5, #8
    a3b0:	0a00      	lsrs	r0, r0, #8
    a3b2:	d002      	beq.n	a3ba <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x142>
    a3b4:	4db5      	ldr	r5, [pc, #724]	; (a68c <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x414>)
    a3b6:	42a8      	cmp	r0, r5
    a3b8:	d10a      	bne.n	a3d0 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x158>
			memcpy(&_buffer[x + y * _width], buffer, w * 2); //fastest copy possible
    a3ba:	1c20      	adds	r0, r4, #0
    a3bc:	4350      	muls	r0, r2
    a3be:	69bc      	ldr	r4, [r7, #24]
    a3c0:	1808      	adds	r0, r1, r0
    a3c2:	0040      	lsls	r0, r0, #1
    a3c4:	1818      	adds	r0, r3, r0
    a3c6:	0062      	lsls	r2, r4, #1
    a3c8:	69f9      	ldr	r1, [r7, #28]
    a3ca:	f007 f8f6 	bl	115ba <memcpy>
			return;
    a3ce:	e1f1      	b.n	a7b4 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x53c>
		} else {
			uint16_t * thisLine = &_buffer[x + y * _width];
    a3d0:	4362      	muls	r2, r4
    a3d2:	1889      	adds	r1, r1, r2
    a3d4:	0049      	lsls	r1, r1, #1
    a3d6:	185b      	adds	r3, r3, r1
			for (uint8_t i = 0; i < w; i++) { //only copy non-transparent-colored pixels
    a3d8:	2000      	movs	r0, #0
    a3da:	69bc      	ldr	r4, [r7, #24]
    a3dc:	42a0      	cmp	r0, r4
    a3de:	d300      	bcc.n	a3e2 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x16a>
    a3e0:	e1e8      	b.n	a7b4 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x53c>
				if (buffer[i] == img.transparentColor) continue;
    a3e2:	69fc      	ldr	r4, [r7, #28]
    a3e4:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
    a3e6:	0045      	lsls	r5, r0, #1
    a3e8:	5b66      	ldrh	r6, [r4, r5]
    a3ea:	890a      	ldrh	r2, [r1, #8]
    a3ec:	42b2      	cmp	r2, r6
    a3ee:	d000      	beq.n	a3f2 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x17a>
				thisLine[i] = buffer[i];
    a3f0:	535e      	strh	r6, [r3, r5]
		if ((!img.transparentColor && img.colorMode == ColorMode::rgb565) || (img.transparentColor == 1 && img.colorMode == ColorMode::index)) { //no transparent color set
			memcpy(&_buffer[x + y * _width], buffer, w * 2); //fastest copy possible
			return;
		} else {
			uint16_t * thisLine = &_buffer[x + y * _width];
			for (uint8_t i = 0; i < w; i++) { //only copy non-transparent-colored pixels
    a3f2:	3001      	adds	r0, #1
    a3f4:	b2c0      	uxtb	r0, r0
    a3f6:	e7f0      	b.n	a3da <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x162>
				thisLine[i] = buffer[i];
			}
			return;
		}
	}
	uint16_t * thisLine = &_buffer[x + y * _width];
    a3f8:	4362      	muls	r2, r4
    a3fa:	1889      	adds	r1, r1, r2
    a3fc:	0049      	lsls	r1, r1, #1
    a3fe:	185b      	adds	r3, r3, r1
    a400:	60fb      	str	r3, [r7, #12]
	int8_t r1[w];
    a402:	69bb      	ldr	r3, [r7, #24]
    a404:	4668      	mov	r0, sp
    a406:	3307      	adds	r3, #7
    a408:	08db      	lsrs	r3, r3, #3
    a40a:	00db      	lsls	r3, r3, #3
    a40c:	1ac0      	subs	r0, r0, r3
    a40e:	4685      	mov	sp, r0
	int8_t b1[w];
    a410:	1ac0      	subs	r0, r0, r3
			}
			return;
		}
	}
	uint16_t * thisLine = &_buffer[x + y * _width];
	int8_t r1[w];
    a412:	466e      	mov	r6, sp
	int8_t b1[w];
    a414:	4685      	mov	sp, r0
	int8_t g1[w];
    a416:	1ac0      	subs	r0, r0, r3
			return;
		}
	}
	uint16_t * thisLine = &_buffer[x + y * _width];
	int8_t r1[w];
	int8_t b1[w];
    a418:	466a      	mov	r2, sp
	int8_t g1[w];
    a41a:	4685      	mov	sp, r0
    a41c:	466c      	mov	r4, sp
			return;
		}
	}
	uint16_t * thisLine = &_buffer[x + y * _width];
	int8_t r1[w];
	int8_t b1[w];
    a41e:	617a      	str	r2, [r7, #20]
	int8_t g1[w];
    a420:	613c      	str	r4, [r7, #16]

	//Extract RGB channels from buffer
	for (uint8_t i = 0; i < w; i++) {
    a422:	2300      	movs	r3, #0
    a424:	69bc      	ldr	r4, [r7, #24]
    a426:	42a3      	cmp	r3, r4
    a428:	d217      	bcs.n	a45a <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x1e2>
		if (img.transparentColor && buffer[i] == img.transparentColor) continue;
    a42a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    a42c:	8911      	ldrh	r1, [r2, #8]
    a42e:	005a      	lsls	r2, r3, #1
    a430:	2900      	cmp	r1, #0
    a432:	d003      	beq.n	a43c <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x1c4>
    a434:	69fc      	ldr	r4, [r7, #28]
    a436:	5aa0      	ldrh	r0, [r4, r2]
    a438:	4288      	cmp	r0, r1
    a43a:	d00b      	beq.n	a454 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x1dc>
		uint16_t color1 = buffer[i];
    a43c:	69fc      	ldr	r4, [r7, #28]
		r1[i] = color1 & B11111;
    a43e:	211f      	movs	r1, #31
	int8_t g1[w];

	//Extract RGB channels from buffer
	for (uint8_t i = 0; i < w; i++) {
		if (img.transparentColor && buffer[i] == img.transparentColor) continue;
		uint16_t color1 = buffer[i];
    a440:	5aa2      	ldrh	r2, [r4, r2]
		r1[i] = color1 & B11111;
		g1[i] = (color1 >> 5) & B111111;
    a442:	693c      	ldr	r4, [r7, #16]

	//Extract RGB channels from buffer
	for (uint8_t i = 0; i < w; i++) {
		if (img.transparentColor && buffer[i] == img.transparentColor) continue;
		uint16_t color1 = buffer[i];
		r1[i] = color1 & B11111;
    a444:	4011      	ands	r1, r2
    a446:	54f1      	strb	r1, [r6, r3]
		g1[i] = (color1 >> 5) & B111111;
    a448:	0551      	lsls	r1, r2, #21
    a44a:	0e89      	lsrs	r1, r1, #26
    a44c:	54e1      	strb	r1, [r4, r3]
		b1[i] = (color1 >> 11) & B11111;
    a44e:	6979      	ldr	r1, [r7, #20]
    a450:	0ad2      	lsrs	r2, r2, #11
    a452:	54ca      	strb	r2, [r1, r3]
	int8_t r1[w];
	int8_t b1[w];
	int8_t g1[w];

	//Extract RGB channels from buffer
	for (uint8_t i = 0; i < w; i++) {
    a454:	3301      	adds	r3, #1
    a456:	b2db      	uxtb	r3, r3
    a458:	e7e4      	b.n	a424 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x1ac>
		g1[i] = (color1 >> 5) & B111111;
		b1[i] = (color1 >> 11) & B11111;
	}

	//Buffer tinting
	if (tint != 0xFFFF) {
    a45a:	4b8a      	ldr	r3, [pc, #552]	; (a684 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x40c>)
    a45c:	8818      	ldrh	r0, [r3, #0]
    a45e:	4b8a      	ldr	r3, [pc, #552]	; (a688 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x410>)
    a460:	4298      	cmp	r0, r3
    a462:	d10c      	bne.n	a47e <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x206>
		}
	}

	//blending
	uint8_t nalpha = 255 - alpha; //complementary of alpha
	switch (blendMode) {
    a464:	4b8a      	ldr	r3, [pc, #552]	; (a690 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x418>)
    a466:	7818      	ldrb	r0, [r3, #0]
    a468:	2804      	cmp	r0, #4
    a46a:	d900      	bls.n	a46e <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x1f6>
    a46c:	e0c9      	b.n	a602 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x38a>
    a46e:	2300      	movs	r3, #0
    a470:	f006 ff88 	bl	11384 <__gnu_thumb1_case_uhi>
    a474:	007a0035 	.word	0x007a0035
    a478:	010100c4 	.word	0x010100c4
    a47c:	0143      	.short	0x0143
	}

	//Buffer tinting
	if (tint != 0xFFFF) {
		int8_t tintR = tint & B11111;
		int8_t tintG = (tint >> 5) & B111111;
    a47e:	0541      	lsls	r1, r0, #21
		b1[i] = (color1 >> 11) & B11111;
	}

	//Buffer tinting
	if (tint != 0xFFFF) {
		int8_t tintR = tint & B11111;
    a480:	231f      	movs	r3, #31
    a482:	4003      	ands	r3, r0
		int8_t tintG = (tint >> 5) & B111111;
    a484:	0e89      	lsrs	r1, r1, #26
		b1[i] = (color1 >> 11) & B11111;
	}

	//Buffer tinting
	if (tint != 0xFFFF) {
		int8_t tintR = tint & B11111;
    a486:	469c      	mov	ip, r3
		int8_t tintG = (tint >> 5) & B111111;
    a488:	6039      	str	r1, [r7, #0]
		int8_t tintB = (tint >> 11) & B11111;
    a48a:	0ac0      	lsrs	r0, r0, #11
		for (uint8_t i = 0; i < w; i++) {
    a48c:	2300      	movs	r3, #0
    a48e:	69bc      	ldr	r4, [r7, #24]
    a490:	42a3      	cmp	r3, r4
    a492:	d2e7      	bcs.n	a464 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x1ec>
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
    a494:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
    a496:	890a      	ldrh	r2, [r1, #8]
    a498:	2a00      	cmp	r2, #0
    a49a:	d004      	beq.n	a4a6 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x22e>
    a49c:	69f9      	ldr	r1, [r7, #28]
    a49e:	005c      	lsls	r4, r3, #1
    a4a0:	5a64      	ldrh	r4, [r4, r1]
    a4a2:	4294      	cmp	r4, r2
    a4a4:	d018      	beq.n	a4d8 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x260>
			r1[i] = r1[i] * tintR / 32;
    a4a6:	56f2      	ldrsb	r2, [r6, r3]
    a4a8:	4664      	mov	r4, ip
    a4aa:	4362      	muls	r2, r4
    a4ac:	17d4      	asrs	r4, r2, #31
    a4ae:	0ee4      	lsrs	r4, r4, #27
			g1[i] = g1[i] * tintG / 64;
    a4b0:	6939      	ldr	r1, [r7, #16]
		int8_t tintR = tint & B11111;
		int8_t tintG = (tint >> 5) & B111111;
		int8_t tintB = (tint >> 11) & B11111;
		for (uint8_t i = 0; i < w; i++) {
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
			r1[i] = r1[i] * tintR / 32;
    a4b2:	18a2      	adds	r2, r4, r2
    a4b4:	1152      	asrs	r2, r2, #5
			g1[i] = g1[i] * tintG / 64;
    a4b6:	683c      	ldr	r4, [r7, #0]
		int8_t tintR = tint & B11111;
		int8_t tintG = (tint >> 5) & B111111;
		int8_t tintB = (tint >> 11) & B11111;
		for (uint8_t i = 0; i < w; i++) {
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
			r1[i] = r1[i] * tintR / 32;
    a4b8:	54f2      	strb	r2, [r6, r3]
			g1[i] = g1[i] * tintG / 64;
    a4ba:	56ca      	ldrsb	r2, [r1, r3]
    a4bc:	4362      	muls	r2, r4
    a4be:	17d4      	asrs	r4, r2, #31
    a4c0:	0ea4      	lsrs	r4, r4, #26
    a4c2:	18a2      	adds	r2, r4, r2
    a4c4:	1192      	asrs	r2, r2, #6
    a4c6:	54ca      	strb	r2, [r1, r3]
			b1[i] = b1[i] * tintB / 32;
    a4c8:	6979      	ldr	r1, [r7, #20]
    a4ca:	56ca      	ldrsb	r2, [r1, r3]
    a4cc:	4342      	muls	r2, r0
    a4ce:	17d4      	asrs	r4, r2, #31
    a4d0:	0ee4      	lsrs	r4, r4, #27
    a4d2:	18a2      	adds	r2, r4, r2
    a4d4:	1152      	asrs	r2, r2, #5
    a4d6:	54ca      	strb	r2, [r1, r3]
	//Buffer tinting
	if (tint != 0xFFFF) {
		int8_t tintR = tint & B11111;
		int8_t tintG = (tint >> 5) & B111111;
		int8_t tintB = (tint >> 11) & B11111;
		for (uint8_t i = 0; i < w; i++) {
    a4d8:	3301      	adds	r3, #1
    a4da:	b2db      	uxtb	r3, r3
    a4dc:	e7d7      	b.n	a48e <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x216>

	//blending
	uint8_t nalpha = 255 - alpha; //complementary of alpha
	switch (blendMode) {
	case BlendMode::blend:
		if (alpha < 255) {
    a4de:	2dff      	cmp	r5, #255	; 0xff
    a4e0:	d100      	bne.n	a4e4 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x26c>
    a4e2:	e08e      	b.n	a602 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x38a>
			for (uint8_t i = 0; i < w; i++) {
    a4e4:	69bc      	ldr	r4, [r7, #24]
    a4e6:	42a3      	cmp	r3, r4
    a4e8:	d300      	bcc.n	a4ec <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x274>
    a4ea:	e08a      	b.n	a602 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x38a>
				if (img.transparentColor && buffer[i] == img.transparentColor) continue;
    a4ec:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    a4ee:	8911      	ldrh	r1, [r2, #8]
    a4f0:	005a      	lsls	r2, r3, #1
    a4f2:	2900      	cmp	r1, #0
    a4f4:	d003      	beq.n	a4fe <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x286>
    a4f6:	69fc      	ldr	r4, [r7, #28]
    a4f8:	5aa0      	ldrh	r0, [r4, r2]
    a4fa:	4288      	cmp	r0, r1
    a4fc:	d026      	beq.n	a54c <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x2d4>
				uint16_t color2 = thisLine[i];
    a4fe:	68fc      	ldr	r4, [r7, #12]
				int16_t r2 = color2 & B11111;
				int16_t g2 = (color2 >> 5) & B111111;
				int16_t b2 = (color2 >> 11) & B11111;
				r1[i] = ((r1[i] * alpha) + (r2 * nalpha)) / 256;
    a500:	201f      	movs	r0, #31
	switch (blendMode) {
	case BlendMode::blend:
		if (alpha < 255) {
			for (uint8_t i = 0; i < w; i++) {
				if (img.transparentColor && buffer[i] == img.transparentColor) continue;
				uint16_t color2 = thisLine[i];
    a502:	5aa1      	ldrh	r1, [r4, r2]
				int16_t r2 = color2 & B11111;
				int16_t g2 = (color2 >> 5) & B111111;
				int16_t b2 = (color2 >> 11) & B11111;
				r1[i] = ((r1[i] * alpha) + (r2 * nalpha)) / 256;
    a504:	56f4      	ldrsb	r4, [r6, r3]
			b1[i] = b1[i] * tintB / 32;
		}
	}

	//blending
	uint8_t nalpha = 255 - alpha; //complementary of alpha
    a506:	43ea      	mvns	r2, r5
				if (img.transparentColor && buffer[i] == img.transparentColor) continue;
				uint16_t color2 = thisLine[i];
				int16_t r2 = color2 & B11111;
				int16_t g2 = (color2 >> 5) & B111111;
				int16_t b2 = (color2 >> 11) & B11111;
				r1[i] = ((r1[i] * alpha) + (r2 * nalpha)) / 256;
    a508:	b2d2      	uxtb	r2, r2
    a50a:	4008      	ands	r0, r1
    a50c:	436c      	muls	r4, r5
    a50e:	4350      	muls	r0, r2
    a510:	1820      	adds	r0, r4, r0
    a512:	17c4      	asrs	r4, r0, #31
    a514:	0e24      	lsrs	r4, r4, #24
    a516:	1820      	adds	r0, r4, r0
    a518:	1200      	asrs	r0, r0, #8
    a51a:	54f0      	strb	r0, [r6, r3]
				g1[i] = ((g1[i] * alpha) + (g2 * nalpha)) / 256;
    a51c:	6938      	ldr	r0, [r7, #16]
    a51e:	56c4      	ldrsb	r4, [r0, r3]
		if (alpha < 255) {
			for (uint8_t i = 0; i < w; i++) {
				if (img.transparentColor && buffer[i] == img.transparentColor) continue;
				uint16_t color2 = thisLine[i];
				int16_t r2 = color2 & B11111;
				int16_t g2 = (color2 >> 5) & B111111;
    a520:	0548      	lsls	r0, r1, #21
				int16_t b2 = (color2 >> 11) & B11111;
				r1[i] = ((r1[i] * alpha) + (r2 * nalpha)) / 256;
				g1[i] = ((g1[i] * alpha) + (g2 * nalpha)) / 256;
    a522:	0e80      	lsrs	r0, r0, #26
    a524:	436c      	muls	r4, r5
    a526:	4350      	muls	r0, r2
    a528:	1820      	adds	r0, r4, r0
    a52a:	17c4      	asrs	r4, r0, #31
    a52c:	0e24      	lsrs	r4, r4, #24
    a52e:	1820      	adds	r0, r4, r0
    a530:	693c      	ldr	r4, [r7, #16]
    a532:	1200      	asrs	r0, r0, #8
    a534:	54e0      	strb	r0, [r4, r3]
				b1[i] = ((b1[i] * alpha) + (b2 * nalpha)) / 256;
    a536:	697c      	ldr	r4, [r7, #20]
    a538:	0ac9      	lsrs	r1, r1, #11
    a53a:	56e0      	ldrsb	r0, [r4, r3]
    a53c:	4351      	muls	r1, r2
    a53e:	4368      	muls	r0, r5
    a540:	1840      	adds	r0, r0, r1
    a542:	17c1      	asrs	r1, r0, #31
    a544:	0e09      	lsrs	r1, r1, #24
    a546:	1808      	adds	r0, r1, r0
    a548:	1200      	asrs	r0, r0, #8
    a54a:	54e0      	strb	r0, [r4, r3]
	//blending
	uint8_t nalpha = 255 - alpha; //complementary of alpha
	switch (blendMode) {
	case BlendMode::blend:
		if (alpha < 255) {
			for (uint8_t i = 0; i < w; i++) {
    a54c:	3301      	adds	r3, #1
    a54e:	b2db      	uxtb	r3, r3
    a550:	e7c8      	b.n	a4e4 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x26c>
			}
		}
		break;
	case BlendMode::add:
		for (uint8_t i = 0; i < w; i++) {
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
    a552:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    a554:	8911      	ldrh	r1, [r2, #8]
    a556:	005a      	lsls	r2, r3, #1
    a558:	2900      	cmp	r1, #0
    a55a:	d009      	beq.n	a570 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x2f8>
    a55c:	69fc      	ldr	r4, [r7, #28]
    a55e:	5aa0      	ldrh	r0, [r4, r2]
    a560:	4288      	cmp	r0, r1
    a562:	d105      	bne.n	a570 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x2f8>
				b1[i] = ((b1[i] * alpha) + (b2 * nalpha)) / 256;
			}
		}
		break;
	case BlendMode::add:
		for (uint8_t i = 0; i < w; i++) {
    a564:	3301      	adds	r3, #1
    a566:	b2db      	uxtb	r3, r3
    a568:	69bc      	ldr	r4, [r7, #24]
    a56a:	42a3      	cmp	r3, r4
    a56c:	d3f1      	bcc.n	a552 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x2da>
    a56e:	e048      	b.n	a602 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x38a>
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
			uint16_t color2 = thisLine[i];
    a570:	68f9      	ldr	r1, [r7, #12]
			int16_t r2 = color2 & B11111;
			int16_t g2 = (color2 >> 5) & B111111;
			int16_t b2 = (color2 >> 11) & B11111;
			r1[i] = min((r1[i] * alpha + r2 * 255) / 256, 31);
    a572:	56f0      	ldrsb	r0, [r6, r3]
		}
		break;
	case BlendMode::add:
		for (uint8_t i = 0; i < w; i++) {
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
			uint16_t color2 = thisLine[i];
    a574:	5a8c      	ldrh	r4, [r1, r2]
			int16_t r2 = color2 & B11111;
			int16_t g2 = (color2 >> 5) & B111111;
			int16_t b2 = (color2 >> 11) & B11111;
			r1[i] = min((r1[i] * alpha + r2 * 255) / 256, 31);
    a576:	4368      	muls	r0, r5
		for (uint8_t i = 0; i < w; i++) {
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
			uint16_t color2 = thisLine[i];
			int16_t r2 = color2 & B11111;
			int16_t g2 = (color2 >> 5) & B111111;
			int16_t b2 = (color2 >> 11) & B11111;
    a578:	0ae2      	lsrs	r2, r4, #11
	case BlendMode::add:
		for (uint8_t i = 0; i < w; i++) {
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
			uint16_t color2 = thisLine[i];
			int16_t r2 = color2 & B11111;
			int16_t g2 = (color2 >> 5) & B111111;
    a57a:	0561      	lsls	r1, r4, #21
    a57c:	0e89      	lsrs	r1, r1, #26
			int16_t b2 = (color2 >> 11) & B11111;
    a57e:	4694      	mov	ip, r2
		break;
	case BlendMode::add:
		for (uint8_t i = 0; i < w; i++) {
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
			uint16_t color2 = thisLine[i];
			int16_t r2 = color2 & B11111;
    a580:	221f      	movs	r2, #31
			int16_t g2 = (color2 >> 5) & B111111;
    a582:	6039      	str	r1, [r7, #0]
			int16_t b2 = (color2 >> 11) & B11111;
			r1[i] = min((r1[i] * alpha + r2 * 255) / 256, 31);
    a584:	4014      	ands	r4, r2
    a586:	21ff      	movs	r1, #255	; 0xff
    a588:	434c      	muls	r4, r1
    a58a:	1900      	adds	r0, r0, r4
    a58c:	4c41      	ldr	r4, [pc, #260]	; (a694 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x41c>)
    a58e:	42a0      	cmp	r0, r4
    a590:	dc04      	bgt.n	a59c <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x324>
    a592:	17c2      	asrs	r2, r0, #31
    a594:	0e12      	lsrs	r2, r2, #24
    a596:	1812      	adds	r2, r2, r0
    a598:	1212      	asrs	r2, r2, #8
    a59a:	b2d2      	uxtb	r2, r2
			g1[i] = min((g1[i] * alpha + g2 * 255) / 256, 63);
    a59c:	6939      	ldr	r1, [r7, #16]
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
			uint16_t color2 = thisLine[i];
			int16_t r2 = color2 & B11111;
			int16_t g2 = (color2 >> 5) & B111111;
			int16_t b2 = (color2 >> 11) & B11111;
			r1[i] = min((r1[i] * alpha + r2 * 255) / 256, 31);
    a59e:	54f2      	strb	r2, [r6, r3]
			g1[i] = min((g1[i] * alpha + g2 * 255) / 256, 63);
    a5a0:	56ca      	ldrsb	r2, [r1, r3]
    a5a2:	6839      	ldr	r1, [r7, #0]
    a5a4:	20ff      	movs	r0, #255	; 0xff
    a5a6:	436a      	muls	r2, r5
    a5a8:	4341      	muls	r1, r0
    a5aa:	483b      	ldr	r0, [pc, #236]	; (a698 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x420>)
    a5ac:	1851      	adds	r1, r2, r1
    a5ae:	223f      	movs	r2, #63	; 0x3f
    a5b0:	4281      	cmp	r1, r0
    a5b2:	dc04      	bgt.n	a5be <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x346>
    a5b4:	17ca      	asrs	r2, r1, #31
    a5b6:	0e12      	lsrs	r2, r2, #24
    a5b8:	1852      	adds	r2, r2, r1
    a5ba:	1212      	asrs	r2, r2, #8
    a5bc:	b2d2      	uxtb	r2, r2
    a5be:	6939      	ldr	r1, [r7, #16]
			b1[i] = min((b1[i] * alpha + b2 * 255) / 256, 31);
    a5c0:	4660      	mov	r0, ip
			uint16_t color2 = thisLine[i];
			int16_t r2 = color2 & B11111;
			int16_t g2 = (color2 >> 5) & B111111;
			int16_t b2 = (color2 >> 11) & B11111;
			r1[i] = min((r1[i] * alpha + r2 * 255) / 256, 31);
			g1[i] = min((g1[i] * alpha + g2 * 255) / 256, 63);
    a5c2:	54ca      	strb	r2, [r1, r3]
			b1[i] = min((b1[i] * alpha + b2 * 255) / 256, 31);
    a5c4:	6979      	ldr	r1, [r7, #20]
    a5c6:	56ca      	ldrsb	r2, [r1, r3]
    a5c8:	21ff      	movs	r1, #255	; 0xff
    a5ca:	4341      	muls	r1, r0
    a5cc:	436a      	muls	r2, r5
    a5ce:	1852      	adds	r2, r2, r1
    a5d0:	211f      	movs	r1, #31
    a5d2:	42a2      	cmp	r2, r4
    a5d4:	dc04      	bgt.n	a5e0 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x368>
    a5d6:	17d1      	asrs	r1, r2, #31
    a5d8:	0e09      	lsrs	r1, r1, #24
    a5da:	1889      	adds	r1, r1, r2
    a5dc:	1209      	asrs	r1, r1, #8
    a5de:	b2c9      	uxtb	r1, r1
    a5e0:	697a      	ldr	r2, [r7, #20]
    a5e2:	54d1      	strb	r1, [r2, r3]
    a5e4:	e7be      	b.n	a564 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x2ec>
		}
		break;
	case BlendMode::subtract:
		for (uint8_t i = 0; i < w; i++) {
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
    a5e6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    a5e8:	8911      	ldrh	r1, [r2, #8]
    a5ea:	005a      	lsls	r2, r3, #1
    a5ec:	2900      	cmp	r1, #0
    a5ee:	d00a      	beq.n	a606 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x38e>
    a5f0:	69fc      	ldr	r4, [r7, #28]
    a5f2:	5aa0      	ldrh	r0, [r4, r2]
    a5f4:	4288      	cmp	r0, r1
    a5f6:	d106      	bne.n	a606 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x38e>
			g1[i] = min((g1[i] * alpha + g2 * 255) / 256, 63);
			b1[i] = min((b1[i] * alpha + b2 * 255) / 256, 31);
		}
		break;
	case BlendMode::subtract:
		for (uint8_t i = 0; i < w; i++) {
    a5f8:	3301      	adds	r3, #1
    a5fa:	b2db      	uxtb	r3, r3
    a5fc:	69bc      	ldr	r4, [r7, #24]
    a5fe:	42a3      	cmp	r3, r4
    a600:	d3f1      	bcc.n	a5e6 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x36e>
		}
	}

	//blending
	uint8_t nalpha = 255 - alpha; //complementary of alpha
	switch (blendMode) {
    a602:	2300      	movs	r3, #0
    a604:	e0c3      	b.n	a78e <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x516>
		}
		break;
	case BlendMode::subtract:
		for (uint8_t i = 0; i < w; i++) {
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
			uint16_t color2 = thisLine[i];
    a606:	68f9      	ldr	r1, [r7, #12]
    a608:	5a8a      	ldrh	r2, [r1, r2]
			int16_t r2 = color2 & B11111;
			int16_t g2 = (color2 >> 5) & B111111;
			int16_t b2 = (color2 >> 11) & B11111;
			r1[i] = max((r2 * 255 - r1[i] * alpha) / 256, 0);
    a60a:	211f      	movs	r1, #31
	case BlendMode::subtract:
		for (uint8_t i = 0; i < w; i++) {
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
			uint16_t color2 = thisLine[i];
			int16_t r2 = color2 & B11111;
			int16_t g2 = (color2 >> 5) & B111111;
    a60c:	0554      	lsls	r4, r2, #21
			int16_t b2 = (color2 >> 11) & B11111;
    a60e:	0ad0      	lsrs	r0, r2, #11
			r1[i] = max((r2 * 255 - r1[i] * alpha) / 256, 0);
    a610:	400a      	ands	r2, r1
    a612:	21ff      	movs	r1, #255	; 0xff
    a614:	434a      	muls	r2, r1
    a616:	56f1      	ldrsb	r1, [r6, r3]
	case BlendMode::subtract:
		for (uint8_t i = 0; i < w; i++) {
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
			uint16_t color2 = thisLine[i];
			int16_t r2 = color2 & B11111;
			int16_t g2 = (color2 >> 5) & B111111;
    a618:	0ea4      	lsrs	r4, r4, #26
			int16_t b2 = (color2 >> 11) & B11111;
			r1[i] = max((r2 * 255 - r1[i] * alpha) / 256, 0);
    a61a:	4369      	muls	r1, r5
    a61c:	1a52      	subs	r2, r2, r1
    a61e:	2100      	movs	r1, #0
    a620:	2aff      	cmp	r2, #255	; 0xff
    a622:	dd01      	ble.n	a628 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x3b0>
    a624:	1211      	asrs	r1, r2, #8
    a626:	b2c9      	uxtb	r1, r1
    a628:	54f1      	strb	r1, [r6, r3]
			g1[i] = max((g2 * 255 - g1[i] * alpha) / 256, 0);
    a62a:	6939      	ldr	r1, [r7, #16]
    a62c:	22ff      	movs	r2, #255	; 0xff
    a62e:	4354      	muls	r4, r2
    a630:	56ca      	ldrsb	r2, [r1, r3]
    a632:	436a      	muls	r2, r5
    a634:	1aa4      	subs	r4, r4, r2
    a636:	2200      	movs	r2, #0
    a638:	2cff      	cmp	r4, #255	; 0xff
    a63a:	dd01      	ble.n	a640 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x3c8>
    a63c:	1224      	asrs	r4, r4, #8
    a63e:	b2e2      	uxtb	r2, r4
    a640:	693c      	ldr	r4, [r7, #16]
			b1[i] = max((b2 * 255 - b1[i] * alpha) / 256, 0);
    a642:	6979      	ldr	r1, [r7, #20]
			uint16_t color2 = thisLine[i];
			int16_t r2 = color2 & B11111;
			int16_t g2 = (color2 >> 5) & B111111;
			int16_t b2 = (color2 >> 11) & B11111;
			r1[i] = max((r2 * 255 - r1[i] * alpha) / 256, 0);
			g1[i] = max((g2 * 255 - g1[i] * alpha) / 256, 0);
    a644:	54e2      	strb	r2, [r4, r3]
			b1[i] = max((b2 * 255 - b1[i] * alpha) / 256, 0);
    a646:	22ff      	movs	r2, #255	; 0xff
    a648:	4350      	muls	r0, r2
    a64a:	56ca      	ldrsb	r2, [r1, r3]
    a64c:	436a      	muls	r2, r5
    a64e:	1a80      	subs	r0, r0, r2
    a650:	2200      	movs	r2, #0
    a652:	28ff      	cmp	r0, #255	; 0xff
    a654:	dd01      	ble.n	a65a <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x3e2>
    a656:	1200      	asrs	r0, r0, #8
    a658:	b2c2      	uxtb	r2, r0
    a65a:	697c      	ldr	r4, [r7, #20]
    a65c:	54e2      	strb	r2, [r4, r3]
    a65e:	e7cb      	b.n	a5f8 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x380>
		}
		break;
	case BlendMode::multiply:
		for (uint8_t i = 0; i < w; i++) {
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
    a660:	6bfd      	ldr	r5, [r7, #60]	; 0x3c
    a662:	005a      	lsls	r2, r3, #1
    a664:	8929      	ldrh	r1, [r5, #8]
    a666:	2900      	cmp	r1, #0
    a668:	d018      	beq.n	a69c <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x424>
    a66a:	69fc      	ldr	r4, [r7, #28]
    a66c:	5aa0      	ldrh	r0, [r4, r2]
    a66e:	4288      	cmp	r0, r1
    a670:	d114      	bne.n	a69c <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x424>
			g1[i] = max((g2 * 255 - g1[i] * alpha) / 256, 0);
			b1[i] = max((b2 * 255 - b1[i] * alpha) / 256, 0);
		}
		break;
	case BlendMode::multiply:
		for (uint8_t i = 0; i < w; i++) {
    a672:	3301      	adds	r3, #1
    a674:	b2db      	uxtb	r3, r3
    a676:	69bc      	ldr	r4, [r7, #24]
    a678:	42a3      	cmp	r3, r4
    a67a:	d3f1      	bcc.n	a660 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x3e8>
    a67c:	e7c1      	b.n	a602 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x38a>
    a67e:	46c0      	nop			; (mov r8, r8)
    a680:	20000076 	.word	0x20000076
    a684:	20000074 	.word	0x20000074
    a688:	0000ffff 	.word	0x0000ffff
    a68c:	00010001 	.word	0x00010001
    a690:	20000cd6 	.word	0x20000cd6
    a694:	00001eff 	.word	0x00001eff
    a698:	00003eff 	.word	0x00003eff
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
			uint16_t color2 = thisLine[i];
    a69c:	68fd      	ldr	r5, [r7, #12]
			int16_t r2 = color2 & B11111;
			int16_t g2 = (color2 >> 5) & B111111;
			int16_t b2 = (color2 >> 11) & B11111;
			r1[i] = max((r2 * r1[i]) / 32, 0);
    a69e:	211f      	movs	r1, #31
		}
		break;
	case BlendMode::multiply:
		for (uint8_t i = 0; i < w; i++) {
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
			uint16_t color2 = thisLine[i];
    a6a0:	5aaa      	ldrh	r2, [r5, r2]
			int16_t r2 = color2 & B11111;
			int16_t g2 = (color2 >> 5) & B111111;
    a6a2:	0554      	lsls	r4, r2, #21
			int16_t b2 = (color2 >> 11) & B11111;
    a6a4:	0ad0      	lsrs	r0, r2, #11
			r1[i] = max((r2 * r1[i]) / 32, 0);
    a6a6:	400a      	ands	r2, r1
    a6a8:	56f1      	ldrsb	r1, [r6, r3]
	case BlendMode::multiply:
		for (uint8_t i = 0; i < w; i++) {
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
			uint16_t color2 = thisLine[i];
			int16_t r2 = color2 & B11111;
			int16_t g2 = (color2 >> 5) & B111111;
    a6aa:	0ea4      	lsrs	r4, r4, #26
			int16_t b2 = (color2 >> 11) & B11111;
			r1[i] = max((r2 * r1[i]) / 32, 0);
    a6ac:	434a      	muls	r2, r1
    a6ae:	2100      	movs	r1, #0
    a6b0:	2a1f      	cmp	r2, #31
    a6b2:	dd01      	ble.n	a6b8 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x440>
    a6b4:	1152      	asrs	r2, r2, #5
    a6b6:	b2d1      	uxtb	r1, r2
    a6b8:	54f1      	strb	r1, [r6, r3]
			g1[i] = max((g2 * g1[i]) / 64, 0);
    a6ba:	6939      	ldr	r1, [r7, #16]
    a6bc:	56ca      	ldrsb	r2, [r1, r3]
    a6be:	4354      	muls	r4, r2
    a6c0:	2200      	movs	r2, #0
    a6c2:	2c3f      	cmp	r4, #63	; 0x3f
    a6c4:	dd01      	ble.n	a6ca <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x452>
    a6c6:	11a4      	asrs	r4, r4, #6
    a6c8:	b2e2      	uxtb	r2, r4
    a6ca:	693c      	ldr	r4, [r7, #16]
			b1[i] = max((b2 * b1[i]) / 32, 0);
    a6cc:	697d      	ldr	r5, [r7, #20]
			uint16_t color2 = thisLine[i];
			int16_t r2 = color2 & B11111;
			int16_t g2 = (color2 >> 5) & B111111;
			int16_t b2 = (color2 >> 11) & B11111;
			r1[i] = max((r2 * r1[i]) / 32, 0);
			g1[i] = max((g2 * g1[i]) / 64, 0);
    a6ce:	54e2      	strb	r2, [r4, r3]
			b1[i] = max((b2 * b1[i]) / 32, 0);
    a6d0:	56ea      	ldrsb	r2, [r5, r3]
    a6d2:	4350      	muls	r0, r2
    a6d4:	2200      	movs	r2, #0
    a6d6:	281f      	cmp	r0, #31
    a6d8:	dd01      	ble.n	a6de <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x466>
    a6da:	1140      	asrs	r0, r0, #5
    a6dc:	b2c2      	uxtb	r2, r0
    a6de:	6979      	ldr	r1, [r7, #20]
    a6e0:	54ca      	strb	r2, [r1, r3]
    a6e2:	e7c6      	b.n	a672 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x3fa>
		}
		break;
	case BlendMode::screen:
		for (uint8_t i = 0; i < w; i++) {
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
    a6e4:	6bfd      	ldr	r5, [r7, #60]	; 0x3c
    a6e6:	005a      	lsls	r2, r3, #1
    a6e8:	8929      	ldrh	r1, [r5, #8]
    a6ea:	2900      	cmp	r1, #0
    a6ec:	d009      	beq.n	a702 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x48a>
    a6ee:	69fc      	ldr	r4, [r7, #28]
    a6f0:	5aa0      	ldrh	r0, [r4, r2]
    a6f2:	4288      	cmp	r0, r1
    a6f4:	d105      	bne.n	a702 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x48a>
			g1[i] = max((g2 * g1[i]) / 64, 0);
			b1[i] = max((b2 * b1[i]) / 32, 0);
		}
		break;
	case BlendMode::screen:
		for (uint8_t i = 0; i < w; i++) {
    a6f6:	3301      	adds	r3, #1
    a6f8:	b2db      	uxtb	r3, r3
    a6fa:	69bc      	ldr	r4, [r7, #24]
    a6fc:	42a3      	cmp	r3, r4
    a6fe:	d3f1      	bcc.n	a6e4 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x46c>
    a700:	e77f      	b.n	a602 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x38a>
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
			uint16_t color2 = thisLine[i];
    a702:	68fd      	ldr	r5, [r7, #12]
    a704:	5aac      	ldrh	r4, [r5, r2]
			int16_t r2 = color2 & B11111;
    a706:	221f      	movs	r2, #31
			int16_t g2 = (color2 >> 5) & B111111;
			int16_t b2 = (color2 >> 11) & B11111;
			r1[i] = min(31 - (31 - r2) * (31 - r1[i]) / 32, 31);
    a708:	1c15      	adds	r5, r2, #0
    a70a:	43a5      	bics	r5, r4
	case BlendMode::screen:
		for (uint8_t i = 0; i < w; i++) {
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
			uint16_t color2 = thisLine[i];
			int16_t r2 = color2 & B11111;
			int16_t g2 = (color2 >> 5) & B111111;
    a70c:	0560      	lsls	r0, r4, #21
			int16_t b2 = (color2 >> 11) & B11111;
    a70e:	0ae1      	lsrs	r1, r4, #11
			r1[i] = min(31 - (31 - r2) * (31 - r1[i]) / 32, 31);
    a710:	1c2c      	adds	r4, r5, #0
    a712:	56f5      	ldrsb	r5, [r6, r3]
	case BlendMode::screen:
		for (uint8_t i = 0; i < w; i++) {
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
			uint16_t color2 = thisLine[i];
			int16_t r2 = color2 & B11111;
			int16_t g2 = (color2 >> 5) & B111111;
    a714:	0e80      	lsrs	r0, r0, #26
			int16_t b2 = (color2 >> 11) & B11111;
			r1[i] = min(31 - (31 - r2) * (31 - r1[i]) / 32, 31);
    a716:	1b55      	subs	r5, r2, r5
    a718:	436c      	muls	r4, r5
    a71a:	4294      	cmp	r4, r2
    a71c:	dd06      	ble.n	a72c <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x4b4>
    a71e:	17e5      	asrs	r5, r4, #31
    a720:	0eed      	lsrs	r5, r5, #27
    a722:	192c      	adds	r4, r5, r4
    a724:	1162      	asrs	r2, r4, #5
    a726:	4252      	negs	r2, r2
    a728:	321f      	adds	r2, #31
    a72a:	b2d2      	uxtb	r2, r2
			g1[i] = min(63 - (63 - g2) * (63 - g1[i]) / 64, 63);
    a72c:	693d      	ldr	r5, [r7, #16]
			if (img.transparentColor && buffer[i] == img.transparentColor) continue;
			uint16_t color2 = thisLine[i];
			int16_t r2 = color2 & B11111;
			int16_t g2 = (color2 >> 5) & B111111;
			int16_t b2 = (color2 >> 11) & B11111;
			r1[i] = min(31 - (31 - r2) * (31 - r1[i]) / 32, 31);
    a72e:	54f2      	strb	r2, [r6, r3]
			g1[i] = min(63 - (63 - g2) * (63 - g1[i]) / 64, 63);
    a730:	56ec      	ldrsb	r4, [r5, r3]
    a732:	223f      	movs	r2, #63	; 0x3f
    a734:	1a10      	subs	r0, r2, r0
    a736:	1b14      	subs	r4, r2, r4
    a738:	4360      	muls	r0, r4
    a73a:	4290      	cmp	r0, r2
    a73c:	dd07      	ble.n	a74e <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x4d6>
    a73e:	17c4      	asrs	r4, r0, #31
    a740:	0ea4      	lsrs	r4, r4, #26
    a742:	1820      	adds	r0, r4, r0
    a744:	1180      	asrs	r0, r0, #6
    a746:	4240      	negs	r0, r0
    a748:	1c02      	adds	r2, r0, #0
    a74a:	323f      	adds	r2, #63	; 0x3f
    a74c:	b2d2      	uxtb	r2, r2
			b1[i] = min(31 - (31 - b2) * (31 - b1[i]) / 32, 31);
    a74e:	697d      	ldr	r5, [r7, #20]
			uint16_t color2 = thisLine[i];
			int16_t r2 = color2 & B11111;
			int16_t g2 = (color2 >> 5) & B111111;
			int16_t b2 = (color2 >> 11) & B11111;
			r1[i] = min(31 - (31 - r2) * (31 - r1[i]) / 32, 31);
			g1[i] = min(63 - (63 - g2) * (63 - g1[i]) / 64, 63);
    a750:	693c      	ldr	r4, [r7, #16]
			b1[i] = min(31 - (31 - b2) * (31 - b1[i]) / 32, 31);
    a752:	56e8      	ldrsb	r0, [r5, r3]
			uint16_t color2 = thisLine[i];
			int16_t r2 = color2 & B11111;
			int16_t g2 = (color2 >> 5) & B111111;
			int16_t b2 = (color2 >> 11) & B11111;
			r1[i] = min(31 - (31 - r2) * (31 - r1[i]) / 32, 31);
			g1[i] = min(63 - (63 - g2) * (63 - g1[i]) / 64, 63);
    a754:	54e2      	strb	r2, [r4, r3]
			b1[i] = min(31 - (31 - b2) * (31 - b1[i]) / 32, 31);
    a756:	221f      	movs	r2, #31
    a758:	1a51      	subs	r1, r2, r1
    a75a:	1a10      	subs	r0, r2, r0
    a75c:	4341      	muls	r1, r0
    a75e:	4291      	cmp	r1, r2
    a760:	dd07      	ble.n	a772 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x4fa>
    a762:	17c8      	asrs	r0, r1, #31
    a764:	0ec0      	lsrs	r0, r0, #27
    a766:	1841      	adds	r1, r0, r1
    a768:	1149      	asrs	r1, r1, #5
    a76a:	4249      	negs	r1, r1
    a76c:	1c0a      	adds	r2, r1, #0
    a76e:	321f      	adds	r2, #31
    a770:	b2d2      	uxtb	r2, r2
    a772:	6979      	ldr	r1, [r7, #20]
    a774:	54ca      	strb	r2, [r1, r3]
    a776:	e7be      	b.n	a6f6 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x47e>
		}
		break;
	}

	for (uint8_t i = 0; i < w; i++) {
		if (img.transparentColor && buffer[i] == img.transparentColor) continue;
    a778:	6bfd      	ldr	r5, [r7, #60]	; 0x3c
    a77a:	005a      	lsls	r2, r3, #1
    a77c:	8929      	ldrh	r1, [r5, #8]
    a77e:	2900      	cmp	r1, #0
    a780:	d009      	beq.n	a796 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x51e>
    a782:	69fc      	ldr	r4, [r7, #28]
    a784:	5aa0      	ldrh	r0, [r4, r2]
    a786:	4288      	cmp	r0, r1
    a788:	d105      	bne.n	a796 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x51e>
			b1[i] = min(31 - (31 - b2) * (31 - b1[i]) / 32, 31);
		}
		break;
	}

	for (uint8_t i = 0; i < w; i++) {
    a78a:	3301      	adds	r3, #1
    a78c:	b2db      	uxtb	r3, r3
    a78e:	69bc      	ldr	r4, [r7, #24]
    a790:	42a3      	cmp	r3, r4
    a792:	d3f1      	bcc.n	a778 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x500>
    a794:	e00b      	b.n	a7ae <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x536>
		if (img.transparentColor && buffer[i] == img.transparentColor) continue;
		thisLine[i] = (b1[i] << 11) + (g1[i] << 5) + r1[i];
    a796:	697d      	ldr	r5, [r7, #20]
    a798:	693c      	ldr	r4, [r7, #16]
    a79a:	56e8      	ldrsb	r0, [r5, r3]
    a79c:	56e1      	ldrsb	r1, [r4, r3]
    a79e:	02c0      	lsls	r0, r0, #11
    a7a0:	0149      	lsls	r1, r1, #5
    a7a2:	1841      	adds	r1, r0, r1
    a7a4:	56f0      	ldrsb	r0, [r6, r3]
    a7a6:	68fd      	ldr	r5, [r7, #12]
    a7a8:	1841      	adds	r1, r0, r1
    a7aa:	52a9      	strh	r1, [r5, r2]
    a7ac:	e7ed      	b.n	a78a <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x512>
    a7ae:	68bd      	ldr	r5, [r7, #8]
    a7b0:	46ad      	mov	sp, r5
    a7b2:	e001      	b.n	a7b8 <_ZN14Gamebuino_Meta5Image16drawBufferedLineEssPttRS0_+0x540>
				if (hi != img.transparentColorIndex) {
					*dst = (*dst & 0x0F) | (*src & 0xF0);
				}
			}
		}
		return;
    a7b4:	68bc      	ldr	r4, [r7, #8]
    a7b6:	46a5      	mov	sp, r4

	for (uint8_t i = 0; i < w; i++) {
		if (img.transparentColor && buffer[i] == img.transparentColor) continue;
		thisLine[i] = (b1[i] << 11) + (g1[i] << 5) + r1[i];
	}
}
    a7b8:	46bd      	mov	sp, r7
    a7ba:	b009      	add	sp, #36	; 0x24
    a7bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a7be:	46c0      	nop			; (mov r8, r8)

0000a7c0 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh>:
	
	
	Graphics::drawChar(x, y, c, size);
}

void Image::drawBitmap(int8_t x, int8_t y, const uint8_t *bitmap) {
    a7c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    a7c2:	b08d      	sub	sp, #52	; 0x34
    a7c4:	9002      	str	r0, [sp, #8]
	uint8_t w = *(bitmap++);
	uint8_t h = *(bitmap++);
	
	if ((x >= _width) || (y >= _height) || (x + w <= 0) || (x + h <= 0)) {
    a7c6:	9d02      	ldr	r5, [sp, #8]
	
	
	Graphics::drawChar(x, y, c, size);
}

void Image::drawBitmap(int8_t x, int8_t y, const uint8_t *bitmap) {
    a7c8:	9101      	str	r1, [sp, #4]
    a7ca:	1c14      	adds	r4, r2, #0
	uint8_t w = *(bitmap++);
	uint8_t h = *(bitmap++);
    a7cc:	7858      	ldrb	r0, [r3, #1]
	
	if ((x >= _width) || (y >= _height) || (x + w <= 0) || (x + h <= 0)) {
    a7ce:	2210      	movs	r2, #16
    a7d0:	5eaa      	ldrsh	r2, [r5, r2]
    a7d2:	9e01      	ldr	r6, [sp, #4]
	
	Graphics::drawChar(x, y, c, size);
}

void Image::drawBitmap(int8_t x, int8_t y, const uint8_t *bitmap) {
	uint8_t w = *(bitmap++);
    a7d4:	7819      	ldrb	r1, [r3, #0]
	uint8_t h = *(bitmap++);
    a7d6:	4684      	mov	ip, r0
	
	if ((x >= _width) || (y >= _height) || (x + w <= 0) || (x + h <= 0)) {
    a7d8:	4296      	cmp	r6, r2
    a7da:	db00      	blt.n	a7de <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x1e>
    a7dc:	e0e3      	b.n	a9a6 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x1e6>
    a7de:	9d02      	ldr	r5, [sp, #8]
    a7e0:	8a6e      	ldrh	r6, [r5, #18]
    a7e2:	b237      	sxth	r7, r6
    a7e4:	42bc      	cmp	r4, r7
    a7e6:	db00      	blt.n	a7ea <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x2a>
    a7e8:	e0dd      	b.n	a9a6 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x1e6>
    a7ea:	9801      	ldr	r0, [sp, #4]
    a7ec:	1840      	adds	r0, r0, r1
    a7ee:	9005      	str	r0, [sp, #20]
    a7f0:	2800      	cmp	r0, #0
    a7f2:	dc00      	bgt.n	a7f6 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x36>
    a7f4:	e0d7      	b.n	a9a6 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x1e6>
    a7f6:	9801      	ldr	r0, [sp, #4]
    a7f8:	1c05      	adds	r5, r0, #0
    a7fa:	4465      	add	r5, ip
    a7fc:	2d00      	cmp	r5, #0
    a7fe:	dc00      	bgt.n	a802 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x42>
    a800:	e0d1      	b.n	a9a6 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x1e6>
		return;
	}
	uint8_t bw = (w + 7) / 8;
    a802:	1dc8      	adds	r0, r1, #7
    a804:	10c0      	asrs	r0, r0, #3
	uint8_t _x = x;
	if (colorMode == ColorMode::index) {
    a806:	9d02      	ldr	r5, [sp, #8]
	uint8_t h = *(bitmap++);
	
	if ((x >= _width) || (y >= _height) || (x + w <= 0) || (x + h <= 0)) {
		return;
	}
	uint8_t bw = (w + 7) / 8;
    a808:	9004      	str	r0, [sp, #16]
	uint8_t _x = x;
	if (colorMode == ColorMode::index) {
    a80a:	7aad      	ldrb	r5, [r5, #10]
	Graphics::drawChar(x, y, c, size);
}

void Image::drawBitmap(int8_t x, int8_t y, const uint8_t *bitmap) {
	uint8_t w = *(bitmap++);
	uint8_t h = *(bitmap++);
    a80c:	3302      	adds	r3, #2
	if ((x >= _width) || (y >= _height) || (x + w <= 0) || (x + h <= 0)) {
		return;
	}
	uint8_t bw = (w + 7) / 8;
	uint8_t _x = x;
	if (colorMode == ColorMode::index) {
    a80e:	9503      	str	r5, [sp, #12]
    a810:	4665      	mov	r5, ip
    a812:	1928      	adds	r0, r5, r4
    a814:	9d03      	ldr	r5, [sp, #12]
    a816:	2d01      	cmp	r5, #1
    a818:	d17c      	bne.n	a914 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x154>
		uint8_t bw = (w + 7) / 8;
		if (y < 0) {
    a81a:	2c00      	cmp	r4, #0
    a81c:	da05      	bge.n	a82a <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x6a>
			h += y;
    a81e:	b2c0      	uxtb	r0, r0
    a820:	4684      	mov	ip, r0
			bitmap -= bw*y;
    a822:	9804      	ldr	r0, [sp, #16]
    a824:	4344      	muls	r4, r0
    a826:	1b1b      	subs	r3, r3, r4
			y = 0;
    a828:	2400      	movs	r4, #0
		}
		if (y + h > _height) {
    a82a:	4665      	mov	r5, ip
    a82c:	1961      	adds	r1, r4, r5
    a82e:	42b9      	cmp	r1, r7
    a830:	dd02      	ble.n	a838 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x78>
			h = _height - y;
    a832:	1b36      	subs	r6, r6, r4
    a834:	b2f6      	uxtb	r6, r6
    a836:	46b4      	mov	ip, r6
		}
		uint8_t x1 = max(0, x);
    a838:	9e01      	ldr	r6, [sp, #4]
		uint8_t x2 = min(_width, x + w);
    a83a:	9d05      	ldr	r5, [sp, #20]
			y = 0;
		}
		if (y + h > _height) {
			h = _height - y;
		}
		uint8_t x1 = max(0, x);
    a83c:	43f1      	mvns	r1, r6
    a83e:	17c9      	asrs	r1, r1, #31
    a840:	4031      	ands	r1, r6
    a842:	b2cf      	uxtb	r7, r1
		uint8_t x2 = min(_width, x + w);
    a844:	4295      	cmp	r5, r2
    a846:	dd00      	ble.n	a84a <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x8a>
    a848:	1c15      	adds	r5, r2, #0
    a84a:	b2ed      	uxtb	r5, r5
    a84c:	9506      	str	r5, [sp, #24]
		
		bitmap += (x1 - x) / 8;
    a84e:	9d01      	ldr	r5, [sp, #4]
    a850:	b279      	sxtb	r1, r7
    a852:	1b49      	subs	r1, r1, r5
    a854:	17c8      	asrs	r0, r1, #31
    a856:	0f40      	lsrs	r0, r0, #29
    a858:	1840      	adds	r0, r0, r1
    a85a:	10c0      	asrs	r0, r0, #3
    a85c:	181b      	adds	r3, r3, r0
		uint8_t first_bitmap_mask = 0x80 >> ((x1 - x) & 7);
    a85e:	2007      	movs	r0, #7
    a860:	4001      	ands	r1, r0
    a862:	2080      	movs	r0, #128	; 0x80
    a864:	4108      	asrs	r0, r1
    a866:	b2c1      	uxtb	r1, r0
		uint16_t bufBytewidth = ((_width + 1) / 2);
    a868:	3201      	adds	r2, #1
		}
		uint8_t x1 = max(0, x);
		uint8_t x2 = min(_width, x + w);
		
		bitmap += (x1 - x) / 8;
		uint8_t first_bitmap_mask = 0x80 >> ((x1 - x) & 7);
    a86a:	9107      	str	r1, [sp, #28]
		uint16_t bufBytewidth = ((_width + 1) / 2);
    a86c:	0fd1      	lsrs	r1, r2, #31
    a86e:	188a      	adds	r2, r1, r2
    a870:	1052      	asrs	r2, r2, #1
		uint8_t* buf = (uint8_t*)_buffer;
		buf += bufBytewidth * y + x1 / 2;
    a872:	b292      	uxth	r2, r2
    a874:	4354      	muls	r4, r2
    a876:	9e02      	ldr	r6, [sp, #8]
    a878:	9205      	str	r2, [sp, #20]
    a87a:	087a      	lsrs	r2, r7, #1
    a87c:	18a4      	adds	r4, r4, r2
    a87e:	6972      	ldr	r2, [r6, #20]
		
		
		uint8_t b1 = color.i;
		uint8_t b2 = color.iu;
		
		for (uint8_t dy=0; dy<h; dy++, bitmap+=bw, buf+=bufBytewidth) {
    a880:	2100      	movs	r1, #0
		
		bitmap += (x1 - x) / 8;
		uint8_t first_bitmap_mask = 0x80 >> ((x1 - x) & 7);
		uint16_t bufBytewidth = ((_width + 1) / 2);
		uint8_t* buf = (uint8_t*)_buffer;
		buf += bufBytewidth * y + x1 / 2;
    a882:	1912      	adds	r2, r2, r4
    a884:	9201      	str	r2, [sp, #4]
		bool screen_alt_initial = (x1 % 2) == 0;
    a886:	2201      	movs	r2, #1
    a888:	43ba      	bics	r2, r7
    a88a:	9208      	str	r2, [sp, #32]
		
		
		uint8_t b1 = color.i;
    a88c:	4a47      	ldr	r2, [pc, #284]	; (a9ac <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x1ec>)
    a88e:	7850      	ldrb	r0, [r2, #1]
		uint8_t b2 = color.iu;
    a890:	7812      	ldrb	r2, [r2, #0]
		uint8_t* buf = (uint8_t*)_buffer;
		buf += bufBytewidth * y + x1 / 2;
		bool screen_alt_initial = (x1 % 2) == 0;
		
		
		uint8_t b1 = color.i;
    a892:	9009      	str	r0, [sp, #36]	; 0x24
		uint8_t b2 = color.iu;
    a894:	920a      	str	r2, [sp, #40]	; 0x28
		
		for (uint8_t dy=0; dy<h; dy++, bitmap+=bw, buf+=bufBytewidth) {
    a896:	9102      	str	r1, [sp, #8]
    a898:	9c02      	ldr	r4, [sp, #8]
    a89a:	4564      	cmp	r4, ip
    a89c:	d100      	bne.n	a8a0 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0xe0>
    a89e:	e082      	b.n	a9a6 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x1e6>
			const uint8_t* bitmap_ptr = bitmap;
			uint8_t bitmap_mask = first_bitmap_mask;
			uint8_t* screen_buf = buf;
			uint8_t pixels = *(bitmap_ptr++);
    a8a0:	1c5a      	adds	r2, r3, #1
    a8a2:	781c      	ldrb	r4, [r3, #0]
    a8a4:	9200      	str	r2, [sp, #0]
			bool screen_alt = screen_alt_initial;
    a8a6:	9d08      	ldr	r5, [sp, #32]
		uint8_t b2 = color.iu;
		
		for (uint8_t dy=0; dy<h; dy++, bitmap+=bw, buf+=bufBytewidth) {
			const uint8_t* bitmap_ptr = bitmap;
			uint8_t bitmap_mask = first_bitmap_mask;
			uint8_t* screen_buf = buf;
    a8a8:	9a01      	ldr	r2, [sp, #4]
		uint8_t b1 = color.i;
		uint8_t b2 = color.iu;
		
		for (uint8_t dy=0; dy<h; dy++, bitmap+=bw, buf+=bufBytewidth) {
			const uint8_t* bitmap_ptr = bitmap;
			uint8_t bitmap_mask = first_bitmap_mask;
    a8aa:	9907      	ldr	r1, [sp, #28]
			uint8_t* screen_buf = buf;
			uint8_t pixels = *(bitmap_ptr++);
    a8ac:	9403      	str	r4, [sp, #12]
			bool screen_alt = screen_alt_initial;
			for (uint8_t sx=x1; sx<x2; sx++) {
    a8ae:	1c38      	adds	r0, r7, #0
    a8b0:	9e06      	ldr	r6, [sp, #24]
    a8b2:	42b0      	cmp	r0, r6
    a8b4:	d223      	bcs.n	a8fe <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x13e>
    a8b6:	9e03      	ldr	r6, [sp, #12]
    a8b8:	400e      	ands	r6, r1
				
				if (screen_alt) {
    a8ba:	2d00      	cmp	r5, #0
    a8bc:	d008      	beq.n	a8d0 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x110>
					if (pixels & bitmap_mask) {
    a8be:	2e00      	cmp	r6, #0
    a8c0:	d00f      	beq.n	a8e2 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x122>
						*screen_buf = (*screen_buf & 0x0F) | b2;
    a8c2:	7816      	ldrb	r6, [r2, #0]
    a8c4:	240f      	movs	r4, #15
    a8c6:	4034      	ands	r4, r6
    a8c8:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    a8ca:	4334      	orrs	r4, r6
    a8cc:	7014      	strb	r4, [r2, #0]
    a8ce:	e008      	b.n	a8e2 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x122>
					}
				} else {
					if (pixels & bitmap_mask) {
    a8d0:	2e00      	cmp	r6, #0
    a8d2:	d005      	beq.n	a8e0 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x120>
						*screen_buf = (*screen_buf & 0xF0) | b1;
    a8d4:	7814      	ldrb	r4, [r2, #0]
    a8d6:	260f      	movs	r6, #15
    a8d8:	43b4      	bics	r4, r6
    a8da:	9e09      	ldr	r6, [sp, #36]	; 0x24
    a8dc:	4334      	orrs	r4, r6
    a8de:	7014      	strb	r4, [r2, #0]
					}
					screen_buf++;
    a8e0:	3201      	adds	r2, #1
				}
				screen_alt = !screen_alt;
    a8e2:	2601      	movs	r6, #1
    a8e4:	4075      	eors	r5, r6
				
				bitmap_mask >>= 1;
    a8e6:	40f1      	lsrs	r1, r6
				if (!bitmap_mask) {
    a8e8:	d106      	bne.n	a8f8 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x138>
					bitmap_mask = 0x80;
					pixels = *(bitmap_ptr++);
    a8ea:	9900      	ldr	r1, [sp, #0]
    a8ec:	9c00      	ldr	r4, [sp, #0]
    a8ee:	7809      	ldrb	r1, [r1, #0]
    a8f0:	19a4      	adds	r4, r4, r6
    a8f2:	9103      	str	r1, [sp, #12]
    a8f4:	9400      	str	r4, [sp, #0]
				}
				screen_alt = !screen_alt;
				
				bitmap_mask >>= 1;
				if (!bitmap_mask) {
					bitmap_mask = 0x80;
    a8f6:	2180      	movs	r1, #128	; 0x80
			const uint8_t* bitmap_ptr = bitmap;
			uint8_t bitmap_mask = first_bitmap_mask;
			uint8_t* screen_buf = buf;
			uint8_t pixels = *(bitmap_ptr++);
			bool screen_alt = screen_alt_initial;
			for (uint8_t sx=x1; sx<x2; sx++) {
    a8f8:	3001      	adds	r0, #1
    a8fa:	b2c0      	uxtb	r0, r0
    a8fc:	e7d8      	b.n	a8b0 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0xf0>
		
		
		uint8_t b1 = color.i;
		uint8_t b2 = color.iu;
		
		for (uint8_t dy=0; dy<h; dy++, bitmap+=bw, buf+=bufBytewidth) {
    a8fe:	9a02      	ldr	r2, [sp, #8]
    a900:	9901      	ldr	r1, [sp, #4]
    a902:	3201      	adds	r2, #1
    a904:	b2d2      	uxtb	r2, r2
    a906:	9202      	str	r2, [sp, #8]
    a908:	9a05      	ldr	r2, [sp, #20]
    a90a:	9804      	ldr	r0, [sp, #16]
    a90c:	1889      	adds	r1, r1, r2
    a90e:	181b      	adds	r3, r3, r0
    a910:	9101      	str	r1, [sp, #4]
    a912:	e7c1      	b.n	a898 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0xd8>
					pixels = *(bitmap_ptr++);
				}
			}
		}
	} else {
		uint8_t dw = 8 - (w%8);
    a914:	2207      	movs	r2, #7
    a916:	4011      	ands	r1, r2
	uint8_t h = *(bitmap++);
	
	if ((x >= _width) || (y >= _height) || (x + w <= 0) || (x + h <= 0)) {
		return;
	}
	uint8_t bw = (w + 7) / 8;
    a918:	9d04      	ldr	r5, [sp, #16]
					pixels = *(bitmap_ptr++);
				}
			}
		}
	} else {
		uint8_t dw = 8 - (w%8);
    a91a:	2208      	movs	r2, #8
    a91c:	1a52      	subs	r2, r2, r1
	uint8_t h = *(bitmap++);
	
	if ((x >= _width) || (y >= _height) || (x + w <= 0) || (x + h <= 0)) {
		return;
	}
	uint8_t bw = (w + 7) / 8;
    a91e:	b2ed      	uxtb	r5, r5
					pixels = *(bitmap_ptr++);
				}
			}
		}
	} else {
		uint8_t dw = 8 - (w%8);
    a920:	b2d2      	uxtb	r2, r2
    a922:	b2c0      	uxtb	r0, r0
	uint8_t h = *(bitmap++);
	
	if ((x >= _width) || (y >= _height) || (x + w <= 0) || (x + h <= 0)) {
		return;
	}
	uint8_t bw = (w + 7) / 8;
    a924:	9506      	str	r5, [sp, #24]
					pixels = *(bitmap_ptr++);
				}
			}
		}
	} else {
		uint8_t dw = 8 - (w%8);
    a926:	9107      	str	r1, [sp, #28]
    a928:	9209      	str	r2, [sp, #36]	; 0x24
    a92a:	900a      	str	r0, [sp, #40]	; 0x28
		for (uint8_t j = 0; j < h; j++) {
    a92c:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    a92e:	b272      	sxtb	r2, r6
    a930:	4294      	cmp	r4, r2
    a932:	d038      	beq.n	a9a6 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x1e6>
    a934:	9d01      	ldr	r5, [sp, #4]
    a936:	1c1e      	adds	r6, r3, #0
    a938:	9505      	str	r5, [sp, #20]
    a93a:	2700      	movs	r7, #0
			x = _x;
			for (uint8_t i = 0; i < bw;) {
    a93c:	9d06      	ldr	r5, [sp, #24]
    a93e:	1c33      	adds	r3, r6, #0
    a940:	42af      	cmp	r7, r5
    a942:	d22d      	bcs.n	a9a0 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x1e0>
				uint8_t b = *(bitmap++);
    a944:	7835      	ldrb	r5, [r6, #0]
				i++;
    a946:	1c7b      	adds	r3, r7, #1
	} else {
		uint8_t dw = 8 - (w%8);
		for (uint8_t j = 0; j < h; j++) {
			x = _x;
			for (uint8_t i = 0; i < bw;) {
				uint8_t b = *(bitmap++);
    a948:	9503      	str	r5, [sp, #12]
				i++;
    a94a:	b2df      	uxtb	r7, r3
    a94c:	2500      	movs	r5, #0
    a94e:	9805      	ldr	r0, [sp, #20]
    a950:	b2e9      	uxtb	r1, r5
    a952:	b2c0      	uxtb	r0, r0
				for (uint8_t k = 0; k < 8; k++) {
					if (i == bw && k == dw) {
    a954:	9a06      	ldr	r2, [sp, #24]
    a956:	9104      	str	r1, [sp, #16]
    a958:	1809      	adds	r1, r1, r0
    a95a:	9008      	str	r0, [sp, #32]
    a95c:	b249      	sxtb	r1, r1
    a95e:	4297      	cmp	r7, r2
    a960:	d107      	bne.n	a972 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x1b2>
    a962:	9b04      	ldr	r3, [sp, #16]
    a964:	9809      	ldr	r0, [sp, #36]	; 0x24
    a966:	4283      	cmp	r3, r0
    a968:	d103      	bne.n	a972 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x1b2>
						x += (w%8);
    a96a:	9d07      	ldr	r5, [sp, #28]
    a96c:	1869      	adds	r1, r5, r1
    a96e:	b249      	sxtb	r1, r1
						break;
    a970:	e013      	b.n	a99a <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x1da>
					}
					if (b&0x80) {
    a972:	9803      	ldr	r0, [sp, #12]
    a974:	b243      	sxtb	r3, r0
    a976:	2b00      	cmp	r3, #0
    a978:	da03      	bge.n	a982 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x1c2>
						drawPixel(x, y);
    a97a:	9802      	ldr	r0, [sp, #8]
    a97c:	1c22      	adds	r2, r4, #0
    a97e:	f7fe fe31 	bl	95e4 <_ZN14Gamebuino_Meta8Graphics9drawPixelEss>
					}
					b <<= 1;
    a982:	9903      	ldr	r1, [sp, #12]
    a984:	9a04      	ldr	r2, [sp, #16]
    a986:	004b      	lsls	r3, r1, #1
    a988:	9908      	ldr	r1, [sp, #32]
    a98a:	b2db      	uxtb	r3, r3
    a98c:	3101      	adds	r1, #1
    a98e:	1851      	adds	r1, r2, r1
    a990:	3501      	adds	r5, #1
    a992:	9303      	str	r3, [sp, #12]
    a994:	b249      	sxtb	r1, r1
		for (uint8_t j = 0; j < h; j++) {
			x = _x;
			for (uint8_t i = 0; i < bw;) {
				uint8_t b = *(bitmap++);
				i++;
				for (uint8_t k = 0; k < 8; k++) {
    a996:	2d08      	cmp	r5, #8
    a998:	d1d9      	bne.n	a94e <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x18e>
    a99a:	3601      	adds	r6, #1
				}
			}
		}
	} else {
		uint8_t dw = 8 - (w%8);
		for (uint8_t j = 0; j < h; j++) {
    a99c:	9105      	str	r1, [sp, #20]
    a99e:	e7cd      	b.n	a93c <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x17c>
    a9a0:	3401      	adds	r4, #1
    a9a2:	b264      	sxtb	r4, r4
    a9a4:	e7c2      	b.n	a92c <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKh+0x16c>
				}
			}
			y++;
		}
	}
}
    a9a6:	b00d      	add	sp, #52	; 0x34
    a9a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a9aa:	46c0      	nop			; (mov r8, r8)
    a9ac:	20000cd8 	.word	0x20000cd8

0000a9b0 <_ZN14Gamebuino_Meta5Image10drawBitmapEaaPKhhh>:

void Image::drawBitmap(int8_t x, int8_t y, const uint8_t *bitmap,
	uint8_t rotation, uint8_t flip) {
    a9b0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    a9b2:	ac06      	add	r4, sp, #24
    a9b4:	7825      	ldrb	r5, [r4, #0]
    a9b6:	ac07      	add	r4, sp, #28
    a9b8:	7824      	ldrb	r4, [r4, #0]
	Graphics::drawBitmap(x, y, bitmap, rotation, flip);
    a9ba:	9500      	str	r5, [sp, #0]
    a9bc:	9401      	str	r4, [sp, #4]
    a9be:	f7fe ffe3 	bl	9988 <_ZN14Gamebuino_Meta8Graphics10drawBitmapEaaPKhhh>
}
    a9c2:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

0000a9c4 <_ZN14Gamebuino_Meta5Image5_fillEv>:
		}
		return;
	}
}

void Image::_fill() {
    a9c4:	b570      	push	{r4, r5, r6, lr}
    a9c6:	1c04      	adds	r4, r0, #0
	if (_buffer) {
    a9c8:	6940      	ldr	r0, [r0, #20]
    a9ca:	2800      	cmp	r0, #0
    a9cc:	d02f      	beq.n	aa2e <_ZN14Gamebuino_Meta5Image5_fillEv+0x6a>
		if (colorMode == ColorMode::rgb565) {
    a9ce:	7aa3      	ldrb	r3, [r4, #10]
    a9d0:	2b00      	cmp	r3, #0
    a9d2:	d11a      	bne.n	aa0a <_ZN14Gamebuino_Meta5Image5_fillEv+0x46>
			uint8_t hi = (uint16_t)color.c >> 8;
    a9d4:	4a16      	ldr	r2, [pc, #88]	; (aa30 <_ZN14Gamebuino_Meta5Image5_fillEv+0x6c>)
    a9d6:	8815      	ldrh	r5, [r2, #0]
    a9d8:	1229      	asrs	r1, r5, #8
			uint8_t lo = (uint16_t)color.c & 0xFF;
			if (hi == lo) {
    a9da:	b2ed      	uxtb	r5, r5
    a9dc:	42a9      	cmp	r1, r5
    a9de:	d108      	bne.n	a9f2 <_ZN14Gamebuino_Meta5Image5_fillEv+0x2e>
				memset(_buffer, lo, _width * _height * 2);
    a9e0:	2210      	movs	r2, #16
    a9e2:	5ea3      	ldrsh	r3, [r4, r2]
    a9e4:	2512      	movs	r5, #18
    a9e6:	5f62      	ldrsh	r2, [r4, r5]
    a9e8:	435a      	muls	r2, r3
    a9ea:	0052      	lsls	r2, r2, #1
    a9ec:	f006 fdee 	bl	115cc <memset>
    a9f0:	e00b      	b.n	aa0a <_ZN14Gamebuino_Meta5Image5_fillEv+0x46>
			} else {
				uint16_t i, pixels = _width * _height;
    a9f2:	8a65      	ldrh	r5, [r4, #18]
    a9f4:	8a21      	ldrh	r1, [r4, #16]
    a9f6:	4369      	muls	r1, r5
    a9f8:	b289      	uxth	r1, r1
				for (i = 0; i<pixels; i++) _buffer[i] = (uint16_t)color.c;
    a9fa:	b29d      	uxth	r5, r3
    a9fc:	428d      	cmp	r5, r1
    a9fe:	d204      	bcs.n	aa0a <_ZN14Gamebuino_Meta5Image5_fillEv+0x46>
    aa00:	8816      	ldrh	r6, [r2, #0]
    aa02:	005d      	lsls	r5, r3, #1
    aa04:	5346      	strh	r6, [r0, r5]
    aa06:	3301      	adds	r3, #1
    aa08:	e7f7      	b.n	a9fa <_ZN14Gamebuino_Meta5Image5_fillEv+0x36>
			}
		}
		
		if (colorMode == ColorMode::index) {
    aa0a:	7aa3      	ldrb	r3, [r4, #10]
    aa0c:	2b01      	cmp	r3, #1
    aa0e:	d10e      	bne.n	aa2e <_ZN14Gamebuino_Meta5Image5_fillEv+0x6a>
			uint8_t pack = ((uint8_t)color.i) | ((uint8_t)color.iu);
    aa10:	4b07      	ldr	r3, [pc, #28]	; (aa30 <_ZN14Gamebuino_Meta5Image5_fillEv+0x6c>)
			memset(_buffer, pack, _width * _height / 2);
    aa12:	6960      	ldr	r0, [r4, #20]
				for (i = 0; i<pixels; i++) _buffer[i] = (uint16_t)color.c;
			}
		}
		
		if (colorMode == ColorMode::index) {
			uint8_t pack = ((uint8_t)color.i) | ((uint8_t)color.iu);
    aa14:	7819      	ldrb	r1, [r3, #0]
    aa16:	785b      	ldrb	r3, [r3, #1]
			memset(_buffer, pack, _width * _height / 2);
    aa18:	4319      	orrs	r1, r3
    aa1a:	2210      	movs	r2, #16
    aa1c:	5ea3      	ldrsh	r3, [r4, r2]
    aa1e:	2512      	movs	r5, #18
    aa20:	5f62      	ldrsh	r2, [r4, r5]
    aa22:	4353      	muls	r3, r2
    aa24:	0fda      	lsrs	r2, r3, #31
    aa26:	18d3      	adds	r3, r2, r3
    aa28:	105a      	asrs	r2, r3, #1
    aa2a:	f006 fdcf 	bl	115cc <memset>
		}
	}
}
    aa2e:	bd70      	pop	{r4, r5, r6, pc}
    aa30:	20000cd8 	.word	0x20000cd8

0000aa34 <_ZN14Gamebuino_Meta5Image8drawCharEsshh>:
		if (img.transparentColor && buffer[i] == img.transparentColor) continue;
		thisLine[i] = (b1[i] << 11) + (g1[i] << 5) + r1[i];
	}
}

void Image::drawChar(int16_t x, int16_t y, unsigned char c, uint8_t size) {
    aa34:	b5f0      	push	{r4, r5, r6, r7, lr}
    aa36:	b08b      	sub	sp, #44	; 0x2c
    aa38:	1c04      	adds	r4, r0, #0
    aa3a:	a810      	add	r0, sp, #64	; 0x40
    aa3c:	7805      	ldrb	r5, [r0, #0]
	if(gfxFont) {
    aa3e:	4874      	ldr	r0, [pc, #464]	; (ac10 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1dc>)
    aa40:	6800      	ldr	r0, [r0, #0]
    aa42:	2800      	cmp	r0, #0
    aa44:	d004      	beq.n	aa50 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1c>
		Graphics::drawChar(x, y, c, size);
    aa46:	9500      	str	r5, [sp, #0]
    aa48:	1c20      	adds	r0, r4, #0
    aa4a:	f7ff f81d 	bl	9a88 <_ZN14Gamebuino_Meta8Graphics8drawCharEsshh>
		return;
    aa4e:	e0dc      	b.n	ac0a <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1d6>
	}
	if((x >= _width)            || // Clip right
    aa50:	2610      	movs	r6, #16
    aa52:	5fa0      	ldrsh	r0, [r4, r6]
    aa54:	4281      	cmp	r1, r0
    aa56:	db00      	blt.n	aa5a <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x26>
    aa58:	e0d7      	b.n	ac0a <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1d6>
    aa5a:	2712      	movs	r7, #18
    aa5c:	5fe6      	ldrsh	r6, [r4, r7]
    aa5e:	4296      	cmp	r6, r2
    aa60:	dc00      	bgt.n	aa64 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x30>
    aa62:	e0d2      	b.n	ac0a <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1d6>
		 (y >= _height)           || // Clip bottom
		 ((x + fontWidth * size - 1) < 0) || // Clip left
    aa64:	4e6b      	ldr	r6, [pc, #428]	; (ac14 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1e0>)
    aa66:	7837      	ldrb	r7, [r6, #0]
    aa68:	1c2e      	adds	r6, r5, #0
    aa6a:	437e      	muls	r6, r7
    aa6c:	198e      	adds	r6, r1, r6
	if(gfxFont) {
		Graphics::drawChar(x, y, c, size);
		return;
	}
	if((x >= _width)            || // Clip right
		 (y >= _height)           || // Clip bottom
    aa6e:	2e00      	cmp	r6, #0
    aa70:	dc00      	bgt.n	aa74 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x40>
    aa72:	e0ca      	b.n	ac0a <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1d6>
		 ((x + fontWidth * size - 1) < 0) || // Clip left
		 ((y + fontHeight * size - 1) < 0))   // Clip top
    aa74:	4e68      	ldr	r6, [pc, #416]	; (ac18 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1e4>)
    aa76:	7836      	ldrb	r6, [r6, #0]
    aa78:	436e      	muls	r6, r5
    aa7a:	1996      	adds	r6, r2, r6
		Graphics::drawChar(x, y, c, size);
		return;
	}
	if((x >= _width)            || // Clip right
		 (y >= _height)           || // Clip bottom
		 ((x + fontWidth * size - 1) < 0) || // Clip left
    aa7c:	2e00      	cmp	r6, #0
    aa7e:	dc00      	bgt.n	aa82 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x4e>
    aa80:	e0c3      	b.n	ac0a <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1d6>
		 ((y + fontHeight * size - 1) < 0))   // Clip top
		return;
	
	if (size == 2 && colorMode == ColorMode::index) {
    aa82:	2d02      	cmp	r5, #2
    aa84:	d1df      	bne.n	aa46 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x12>
    aa86:	7aa6      	ldrb	r6, [r4, #10]
    aa88:	2e01      	cmp	r6, #1
    aa8a:	d1dc      	bne.n	aa46 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x12>
		if(!_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior
    aa8c:	4d63      	ldr	r5, [pc, #396]	; (ac1c <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1e8>)
    aa8e:	782d      	ldrb	r5, [r5, #0]
    aa90:	2d00      	cmp	r5, #0
    aa92:	d103      	bne.n	aa9c <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x68>
    aa94:	2baf      	cmp	r3, #175	; 0xaf
    aa96:	d901      	bls.n	aa9c <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x68>
    aa98:	3301      	adds	r3, #1
    aa9a:	b2db      	uxtb	r3, r3
		if (c >= 0x80) c -= 0x20;
    aa9c:	b25d      	sxtb	r5, r3
    aa9e:	2d00      	cmp	r5, #0
    aaa0:	da01      	bge.n	aaa6 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x72>
    aaa2:	3b20      	subs	r3, #32
    aaa4:	b2db      	uxtb	r3, r3
    aaa6:	4d5e      	ldr	r5, [pc, #376]	; (ac20 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1ec>)
    aaa8:	6964      	ldr	r4, [r4, #20]
    aaaa:	46ac      	mov	ip, r5
    aaac:	9405      	str	r4, [sp, #20]
		if (!(x % 2)) {
			uint8_t fg = color.iu | color.i;
    aaae:	4664      	mov	r4, ip
    aab0:	7864      	ldrb	r4, [r4, #1]
    aab2:	4d5c      	ldr	r5, [pc, #368]	; (ac24 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1f0>)
    aab4:	3f01      	subs	r7, #1
    aab6:	9403      	str	r4, [sp, #12]
		return;
	
	if (size == 2 && colorMode == ColorMode::index) {
		if(!_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior
		if (c >= 0x80) c -= 0x20;
		if (!(x % 2)) {
    aab8:	07ce      	lsls	r6, r1, #31
    aaba:	d449      	bmi.n	ab50 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x11c>
			uint8_t fg = color.iu | color.i;
    aabc:	4666      	mov	r6, ip
    aabe:	7836      	ldrb	r6, [r6, #0]
			uint8_t bg = bgcolor.iu | bgcolor.i;
			uint8_t* buf = (uint8_t*)_buffer;
			uint8_t img_bytewidth = (_width + 1) / 2;
    aac0:	3001      	adds	r0, #1
	
	if (size == 2 && colorMode == ColorMode::index) {
		if(!_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior
		if (c >= 0x80) c -= 0x20;
		if (!(x % 2)) {
			uint8_t fg = color.iu | color.i;
    aac2:	4334      	orrs	r4, r6
			uint8_t bg = bgcolor.iu | bgcolor.i;
    aac4:	786e      	ldrb	r6, [r5, #1]
    aac6:	782d      	ldrb	r5, [r5, #0]
			uint8_t* buf = (uint8_t*)_buffer;
			uint8_t img_bytewidth = (_width + 1) / 2;
			buf += y*img_bytewidth + (x / 2);
			uint8_t* _buf = buf;
			uint8_t font_bytewidth = fontWidth - 1;
    aac8:	b2ff      	uxtb	r7, r7
	if (size == 2 && colorMode == ColorMode::index) {
		if(!_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior
		if (c >= 0x80) c -= 0x20;
		if (!(x % 2)) {
			uint8_t fg = color.iu | color.i;
			uint8_t bg = bgcolor.iu | bgcolor.i;
    aaca:	4335      	orrs	r5, r6
			uint8_t* buf = (uint8_t*)_buffer;
			uint8_t img_bytewidth = (_width + 1) / 2;
    aacc:	0fc6      	lsrs	r6, r0, #31
    aace:	46b4      	mov	ip, r6
    aad0:	4460      	add	r0, ip
    aad2:	1040      	asrs	r0, r0, #1
			buf += y*img_bytewidth + (x / 2);
    aad4:	b2c0      	uxtb	r0, r0
    aad6:	0fce      	lsrs	r6, r1, #31
    aad8:	4342      	muls	r2, r0
    aada:	46b4      	mov	ip, r6
    aadc:	4461      	add	r1, ip
    aade:	1049      	asrs	r1, r1, #1
    aae0:	1852      	adds	r2, r2, r1
    aae2:	9905      	ldr	r1, [sp, #20]
			uint8_t* _buf = buf;
			uint8_t font_bytewidth = fontWidth - 1;
    aae4:	9706      	str	r7, [sp, #24]
			for (uint8_t i = 0; i < fontWidth; i++) {
				uint8_t line;
				if (i == font_bytewidth) {
					line = 0;
				} else {
					line = font[c*font_bytewidth + i];
    aae6:	435f      	muls	r7, r3
		if (!(x % 2)) {
			uint8_t fg = color.iu | color.i;
			uint8_t bg = bgcolor.iu | bgcolor.i;
			uint8_t* buf = (uint8_t*)_buffer;
			uint8_t img_bytewidth = (_width + 1) / 2;
			buf += y*img_bytewidth + (x / 2);
    aae8:	188a      	adds	r2, r1, r2
    aaea:	9203      	str	r2, [sp, #12]
						*buf = bg;
						buf += img_bytewidth;
						*buf = bg;
						buf += img_bytewidth;
					} else {
						buf += img_bytewidth*2;
    aaec:	0042      	lsls	r2, r0, #1
    aaee:	9205      	str	r2, [sp, #20]
		if (!(x % 2)) {
			uint8_t fg = color.iu | color.i;
			uint8_t bg = bgcolor.iu | bgcolor.i;
			uint8_t* buf = (uint8_t*)_buffer;
			uint8_t img_bytewidth = (_width + 1) / 2;
			buf += y*img_bytewidth + (x / 2);
    aaf0:	9a03      	ldr	r2, [sp, #12]
			for (uint8_t i = 0; i < fontWidth; i++) {
				uint8_t line;
				if (i == font_bytewidth) {
					line = 0;
				} else {
					line = font[c*font_bytewidth + i];
    aaf2:	9704      	str	r7, [sp, #16]
    aaf4:	9903      	ldr	r1, [sp, #12]
    aaf6:	1a53      	subs	r3, r2, r1
			uint8_t* buf = (uint8_t*)_buffer;
			uint8_t img_bytewidth = (_width + 1) / 2;
			buf += y*img_bytewidth + (x / 2);
			uint8_t* _buf = buf;
			uint8_t font_bytewidth = fontWidth - 1;
			for (uint8_t i = 0; i < fontWidth; i++) {
    aaf8:	4946      	ldr	r1, [pc, #280]	; (ac14 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1e0>)
    aafa:	b2db      	uxtb	r3, r3
    aafc:	7809      	ldrb	r1, [r1, #0]
    aafe:	4299      	cmp	r1, r3
    ab00:	d800      	bhi.n	ab04 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0xd0>
    ab02:	e082      	b.n	ac0a <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1d6>
				uint8_t line;
				if (i == font_bytewidth) {
    ab04:	9e06      	ldr	r6, [sp, #24]
    ab06:	42b3      	cmp	r3, r6
    ab08:	d005      	beq.n	ab16 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0xe2>
					line = 0;
				} else {
					line = font[c*font_bytewidth + i];
    ab0a:	4947      	ldr	r1, [pc, #284]	; (ac28 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1f4>)
    ab0c:	9f04      	ldr	r7, [sp, #16]
    ab0e:	6809      	ldr	r1, [r1, #0]
    ab10:	19c9      	adds	r1, r1, r7
    ab12:	5cc9      	ldrb	r1, [r1, r3]
    ab14:	e000      	b.n	ab18 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0xe4>
			uint8_t* _buf = buf;
			uint8_t font_bytewidth = fontWidth - 1;
			for (uint8_t i = 0; i < fontWidth; i++) {
				uint8_t line;
				if (i == font_bytewidth) {
					line = 0;
    ab16:	2100      	movs	r1, #0
    ab18:	1c13      	adds	r3, r2, #0
    ab1a:	2600      	movs	r6, #0
				} else {
					line = font[c*font_bytewidth + i];
				}
				for (uint8_t j = 0; j < fontHeight; j++) {
    ab1c:	4f3e      	ldr	r7, [pc, #248]	; (ac18 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1e4>)
    ab1e:	783f      	ldrb	r7, [r7, #0]
    ab20:	42b7      	cmp	r7, r6
    ab22:	d913      	bls.n	ab4c <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x118>
					if (line & 0x01) {
    ab24:	07cf      	lsls	r7, r1, #31
    ab26:	d504      	bpl.n	ab32 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0xfe>
						*buf = fg;
    ab28:	701c      	strb	r4, [r3, #0]
						buf += img_bytewidth;
    ab2a:	181b      	adds	r3, r3, r0
						*buf = fg;
    ab2c:	701c      	strb	r4, [r3, #0]
						buf += img_bytewidth;
    ab2e:	181b      	adds	r3, r3, r0
    ab30:	e008      	b.n	ab44 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x110>
					} else if (fg != bg) {
    ab32:	42ac      	cmp	r4, r5
    ab34:	d004      	beq.n	ab40 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x10c>
						*buf = bg;
    ab36:	701d      	strb	r5, [r3, #0]
						buf += img_bytewidth;
    ab38:	181b      	adds	r3, r3, r0
						*buf = bg;
    ab3a:	701d      	strb	r5, [r3, #0]
						buf += img_bytewidth;
    ab3c:	181b      	adds	r3, r3, r0
    ab3e:	e001      	b.n	ab44 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x110>
					} else {
						buf += img_bytewidth*2;
    ab40:	9f05      	ldr	r7, [sp, #20]
    ab42:	19db      	adds	r3, r3, r7
				if (i == font_bytewidth) {
					line = 0;
				} else {
					line = font[c*font_bytewidth + i];
				}
				for (uint8_t j = 0; j < fontHeight; j++) {
    ab44:	3601      	adds	r6, #1
						*buf = bg;
						buf += img_bytewidth;
					} else {
						buf += img_bytewidth*2;
					}
					line >>= 1;
    ab46:	0849      	lsrs	r1, r1, #1
				if (i == font_bytewidth) {
					line = 0;
				} else {
					line = font[c*font_bytewidth + i];
				}
				for (uint8_t j = 0; j < fontHeight; j++) {
    ab48:	b2f6      	uxtb	r6, r6
    ab4a:	e7e7      	b.n	ab1c <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0xe8>
					} else {
						buf += img_bytewidth*2;
					}
					line >>= 1;
				}
				_buf++;
    ab4c:	3201      	adds	r2, #1
    ab4e:	e7d1      	b.n	aaf4 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0xc0>
			}
			
			return;
		} else {
			uint8_t fg1 = color.i;
			uint8_t fg2 = color.iu;
    ab50:	4666      	mov	r6, ip
    ab52:	7836      	ldrb	r6, [r6, #0]
			uint8_t bg1 = bgcolor.i;
			uint8_t bg2 = bgcolor.iu;
			
			uint8_t* buf = (uint8_t*)_buffer;
			uint8_t img_bytewidth = (_width + 1) / 2;
    ab54:	3001      	adds	r0, #1
			}
			
			return;
		} else {
			uint8_t fg1 = color.i;
			uint8_t fg2 = color.iu;
    ab56:	9606      	str	r6, [sp, #24]
			uint8_t bg1 = bgcolor.i;
    ab58:	786c      	ldrb	r4, [r5, #1]
			uint8_t bg2 = bgcolor.iu;
    ab5a:	782d      	ldrb	r5, [r5, #0]
			
			return;
		} else {
			uint8_t fg1 = color.i;
			uint8_t fg2 = color.iu;
			uint8_t bg1 = bgcolor.i;
    ab5c:	9404      	str	r4, [sp, #16]
			uint8_t bg2 = bgcolor.iu;
			
			uint8_t* buf = (uint8_t*)_buffer;
			uint8_t img_bytewidth = (_width + 1) / 2;
    ab5e:	0fc4      	lsrs	r4, r0, #31
    ab60:	1820      	adds	r0, r4, r0
    ab62:	1040      	asrs	r0, r0, #1
			buf += y*img_bytewidth + (x / 2);
    ab64:	b2c4      	uxtb	r4, r0
    ab66:	4362      	muls	r2, r4
    ab68:	0fcc      	lsrs	r4, r1, #31
    ab6a:	1861      	adds	r1, r4, r1
    ab6c:	1049      	asrs	r1, r1, #1
			return;
		} else {
			uint8_t fg1 = color.i;
			uint8_t fg2 = color.iu;
			uint8_t bg1 = bgcolor.i;
			uint8_t bg2 = bgcolor.iu;
    ab6e:	9507      	str	r5, [sp, #28]
			
			uint8_t* buf = (uint8_t*)_buffer;
			uint8_t img_bytewidth = (_width + 1) / 2;
			buf += y*img_bytewidth + (x / 2);
    ab70:	9d05      	ldr	r5, [sp, #20]
    ab72:	1852      	adds	r2, r2, r1
    ab74:	18aa      	adds	r2, r5, r2
			img_bytewidth--;
			uint8_t* _buf = buf;
			uint8_t font_bytewidth = fontWidth - 1;
    ab76:	b2ff      	uxtb	r7, r7
			uint8_t bg1 = bgcolor.i;
			uint8_t bg2 = bgcolor.iu;
			
			uint8_t* buf = (uint8_t*)_buffer;
			uint8_t img_bytewidth = (_width + 1) / 2;
			buf += y*img_bytewidth + (x / 2);
    ab78:	9205      	str	r2, [sp, #20]
			img_bytewidth--;
			uint8_t* _buf = buf;
			uint8_t font_bytewidth = fontWidth - 1;
    ab7a:	9702      	str	r7, [sp, #8]
			uint8_t bg2 = bgcolor.iu;
			
			uint8_t* buf = (uint8_t*)_buffer;
			uint8_t img_bytewidth = (_width + 1) / 2;
			buf += y*img_bytewidth + (x / 2);
			img_bytewidth--;
    ab7c:	1e42      	subs	r2, r0, #1
			for (uint8_t i = 0; i < fontWidth; i++) {
				uint8_t line;
				if (i == font_bytewidth) {
					line = 0;
				} else {
					line = font[c*font_bytewidth + i];
    ab7e:	435f      	muls	r7, r3
    ab80:	b2d2      	uxtb	r2, r2
						buf += img_bytewidth;
						*(buf++) = b1;
						*buf = b2;
						buf += img_bytewidth;
					} else {
						buf += (img_bytewidth+1)*2;
    ab82:	1c53      	adds	r3, r2, #1
    ab84:	005b      	lsls	r3, r3, #1
			uint8_t bg1 = bgcolor.i;
			uint8_t bg2 = bgcolor.iu;
			
			uint8_t* buf = (uint8_t*)_buffer;
			uint8_t img_bytewidth = (_width + 1) / 2;
			buf += y*img_bytewidth + (x / 2);
    ab86:	9905      	ldr	r1, [sp, #20]
			for (uint8_t i = 0; i < fontWidth; i++) {
				uint8_t line;
				if (i == font_bytewidth) {
					line = 0;
				} else {
					line = font[c*font_bytewidth + i];
    ab88:	9708      	str	r7, [sp, #32]
						buf += img_bytewidth;
						*(buf++) = b1;
						*buf = b2;
						buf += img_bytewidth;
					} else {
						buf += (img_bytewidth+1)*2;
    ab8a:	9309      	str	r3, [sp, #36]	; 0x24
    ab8c:	9e05      	ldr	r6, [sp, #20]
			uint8_t img_bytewidth = (_width + 1) / 2;
			buf += y*img_bytewidth + (x / 2);
			img_bytewidth--;
			uint8_t* _buf = buf;
			uint8_t font_bytewidth = fontWidth - 1;
			for (uint8_t i = 0; i < fontWidth; i++) {
    ab8e:	4821      	ldr	r0, [pc, #132]	; (ac14 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1e0>)
    ab90:	1b8b      	subs	r3, r1, r6
    ab92:	7800      	ldrb	r0, [r0, #0]
    ab94:	b2db      	uxtb	r3, r3
    ab96:	4298      	cmp	r0, r3
    ab98:	d937      	bls.n	ac0a <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1d6>
				uint8_t line;
				if (i == font_bytewidth) {
    ab9a:	9e02      	ldr	r6, [sp, #8]
    ab9c:	42b3      	cmp	r3, r6
    ab9e:	d005      	beq.n	abac <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x178>
					line = 0;
				} else {
					line = font[c*font_bytewidth + i];
    aba0:	4821      	ldr	r0, [pc, #132]	; (ac28 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1f4>)
    aba2:	9f08      	ldr	r7, [sp, #32]
    aba4:	6800      	ldr	r0, [r0, #0]
    aba6:	19c0      	adds	r0, r0, r7
    aba8:	5cc0      	ldrb	r0, [r0, r3]
    abaa:	e000      	b.n	abae <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x17a>
			uint8_t* _buf = buf;
			uint8_t font_bytewidth = fontWidth - 1;
			for (uint8_t i = 0; i < fontWidth; i++) {
				uint8_t line;
				if (i == font_bytewidth) {
					line = 0;
    abac:	2000      	movs	r0, #0
    abae:	1c0b      	adds	r3, r1, #0
    abb0:	2400      	movs	r4, #0
				} else {
					line = font[c*font_bytewidth + i];
				}
				for (uint8_t j = 0; j < fontHeight; j++) {
    abb2:	4d19      	ldr	r5, [pc, #100]	; (ac18 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1e4>)
    abb4:	782d      	ldrb	r5, [r5, #0]
    abb6:	42a5      	cmp	r5, r4
    abb8:	d925      	bls.n	ac06 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1d2>
					uint8_t b1 = *buf;
					uint8_t b2 = *(buf + 1);
    abba:	785d      	ldrb	r5, [r3, #1]
					line = 0;
				} else {
					line = font[c*font_bytewidth + i];
				}
				for (uint8_t j = 0; j < fontHeight; j++) {
					uint8_t b1 = *buf;
    abbc:	781e      	ldrb	r6, [r3, #0]
					uint8_t b2 = *(buf + 1);
    abbe:	46ac      	mov	ip, r5
					b1 &= 0xF0;
					b2 &= 0x0F;
    abc0:	4667      	mov	r7, ip
					line = font[c*font_bytewidth + i];
				}
				for (uint8_t j = 0; j < fontHeight; j++) {
					uint8_t b1 = *buf;
					uint8_t b2 = *(buf + 1);
					b1 &= 0xF0;
    abc2:	250f      	movs	r5, #15
					b2 &= 0x0F;
    abc4:	402f      	ands	r7, r5
					line = font[c*font_bytewidth + i];
				}
				for (uint8_t j = 0; j < fontHeight; j++) {
					uint8_t b1 = *buf;
					uint8_t b2 = *(buf + 1);
					b1 &= 0xF0;
    abc6:	43ae      	bics	r6, r5
					b2 &= 0x0F;
    abc8:	46bc      	mov	ip, r7
					if (line & 0x01) {
    abca:	07c5      	lsls	r5, r0, #31
    abcc:	d504      	bpl.n	abd8 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1a4>
						b1 |= fg1;
    abce:	9f03      	ldr	r7, [sp, #12]
						b2 |= fg2;
    abd0:	4665      	mov	r5, ip
					uint8_t b1 = *buf;
					uint8_t b2 = *(buf + 1);
					b1 &= 0xF0;
					b2 &= 0x0F;
					if (line & 0x01) {
						b1 |= fg1;
    abd2:	433e      	orrs	r6, r7
						b2 |= fg2;
    abd4:	9f06      	ldr	r7, [sp, #24]
    abd6:	e006      	b.n	abe6 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1b2>
						*buf = b2;
						buf += img_bytewidth;
						*(buf++) = b1;
						*buf = b2;
						buf += img_bytewidth;
					} else if (fg1 != bg1) {
    abd8:	9d03      	ldr	r5, [sp, #12]
    abda:	9f04      	ldr	r7, [sp, #16]
    abdc:	42bd      	cmp	r5, r7
    abde:	d00c      	beq.n	abfa <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1c6>
						b1 |= bg1;
    abe0:	433e      	orrs	r6, r7
						b2 |= bg2;
    abe2:	9f07      	ldr	r7, [sp, #28]
    abe4:	4665      	mov	r5, ip
    abe6:	433d      	orrs	r5, r7
						*(buf++) = b1;
    abe8:	1c5f      	adds	r7, r3, #1
    abea:	701e      	strb	r6, [r3, #0]
						*buf = b2;
    abec:	705d      	strb	r5, [r3, #1]
						buf += img_bytewidth;
    abee:	18bb      	adds	r3, r7, r2
						*(buf++) = b1;
						*buf = b2;
    abf0:	705d      	strb	r5, [r3, #1]
						b1 |= bg1;
						b2 |= bg2;
						*(buf++) = b1;
						*buf = b2;
						buf += img_bytewidth;
						*(buf++) = b1;
    abf2:	701e      	strb	r6, [r3, #0]
    abf4:	3301      	adds	r3, #1
						*buf = b2;
						buf += img_bytewidth;
    abf6:	189b      	adds	r3, r3, r2
    abf8:	e001      	b.n	abfe <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x1ca>
					} else {
						buf += (img_bytewidth+1)*2;
    abfa:	9d09      	ldr	r5, [sp, #36]	; 0x24
    abfc:	195b      	adds	r3, r3, r5
				if (i == font_bytewidth) {
					line = 0;
				} else {
					line = font[c*font_bytewidth + i];
				}
				for (uint8_t j = 0; j < fontHeight; j++) {
    abfe:	3401      	adds	r4, #1
						*buf = b2;
						buf += img_bytewidth;
					} else {
						buf += (img_bytewidth+1)*2;
					}
					line >>= 1;
    ac00:	0840      	lsrs	r0, r0, #1
				if (i == font_bytewidth) {
					line = 0;
				} else {
					line = font[c*font_bytewidth + i];
				}
				for (uint8_t j = 0; j < fontHeight; j++) {
    ac02:	b2e4      	uxtb	r4, r4
    ac04:	e7d5      	b.n	abb2 <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x17e>
					} else {
						buf += (img_bytewidth+1)*2;
					}
					line >>= 1;
				}
				_buf++;
    ac06:	3101      	adds	r1, #1
    ac08:	e7c0      	b.n	ab8c <_ZN14Gamebuino_Meta5Image8drawCharEsshh+0x158>
		}
	}
	
	
	Graphics::drawChar(x, y, c, size);
}
    ac0a:	b00b      	add	sp, #44	; 0x2c
    ac0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ac0e:	46c0      	nop			; (mov r8, r8)
    ac10:	20000cd0 	.word	0x20000cd0
    ac14:	20000cc0 	.word	0x20000cc0
    ac18:	20000cd5 	.word	0x20000cd5
    ac1c:	20000cda 	.word	0x20000cda
    ac20:	20000cd8 	.word	0x20000cd8
    ac24:	20000cc2 	.word	0x20000cc2
    ac28:	20000cc8 	.word	0x20000cc8

0000ac2c <_ZN14Gamebuino_Meta13Frame_HandlerC1EPNS_5ImageE>:
#include "../Graphics-SD.h"
#include "../../Gamebuino-Meta.h"

namespace Gamebuino_Meta {

Frame_Handler::Frame_Handler(Image* _img) {
    ac2c:	4b04      	ldr	r3, [pc, #16]	; (ac40 <_ZN14Gamebuino_Meta13Frame_HandlerC1EPNS_5ImageE+0x14>)
	img = _img;
    ac2e:	6041      	str	r1, [r0, #4]
#include "../Graphics-SD.h"
#include "../../Gamebuino-Meta.h"

namespace Gamebuino_Meta {

Frame_Handler::Frame_Handler(Image* _img) {
    ac30:	3308      	adds	r3, #8
    ac32:	6003      	str	r3, [r0, #0]
	img = _img;
	buf = img->_buffer;
    ac34:	694b      	ldr	r3, [r1, #20]
    ac36:	6083      	str	r3, [r0, #8]
	bufferSize = img->bufferSize;
    ac38:	8c4b      	ldrh	r3, [r1, #34]	; 0x22
    ac3a:	8183      	strh	r3, [r0, #12]
}
    ac3c:	4770      	bx	lr
    ac3e:	46c0      	nop			; (mov r8, r8)
    ac40:	00015458 	.word	0x00015458

0000ac44 <_ZN14Gamebuino_Meta13Frame_Handler14allocateBufferEv>:

uint32_t Frame_Handler::getBufferSizeWithFrames() {
	return img->getBufferSize();
}

void Frame_Handler::allocateBuffer() {
    ac44:	b538      	push	{r3, r4, r5, lr}
	uint32_t bytes = getBufferSizeWithFrames();
    ac46:	6803      	ldr	r3, [r0, #0]

uint32_t Frame_Handler::getBufferSizeWithFrames() {
	return img->getBufferSize();
}

void Frame_Handler::allocateBuffer() {
    ac48:	1c04      	adds	r4, r0, #0
	uint32_t bytes = getBufferSizeWithFrames();
    ac4a:	695b      	ldr	r3, [r3, #20]
    ac4c:	4798      	blx	r3
    ac4e:	1c05      	adds	r5, r0, #0
	if (buf && (bytes <= bufferSize)) {
    ac50:	68a0      	ldr	r0, [r4, #8]
    ac52:	2800      	cmp	r0, #0
    ac54:	d00a      	beq.n	ac6c <_ZN14Gamebuino_Meta13Frame_Handler14allocateBufferEv+0x28>
    ac56:	89a3      	ldrh	r3, [r4, #12]
    ac58:	429d      	cmp	r5, r3
    ac5a:	d802      	bhi.n	ac62 <_ZN14Gamebuino_Meta13Frame_Handler14allocateBufferEv+0x1e>
		img->_buffer = buf;
    ac5c:	6863      	ldr	r3, [r4, #4]
    ac5e:	6158      	str	r0, [r3, #20]
		return;
    ac60:	e017      	b.n	ac92 <_ZN14Gamebuino_Meta13Frame_Handler14allocateBufferEv+0x4e>
	}
	if (buf && (uint32_t)buf >= 0x20000000) {
    ac62:	4b0c      	ldr	r3, [pc, #48]	; (ac94 <_ZN14Gamebuino_Meta13Frame_Handler14allocateBufferEv+0x50>)
    ac64:	4298      	cmp	r0, r3
    ac66:	d901      	bls.n	ac6c <_ZN14Gamebuino_Meta13Frame_Handler14allocateBufferEv+0x28>
		free(buf);
    ac68:	f006 fc8e 	bl	11588 <free>
	}
	if ((buf = (uint16_t *)malloc(bytes))) {
    ac6c:	1c28      	adds	r0, r5, #0
    ac6e:	f006 fc81 	bl	11574 <malloc>
    ac72:	60a0      	str	r0, [r4, #8]
    ac74:	2800      	cmp	r0, #0
    ac76:	d005      	beq.n	ac84 <_ZN14Gamebuino_Meta13Frame_Handler14allocateBufferEv+0x40>
		memset(buf, 0, bytes);
    ac78:	2100      	movs	r1, #0
    ac7a:	1c2a      	adds	r2, r5, #0
    ac7c:	f006 fca6 	bl	115cc <memset>
		bufferSize = bytes;
    ac80:	81a5      	strh	r5, [r4, #12]
    ac82:	e003      	b.n	ac8c <_ZN14Gamebuino_Meta13Frame_Handler14allocateBufferEv+0x48>
	} else {
		// we weren't able to allocate anything :(
		img->_width = img->_height = 0;
    ac84:	6863      	ldr	r3, [r4, #4]
    ac86:	8258      	strh	r0, [r3, #18]
    ac88:	8218      	strh	r0, [r3, #16]
		bufferSize = 0;
    ac8a:	81a0      	strh	r0, [r4, #12]
	}
	img->_buffer = buf;
    ac8c:	6863      	ldr	r3, [r4, #4]
    ac8e:	68a4      	ldr	r4, [r4, #8]
    ac90:	615c      	str	r4, [r3, #20]
}
    ac92:	bd38      	pop	{r3, r4, r5, pc}
    ac94:	1fffffff 	.word	0x1fffffff

0000ac98 <_ZN14Gamebuino_Meta17Frame_Handler_MemC1EPNS_5ImageE>:
#include "../Graphics-SD.h"
#include "../../Gamebuino-Meta.h"

namespace Gamebuino_Meta {

Frame_Handler::Frame_Handler(Image* _img) {
    ac98:	4b05      	ldr	r3, [pc, #20]	; (acb0 <_ZN14Gamebuino_Meta17Frame_Handler_MemC1EPNS_5ImageE+0x18>)
	img = _img;
    ac9a:	6041      	str	r1, [r0, #4]
#include "../Graphics-SD.h"
#include "../../Gamebuino-Meta.h"

namespace Gamebuino_Meta {

Frame_Handler::Frame_Handler(Image* _img) {
    ac9c:	3308      	adds	r3, #8
    ac9e:	6003      	str	r3, [r0, #0]
	img = _img;
	buf = img->_buffer;
    aca0:	694b      	ldr	r3, [r1, #20]
    aca2:	6083      	str	r3, [r0, #8]
	bufferSize = img->bufferSize;
    aca4:	8c4b      	ldrh	r3, [r1, #34]	; 0x22
    aca6:	8183      	strh	r3, [r0, #12]
		bufferSize = 0;
	}
	img->_buffer = buf;
}

Frame_Handler_Mem::Frame_Handler_Mem(Image* _img) : Frame_Handler(_img) {
    aca8:	4b02      	ldr	r3, [pc, #8]	; (acb4 <_ZN14Gamebuino_Meta17Frame_Handler_MemC1EPNS_5ImageE+0x1c>)
    acaa:	3308      	adds	r3, #8
    acac:	6003      	str	r3, [r0, #0]
	
}
    acae:	4770      	bx	lr
    acb0:	00015458 	.word	0x00015458
    acb4:	00015438 	.word	0x00015438

0000acb8 <_ZN14Gamebuino_Meta17Frame_Handler_RAMC1EPNS_5ImageE>:

void Frame_Handler_Mem::next() {
	img->_buffer = (uint16_t*)((uint32_t)img->_buffer + img->getBufferSize());
}

Frame_Handler_RAM::Frame_Handler_RAM(Image* _img) : Frame_Handler_Mem(_img) {
    acb8:	b510      	push	{r4, lr}
    acba:	1c04      	adds	r4, r0, #0
    acbc:	f7ff ffec 	bl	ac98 <_ZN14Gamebuino_Meta17Frame_Handler_MemC1EPNS_5ImageE>
    acc0:	4b03      	ldr	r3, [pc, #12]	; (acd0 <_ZN14Gamebuino_Meta17Frame_Handler_RAMC1EPNS_5ImageE+0x18>)
	allocateBuffer();
    acc2:	1c20      	adds	r0, r4, #0

void Frame_Handler_Mem::next() {
	img->_buffer = (uint16_t*)((uint32_t)img->_buffer + img->getBufferSize());
}

Frame_Handler_RAM::Frame_Handler_RAM(Image* _img) : Frame_Handler_Mem(_img) {
    acc4:	3308      	adds	r3, #8
    acc6:	6023      	str	r3, [r4, #0]
	allocateBuffer();
    acc8:	f7ff ffbc 	bl	ac44 <_ZN14Gamebuino_Meta13Frame_Handler14allocateBufferEv>
}
    accc:	1c20      	adds	r0, r4, #0
    acce:	bd10      	pop	{r4, pc}
    acd0:	00015418 	.word	0x00015418

0000acd4 <_ZN14Gamebuino_Meta5Image4initEttPch>:

Image::Image(uint16_t w, uint16_t h, char* filename, uint8_t fl) : Graphics(w, h) {
	freshStart();
	init(w, h, filename, fl);
}
void Image::init(uint16_t w, uint16_t h, char* filename, uint8_t fl) {
    acd4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    acd6:	1c1e      	adds	r6, r3, #0
    acd8:	ab08      	add	r3, sp, #32
    acda:	781b      	ldrb	r3, [r3, #0]
    acdc:	9200      	str	r2, [sp, #0]
    acde:	9301      	str	r3, [sp, #4]
	if (isObjectCopy) {
    ace0:	1d43      	adds	r3, r0, #5
    ace2:	7fdb      	ldrb	r3, [r3, #31]

Image::Image(uint16_t w, uint16_t h, char* filename, uint8_t fl) : Graphics(w, h) {
	freshStart();
	init(w, h, filename, fl);
}
void Image::init(uint16_t w, uint16_t h, char* filename, uint8_t fl) {
    ace4:	1c04      	adds	r4, r0, #0
    ace6:	1c0f      	adds	r7, r1, #0
	if (isObjectCopy) {
    ace8:	2b00      	cmp	r3, #0
    acea:	d125      	bne.n	ad38 <_ZN14Gamebuino_Meta5Image4initEttPch+0x64>
		return;
	}
	if (frame_handler) {
    acec:	69c0      	ldr	r0, [r0, #28]
    acee:	2800      	cmp	r0, #0
    acf0:	d003      	beq.n	acfa <_ZN14Gamebuino_Meta5Image4initEttPch+0x26>
		delete frame_handler;
    acf2:	6803      	ldr	r3, [r0, #0]
    acf4:	685b      	ldr	r3, [r3, #4]
    acf6:	4798      	blx	r3
    acf8:	e001      	b.n	acfe <_ZN14Gamebuino_Meta5Image4initEttPch+0x2a>
	} else {
		bufferSize = 0;
    acfa:	8460      	strh	r0, [r4, #34]	; 0x22
		_buffer = 0;
    acfc:	6160      	str	r0, [r4, #20]
	}
	transparentColor = 0;
	_width = w;
	_height = h;
    acfe:	9a00      	ldr	r2, [sp, #0]
	frame_looping = fl;
    ad00:	1c63      	adds	r3, r4, #1
		bufferSize = 0;
		_buffer = 0;
	}
	transparentColor = 0;
	_width = w;
	_height = h;
    ad02:	8262      	strh	r2, [r4, #18]
	frame_looping = fl;
    ad04:	9a01      	ldr	r2, [sp, #4]
		delete frame_handler;
	} else {
		bufferSize = 0;
		_buffer = 0;
	}
	transparentColor = 0;
    ad06:	2500      	movs	r5, #0
	_width = w;
    ad08:	8227      	strh	r7, [r4, #16]
		delete frame_handler;
	} else {
		bufferSize = 0;
		_buffer = 0;
	}
	transparentColor = 0;
    ad0a:	8125      	strh	r5, [r4, #8]
	_width = w;
	_height = h;
	frame_looping = fl;
	frame = 0;
	frame_handler = new Frame_Handler_SD(this);
    ad0c:	2014      	movs	r0, #20
		_buffer = 0;
	}
	transparentColor = 0;
	_width = w;
	_height = h;
	frame_looping = fl;
    ad0e:	77da      	strb	r2, [r3, #31]
	frame = 0;
    ad10:	8365      	strh	r5, [r4, #26]
	frame_handler = new Frame_Handler_SD(this);
    ad12:	f005 fa8d 	bl	10230 <_Znwj>
    ad16:	1c21      	adds	r1, r4, #0
    ad18:	1c07      	adds	r7, r0, #0
    ad1a:	f001 fb3f 	bl	c39c <_ZN14Gamebuino_Meta16Frame_Handler_SDC1EPNS_5ImageE>
    ad1e:	61e7      	str	r7, [r4, #28]
	// for the SD handler we do NOT set frame to zero
	// unlike the other handlers the SD handler must be lazy-inited
	// and calling setFrame(0) here would trigger the lazy init already
	//setFrame(0);
	((Frame_Handler_SD*)frame_handler)->init(filename);
    ad20:	1c38      	adds	r0, r7, #0
    ad22:	1c31      	adds	r1, r6, #0
    ad24:	f001 fb48 	bl	c3b8 <_ZN14Gamebuino_Meta16Frame_Handler_SD4initEPc>
	frame_loopcounter = 0;
    ad28:	1d23      	adds	r3, r4, #4
    ad2a:	77dd      	strb	r5, [r3, #31]
	last_frame = (gb.frameCount & 0xFF) - 1;
    ad2c:	4b03      	ldr	r3, [pc, #12]	; (ad3c <_ZN14Gamebuino_Meta5Image4initEttPch+0x68>)
    ad2e:	3403      	adds	r4, #3
    ad30:	33fc      	adds	r3, #252	; 0xfc
    ad32:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    ad34:	3b01      	subs	r3, #1
    ad36:	77e3      	strb	r3, [r4, #31]
}
    ad38:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    ad3a:	46c0      	nop			; (mov r8, r8)
    ad3c:	20000a3c 	.word	0x20000a3c

0000ad40 <_ZN14Gamebuino_Meta5Image13getBufferSizeEv>:
	drawLine(x, y, x+w-1, y);
}

uint16_t Image::getBufferSize() {
	uint16_t bytes = 0;
	if (colorMode == ColorMode::index) {
    ad40:	7a82      	ldrb	r2, [r0, #10]
		return;
	}
	drawLine(x, y, x+w-1, y);
}

uint16_t Image::getBufferSize() {
    ad42:	1c03      	adds	r3, r0, #0
	uint16_t bytes = 0;
	if (colorMode == ColorMode::index) {
    ad44:	2a01      	cmp	r2, #1
    ad46:	d109      	bne.n	ad5c <_ZN14Gamebuino_Meta5Image13getBufferSizeEv+0x1c>
		// 4 bits per pixel = 1/2 byte
		// add 1 to width to ceil the number, rather than flooring
		bytes = ((_width + 1) / 2) * _height;
    ad48:	2110      	movs	r1, #16
    ad4a:	5e42      	ldrsh	r2, [r0, r1]
    ad4c:	8a5b      	ldrh	r3, [r3, #18]
    ad4e:	3201      	adds	r2, #1
    ad50:	0fd0      	lsrs	r0, r2, #31
    ad52:	1880      	adds	r0, r0, r2
    ad54:	1040      	asrs	r0, r0, #1
    ad56:	4358      	muls	r0, r3
    ad58:	b280      	uxth	r0, r0
    ad5a:	e007      	b.n	ad6c <_ZN14Gamebuino_Meta5Image13getBufferSizeEv+0x2c>
	}
	drawLine(x, y, x+w-1, y);
}

uint16_t Image::getBufferSize() {
	uint16_t bytes = 0;
    ad5c:	2000      	movs	r0, #0
	if (colorMode == ColorMode::index) {
		// 4 bits per pixel = 1/2 byte
		// add 1 to width to ceil the number, rather than flooring
		bytes = ((_width + 1) / 2) * _height;
	} else if (colorMode == ColorMode::rgb565) {
    ad5e:	4282      	cmp	r2, r0
    ad60:	d104      	bne.n	ad6c <_ZN14Gamebuino_Meta5Image13getBufferSizeEv+0x2c>
		bytes = _width * _height * 2; //16 bits per pixel = 2 bytes
    ad62:	8a18      	ldrh	r0, [r3, #16]
    ad64:	8a5b      	ldrh	r3, [r3, #18]
    ad66:	4358      	muls	r0, r3
    ad68:	0040      	lsls	r0, r0, #1
    ad6a:	b280      	uxth	r0, r0
	}
	return bytes;
}
    ad6c:	4770      	bx	lr

0000ad6e <_ZN14Gamebuino_Meta13Frame_Handler23getBufferSizeWithFramesEv>:

void Frame_Handler::first() {
	set(0);
}

uint32_t Frame_Handler::getBufferSizeWithFrames() {
    ad6e:	b508      	push	{r3, lr}
	return img->getBufferSize();
    ad70:	6840      	ldr	r0, [r0, #4]
    ad72:	f7ff ffe5 	bl	ad40 <_ZN14Gamebuino_Meta5Image13getBufferSizeEv>
}
    ad76:	bd08      	pop	{r3, pc}

0000ad78 <_ZN14Gamebuino_Meta17Frame_Handler_Mem3setEt>:
		img->_buffer = buf;
		img->bufferSize = 0;
	}
}

void Frame_Handler_Mem::set(uint16_t frame) {
    ad78:	b570      	push	{r4, r5, r6, lr}
	uint32_t buf_size = img->getBufferSize();
    ad7a:	6844      	ldr	r4, [r0, #4]
		img->_buffer = buf;
		img->bufferSize = 0;
	}
}

void Frame_Handler_Mem::set(uint16_t frame) {
    ad7c:	1c05      	adds	r5, r0, #0
	uint32_t buf_size = img->getBufferSize();
    ad7e:	1c20      	adds	r0, r4, #0
		img->_buffer = buf;
		img->bufferSize = 0;
	}
}

void Frame_Handler_Mem::set(uint16_t frame) {
    ad80:	1c0e      	adds	r6, r1, #0
	uint32_t buf_size = img->getBufferSize();
    ad82:	f7ff ffdd 	bl	ad40 <_ZN14Gamebuino_Meta5Image13getBufferSizeEv>
	img->_buffer = (uint16_t*)((uint32_t)buf + (buf_size * frame));
    ad86:	4346      	muls	r6, r0
    ad88:	68ab      	ldr	r3, [r5, #8]
    ad8a:	199e      	adds	r6, r3, r6
    ad8c:	6166      	str	r6, [r4, #20]
}
    ad8e:	bd70      	pop	{r4, r5, r6, pc}

0000ad90 <_ZN14Gamebuino_Meta17Frame_Handler_Mem4nextEv>:

void Frame_Handler_Mem::next() {
    ad90:	b510      	push	{r4, lr}
	img->_buffer = (uint16_t*)((uint32_t)img->_buffer + img->getBufferSize());
    ad92:	6844      	ldr	r4, [r0, #4]
    ad94:	1c20      	adds	r0, r4, #0
    ad96:	f7ff ffd3 	bl	ad40 <_ZN14Gamebuino_Meta5Image13getBufferSizeEv>
    ad9a:	6963      	ldr	r3, [r4, #20]
    ad9c:	1818      	adds	r0, r3, r0
    ad9e:	6160      	str	r0, [r4, #20]
}
    ada0:	bd10      	pop	{r4, pc}

0000ada2 <_ZN14Gamebuino_Meta17Frame_Handler_RAM23getBufferSizeWithFramesEv>:
		img->_buffer = buf;
		img->bufferSize = bufferSize;
	}
}

uint32_t Frame_Handler_RAM::getBufferSizeWithFrames() {
    ada2:	b510      	push	{r4, lr}
	return img->getBufferSize() * img->frames;
    ada4:	6844      	ldr	r4, [r0, #4]
    ada6:	1c20      	adds	r0, r4, #0
    ada8:	f7ff ffca 	bl	ad40 <_ZN14Gamebuino_Meta5Image13getBufferSizeEv>
    adac:	8b23      	ldrh	r3, [r4, #24]
    adae:	4358      	muls	r0, r3
}
    adb0:	bd10      	pop	{r4, pc}

0000adb2 <_ZN14Gamebuino_Meta5Image14startRecordingEPc>:
		bytes = _width * _height * 2; //16 bits per pixel = 2 bytes
	}
	return bytes;
}

bool Image::startRecording(char* filename) {
    adb2:	b508      	push	{r3, lr}
	return !isObjectCopy && Graphics_SD::startRecording(this, filename);
    adb4:	1d42      	adds	r2, r0, #5
    adb6:	7fd2      	ldrb	r2, [r2, #31]
		bytes = _width * _height * 2; //16 bits per pixel = 2 bytes
	}
	return bytes;
}

bool Image::startRecording(char* filename) {
    adb8:	1c03      	adds	r3, r0, #0
	return !isObjectCopy && Graphics_SD::startRecording(this, filename);
    adba:	2000      	movs	r0, #0
    adbc:	4282      	cmp	r2, r0
    adbe:	d102      	bne.n	adc6 <_ZN14Gamebuino_Meta5Image14startRecordingEPc+0x14>
    adc0:	1c18      	adds	r0, r3, #0
    adc2:	f001 fbc3 	bl	c54c <_ZN14Gamebuino_Meta11Graphics_SD14startRecordingEPNS_5ImageEPc>
}
    adc6:	bd08      	pop	{r3, pc}

0000adc8 <_ZN14Gamebuino_Meta5Image13stopRecordingEb>:

void Image::stopRecording(bool output) {
    adc8:	b508      	push	{r3, lr}
	if (!isObjectCopy) {
    adca:	1d43      	adds	r3, r0, #5
    adcc:	7fdb      	ldrb	r3, [r3, #31]
    adce:	2b00      	cmp	r3, #0
    add0:	d101      	bne.n	add6 <_ZN14Gamebuino_Meta5Image13stopRecordingEb+0xe>
		Graphics_SD::stopRecording(this, output);
    add2:	f001 fbff 	bl	c5d4 <_ZN14Gamebuino_Meta11Graphics_SD13stopRecordingEPNS_5ImageEb>
	}
}
    add6:	bd08      	pop	{r3, pc}

0000add8 <_ZN14Gamebuino_Meta5Image4saveEPc>:

bool Image::save(char* filename) {
    add8:	b508      	push	{r3, lr}
	return !isObjectCopy && Graphics_SD::save(this, filename);
    adda:	1d42      	adds	r2, r0, #5
    addc:	7fd2      	ldrb	r2, [r2, #31]
	if (!isObjectCopy) {
		Graphics_SD::stopRecording(this, output);
	}
}

bool Image::save(char* filename) {
    adde:	1c03      	adds	r3, r0, #0
	return !isObjectCopy && Graphics_SD::save(this, filename);
    ade0:	2000      	movs	r0, #0
    ade2:	4282      	cmp	r2, r0
    ade4:	d102      	bne.n	adec <_ZN14Gamebuino_Meta5Image4saveEPc+0x14>
    ade6:	1c18      	adds	r0, r3, #0
    ade8:	f001 fc20 	bl	c62c <_ZN14Gamebuino_Meta11Graphics_SD4saveEPNS_5ImageEPc>
}
    adec:	bd08      	pop	{r3, pc}

0000adee <_ZN14Gamebuino_Meta5Image14allocateBufferEv>:

void Image::allocateBuffer() {
    adee:	b508      	push	{r3, lr}
	if (!isObjectCopy) {
    adf0:	1d43      	adds	r3, r0, #5
    adf2:	7fdb      	ldrb	r3, [r3, #31]
    adf4:	2b00      	cmp	r3, #0
    adf6:	d102      	bne.n	adfe <_ZN14Gamebuino_Meta5Image14allocateBufferEv+0x10>
		frame_handler->allocateBuffer();
    adf8:	69c0      	ldr	r0, [r0, #28]
    adfa:	f7ff ff23 	bl	ac44 <_ZN14Gamebuino_Meta13Frame_Handler14allocateBufferEv>
	}
}
    adfe:	bd08      	pop	{r3, pc}

0000ae00 <_ZN14Gamebuino_Meta5Image8getPixelEss>:

uint16_t Image::getPixel(int16_t x, int16_t y) {
    ae00:	b530      	push	{r4, r5, lr}
	if (colorMode == ColorMode::rgb565) {
    ae02:	7a85      	ldrb	r5, [r0, #10]
    ae04:	2310      	movs	r3, #16
    ae06:	5ec4      	ldrsh	r4, [r0, r3]
    ae08:	6943      	ldr	r3, [r0, #20]
    ae0a:	2d00      	cmp	r5, #0
    ae0c:	d104      	bne.n	ae18 <_ZN14Gamebuino_Meta5Image8getPixelEss+0x18>
		return _buffer[x + y * _width];
    ae0e:	4362      	muls	r2, r4
    ae10:	1889      	adds	r1, r1, r2
    ae12:	0049      	lsls	r1, r1, #1
    ae14:	5a58      	ldrh	r0, [r3, r1]
    ae16:	e011      	b.n	ae3c <_ZN14Gamebuino_Meta5Image8getPixelEss+0x3c>
	} else {
		uint16_t addr = ((_width + 1) / 2) * y + x / 2;
    ae18:	1c60      	adds	r0, r4, #1
    ae1a:	0fc4      	lsrs	r4, r0, #31
    ae1c:	1820      	adds	r0, r4, r0
    ae1e:	1040      	asrs	r0, r0, #1
    ae20:	4342      	muls	r2, r0
    ae22:	0fcd      	lsrs	r5, r1, #31
    ae24:	186d      	adds	r5, r5, r1
    ae26:	106d      	asrs	r5, r5, #1
    ae28:	18aa      	adds	r2, r5, r2
    ae2a:	b292      	uxth	r2, r2
		uint8_t* buf = (uint8_t*)_buffer;
		if (!(x % 2)) { //odd pixels
    ae2c:	07c8      	lsls	r0, r1, #31
    ae2e:	d402      	bmi.n	ae36 <_ZN14Gamebuino_Meta5Image8getPixelEss+0x36>
			return buf[addr] >> 4;
    ae30:	5c98      	ldrb	r0, [r3, r2]
    ae32:	0900      	lsrs	r0, r0, #4
    ae34:	e002      	b.n	ae3c <_ZN14Gamebuino_Meta5Image8getPixelEss+0x3c>
		} else {
			return buf[addr] & 0x0F;
    ae36:	5c98      	ldrb	r0, [r3, r2]
    ae38:	230f      	movs	r3, #15
    ae3a:	4018      	ands	r0, r3
		}
	}
}
    ae3c:	bd30      	pop	{r4, r5, pc}
	...

0000ae40 <_ZN14Gamebuino_Meta5Image9nextFrameEv>:
	} else {
		return (ColorIndex)c;
	}
}

void Image::nextFrame() {
    ae40:	b510      	push	{r4, lr}
	if (frames) {
    ae42:	8b03      	ldrh	r3, [r0, #24]
	} else {
		return (ColorIndex)c;
	}
}

void Image::nextFrame() {
    ae44:	1c04      	adds	r4, r0, #0
	if (frames) {
    ae46:	2b00      	cmp	r3, #0
    ae48:	d00d      	beq.n	ae66 <_ZN14Gamebuino_Meta5Image9nextFrameEv+0x26>
		if (frames == 1 || !frame_looping || last_frame == (gb.frameCount & 0xFF)) {
    ae4a:	2b01      	cmp	r3, #1
    ae4c:	d02e      	beq.n	aeac <_ZN14Gamebuino_Meta5Image9nextFrameEv+0x6c>
    ae4e:	1c42      	adds	r2, r0, #1
    ae50:	7fd2      	ldrb	r2, [r2, #31]
    ae52:	2a00      	cmp	r2, #0
    ae54:	d02a      	beq.n	aeac <_ZN14Gamebuino_Meta5Image9nextFrameEv+0x6c>
    ae56:	1cc2      	adds	r2, r0, #3
    ae58:	7fd1      	ldrb	r1, [r2, #31]
    ae5a:	4a15      	ldr	r2, [pc, #84]	; (aeb0 <_ZN14Gamebuino_Meta5Image9nextFrameEv+0x70>)
    ae5c:	32fc      	adds	r2, #252	; 0xfc
    ae5e:	6e12      	ldr	r2, [r2, #96]	; 0x60
    ae60:	b2d2      	uxtb	r2, r2
    ae62:	4291      	cmp	r1, r2
    ae64:	d022      	beq.n	aeac <_ZN14Gamebuino_Meta5Image9nextFrameEv+0x6c>
			return;
		}
	}
	last_frame = gb.frameCount & 0xFF;
    ae66:	4a12      	ldr	r2, [pc, #72]	; (aeb0 <_ZN14Gamebuino_Meta5Image9nextFrameEv+0x70>)
    ae68:	32fc      	adds	r2, #252	; 0xfc
    ae6a:	6e11      	ldr	r1, [r2, #96]	; 0x60
    ae6c:	1ce2      	adds	r2, r4, #3
    ae6e:	77d1      	strb	r1, [r2, #31]
    ae70:	1d22      	adds	r2, r4, #4
	if (frames)  {
    ae72:	2b00      	cmp	r3, #0
    ae74:	d10b      	bne.n	ae8e <_ZN14Gamebuino_Meta5Image9nextFrameEv+0x4e>
		frame_loopcounter++;
		if (frame_loopcounter < frame_looping) {
			return;
		}
	}
	frame_loopcounter = 0;
    ae76:	2100      	movs	r1, #0
    ae78:	77d1      	strb	r1, [r2, #31]
	if ((frame + 1) >= frames) {
    ae7a:	8b62      	ldrh	r2, [r4, #26]
    ae7c:	69e0      	ldr	r0, [r4, #28]
    ae7e:	3201      	adds	r2, #1
    ae80:	429a      	cmp	r2, r3
    ae82:	db0d      	blt.n	aea0 <_ZN14Gamebuino_Meta5Image9nextFrameEv+0x60>
		frame = 0;
		frame_handler->first();
    ae84:	6803      	ldr	r3, [r0, #0]
			return;
		}
	}
	frame_loopcounter = 0;
	if ((frame + 1) >= frames) {
		frame = 0;
    ae86:	8361      	strh	r1, [r4, #26]
		frame_handler->first();
    ae88:	691b      	ldr	r3, [r3, #16]
    ae8a:	4798      	blx	r3
    ae8c:	e00e      	b.n	aeac <_ZN14Gamebuino_Meta5Image9nextFrameEv+0x6c>
			return;
		}
	}
	last_frame = gb.frameCount & 0xFF;
	if (frames)  {
		frame_loopcounter++;
    ae8e:	7fd1      	ldrb	r1, [r2, #31]
		if (frame_loopcounter < frame_looping) {
    ae90:	1c60      	adds	r0, r4, #1
			return;
		}
	}
	last_frame = gb.frameCount & 0xFF;
	if (frames)  {
		frame_loopcounter++;
    ae92:	3101      	adds	r1, #1
    ae94:	b2c9      	uxtb	r1, r1
    ae96:	77d1      	strb	r1, [r2, #31]
		if (frame_loopcounter < frame_looping) {
    ae98:	7fc0      	ldrb	r0, [r0, #31]
    ae9a:	4288      	cmp	r0, r1
    ae9c:	d9eb      	bls.n	ae76 <_ZN14Gamebuino_Meta5Image9nextFrameEv+0x36>
    ae9e:	e005      	b.n	aeac <_ZN14Gamebuino_Meta5Image9nextFrameEv+0x6c>
	frame_loopcounter = 0;
	if ((frame + 1) >= frames) {
		frame = 0;
		frame_handler->first();
	} else {
		frame_handler->next();
    aea0:	6803      	ldr	r3, [r0, #0]
    aea2:	689b      	ldr	r3, [r3, #8]
    aea4:	4798      	blx	r3
		frame++;
    aea6:	8b63      	ldrh	r3, [r4, #26]
    aea8:	3301      	adds	r3, #1
    aeaa:	8363      	strh	r3, [r4, #26]
	}
}
    aeac:	bd10      	pop	{r4, pc}
    aeae:	46c0      	nop			; (mov r8, r8)
    aeb0:	20000a3c 	.word	0x20000a3c

0000aeb4 <_ZN14Gamebuino_Meta5Image8setFrameEt>:

void Image::setFrame(uint16_t _frame) {
    aeb4:	b510      	push	{r4, lr}
	if (frames == 1) {
    aeb6:	8b03      	ldrh	r3, [r0, #24]
		frame_handler->next();
		frame++;
	}
}

void Image::setFrame(uint16_t _frame) {
    aeb8:	1c04      	adds	r4, r0, #0
	if (frames == 1) {
    aeba:	2b01      	cmp	r3, #1
    aebc:	d010      	beq.n	aee0 <_ZN14Gamebuino_Meta5Image8setFrameEt+0x2c>
		return;
	}
	if (_frame >= frames) {
    aebe:	4299      	cmp	r1, r3
    aec0:	d301      	bcc.n	aec6 <_ZN14Gamebuino_Meta5Image8setFrameEt+0x12>
		_frame = frames - 1;
    aec2:	1e59      	subs	r1, r3, #1
    aec4:	b289      	uxth	r1, r1
	}
	frame = _frame;
	frame_handler->set(frame);
    aec6:	69e0      	ldr	r0, [r4, #28]
		return;
	}
	if (_frame >= frames) {
		_frame = frames - 1;
	}
	frame = _frame;
    aec8:	8361      	strh	r1, [r4, #26]
	frame_handler->set(frame);
    aeca:	6803      	ldr	r3, [r0, #0]
    aecc:	68db      	ldr	r3, [r3, #12]
    aece:	4798      	blx	r3
	last_frame = gb.frameCount & 0xFF; // we already loaded this frame!
    aed0:	4b04      	ldr	r3, [pc, #16]	; (aee4 <_ZN14Gamebuino_Meta5Image8setFrameEt+0x30>)
    aed2:	33fc      	adds	r3, #252	; 0xfc
    aed4:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    aed6:	1ce3      	adds	r3, r4, #3
    aed8:	77da      	strb	r2, [r3, #31]
	frame_loopcounter = 0;
    aeda:	3404      	adds	r4, #4
    aedc:	2300      	movs	r3, #0
    aede:	77e3      	strb	r3, [r4, #31]
}
    aee0:	bd10      	pop	{r4, pc}
    aee2:	46c0      	nop			; (mov r8, r8)
    aee4:	20000a3c 	.word	0x20000a3c

0000aee8 <_ZN14Gamebuino_Meta5Image4initEttNS_9ColorModeEth>:

Image::Image(uint16_t w, uint16_t h, ColorMode col, uint16_t frames, uint8_t fl) : Graphics(w, h) {
	freshStart();
	init(w, h, col, frames, fl);
}
void Image::init(uint16_t w, uint16_t h, ColorMode col, uint16_t _frames, uint8_t fl) {
    aee8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    aeea:	1c1e      	adds	r6, r3, #0
    aeec:	ab08      	add	r3, sp, #32
    aeee:	881f      	ldrh	r7, [r3, #0]
    aef0:	ab09      	add	r3, sp, #36	; 0x24
    aef2:	781b      	ldrb	r3, [r3, #0]
    aef4:	9200      	str	r2, [sp, #0]
    aef6:	9301      	str	r3, [sp, #4]
	if (isObjectCopy) {
    aef8:	1d43      	adds	r3, r0, #5
    aefa:	7fdb      	ldrb	r3, [r3, #31]

Image::Image(uint16_t w, uint16_t h, ColorMode col, uint16_t frames, uint8_t fl) : Graphics(w, h) {
	freshStart();
	init(w, h, col, frames, fl);
}
void Image::init(uint16_t w, uint16_t h, ColorMode col, uint16_t _frames, uint8_t fl) {
    aefc:	1c04      	adds	r4, r0, #0
    aefe:	1c0d      	adds	r5, r1, #0
	if (isObjectCopy) {
    af00:	2b00      	cmp	r3, #0
    af02:	d126      	bne.n	af52 <_ZN14Gamebuino_Meta5Image4initEttNS_9ColorModeEth+0x6a>
		return;
	}
	if (frame_handler) {
    af04:	69c0      	ldr	r0, [r0, #28]
    af06:	2800      	cmp	r0, #0
    af08:	d003      	beq.n	af12 <_ZN14Gamebuino_Meta5Image4initEttNS_9ColorModeEth+0x2a>
		delete frame_handler;
    af0a:	6803      	ldr	r3, [r0, #0]
    af0c:	685b      	ldr	r3, [r3, #4]
    af0e:	4798      	blx	r3
    af10:	e001      	b.n	af16 <_ZN14Gamebuino_Meta5Image4initEttNS_9ColorModeEth+0x2e>
	} else {
		bufferSize = 0;
    af12:	8460      	strh	r0, [r4, #34]	; 0x22
		_buffer = 0;
    af14:	6160      	str	r0, [r4, #20]
	}
	transparentColor = 0xF81F;
	frames = _frames;
	colorMode = col;
	_width = w;
	_height = h;
    af16:	9a00      	ldr	r2, [sp, #0]
		delete frame_handler;
	} else {
		bufferSize = 0;
		_buffer = 0;
	}
	transparentColor = 0xF81F;
    af18:	4b0e      	ldr	r3, [pc, #56]	; (af54 <_ZN14Gamebuino_Meta5Image4initEttNS_9ColorModeEth+0x6c>)
	frames = _frames;
	colorMode = col;
	_width = w;
	_height = h;
    af1a:	8262      	strh	r2, [r4, #18]
	frame_looping = fl;
    af1c:	9a01      	ldr	r2, [sp, #4]
		delete frame_handler;
	} else {
		bufferSize = 0;
		_buffer = 0;
	}
	transparentColor = 0xF81F;
    af1e:	8123      	strh	r3, [r4, #8]
	frames = _frames;
	colorMode = col;
	_width = w;
	_height = h;
	frame_looping = fl;
    af20:	1c63      	adds	r3, r4, #1
		_buffer = 0;
	}
	transparentColor = 0xF81F;
	frames = _frames;
	colorMode = col;
	_width = w;
    af22:	8225      	strh	r5, [r4, #16]
	} else {
		bufferSize = 0;
		_buffer = 0;
	}
	transparentColor = 0xF81F;
	frames = _frames;
    af24:	8327      	strh	r7, [r4, #24]
	colorMode = col;
    af26:	72a6      	strb	r6, [r4, #10]
	_width = w;
	_height = h;
	frame_looping = fl;
	frame_handler = new Frame_Handler_RAM(this);
    af28:	2010      	movs	r0, #16
	transparentColor = 0xF81F;
	frames = _frames;
	colorMode = col;
	_width = w;
	_height = h;
	frame_looping = fl;
    af2a:	77da      	strb	r2, [r3, #31]
	frame_handler = new Frame_Handler_RAM(this);
    af2c:	f005 f980 	bl	10230 <_Znwj>
    af30:	1c21      	adds	r1, r4, #0
    af32:	1c05      	adds	r5, r0, #0
    af34:	f7ff fec0 	bl	acb8 <_ZN14Gamebuino_Meta17Frame_Handler_RAMC1EPNS_5ImageE>
	frame_loopcounter = 0;
    af38:	1d23      	adds	r3, r4, #4
    af3a:	2100      	movs	r1, #0
	frames = _frames;
	colorMode = col;
	_width = w;
	_height = h;
	frame_looping = fl;
	frame_handler = new Frame_Handler_RAM(this);
    af3c:	61e5      	str	r5, [r4, #28]
	frame_loopcounter = 0;
    af3e:	77d9      	strb	r1, [r3, #31]
	last_frame = (gb.frameCount & 0xFF) - 1;
    af40:	4b05      	ldr	r3, [pc, #20]	; (af58 <_ZN14Gamebuino_Meta5Image4initEttNS_9ColorModeEth+0x70>)
	setFrame(0);
    af42:	1c20      	adds	r0, r4, #0
	_width = w;
	_height = h;
	frame_looping = fl;
	frame_handler = new Frame_Handler_RAM(this);
	frame_loopcounter = 0;
	last_frame = (gb.frameCount & 0xFF) - 1;
    af44:	33fc      	adds	r3, #252	; 0xfc
    af46:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    af48:	1ce3      	adds	r3, r4, #3
    af4a:	3a01      	subs	r2, #1
    af4c:	77da      	strb	r2, [r3, #31]
	setFrame(0);
    af4e:	f7ff ffb1 	bl	aeb4 <_ZN14Gamebuino_Meta5Image8setFrameEt>
}
    af52:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    af54:	fffff81f 	.word	0xfffff81f
    af58:	20000a3c 	.word	0x20000a3c

0000af5c <_ZN14Gamebuino_Meta5Image4initEPKtNS_9ColorModeEth.part.10>:

Image::Image(const uint16_t* buffer, ColorMode col, uint16_t frames, uint8_t fl) : Graphics(0, 0) {
	freshStart();
	init(buffer, col, frames, fl);
}
void Image::init(const uint16_t* buffer, ColorMode col, uint16_t _frames, uint8_t fl) {
    af5c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    af5e:	1c1f      	adds	r7, r3, #0
    af60:	ab08      	add	r3, sp, #32
    af62:	1c04      	adds	r4, r0, #0
    af64:	781b      	ldrb	r3, [r3, #0]
	if (isObjectCopy) {
		return;
	}
	if (frame_handler) {
    af66:	69c0      	ldr	r0, [r0, #28]

Image::Image(const uint16_t* buffer, ColorMode col, uint16_t frames, uint8_t fl) : Graphics(0, 0) {
	freshStart();
	init(buffer, col, frames, fl);
}
void Image::init(const uint16_t* buffer, ColorMode col, uint16_t _frames, uint8_t fl) {
    af68:	1c0d      	adds	r5, r1, #0
    af6a:	1c16      	adds	r6, r2, #0
    af6c:	9301      	str	r3, [sp, #4]
	if (isObjectCopy) {
		return;
	}
	if (frame_handler) {
    af6e:	2800      	cmp	r0, #0
    af70:	d002      	beq.n	af78 <_ZN14Gamebuino_Meta5Image4initEPKtNS_9ColorModeEth.part.10+0x1c>
		delete frame_handler;
    af72:	6803      	ldr	r3, [r0, #0]
    af74:	685b      	ldr	r3, [r3, #4]
    af76:	4798      	blx	r3
	}
	bufferSize = 0;
	if (_buffer && (uint32_t)_buffer >= 0x20000000) {
    af78:	6960      	ldr	r0, [r4, #20]
		return;
	}
	if (frame_handler) {
		delete frame_handler;
	}
	bufferSize = 0;
    af7a:	2300      	movs	r3, #0
    af7c:	8463      	strh	r3, [r4, #34]	; 0x22
	if (_buffer && (uint32_t)_buffer >= 0x20000000) {
    af7e:	4298      	cmp	r0, r3
    af80:	d004      	beq.n	af8c <_ZN14Gamebuino_Meta5Image4initEPKtNS_9ColorModeEth.part.10+0x30>
    af82:	4b13      	ldr	r3, [pc, #76]	; (afd0 <_ZN14Gamebuino_Meta5Image4initEPKtNS_9ColorModeEth.part.10+0x74>)
    af84:	4298      	cmp	r0, r3
    af86:	d901      	bls.n	af8c <_ZN14Gamebuino_Meta5Image4initEPKtNS_9ColorModeEth.part.10+0x30>
		free(_buffer);
    af88:	f006 fafe 	bl	11588 <free>
	}
	transparentColor = 0xF81F;
    af8c:	4b11      	ldr	r3, [pc, #68]	; (afd4 <_ZN14Gamebuino_Meta5Image4initEPKtNS_9ColorModeEth.part.10+0x78>)
	frames = _frames;
    af8e:	8327      	strh	r7, [r4, #24]
	}
	bufferSize = 0;
	if (_buffer && (uint32_t)_buffer >= 0x20000000) {
		free(_buffer);
	}
	transparentColor = 0xF81F;
    af90:	8123      	strh	r3, [r4, #8]
	frames = _frames;
	colorMode = col;
	uint16_t* buf = (uint16_t*)buffer;
	_width = *(buf++);
    af92:	882b      	ldrh	r3, [r5, #0]
	_height = *(buf++);
	
	_buffer = buf;
	frame_looping = fl;
    af94:	9a01      	ldr	r2, [sp, #4]
	}
	transparentColor = 0xF81F;
	frames = _frames;
	colorMode = col;
	uint16_t* buf = (uint16_t*)buffer;
	_width = *(buf++);
    af96:	8223      	strh	r3, [r4, #16]
	_height = *(buf++);
    af98:	886b      	ldrh	r3, [r5, #2]
    af9a:	3504      	adds	r5, #4
    af9c:	8263      	strh	r3, [r4, #18]
	
	_buffer = buf;
	frame_looping = fl;
    af9e:	1c63      	adds	r3, r4, #1
	if (_buffer && (uint32_t)_buffer >= 0x20000000) {
		free(_buffer);
	}
	transparentColor = 0xF81F;
	frames = _frames;
	colorMode = col;
    afa0:	72a6      	strb	r6, [r4, #10]
	uint16_t* buf = (uint16_t*)buffer;
	_width = *(buf++);
	_height = *(buf++);
	
	_buffer = buf;
    afa2:	6165      	str	r5, [r4, #20]
	frame_looping = fl;
	frame_handler = new Frame_Handler_Mem(this);
    afa4:	2010      	movs	r0, #16
	uint16_t* buf = (uint16_t*)buffer;
	_width = *(buf++);
	_height = *(buf++);
	
	_buffer = buf;
	frame_looping = fl;
    afa6:	77da      	strb	r2, [r3, #31]
	frame_handler = new Frame_Handler_Mem(this);
    afa8:	f005 f942 	bl	10230 <_Znwj>
    afac:	1c21      	adds	r1, r4, #0
    afae:	1c05      	adds	r5, r0, #0
    afb0:	f7ff fe72 	bl	ac98 <_ZN14Gamebuino_Meta17Frame_Handler_MemC1EPNS_5ImageE>
	frame_loopcounter = 0;
    afb4:	1d23      	adds	r3, r4, #4
    afb6:	2100      	movs	r1, #0
	_width = *(buf++);
	_height = *(buf++);
	
	_buffer = buf;
	frame_looping = fl;
	frame_handler = new Frame_Handler_Mem(this);
    afb8:	61e5      	str	r5, [r4, #28]
	frame_loopcounter = 0;
    afba:	77d9      	strb	r1, [r3, #31]
	last_frame = (gb.frameCount & 0xFF) - 1;
    afbc:	4b06      	ldr	r3, [pc, #24]	; (afd8 <_ZN14Gamebuino_Meta5Image4initEPKtNS_9ColorModeEth.part.10+0x7c>)
	setFrame(0);
    afbe:	1c20      	adds	r0, r4, #0
	
	_buffer = buf;
	frame_looping = fl;
	frame_handler = new Frame_Handler_Mem(this);
	frame_loopcounter = 0;
	last_frame = (gb.frameCount & 0xFF) - 1;
    afc0:	33fc      	adds	r3, #252	; 0xfc
    afc2:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    afc4:	1ce3      	adds	r3, r4, #3
    afc6:	3a01      	subs	r2, #1
    afc8:	77da      	strb	r2, [r3, #31]
	setFrame(0);
    afca:	f7ff ff73 	bl	aeb4 <_ZN14Gamebuino_Meta5Image8setFrameEt>
}
    afce:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    afd0:	1fffffff 	.word	0x1fffffff
    afd4:	fffff81f 	.word	0xfffff81f
    afd8:	20000a3c 	.word	0x20000a3c

0000afdc <_ZN14Gamebuino_Meta5Image4initEPKtNS_9ColorModeEth>:

Image::Image(const uint16_t* buffer, ColorMode col, uint16_t frames, uint8_t fl) : Graphics(0, 0) {
	freshStart();
	init(buffer, col, frames, fl);
}
void Image::init(const uint16_t* buffer, ColorMode col, uint16_t _frames, uint8_t fl) {
    afdc:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (isObjectCopy) {
    afde:	1d45      	adds	r5, r0, #5
    afe0:	7fed      	ldrb	r5, [r5, #31]

Image::Image(const uint16_t* buffer, ColorMode col, uint16_t frames, uint8_t fl) : Graphics(0, 0) {
	freshStart();
	init(buffer, col, frames, fl);
}
void Image::init(const uint16_t* buffer, ColorMode col, uint16_t _frames, uint8_t fl) {
    afe2:	ac06      	add	r4, sp, #24
    afe4:	7824      	ldrb	r4, [r4, #0]
	if (isObjectCopy) {
    afe6:	2d00      	cmp	r5, #0
    afe8:	d102      	bne.n	aff0 <_ZN14Gamebuino_Meta5Image4initEPKtNS_9ColorModeEth+0x14>
    afea:	9400      	str	r4, [sp, #0]
    afec:	f7ff ffb6 	bl	af5c <_ZN14Gamebuino_Meta5Image4initEPKtNS_9ColorModeEth.part.10>
	frame_looping = fl;
	frame_handler = new Frame_Handler_Mem(this);
	frame_loopcounter = 0;
	last_frame = (gb.frameCount & 0xFF) - 1;
	setFrame(0);
}
    aff0:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

0000aff2 <_ZN14Gamebuino_Meta5Image4initEPKtth>:
// flash constructors
Image::Image(const uint16_t* buffer, uint16_t frames, uint8_t fl) : Graphics(0, 0) {
	freshStart();
	init(buffer, frames, fl);
}
void Image::init(const uint16_t* buffer, uint16_t frames, uint8_t fl) {
    aff2:	b513      	push	{r0, r1, r4, lr}
    aff4:	1c14      	adds	r4, r2, #0
	init(buffer, ColorMode::rgb565, frames, fl);
    aff6:	9300      	str	r3, [sp, #0]
    aff8:	2200      	movs	r2, #0
    affa:	1c23      	adds	r3, r4, #0
    affc:	f7ff ffee 	bl	afdc <_ZN14Gamebuino_Meta5Image4initEPKtNS_9ColorModeEth>
}
    b000:	bd13      	pop	{r0, r1, r4, pc}
	...

0000b004 <_ZN14Gamebuino_Meta5ImageC1EPKtth>:
	last_frame = (gb.frameCount & 0xFF) - 1;
	setFrame(0);
}

// flash constructors
Image::Image(const uint16_t* buffer, uint16_t frames, uint8_t fl) : Graphics(0, 0) {
    b004:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b006:	1c0f      	adds	r7, r1, #0
    b008:	2100      	movs	r1, #0
    b00a:	1c16      	adds	r6, r2, #0
    b00c:	1c0a      	adds	r2, r1, #0
    b00e:	1c04      	adds	r4, r0, #0
    b010:	1c1d      	adds	r5, r3, #0
    b012:	f7fe ff61 	bl	9ed8 <_ZN14Gamebuino_Meta8GraphicsC1Ess>
    b016:	4b09      	ldr	r3, [pc, #36]	; (b03c <_ZN14Gamebuino_Meta5ImageC1EPKtth+0x38>)

void Image::freshStart() {
	_buffer = 0;
	frame_handler = 0;
	bufferSize = 0;
	isObjectCopy = false;
    b018:	1d62      	adds	r2, r4, #5
	last_frame = (gb.frameCount & 0xFF) - 1;
	setFrame(0);
}

// flash constructors
Image::Image(const uint16_t* buffer, uint16_t frames, uint8_t fl) : Graphics(0, 0) {
    b01a:	3308      	adds	r3, #8
    b01c:	6023      	str	r3, [r4, #0]
    b01e:	2300      	movs	r3, #0
    b020:	8363      	strh	r3, [r4, #26]
/********
 * start of actual image class
 ********/

void Image::freshStart() {
	_buffer = 0;
    b022:	6163      	str	r3, [r4, #20]
	frame_handler = 0;
    b024:	61e3      	str	r3, [r4, #28]
	bufferSize = 0;
    b026:	8463      	strh	r3, [r4, #34]	; 0x22
}

// flash constructors
Image::Image(const uint16_t* buffer, uint16_t frames, uint8_t fl) : Graphics(0, 0) {
	freshStart();
	init(buffer, frames, fl);
    b028:	1c20      	adds	r0, r4, #0

void Image::freshStart() {
	_buffer = 0;
	frame_handler = 0;
	bufferSize = 0;
	isObjectCopy = false;
    b02a:	77d3      	strb	r3, [r2, #31]
}

// flash constructors
Image::Image(const uint16_t* buffer, uint16_t frames, uint8_t fl) : Graphics(0, 0) {
	freshStart();
	init(buffer, frames, fl);
    b02c:	1c39      	adds	r1, r7, #0
    b02e:	1c32      	adds	r2, r6, #0
    b030:	1c2b      	adds	r3, r5, #0
    b032:	f7ff ffde 	bl	aff2 <_ZN14Gamebuino_Meta5Image4initEPKtth>
}
    b036:	1c20      	adds	r0, r4, #0
    b038:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    b03a:	46c0      	nop			; (mov r8, r8)
    b03c:	00015478 	.word	0x00015478

0000b040 <_ZN14Gamebuino_Meta5ImageC1EPKtNS_9ColorModeEth>:
void Image::init(const uint16_t* buffer, uint16_t frames, uint8_t fl) {
	init(buffer, ColorMode::rgb565, frames, fl);
}

Image::Image(const uint16_t* buffer, ColorMode col, uint16_t frames, uint8_t fl) : Graphics(0, 0) {
    b040:	b5f0      	push	{r4, r5, r6, r7, lr}
    b042:	1c0e      	adds	r6, r1, #0
    b044:	b085      	sub	sp, #20
    b046:	2100      	movs	r1, #0
    b048:	1c15      	adds	r5, r2, #0
    b04a:	9303      	str	r3, [sp, #12]
    b04c:	1c0a      	adds	r2, r1, #0
    b04e:	ab0a      	add	r3, sp, #40	; 0x28
    b050:	1c04      	adds	r4, r0, #0
    b052:	781f      	ldrb	r7, [r3, #0]
    b054:	f7fe ff40 	bl	9ed8 <_ZN14Gamebuino_Meta8GraphicsC1Ess>
    b058:	4b09      	ldr	r3, [pc, #36]	; (b080 <_ZN14Gamebuino_Meta5ImageC1EPKtNS_9ColorModeEth+0x40>)

void Image::freshStart() {
	_buffer = 0;
	frame_handler = 0;
	bufferSize = 0;
	isObjectCopy = false;
    b05a:	1d62      	adds	r2, r4, #5
}
void Image::init(const uint16_t* buffer, uint16_t frames, uint8_t fl) {
	init(buffer, ColorMode::rgb565, frames, fl);
}

Image::Image(const uint16_t* buffer, ColorMode col, uint16_t frames, uint8_t fl) : Graphics(0, 0) {
    b05c:	3308      	adds	r3, #8
    b05e:	6023      	str	r3, [r4, #0]
    b060:	2300      	movs	r3, #0
    b062:	8363      	strh	r3, [r4, #26]
/********
 * start of actual image class
 ********/

void Image::freshStart() {
	_buffer = 0;
    b064:	6163      	str	r3, [r4, #20]
	frame_handler = 0;
    b066:	61e3      	str	r3, [r4, #28]
	bufferSize = 0;
    b068:	8463      	strh	r3, [r4, #34]	; 0x22
    b06a:	1c20      	adds	r0, r4, #0
	isObjectCopy = false;
    b06c:	77d3      	strb	r3, [r2, #31]
    b06e:	1c31      	adds	r1, r6, #0
    b070:	9700      	str	r7, [sp, #0]
    b072:	1c2a      	adds	r2, r5, #0
    b074:	9b03      	ldr	r3, [sp, #12]
    b076:	f7ff ff71 	bl	af5c <_ZN14Gamebuino_Meta5Image4initEPKtNS_9ColorModeEth.part.10>
}

Image::Image(const uint16_t* buffer, ColorMode col, uint16_t frames, uint8_t fl) : Graphics(0, 0) {
	freshStart();
	init(buffer, col, frames, fl);
}
    b07a:	1c20      	adds	r0, r4, #0
    b07c:	b005      	add	sp, #20
    b07e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b080:	00015478 	.word	0x00015478

0000b084 <_ZN14Gamebuino_Meta5ImageC1EttNS_9ColorModeEth>:
}
void Image::init(uint16_t w, uint16_t h, uint16_t frames, uint8_t fl) {
	init(w, h, ColorMode::rgb565, frames, fl);
}

Image::Image(uint16_t w, uint16_t h, ColorMode col, uint16_t frames, uint8_t fl) : Graphics(w, h) {
    b084:	b5f0      	push	{r4, r5, r6, r7, lr}
    b086:	b085      	sub	sp, #20
    b088:	9301      	str	r3, [sp, #4]
    b08a:	ab0a      	add	r3, sp, #40	; 0x28
    b08c:	881b      	ldrh	r3, [r3, #0]
    b08e:	b28f      	uxth	r7, r1
    b090:	9302      	str	r3, [sp, #8]
    b092:	ab0b      	add	r3, sp, #44	; 0x2c
    b094:	781b      	ldrb	r3, [r3, #0]
    b096:	b296      	uxth	r6, r2
    b098:	b239      	sxth	r1, r7
    b09a:	b232      	sxth	r2, r6
    b09c:	1c04      	adds	r4, r0, #0
    b09e:	9303      	str	r3, [sp, #12]
    b0a0:	f7fe ff1a 	bl	9ed8 <_ZN14Gamebuino_Meta8GraphicsC1Ess>
    b0a4:	4b15      	ldr	r3, [pc, #84]	; (b0fc <_ZN14Gamebuino_Meta5ImageC1EttNS_9ColorModeEth+0x78>)
    b0a6:	2500      	movs	r5, #0
    b0a8:	3308      	adds	r3, #8
    b0aa:	6023      	str	r3, [r4, #0]

void Image::freshStart() {
	_buffer = 0;
	frame_handler = 0;
	bufferSize = 0;
	isObjectCopy = false;
    b0ac:	1d63      	adds	r3, r4, #5
}
void Image::init(uint16_t w, uint16_t h, uint16_t frames, uint8_t fl) {
	init(w, h, ColorMode::rgb565, frames, fl);
}

Image::Image(uint16_t w, uint16_t h, ColorMode col, uint16_t frames, uint8_t fl) : Graphics(w, h) {
    b0ae:	8365      	strh	r5, [r4, #26]
/********
 * start of actual image class
 ********/

void Image::freshStart() {
	_buffer = 0;
    b0b0:	6165      	str	r5, [r4, #20]
	frame_handler = 0;
    b0b2:	61e5      	str	r5, [r4, #28]
	bufferSize = 0;
    b0b4:	8465      	strh	r5, [r4, #34]	; 0x22
	isObjectCopy = false;
    b0b6:	77dd      	strb	r5, [r3, #31]
		delete frame_handler;
	} else {
		bufferSize = 0;
		_buffer = 0;
	}
	transparentColor = 0xF81F;
    b0b8:	4b11      	ldr	r3, [pc, #68]	; (b100 <_ZN14Gamebuino_Meta5ImageC1EttNS_9ColorModeEth+0x7c>)
	frames = _frames;
    b0ba:	9a02      	ldr	r2, [sp, #8]
		delete frame_handler;
	} else {
		bufferSize = 0;
		_buffer = 0;
	}
	transparentColor = 0xF81F;
    b0bc:	8123      	strh	r3, [r4, #8]
	frames = _frames;
	colorMode = col;
    b0be:	9b01      	ldr	r3, [sp, #4]
	} else {
		bufferSize = 0;
		_buffer = 0;
	}
	transparentColor = 0xF81F;
	frames = _frames;
    b0c0:	8322      	strh	r2, [r4, #24]
	colorMode = col;
	_width = w;
	_height = h;
	frame_looping = fl;
    b0c2:	9a03      	ldr	r2, [sp, #12]
		bufferSize = 0;
		_buffer = 0;
	}
	transparentColor = 0xF81F;
	frames = _frames;
	colorMode = col;
    b0c4:	72a3      	strb	r3, [r4, #10]
	_width = w;
	_height = h;
	frame_looping = fl;
    b0c6:	1c63      	adds	r3, r4, #1
	}
	transparentColor = 0xF81F;
	frames = _frames;
	colorMode = col;
	_width = w;
	_height = h;
    b0c8:	8266      	strh	r6, [r4, #18]
		_buffer = 0;
	}
	transparentColor = 0xF81F;
	frames = _frames;
	colorMode = col;
	_width = w;
    b0ca:	8227      	strh	r7, [r4, #16]
	_height = h;
	frame_looping = fl;
	frame_handler = new Frame_Handler_RAM(this);
    b0cc:	2010      	movs	r0, #16
	transparentColor = 0xF81F;
	frames = _frames;
	colorMode = col;
	_width = w;
	_height = h;
	frame_looping = fl;
    b0ce:	77da      	strb	r2, [r3, #31]
	frame_handler = new Frame_Handler_RAM(this);
    b0d0:	f005 f8ae 	bl	10230 <_Znwj>
    b0d4:	1c21      	adds	r1, r4, #0
    b0d6:	1c06      	adds	r6, r0, #0
    b0d8:	f7ff fdee 	bl	acb8 <_ZN14Gamebuino_Meta17Frame_Handler_RAMC1EPNS_5ImageE>
	frame_loopcounter = 0;
    b0dc:	1d23      	adds	r3, r4, #4
	frames = _frames;
	colorMode = col;
	_width = w;
	_height = h;
	frame_looping = fl;
	frame_handler = new Frame_Handler_RAM(this);
    b0de:	61e6      	str	r6, [r4, #28]
	frame_loopcounter = 0;
    b0e0:	77dd      	strb	r5, [r3, #31]
	last_frame = (gb.frameCount & 0xFF) - 1;
    b0e2:	4b08      	ldr	r3, [pc, #32]	; (b104 <_ZN14Gamebuino_Meta5ImageC1EttNS_9ColorModeEth+0x80>)
	setFrame(0);
    b0e4:	1c20      	adds	r0, r4, #0
	_width = w;
	_height = h;
	frame_looping = fl;
	frame_handler = new Frame_Handler_RAM(this);
	frame_loopcounter = 0;
	last_frame = (gb.frameCount & 0xFF) - 1;
    b0e6:	33fc      	adds	r3, #252	; 0xfc
    b0e8:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    b0ea:	1ce3      	adds	r3, r4, #3
    b0ec:	3a01      	subs	r2, #1
    b0ee:	77da      	strb	r2, [r3, #31]
	setFrame(0);
    b0f0:	1c29      	adds	r1, r5, #0
    b0f2:	f7ff fedf 	bl	aeb4 <_ZN14Gamebuino_Meta5Image8setFrameEt>
}

Image::Image(uint16_t w, uint16_t h, ColorMode col, uint16_t frames, uint8_t fl) : Graphics(w, h) {
	freshStart();
	init(w, h, col, frames, fl);
}
    b0f6:	1c20      	adds	r0, r4, #0
    b0f8:	b005      	add	sp, #20
    b0fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b0fc:	00015478 	.word	0x00015478
    b100:	fffff81f 	.word	0xfffff81f
    b104:	20000a3c 	.word	0x20000a3c

0000b108 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_>:
void Image::drawBitmap(int8_t x, int8_t y, const uint8_t *bitmap,
	uint8_t rotation, uint8_t flip) {
	Graphics::drawBitmap(x, y, bitmap, rotation, flip);
}

void Image::drawImage(int16_t x, int16_t y, Image& img) {
    b108:	b5f0      	push	{r4, r5, r6, r7, lr}
    b10a:	b08d      	sub	sp, #52	; 0x34
    b10c:	9104      	str	r1, [sp, #16]
    b10e:	9205      	str	r2, [sp, #20]
    b110:	1c1c      	adds	r4, r3, #0
	//draw INDEX => RGB, non-transparent
	if ((img.colorMode == ColorMode::index) && (colorMode == ColorMode::rgb565) && !img.useTransparentIndex) {
    b112:	7a9b      	ldrb	r3, [r3, #10]
void Image::drawBitmap(int8_t x, int8_t y, const uint8_t *bitmap,
	uint8_t rotation, uint8_t flip) {
	Graphics::drawBitmap(x, y, bitmap, rotation, flip);
}

void Image::drawImage(int16_t x, int16_t y, Image& img) {
    b114:	1c05      	adds	r5, r0, #0
	//draw INDEX => RGB, non-transparent
	if ((img.colorMode == ColorMode::index) && (colorMode == ColorMode::rgb565) && !img.useTransparentIndex) {
    b116:	2b01      	cmp	r3, #1
    b118:	d000      	beq.n	b11c <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0x14>
    b11a:	e093      	b.n	b244 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0x13c>
    b11c:	7a83      	ldrb	r3, [r0, #10]
    b11e:	2b00      	cmp	r3, #0
    b120:	d000      	beq.n	b124 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0x1c>
    b122:	e08f      	b.n	b244 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0x13c>
    b124:	7a66      	ldrb	r6, [r4, #9]
    b126:	2e00      	cmp	r6, #0
    b128:	d000      	beq.n	b12c <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0x24>
    b12a:	e08b      	b.n	b244 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0x13c>
		img.nextFrame();
    b12c:	1c20      	adds	r0, r4, #0
    b12e:	f7ff fe87 	bl	ae40 <_ZN14Gamebuino_Meta5Image9nextFrameEv>
		int16_t w1 = img._width; //width of the source image
		int16_t h1 = img._height; //height of the source image
    b132:	8a67      	ldrh	r7, [r4, #18]
		if ((x > _width) || ((x + w1) < 0) || (y > _height) || ((y + h1) < 0)) return;
    b134:	8a2a      	ldrh	r2, [r5, #16]
void Image::drawImage(int16_t x, int16_t y, Image& img) {
	//draw INDEX => RGB, non-transparent
	if ((img.colorMode == ColorMode::index) && (colorMode == ColorMode::rgb565) && !img.useTransparentIndex) {
		img.nextFrame();
		int16_t w1 = img._width; //width of the source image
		int16_t h1 = img._height; //height of the source image
    b136:	9708      	str	r7, [sp, #32]
		if ((x > _width) || ((x + w1) < 0) || (y > _height) || ((y + h1) < 0)) return;
    b138:	9f04      	ldr	r7, [sp, #16]
    b13a:	b211      	sxth	r1, r2

void Image::drawImage(int16_t x, int16_t y, Image& img) {
	//draw INDEX => RGB, non-transparent
	if ((img.colorMode == ColorMode::index) && (colorMode == ColorMode::rgb565) && !img.useTransparentIndex) {
		img.nextFrame();
		int16_t w1 = img._width; //width of the source image
    b13c:	8a23      	ldrh	r3, [r4, #16]
		int16_t h1 = img._height; //height of the source image
		if ((x > _width) || ((x + w1) < 0) || (y > _height) || ((y + h1) < 0)) return;
    b13e:	428f      	cmp	r7, r1
    b140:	dd00      	ble.n	b144 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0x3c>
    b142:	e085      	b.n	b250 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0x148>
    b144:	b218      	sxth	r0, r3
    b146:	9006      	str	r0, [sp, #24]
    b148:	183f      	adds	r7, r7, r0
    b14a:	9707      	str	r7, [sp, #28]
    b14c:	d500      	bpl.n	b150 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0x48>
    b14e:	e07f      	b.n	b250 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0x148>
    b150:	8a6f      	ldrh	r7, [r5, #18]
    b152:	970b      	str	r7, [sp, #44]	; 0x2c
    b154:	b23f      	sxth	r7, r7
    b156:	46bc      	mov	ip, r7
    b158:	9f05      	ldr	r7, [sp, #20]
    b15a:	4567      	cmp	r7, ip
    b15c:	dc78      	bgt.n	b250 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0x148>
    b15e:	9808      	ldr	r0, [sp, #32]
    b160:	b200      	sxth	r0, r0
    b162:	183f      	adds	r7, r7, r0
    b164:	9709      	str	r7, [sp, #36]	; 0x24
    b166:	d473      	bmi.n	b250 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0x148>
		//horizontal cropping
		int16_t i2offset = 0;
		int16_t w2cropped = w1;
		if (x < 0) {
    b168:	9f04      	ldr	r7, [sp, #16]
    b16a:	2f00      	cmp	r7, #0
    b16c:	da0d      	bge.n	b18a <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0x82>
			i2offset = -x;
    b16e:	b2b8      	uxth	r0, r7
    b170:	4246      	negs	r6, r0
			w2cropped = w1 + x;
    b172:	18c3      	adds	r3, r0, r3
		if ((x > _width) || ((x + w1) < 0) || (y > _height) || ((y + h1) < 0)) return;
		//horizontal cropping
		int16_t i2offset = 0;
		int16_t w2cropped = w1;
		if (x < 0) {
			i2offset = -x;
    b174:	b2b6      	uxth	r6, r6
			w2cropped = w1 + x;
    b176:	b29b      	uxth	r3, r3
		if ((x > _width) || ((x + w1) < 0) || (y > _height) || ((y + h1) < 0)) return;
		//horizontal cropping
		int16_t i2offset = 0;
		int16_t w2cropped = w1;
		if (x < 0) {
			i2offset = -x;
    b178:	9607      	str	r6, [sp, #28]
    b17a:	1c1e      	adds	r6, r3, #0
    b17c:	b21b      	sxth	r3, r3
    b17e:	428b      	cmp	r3, r1
    b180:	dd00      	ble.n	b184 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0x7c>
    b182:	1c16      	adds	r6, r2, #0
    b184:	b2b6      	uxth	r6, r6
    b186:	960a      	str	r6, [sp, #40]	; 0x28
    b188:	e00a      	b.n	b1a0 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0x98>
			w2cropped = w1 + x;
			if (w2cropped > _width) {
				w2cropped = _width;
			}
		} else if ((x + w1) > _width) {
    b18a:	9807      	ldr	r0, [sp, #28]
    b18c:	4288      	cmp	r0, r1
    b18e:	dd05      	ble.n	b19c <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0x94>
			w2cropped = _width - x;
    b190:	9f04      	ldr	r7, [sp, #16]
		img.nextFrame();
		int16_t w1 = img._width; //width of the source image
		int16_t h1 = img._height; //height of the source image
		if ((x > _width) || ((x + w1) < 0) || (y > _height) || ((y + h1) < 0)) return;
		//horizontal cropping
		int16_t i2offset = 0;
    b192:	9607      	str	r6, [sp, #28]
			w2cropped = w1 + x;
			if (w2cropped > _width) {
				w2cropped = _width;
			}
		} else if ((x + w1) > _width) {
			w2cropped = _width - x;
    b194:	1bd2      	subs	r2, r2, r7
    b196:	b292      	uxth	r2, r2
    b198:	920a      	str	r2, [sp, #40]	; 0x28
    b19a:	e001      	b.n	b1a0 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0x98>
		int16_t w1 = img._width; //width of the source image
		int16_t h1 = img._height; //height of the source image
		if ((x > _width) || ((x + w1) < 0) || (y > _height) || ((y + h1) < 0)) return;
		//horizontal cropping
		int16_t i2offset = 0;
		int16_t w2cropped = w1;
    b19c:	930a      	str	r3, [sp, #40]	; 0x28
		img.nextFrame();
		int16_t w1 = img._width; //width of the source image
		int16_t h1 = img._height; //height of the source image
		if ((x > _width) || ((x + w1) < 0) || (y > _height) || ((y + h1) < 0)) return;
		//horizontal cropping
		int16_t i2offset = 0;
    b19e:	9607      	str	r6, [sp, #28]
		}

		//vertical cropping
		int16_t j2offset = 0;
		int16_t h2cropped = h1;
		if (y < 0) {
    b1a0:	9e05      	ldr	r6, [sp, #20]
    b1a2:	2e00      	cmp	r6, #0
    b1a4:	da0c      	bge.n	b1c0 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0xb8>
			j2offset = -y;
			h2cropped = h1 + y;
    b1a6:	9f08      	ldr	r7, [sp, #32]

		//vertical cropping
		int16_t j2offset = 0;
		int16_t h2cropped = h1;
		if (y < 0) {
			j2offset = -y;
    b1a8:	b2b1      	uxth	r1, r6
    b1aa:	424b      	negs	r3, r1
			h2cropped = h1 + y;
    b1ac:	19c9      	adds	r1, r1, r7
    b1ae:	b289      	uxth	r1, r1
    b1b0:	1c0a      	adds	r2, r1, #0
    b1b2:	b209      	sxth	r1, r1

		//vertical cropping
		int16_t j2offset = 0;
		int16_t h2cropped = h1;
		if (y < 0) {
			j2offset = -y;
    b1b4:	b29b      	uxth	r3, r3
    b1b6:	4561      	cmp	r1, ip
    b1b8:	dd09      	ble.n	b1ce <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0xc6>
    b1ba:	980b      	ldr	r0, [sp, #44]	; 0x2c
    b1bc:	1c02      	adds	r2, r0, #0
    b1be:	e006      	b.n	b1ce <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0xc6>
			h2cropped = h1 + y;
			if (h2cropped > _height) {
				h2cropped = _height;
			}
		} else if ((y + h1) > _height) {
    b1c0:	9909      	ldr	r1, [sp, #36]	; 0x24
		} else if ((x + w1) > _width) {
			w2cropped = _width - x;
		}

		//vertical cropping
		int16_t j2offset = 0;
    b1c2:	2300      	movs	r3, #0
			j2offset = -y;
			h2cropped = h1 + y;
			if (h2cropped > _height) {
				h2cropped = _height;
			}
		} else if ((y + h1) > _height) {
    b1c4:	4561      	cmp	r1, ip
    b1c6:	dd04      	ble.n	b1d2 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0xca>
			h2cropped = _height - y;
    b1c8:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    b1ca:	9f05      	ldr	r7, [sp, #20]
    b1cc:	1bf2      	subs	r2, r6, r7
    b1ce:	b292      	uxth	r2, r2
    b1d0:	9208      	str	r2, [sp, #32]
		
		for (int j2 = 0; j2 < h2cropped; j2++) {
			uint8_t *srcLine;
			
			// w1+1 for ceiling rather than flooring
			srcLine = (uint8_t*)img._buffer + ((w1 + 1) / 2) * (j2 + j2offset) + (i2offset/2);
    b1d2:	9a06      	ldr	r2, [sp, #24]
    b1d4:	9f07      	ldr	r7, [sp, #28]
    b1d6:	3201      	adds	r2, #1
    b1d8:	0fd1      	lsrs	r1, r2, #31
    b1da:	188a      	adds	r2, r1, r2
    b1dc:	1052      	asrs	r2, r2, #1
    b1de:	b23f      	sxth	r7, r7
    b1e0:	b21e      	sxth	r6, r3
    b1e2:	9706      	str	r7, [sp, #24]
    b1e4:	1c13      	adds	r3, r2, #0
    b1e6:	4373      	muls	r3, r6
    b1e8:	960b      	str	r6, [sp, #44]	; 0x2c
    b1ea:	9e06      	ldr	r6, [sp, #24]
    b1ec:	0fff      	lsrs	r7, r7, #31
    b1ee:	19bf      	adds	r7, r7, r6
    b1f0:	107f      	asrs	r7, r7, #1
    b1f2:	9209      	str	r2, [sp, #36]	; 0x24
    b1f4:	19df      	adds	r7, r3, r7
			}
		} else if ((y + h1) > _height) {
			h2cropped = _height - y;
		}
		
		for (int j2 = 0; j2 < h2cropped; j2++) {
    b1f6:	2600      	movs	r6, #0
    b1f8:	9a08      	ldr	r2, [sp, #32]
    b1fa:	b213      	sxth	r3, r2
    b1fc:	429e      	cmp	r6, r3
    b1fe:	da27      	bge.n	b250 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0x148>
			// w1+1 for ceiling rather than flooring
			srcLine = (uint8_t*)img._buffer + ((w1 + 1) / 2) * (j2 + j2offset) + (i2offset/2);
			

			indexTo565(
				&_buffer[x + i2offset + (y + j2offset + j2)*_width],
    b200:	9804      	ldr	r0, [sp, #16]
    b202:	9906      	ldr	r1, [sp, #24]
    b204:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    b206:	1843      	adds	r3, r0, r1
    b208:	9905      	ldr	r1, [sp, #20]
    b20a:	1850      	adds	r0, r2, r1
    b20c:	2110      	movs	r1, #16
    b20e:	5e6a      	ldrsh	r2, [r5, r1]
    b210:	1980      	adds	r0, r0, r6
    b212:	4350      	muls	r0, r2
    b214:	1818      	adds	r0, r3, r0
		
		for (int j2 = 0; j2 < h2cropped; j2++) {
			uint8_t *srcLine;
			
			// w1+1 for ceiling rather than flooring
			srcLine = (uint8_t*)img._buffer + ((w1 + 1) / 2) * (j2 + j2offset) + (i2offset/2);
    b216:	6963      	ldr	r3, [r4, #20]
			

			indexTo565(
				&_buffer[x + i2offset + (y + j2offset + j2)*_width],
				srcLine, colorIndex, w2cropped, i2offset%2
			);
    b218:	696a      	ldr	r2, [r5, #20]
		
		for (int j2 = 0; j2 < h2cropped; j2++) {
			uint8_t *srcLine;
			
			// w1+1 for ceiling rather than flooring
			srcLine = (uint8_t*)img._buffer + ((w1 + 1) / 2) * (j2 + j2offset) + (i2offset/2);
    b21a:	19d9      	adds	r1, r3, r7
			

			indexTo565(
				&_buffer[x + i2offset + (y + j2offset + j2)*_width],
				srcLine, colorIndex, w2cropped, i2offset%2
			);
    b21c:	4b0d      	ldr	r3, [pc, #52]	; (b254 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0x14c>)
    b21e:	0040      	lsls	r0, r0, #1
    b220:	1810      	adds	r0, r2, r0
    b222:	681a      	ldr	r2, [r3, #0]
    b224:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    b226:	9003      	str	r0, [sp, #12]
    b228:	b29b      	uxth	r3, r3
    b22a:	9302      	str	r3, [sp, #8]
    b22c:	9b07      	ldr	r3, [sp, #28]
    b22e:	2001      	movs	r0, #1
    b230:	4003      	ands	r3, r0
    b232:	9300      	str	r3, [sp, #0]
    b234:	9803      	ldr	r0, [sp, #12]
    b236:	9b02      	ldr	r3, [sp, #8]
    b238:	f7fd fefa 	bl	9030 <_ZN14Gamebuino_Meta8Graphics10indexTo565EPtPhPNS_5ColorEtb>
    b23c:	9909      	ldr	r1, [sp, #36]	; 0x24
			}
		} else if ((y + h1) > _height) {
			h2cropped = _height - y;
		}
		
		for (int j2 = 0; j2 < h2cropped; j2++) {
    b23e:	3601      	adds	r6, #1
    b240:	187f      	adds	r7, r7, r1
    b242:	e7d9      	b.n	b1f8 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_+0xf0>
			);
		}
		
		return;
	}
	Graphics::drawImage(x, y, img);
    b244:	1c28      	adds	r0, r5, #0
    b246:	9904      	ldr	r1, [sp, #16]
    b248:	9a05      	ldr	r2, [sp, #20]
    b24a:	1c23      	adds	r3, r4, #0
    b24c:	f7fd ff0c 	bl	9068 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageE>
}
    b250:	b00d      	add	sp, #52	; 0x34
    b252:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b254:	20000050 	.word	0x20000050

0000b258 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_ss>:

void Image::drawImage(int16_t x, int16_t y, Image& img, int16_t w2, int16_t h2) {
    b258:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    b25a:	ac08      	add	r4, sp, #32
    b25c:	2600      	movs	r6, #0
    b25e:	5fa5      	ldrsh	r5, [r4, r6]
	if ((img._width == w2) && (img._height == h2)) {
    b260:	2710      	movs	r7, #16
    b262:	5fde      	ldrsh	r6, [r3, r7]
		return;
	}
	Graphics::drawImage(x, y, img);
}

void Image::drawImage(int16_t x, int16_t y, Image& img, int16_t w2, int16_t h2) {
    b264:	ac09      	add	r4, sp, #36	; 0x24
    b266:	2700      	movs	r7, #0
    b268:	5fe4      	ldrsh	r4, [r4, r7]
	if ((img._width == w2) && (img._height == h2)) {
    b26a:	42ae      	cmp	r6, r5
    b26c:	d107      	bne.n	b27e <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_ss+0x26>
    b26e:	2712      	movs	r7, #18
    b270:	5fde      	ldrsh	r6, [r3, r7]
    b272:	42a6      	cmp	r6, r4
    b274:	d103      	bne.n	b27e <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_ss+0x26>
		drawImage(x, y, img);
    b276:	6804      	ldr	r4, [r0, #0]
    b278:	6b64      	ldr	r4, [r4, #52]	; 0x34
    b27a:	47a0      	blx	r4
    b27c:	e003      	b.n	b286 <_ZN14Gamebuino_Meta5Image9drawImageEssRS0_ss+0x2e>
		return;
	}
	Graphics::drawImage(x, y, img, w2, h2);
    b27e:	9500      	str	r5, [sp, #0]
    b280:	9401      	str	r4, [sp, #4]
    b282:	f7fd fd21 	bl	8cc8 <_ZN14Gamebuino_Meta8Graphics9drawImageEssRNS_5ImageEss>
}
    b286:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

0000b288 <_ZN7FatFile7seekCurEl>:
  bool rmRfStar();
  /** Set the files position to current position + \a pos. See seekSet().
   * \param[in] offset The new position in bytes from the current position.
   * \return true for success or false for failure.
   */
  bool seekCur(int32_t offset) {
    b288:	b508      	push	{r3, lr}
    return seekSet(m_curPosition + offset);
    b28a:	6943      	ldr	r3, [r0, #20]
    b28c:	18c9      	adds	r1, r1, r3
    b28e:	f001 ff7f 	bl	d190 <_ZN7FatFile7seekSetEm>
  }
    b292:	bd08      	pop	{r3, pc}

0000b294 <_ZN14Gamebuino_Meta10writeAsRGBEtP4File>:
#include "../Misc.h"
#include "../../config/config.h"

namespace Gamebuino_Meta {

void writeAsRGB(uint16_t b, File* f) {
    b294:	b537      	push	{r0, r1, r2, r4, r5, lr}
    b296:	1c0c      	adds	r4, r1, #0
	RGB888 c = rgb565Torgb888(b);
    b298:	f001 fa8b 	bl	c7b2 <_ZN14Gamebuino_Meta14rgb565Torgb888Et>
    b29c:	ad01      	add	r5, sp, #4
    b29e:	0a03      	lsrs	r3, r0, #8
    b2a0:	7028      	strb	r0, [r5, #0]
    b2a2:	706b      	strb	r3, [r5, #1]
    b2a4:	0200      	lsls	r0, r0, #8
	f->write(c.b);
    b2a6:	6823      	ldr	r3, [r4, #0]
#include "../../config/config.h"

namespace Gamebuino_Meta {

void writeAsRGB(uint16_t b, File* f) {
	RGB888 c = rgb565Torgb888(b);
    b2a8:	0e00      	lsrs	r0, r0, #24
    b2aa:	70a8      	strb	r0, [r5, #2]
	f->write(c.b);
    b2ac:	b2c1      	uxtb	r1, r0
    b2ae:	681b      	ldr	r3, [r3, #0]
    b2b0:	1c20      	adds	r0, r4, #0
    b2b2:	4798      	blx	r3
	f->write(c.g);
    b2b4:	6823      	ldr	r3, [r4, #0]
    b2b6:	7869      	ldrb	r1, [r5, #1]
    b2b8:	681b      	ldr	r3, [r3, #0]
    b2ba:	1c20      	adds	r0, r4, #0
    b2bc:	4798      	blx	r3
	f->write(c.r);
    b2be:	6823      	ldr	r3, [r4, #0]
    b2c0:	7829      	ldrb	r1, [r5, #0]
    b2c2:	681b      	ldr	r3, [r3, #0]
    b2c4:	1c20      	adds	r0, r4, #0
    b2c6:	4798      	blx	r3
}
    b2c8:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

0000b2ca <_ZN14Gamebuino_Meta3BMPC1EPNS_5ImageEt>:
BMP::BMP() {
	valid = false;
}

BMP::BMP(Image* img, uint16_t _frames) {
	if (img->colorMode == ColorMode::index) {
    b2ca:	7a8b      	ldrb	r3, [r1, #10]
    b2cc:	2b01      	cmp	r3, #1
    b2ce:	d102      	bne.n	b2d6 <_ZN14Gamebuino_Meta3BMPC1EPNS_5ImageEt+0xc>
		depth = 4;
    b2d0:	2304      	movs	r3, #4
    b2d2:	7003      	strb	r3, [r0, #0]
    b2d4:	e007      	b.n	b2e6 <_ZN14Gamebuino_Meta3BMPC1EPNS_5ImageEt+0x1c>
	} else if (!img->transparentColor) {
    b2d6:	890b      	ldrh	r3, [r1, #8]
    b2d8:	2b00      	cmp	r3, #0
    b2da:	d102      	bne.n	b2e2 <_ZN14Gamebuino_Meta3BMPC1EPNS_5ImageEt+0x18>
		depth = 24;
    b2dc:	2318      	movs	r3, #24
    b2de:	7003      	strb	r3, [r0, #0]
    b2e0:	e001      	b.n	b2e6 <_ZN14Gamebuino_Meta3BMPC1EPNS_5ImageEt+0x1c>
	} else {
		depth = 32;
    b2e2:	2320      	movs	r3, #32
    b2e4:	7003      	strb	r3, [r0, #0]
	}
	width = img->_width;
    b2e6:	8a0b      	ldrh	r3, [r1, #16]
    b2e8:	8103      	strh	r3, [r0, #8]
	height = img->_height;
    b2ea:	8a4b      	ldrh	r3, [r1, #18]
	frames = _frames;
    b2ec:	8182      	strh	r2, [r0, #12]
		depth = 24;
	} else {
		depth = 32;
	}
	width = img->_width;
	height = img->_height;
    b2ee:	8143      	strh	r3, [r0, #10]
	frames = _frames;
}
    b2f0:	4770      	bx	lr
	...

0000b2f4 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE>:

BMP::BMP(File* file, Image* img) {
    b2f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    b2f6:	1c0d      	adds	r5, r1, #0
    b2f8:	1c16      	adds	r6, r2, #0
	valid = false;
	file->rewind();
    b2fa:	1c2a      	adds	r2, r5, #0
    b2fc:	3210      	adds	r2, #16
	height = img->_height;
	frames = _frames;
}

BMP::BMP(File* file, Image* img) {
	valid = false;
    b2fe:	2100      	movs	r1, #0
	width = img->_width;
	height = img->_height;
	frames = _frames;
}

BMP::BMP(File* file, Image* img) {
    b300:	b089      	sub	sp, #36	; 0x24
	valid = false;
    b302:	7041      	strb	r1, [r0, #1]
	width = img->_width;
	height = img->_height;
	frames = _frames;
}

BMP::BMP(File* file, Image* img) {
    b304:	1c04      	adds	r4, r0, #0
   * the value false is returned for failure.
   */
  static bool remove(FatFile* dirFile, const char* path);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    b306:	1c10      	adds	r0, r2, #0
	valid = false;
	file->rewind();
    b308:	9201      	str	r2, [sp, #4]
    b30a:	f001 ff41 	bl	d190 <_ZN7FatFile7seekSetEm>
	if (f_read16(file) != 0x4D42) {
    b30e:	1c28      	adds	r0, r5, #0
    b310:	f001 fa64 	bl	c7dc <_ZN14Gamebuino_Meta8f_read16EP4File>
    b314:	4b65      	ldr	r3, [pc, #404]	; (b4ac <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x1b8>)
    b316:	4298      	cmp	r0, r3
    b318:	d000      	beq.n	b31c <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x28>
    b31a:	e0c3      	b.n	b4a4 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x1b0>
		// no valid BMP header
		return;
	}
	file->seekCur(4); // skip file size
    b31c:	2104      	movs	r1, #4
    b31e:	9801      	ldr	r0, [sp, #4]
    b320:	f7ff ffb2 	bl	b288 <_ZN7FatFile7seekCurEl>
	creatorBits = f_read32(file);
    b324:	1c28      	adds	r0, r5, #0
    b326:	f001 fa63 	bl	c7f0 <_ZN14Gamebuino_Meta8f_read32EP4File>
    b32a:	6060      	str	r0, [r4, #4]
	image_offset = f_read32(file);
    b32c:	1c28      	adds	r0, r5, #0
    b32e:	f001 fa5f 	bl	c7f0 <_ZN14Gamebuino_Meta8f_read32EP4File>
    b332:	70a0      	strb	r0, [r4, #2]
	uint32_t header_size = f_read32(file);
    b334:	1c28      	adds	r0, r5, #0
    b336:	f001 fa5b 	bl	c7f0 <_ZN14Gamebuino_Meta8f_read32EP4File>
    b33a:	1c07      	adds	r7, r0, #0
	width = f_read32(file);
    b33c:	1c28      	adds	r0, r5, #0
    b33e:	f001 fa57 	bl	c7f0 <_ZN14Gamebuino_Meta8f_read32EP4File>
    b342:	8120      	strh	r0, [r4, #8]
	if (img->_width && width > img->_width) {
		// BMP too large
		return;
	}
#endif
	img->_width = width;
    b344:	8230      	strh	r0, [r6, #16]
	uint32_t pixel_height = f_read32(file);
    b346:	1c28      	adds	r0, r5, #0
    b348:	f001 fa52 	bl	c7f0 <_ZN14Gamebuino_Meta8f_read32EP4File>
	if (img->_height) {
    b34c:	8a71      	ldrh	r1, [r6, #18]
    b34e:	2900      	cmp	r1, #0
    b350:	d007      	beq.n	b362 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x6e>
		height = img->_height;
    b352:	8161      	strh	r1, [r4, #10]
		img->frames = frames = pixel_height / img->_height;
    b354:	b209      	sxth	r1, r1
    b356:	f006 f81f 	bl	11398 <__aeabi_uidiv>
    b35a:	b280      	uxth	r0, r0
    b35c:	81a0      	strh	r0, [r4, #12]
    b35e:	8330      	strh	r0, [r6, #24]
    b360:	e004      	b.n	b36c <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x78>
	} else {
		img->_height = height = pixel_height;
		img->frames = frames = 1;
    b362:	2301      	movs	r3, #1
	uint32_t pixel_height = f_read32(file);
	if (img->_height) {
		height = img->_height;
		img->frames = frames = pixel_height / img->_height;
	} else {
		img->_height = height = pixel_height;
    b364:	8160      	strh	r0, [r4, #10]
    b366:	8270      	strh	r0, [r6, #18]
		img->frames = frames = 1;
    b368:	81a3      	strh	r3, [r4, #12]
    b36a:	8333      	strh	r3, [r6, #24]
	}
	if (f_read16(file) != 1) { // # planes, must always be 1
    b36c:	1c28      	adds	r0, r5, #0
    b36e:	f001 fa35 	bl	c7dc <_ZN14Gamebuino_Meta8f_read16EP4File>
    b372:	2801      	cmp	r0, #1
    b374:	d000      	beq.n	b378 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x84>
    b376:	e095      	b.n	b4a4 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x1b0>
		return;
	}
	depth = f_read16(file);
    b378:	1c28      	adds	r0, r5, #0
    b37a:	f001 fa2f 	bl	c7dc <_ZN14Gamebuino_Meta8f_read16EP4File>
    b37e:	b2c0      	uxtb	r0, r0
    b380:	7020      	strb	r0, [r4, #0]
	if (depth != 4 && depth != 24 && depth != 32) {
    b382:	2804      	cmp	r0, #4
    b384:	d004      	beq.n	b390 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x9c>
    b386:	2818      	cmp	r0, #24
    b388:	d002      	beq.n	b390 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x9c>
    b38a:	2820      	cmp	r0, #32
    b38c:	d000      	beq.n	b390 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x9c>
    b38e:	e089      	b.n	b4a4 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x1b0>
		// we can only load BMPs of depth 4 or 24 or 32
		return;
	}
	uint32_t compression = f_read32(file);
    b390:	1c28      	adds	r0, r5, #0
    b392:	f001 fa2d 	bl	c7f0 <_ZN14Gamebuino_Meta8f_read32EP4File>
	bool createRGBAmasks = false;
	if (depth == 32) {
    b396:	7823      	ldrb	r3, [r4, #0]
    b398:	2b20      	cmp	r3, #32
    b39a:	d12d      	bne.n	b3f8 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x104>
		createRGBAmasks = compression == 3;
    b39c:	1ec3      	subs	r3, r0, #3
    b39e:	425a      	negs	r2, r3
    b3a0:	4153      	adcs	r3, r2
    b3a2:	b2db      	uxtb	r3, r3
	}
	if (compression != 0 && !createRGBAmasks) {
    b3a4:	2800      	cmp	r0, #0
    b3a6:	d002      	beq.n	b3ae <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0xba>
    b3a8:	2b00      	cmp	r3, #0
    b3aa:	d102      	bne.n	b3b2 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0xbe>
    b3ac:	e07a      	b.n	b4a4 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x1b0>
		
		
		img->colorMode = ColorMode::index;
		img->useTransparentIndex = false; // TODO: transparency detection
	} else {
		if (createRGBAmasks) {
    b3ae:	2b00      	cmp	r3, #0
    b3b0:	d026      	beq.n	b400 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x10c>
			file->seekCur(20); // we ignore mage size, x pixels per meter, y pixels per meter, colors and important colors
    b3b2:	9801      	ldr	r0, [sp, #4]
    b3b4:	2114      	movs	r1, #20
    b3b6:	f7ff ff67 	bl	b288 <_ZN7FatFile7seekCurEl>
    b3ba:	2700      	movs	r7, #0
			for (uint8_t i = 0; i < 4; i++) {
				uint32_t mask = f_read32(file);
    b3bc:	1c28      	adds	r0, r5, #0
    b3be:	f001 fa17 	bl	c7f0 <_ZN14Gamebuino_Meta8f_read32EP4File>
				for (uint8_t j = 0; j < 4; j++) {
					if ((0xFF << (j*8)) & mask) {
    b3c2:	b2c3      	uxtb	r3, r0
    b3c4:	2b00      	cmp	r3, #0
    b3c6:	d10c      	bne.n	b3e2 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0xee>
    b3c8:	23ff      	movs	r3, #255	; 0xff
    b3ca:	021b      	lsls	r3, r3, #8
    b3cc:	4218      	tst	r0, r3
    b3ce:	d10a      	bne.n	b3e6 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0xf2>
    b3d0:	23ff      	movs	r3, #255	; 0xff
    b3d2:	041b      	lsls	r3, r3, #16
    b3d4:	4218      	tst	r0, r3
    b3d6:	d108      	bne.n	b3ea <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0xf6>
    b3d8:	0e00      	lsrs	r0, r0, #24
	} else {
		if (createRGBAmasks) {
			file->seekCur(20); // we ignore mage size, x pixels per meter, y pixels per meter, colors and important colors
			for (uint8_t i = 0; i < 4; i++) {
				uint32_t mask = f_read32(file);
				for (uint8_t j = 0; j < 4; j++) {
    b3da:	2303      	movs	r3, #3
					if ((0xFF << (j*8)) & mask) {
    b3dc:	2800      	cmp	r0, #0
    b3de:	d007      	beq.n	b3f0 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0xfc>
    b3e0:	e004      	b.n	b3ec <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0xf8>
	} else {
		if (createRGBAmasks) {
			file->seekCur(20); // we ignore mage size, x pixels per meter, y pixels per meter, colors and important colors
			for (uint8_t i = 0; i < 4; i++) {
				uint32_t mask = f_read32(file);
				for (uint8_t j = 0; j < 4; j++) {
    b3e2:	2300      	movs	r3, #0
    b3e4:	e002      	b.n	b3ec <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0xf8>
    b3e6:	2301      	movs	r3, #1
    b3e8:	e000      	b.n	b3ec <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0xf8>
    b3ea:	2302      	movs	r3, #2
    b3ec:	19e2      	adds	r2, r4, r7
					if ((0xFF << (j*8)) & mask) {
						indexMap[i] = j;
    b3ee:	7393      	strb	r3, [r2, #14]
    b3f0:	3701      	adds	r7, #1
		img->colorMode = ColorMode::index;
		img->useTransparentIndex = false; // TODO: transparency detection
	} else {
		if (createRGBAmasks) {
			file->seekCur(20); // we ignore mage size, x pixels per meter, y pixels per meter, colors and important colors
			for (uint8_t i = 0; i < 4; i++) {
    b3f2:	2f04      	cmp	r7, #4
    b3f4:	d1e2      	bne.n	b3bc <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0xc8>
    b3f6:	e00b      	b.n	b410 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x11c>
	uint32_t compression = f_read32(file);
	bool createRGBAmasks = false;
	if (depth == 32) {
		createRGBAmasks = compression == 3;
	}
	if (compression != 0 && !createRGBAmasks) {
    b3f8:	2800      	cmp	r0, #0
    b3fa:	d153      	bne.n	b4a4 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x1b0>
	}
	
	// we assume our color table so just ignore the one specified in the BMP
	
	
	if (depth == 4) {
    b3fc:	2b04      	cmp	r3, #4
    b3fe:	d011      	beq.n	b424 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x130>
						break;
					}
				}
			}
		} else {
			indexMap[0] = 2;
    b400:	2302      	movs	r3, #2
    b402:	73a3      	strb	r3, [r4, #14]
			indexMap[1] = 1;
    b404:	2301      	movs	r3, #1
    b406:	73e3      	strb	r3, [r4, #15]
			indexMap[2] = 0;
    b408:	2300      	movs	r3, #0
    b40a:	7423      	strb	r3, [r4, #16]
			indexMap[3] = 3;
    b40c:	2303      	movs	r3, #3
    b40e:	7463      	strb	r3, [r4, #17]
		}
		img->colorMode = ColorMode::rgb565;
    b410:	2300      	movs	r3, #0
    b412:	72b3      	strb	r3, [r6, #10]
		img->transparentColor = 0; // transparent color is detected during frame analysis
    b414:	8133      	strh	r3, [r6, #8]
	}
	
	file->seekSet(image_offset);
    b416:	78a1      	ldrb	r1, [r4, #2]
    b418:	9801      	ldr	r0, [sp, #4]
    b41a:	f001 feb9 	bl	d190 <_ZN7FatFile7seekSetEm>
	valid = true;
    b41e:	2301      	movs	r3, #1
    b420:	7063      	strb	r3, [r4, #1]
    b422:	e03f      	b.n	b4a4 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x1b0>
	
	// we assume our color table so just ignore the one specified in the BMP
	
	
	if (depth == 4) {
		file->seekCur(12); // we ignore image size, x pixels and y pixels per meter
    b424:	210c      	movs	r1, #12
    b426:	9801      	ldr	r0, [sp, #4]
    b428:	f7ff ff2e 	bl	b288 <_ZN7FatFile7seekCurEl>
		uint8_t num_colors = f_read32(file);
    b42c:	1c28      	adds	r0, r5, #0
    b42e:	f001 f9df 	bl	c7f0 <_ZN14Gamebuino_Meta8f_read32EP4File>
    b432:	b2c0      	uxtb	r0, r0
    b434:	1c03      	adds	r3, r0, #0
    b436:	2810      	cmp	r0, #16
    b438:	d900      	bls.n	b43c <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x148>
    b43a:	2310      	movs	r3, #16
		if (num_colors > 16) {
			num_colors = 16;
		}
		file->seekSet(header_size + 14);
    b43c:	1c39      	adds	r1, r7, #0
    b43e:	b2db      	uxtb	r3, r3
    b440:	310e      	adds	r1, #14
    b442:	9801      	ldr	r0, [sp, #4]
    b444:	9302      	str	r3, [sp, #8]
    b446:	f001 fea3 	bl	d190 <_ZN7FatFile7seekSetEm>
		for (uint8_t i = 0; i < num_colors; i++) {
    b44a:	1c27      	adds	r7, r4, #0
    b44c:	1b3b      	subs	r3, r7, r4
    b44e:	9a02      	ldr	r2, [sp, #8]
    b450:	b2db      	uxtb	r3, r3
    b452:	4293      	cmp	r3, r2
    b454:	d221      	bcs.n	b49a <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x1a6>
			uint8_t b = file->read();
    b456:	682b      	ldr	r3, [r5, #0]
    b458:	1c28      	adds	r0, r5, #0
    b45a:	68db      	ldr	r3, [r3, #12]
    b45c:	4798      	blx	r3
			uint8_t g = file->read();
    b45e:	682b      	ldr	r3, [r5, #0]
		if (num_colors > 16) {
			num_colors = 16;
		}
		file->seekSet(header_size + 14);
		for (uint8_t i = 0; i < num_colors; i++) {
			uint8_t b = file->read();
    b460:	9003      	str	r0, [sp, #12]
			uint8_t g = file->read();
    b462:	68db      	ldr	r3, [r3, #12]
    b464:	1c28      	adds	r0, r5, #0
    b466:	4798      	blx	r3
			uint8_t r = file->read();
    b468:	682b      	ldr	r3, [r5, #0]
			num_colors = 16;
		}
		file->seekSet(header_size + 14);
		for (uint8_t i = 0; i < num_colors; i++) {
			uint8_t b = file->read();
			uint8_t g = file->read();
    b46a:	9004      	str	r0, [sp, #16]
			uint8_t r = file->read();
    b46c:	68db      	ldr	r3, [r3, #12]
    b46e:	1c28      	adds	r0, r5, #0
    b470:	4798      	blx	r3
			file->read(); // trash transparency
    b472:	682b      	ldr	r3, [r5, #0]
		}
		file->seekSet(header_size + 14);
		for (uint8_t i = 0; i < num_colors; i++) {
			uint8_t b = file->read();
			uint8_t g = file->read();
			uint8_t r = file->read();
    b474:	9005      	str	r0, [sp, #20]
			file->read(); // trash transparency
    b476:	68db      	ldr	r3, [r3, #12]
    b478:	1c28      	adds	r0, r5, #0
    b47a:	4798      	blx	r3
			indexMap[i] = (uint8_t)Graphics::rgb565ToIndex((Color)rgb888Torgb565({r, g, b}));
    b47c:	9a05      	ldr	r2, [sp, #20]
    b47e:	ab07      	add	r3, sp, #28
    b480:	701a      	strb	r2, [r3, #0]
    b482:	9a04      	ldr	r2, [sp, #16]
    b484:	3701      	adds	r7, #1
    b486:	705a      	strb	r2, [r3, #1]
    b488:	9a03      	ldr	r2, [sp, #12]
    b48a:	709a      	strb	r2, [r3, #2]
    b48c:	9807      	ldr	r0, [sp, #28]
    b48e:	f001 f97f 	bl	c790 <_ZN14Gamebuino_Meta14rgb888Torgb565ENS_6RGB888E>
    b492:	f7fd ff69 	bl	9368 <_ZN14Gamebuino_Meta8Graphics13rgb565ToIndexENS_5ColorE>
    b496:	7378      	strb	r0, [r7, #13]
    b498:	e7d8      	b.n	b44c <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x158>
		}
		
		
		img->colorMode = ColorMode::index;
    b49a:	2301      	movs	r3, #1
    b49c:	72b3      	strb	r3, [r6, #10]
		img->useTransparentIndex = false; // TODO: transparency detection
    b49e:	2300      	movs	r3, #0
    b4a0:	7273      	strb	r3, [r6, #9]
    b4a2:	e7b8      	b.n	b416 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE+0x122>
		img->transparentColor = 0; // transparent color is detected during frame analysis
	}
	
	file->seekSet(image_offset);
	valid = true;
}
    b4a4:	1c20      	adds	r0, r4, #0
    b4a6:	b009      	add	sp, #36	; 0x24
    b4a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b4aa:	46c0      	nop			; (mov r8, r8)
    b4ac:	00004d42 	.word	0x00004d42

0000b4b0 <_ZN14Gamebuino_Meta3BMP7isValidEv>:

bool BMP::isValid() {
	return valid;
    b4b0:	7840      	ldrb	r0, [r0, #1]
}
    b4b2:	4770      	bx	lr

0000b4b4 <_ZN14Gamebuino_Meta3BMP14getCreatorBitsEv>:

uint32_t BMP::getCreatorBits() {
	return creatorBits;
    b4b4:	6840      	ldr	r0, [r0, #4]
}
    b4b6:	4770      	bx	lr

0000b4b8 <_ZN14Gamebuino_Meta3BMP14setCreatorBitsEmP4File>:

void BMP::setCreatorBits(uint32_t bits, File* file) {
    b4b8:	b538      	push	{r3, r4, r5, lr}
	file->seekSet(6);
    b4ba:	1c10      	adds	r0, r2, #0

uint32_t BMP::getCreatorBits() {
	return creatorBits;
}

void BMP::setCreatorBits(uint32_t bits, File* file) {
    b4bc:	1c0d      	adds	r5, r1, #0
    b4be:	1c14      	adds	r4, r2, #0
	file->seekSet(6);
    b4c0:	2106      	movs	r1, #6
    b4c2:	3010      	adds	r0, #16
    b4c4:	f001 fe64 	bl	d190 <_ZN7FatFile7seekSetEm>
	f_write32(bits, file);
    b4c8:	1c28      	adds	r0, r5, #0
    b4ca:	1c21      	adds	r1, r4, #0
    b4cc:	f001 f998 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
}
    b4d0:	bd38      	pop	{r3, r4, r5, pc}

0000b4d2 <_ZN14Gamebuino_Meta3BMP10getRowSizeEv>:
	}
	return image_size;
}

uint32_t BMP::getRowSize() {
	if (depth == 4) {
    b4d2:	7802      	ldrb	r2, [r0, #0]
    b4d4:	8903      	ldrh	r3, [r0, #8]
		return ((4*width+31)/32) * 4;
    b4d6:	0098      	lsls	r0, r3, #2
	}
	return image_size;
}

uint32_t BMP::getRowSize() {
	if (depth == 4) {
    b4d8:	2a04      	cmp	r2, #4
    b4da:	d103      	bne.n	b4e4 <_ZN14Gamebuino_Meta3BMP10getRowSizeEv+0x12>
		return ((4*width+31)/32) * 4;
    b4dc:	301f      	adds	r0, #31
    b4de:	1140      	asrs	r0, r0, #5
    b4e0:	0080      	lsls	r0, r0, #2
    b4e2:	e005      	b.n	b4f0 <_ZN14Gamebuino_Meta3BMP10getRowSizeEv+0x1e>
	}
	if (depth == 24) {
    b4e4:	2a18      	cmp	r2, #24
    b4e6:	d103      	bne.n	b4f0 <_ZN14Gamebuino_Meta3BMP10getRowSizeEv+0x1e>
		return (width * 3 + 3) & ~3;
    b4e8:	2203      	movs	r2, #3
    b4ea:	1c58      	adds	r0, r3, #1
    b4ec:	4350      	muls	r0, r2
    b4ee:	4390      	bics	r0, r2
	}
	return width * 4;
}
    b4f0:	4770      	bx	lr
	...

0000b4f4 <_ZN14Gamebuino_Meta3BMP11writeHeaderEP4File>:
void BMP::setCreatorBits(uint32_t bits, File* file) {
	file->seekSet(6);
	f_write32(bits, file);
}

uint32_t BMP::writeHeader(File* file) {
    b4f4:	b5f0      	push	{r4, r5, r6, r7, lr}
	// lets first create some helpful variables
	uint16_t header_size = 40;
	uint32_t pixel_height = height * frames;
    b4f6:	8943      	ldrh	r3, [r0, #10]
    b4f8:	8982      	ldrh	r2, [r0, #12]
void BMP::setCreatorBits(uint32_t bits, File* file) {
	file->seekSet(6);
	f_write32(bits, file);
}

uint32_t BMP::writeHeader(File* file) {
    b4fa:	b085      	sub	sp, #20
	// lets first create some helpful variables
	uint16_t header_size = 40;
	uint32_t pixel_height = height * frames;
    b4fc:	435a      	muls	r2, r3
	uint8_t color_table = 0;
	if (depth == 4) {
    b4fe:	7803      	ldrb	r3, [r0, #0]
void BMP::setCreatorBits(uint32_t bits, File* file) {
	file->seekSet(6);
	f_write32(bits, file);
}

uint32_t BMP::writeHeader(File* file) {
    b500:	1c05      	adds	r5, r0, #0
    b502:	1c0c      	adds	r4, r1, #0
	// lets first create some helpful variables
	uint16_t header_size = 40;
	uint32_t pixel_height = height * frames;
    b504:	9202      	str	r2, [sp, #8]
	uint8_t color_table = 0;
	if (depth == 4) {
    b506:	2b04      	cmp	r3, #4
    b508:	d003      	beq.n	b512 <_ZN14Gamebuino_Meta3BMP11writeHeaderEP4File+0x1e>

uint32_t BMP::writeHeader(File* file) {
	// lets first create some helpful variables
	uint16_t header_size = 40;
	uint32_t pixel_height = height * frames;
	uint8_t color_table = 0;
    b50a:	2600      	movs	r6, #0
	if (depth == 4) {
		color_table = 16;
	}
	if (depth == 32) {
    b50c:	2b20      	cmp	r3, #32
    b50e:	d101      	bne.n	b514 <_ZN14Gamebuino_Meta3BMP11writeHeaderEP4File+0x20>
    b510:	e003      	b.n	b51a <_ZN14Gamebuino_Meta3BMP11writeHeaderEP4File+0x26>
	// lets first create some helpful variables
	uint16_t header_size = 40;
	uint32_t pixel_height = height * frames;
	uint8_t color_table = 0;
	if (depth == 4) {
		color_table = 16;
    b512:	2610      	movs	r6, #16
	f_write32(bits, file);
}

uint32_t BMP::writeHeader(File* file) {
	// lets first create some helpful variables
	uint16_t header_size = 40;
    b514:	2328      	movs	r3, #40	; 0x28
    b516:	9300      	str	r3, [sp, #0]
    b518:	e001      	b.n	b51e <_ZN14Gamebuino_Meta3BMP11writeHeaderEP4File+0x2a>
	uint8_t color_table = 0;
	if (depth == 4) {
		color_table = 16;
	}
	if (depth == 32) {
		header_size = 124;
    b51a:	237c      	movs	r3, #124	; 0x7c
    b51c:	9300      	str	r3, [sp, #0]
	}
	image_offset = 14 + header_size + color_table * 4;
    b51e:	9b00      	ldr	r3, [sp, #0]
    b520:	00b7      	lsls	r7, r6, #2
    b522:	19df      	adds	r7, r3, r7
    b524:	370e      	adds	r7, #14
    b526:	b2ff      	uxtb	r7, r7
    b528:	70af      	strb	r7, [r5, #2]
	uint32_t image_size = getRowSize() * pixel_height;
    b52a:	1c28      	adds	r0, r5, #0
    b52c:	f7ff ffd1 	bl	b4d2 <_ZN14Gamebuino_Meta3BMP10getRowSizeEv>
    b530:	9b02      	ldr	r3, [sp, #8]
    b532:	2100      	movs	r1, #0
    b534:	4343      	muls	r3, r0
	uint32_t file_size = image_offset + image_size;
    b536:	18ff      	adds	r7, r7, r3
    b538:	9703      	str	r7, [sp, #12]
	
	
	file->rewind();
    b53a:	1c27      	adds	r7, r4, #0
    b53c:	3710      	adds	r7, #16
    b53e:	1c38      	adds	r0, r7, #0
	}
	if (depth == 32) {
		header_size = 124;
	}
	image_offset = 14 + header_size + color_table * 4;
	uint32_t image_size = getRowSize() * pixel_height;
    b540:	9301      	str	r3, [sp, #4]
    b542:	f001 fe25 	bl	d190 <_ZN7FatFile7seekSetEm>
   * \param[in] str Pointer to the string.
   * Use getWriteError to check for errors.
   * \return count of characters written for success or -1 for failure.
   */
  int write(const char* str) {
    return write(str, strlen(str));
    b546:	2202      	movs	r2, #2
    b548:	493f      	ldr	r1, [pc, #252]	; (b648 <_ZN14Gamebuino_Meta3BMP11writeHeaderEP4File+0x154>)
    b54a:	1c38      	adds	r0, r7, #0
    b54c:	f002 f8c8 	bl	d6e0 <_ZN7FatFile5writeEPKvj>
	uint32_t file_size = image_offset + image_size;
	
	
	file->rewind();
	file->write("BM"); // this actually is a BMP image
	f_write32(file_size, file);
    b550:	9803      	ldr	r0, [sp, #12]
    b552:	1c21      	adds	r1, r4, #0
    b554:	f001 f954 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
	f_write32(0, file); // creator bits
    b558:	2000      	movs	r0, #0
    b55a:	1c21      	adds	r1, r4, #0
    b55c:	f001 f950 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
	f_write32(image_offset, file);
    b560:	78a8      	ldrb	r0, [r5, #2]
    b562:	1c21      	adds	r1, r4, #0
    b564:	f001 f94c 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
	f_write32(header_size, file);
    b568:	9800      	ldr	r0, [sp, #0]
    b56a:	1c21      	adds	r1, r4, #0
    b56c:	f001 f948 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
	f_write32(width, file);
    b570:	8928      	ldrh	r0, [r5, #8]
    b572:	1c21      	adds	r1, r4, #0
    b574:	f001 f944 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
	f_write32(pixel_height, file);
    b578:	9802      	ldr	r0, [sp, #8]
    b57a:	1c21      	adds	r1, r4, #0
    b57c:	f001 f940 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
	f_write16(1, file); // number of panes must be 1
    b580:	2001      	movs	r0, #1
    b582:	1c21      	adds	r1, r4, #0
    b584:	f001 f945 	bl	c812 <_ZN14Gamebuino_Meta9f_write16EtP4File>
	f_write16(depth, file);
    b588:	7828      	ldrb	r0, [r5, #0]
    b58a:	1c21      	adds	r1, r4, #0
    b58c:	f001 f941 	bl	c812 <_ZN14Gamebuino_Meta9f_write16EtP4File>
	if (depth == 32) {
    b590:	782b      	ldrb	r3, [r5, #0]
    b592:	2b20      	cmp	r3, #32
    b594:	d104      	bne.n	b5a0 <_ZN14Gamebuino_Meta3BMP11writeHeaderEP4File+0xac>
		f_write32(3, file); // bitmask
    b596:	2003      	movs	r0, #3
    b598:	1c21      	adds	r1, r4, #0
    b59a:	f001 f931 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
    b59e:	e003      	b.n	b5a8 <_ZN14Gamebuino_Meta3BMP11writeHeaderEP4File+0xb4>
	} else {
		f_write32(0, file); // no compression
    b5a0:	2000      	movs	r0, #0
    b5a2:	1c21      	adds	r1, r4, #0
    b5a4:	f001 f92c 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
	}
	f_write32(image_size, file);
    b5a8:	9801      	ldr	r0, [sp, #4]
    b5aa:	1c21      	adds	r1, r4, #0
    b5ac:	f001 f928 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
	f_write32(0, file); // x pixels per meter horizontal
    b5b0:	2000      	movs	r0, #0
    b5b2:	1c21      	adds	r1, r4, #0
    b5b4:	f001 f924 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
	f_write32(0, file); // y pixels per meter vertically
    b5b8:	2000      	movs	r0, #0
    b5ba:	1c21      	adds	r1, r4, #0
    b5bc:	f001 f920 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
	f_write32(color_table, file);
    b5c0:	1c30      	adds	r0, r6, #0
    b5c2:	1c21      	adds	r1, r4, #0
    b5c4:	f001 f91c 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
	if (color_table) {
		f_write32(color_table, file); // important colors
    b5c8:	1c30      	adds	r0, r6, #0
    b5ca:	1c21      	adds	r1, r4, #0
	}
	f_write32(image_size, file);
	f_write32(0, file); // x pixels per meter horizontal
	f_write32(0, file); // y pixels per meter vertically
	f_write32(color_table, file);
	if (color_table) {
    b5cc:	2e00      	cmp	r6, #0
    b5ce:	d013      	beq.n	b5f8 <_ZN14Gamebuino_Meta3BMP11writeHeaderEP4File+0x104>
		f_write32(color_table, file); // important colors
    b5d0:	f001 f916 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
    b5d4:	2700      	movs	r7, #0
		for (uint8_t i = 0; i < color_table; i++) {
			writeAsRGB((uint16_t)Graphics::colorIndex[i], file);
    b5d6:	4b1d      	ldr	r3, [pc, #116]	; (b64c <_ZN14Gamebuino_Meta3BMP11writeHeaderEP4File+0x158>)
    b5d8:	007a      	lsls	r2, r7, #1
    b5da:	681b      	ldr	r3, [r3, #0]
    b5dc:	1c21      	adds	r1, r4, #0
    b5de:	5ad0      	ldrh	r0, [r2, r3]
    b5e0:	f7ff fe58 	bl	b294 <_ZN14Gamebuino_Meta10writeAsRGBEtP4File>
			file->write((uint8_t)0);
    b5e4:	6823      	ldr	r3, [r4, #0]
    b5e6:	1c20      	adds	r0, r4, #0
    b5e8:	681b      	ldr	r3, [r3, #0]
    b5ea:	2100      	movs	r1, #0
    b5ec:	3701      	adds	r7, #1
    b5ee:	4798      	blx	r3
	f_write32(0, file); // x pixels per meter horizontal
	f_write32(0, file); // y pixels per meter vertically
	f_write32(color_table, file);
	if (color_table) {
		f_write32(color_table, file); // important colors
		for (uint8_t i = 0; i < color_table; i++) {
    b5f0:	b2fb      	uxtb	r3, r7
    b5f2:	42b3      	cmp	r3, r6
    b5f4:	d3ef      	bcc.n	b5d6 <_ZN14Gamebuino_Meta3BMP11writeHeaderEP4File+0xe2>
    b5f6:	e001      	b.n	b5fc <_ZN14Gamebuino_Meta3BMP11writeHeaderEP4File+0x108>
			writeAsRGB((uint16_t)Graphics::colorIndex[i], file);
			file->write((uint8_t)0);
		}
	} else {
		f_write32(0, file); // no important colors
    b5f8:	f001 f902 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
	}
	if (depth == 32) {
    b5fc:	782b      	ldrb	r3, [r5, #0]
    b5fe:	2b20      	cmp	r3, #32
    b600:	d11f      	bne.n	b642 <_ZN14Gamebuino_Meta3BMP11writeHeaderEP4File+0x14e>
		f_write32(0x00FF0000, file); // R bitmask
    b602:	20ff      	movs	r0, #255	; 0xff
    b604:	0400      	lsls	r0, r0, #16
    b606:	1c21      	adds	r1, r4, #0
    b608:	f001 f8fa 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
		f_write32(0x0000FF00, file); // G bitmask
    b60c:	20ff      	movs	r0, #255	; 0xff
    b60e:	0200      	lsls	r0, r0, #8
    b610:	1c21      	adds	r1, r4, #0
    b612:	f001 f8f5 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
		f_write32(0x000000FF, file); // B bitmask
    b616:	20ff      	movs	r0, #255	; 0xff
    b618:	1c21      	adds	r1, r4, #0
    b61a:	f001 f8f1 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
		f_write32(0xFF000000, file); // alpha bitmask
    b61e:	20ff      	movs	r0, #255	; 0xff
    b620:	0600      	lsls	r0, r0, #24
    b622:	1c21      	adds	r1, r4, #0
    b624:	f001 f8ec 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
		f_write32(0x73524742, file); // color space sRGB
    b628:	4809      	ldr	r0, [pc, #36]	; (b650 <_ZN14Gamebuino_Meta3BMP11writeHeaderEP4File+0x15c>)
    b62a:	1c21      	adds	r1, r4, #0
    b62c:	f001 f8e8 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
    b630:	2510      	movs	r5, #16
    b632:	3d01      	subs	r5, #1
		for (uint8_t i = 0; i < ((0x24 / 4) + 3 + 4); i++) {
			f_write32(0, file); // unused stuff
    b634:	2000      	movs	r0, #0
    b636:	1c21      	adds	r1, r4, #0
    b638:	b2ed      	uxtb	r5, r5
    b63a:	f001 f8e1 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
		f_write32(0x00FF0000, file); // R bitmask
		f_write32(0x0000FF00, file); // G bitmask
		f_write32(0x000000FF, file); // B bitmask
		f_write32(0xFF000000, file); // alpha bitmask
		f_write32(0x73524742, file); // color space sRGB
		for (uint8_t i = 0; i < ((0x24 / 4) + 3 + 4); i++) {
    b63e:	2d00      	cmp	r5, #0
    b640:	d1f7      	bne.n	b632 <_ZN14Gamebuino_Meta3BMP11writeHeaderEP4File+0x13e>
			f_write32(0, file); // unused stuff
		}
	}
	return image_size;
}
    b642:	9801      	ldr	r0, [sp, #4]
    b644:	b005      	add	sp, #20
    b646:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b648:	000154c8 	.word	0x000154c8
    b64c:	20000050 	.word	0x20000050
    b650:	73524742 	.word	0x73524742

0000b654 <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File>:
		return (width * 3 + 3) & ~3;
	}
	return width * 4;
}

uint16_t BMP::readBuffer(uint16_t* buf, uint32_t offset, uint16_t transparentColor, File* file) {
    b654:	b5f0      	push	{r4, r5, r6, r7, lr}
    b656:	b08b      	sub	sp, #44	; 0x2c
    b658:	1c17      	adds	r7, r2, #0
    b65a:	1c04      	adds	r4, r0, #0
    b65c:	9301      	str	r3, [sp, #4]
    b65e:	9105      	str	r1, [sp, #20]
	
	uint32_t rowSize = getRowSize();
    b660:	f7ff ff37 	bl	b4d2 <_ZN14Gamebuino_Meta3BMP10getRowSizeEv>
		return (width * 3 + 3) & ~3;
	}
	return width * 4;
}

uint16_t BMP::readBuffer(uint16_t* buf, uint32_t offset, uint16_t transparentColor, File* file) {
    b664:	9d10      	ldr	r5, [sp, #64]	; 0x40
	
	uint32_t rowSize = getRowSize();
    b666:	1c06      	adds	r6, r0, #0
	file->seekSet(offset);
    b668:	1c29      	adds	r1, r5, #0
    b66a:	3110      	adds	r1, #16
    b66c:	9104      	str	r1, [sp, #16]
    b66e:	1c08      	adds	r0, r1, #0
    b670:	1c39      	adds	r1, r7, #0
    b672:	f001 fd8d 	bl	d190 <_ZN7FatFile7seekSetEm>
	if (depth == 4) {
    b676:	7822      	ldrb	r2, [r4, #0]
    b678:	8923      	ldrh	r3, [r4, #8]
    b67a:	2a04      	cmp	r2, #4
    b67c:	d133      	bne.n	b6e6 <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0x92>
		uint8_t dif = rowSize - ((width + 1) / 2);
    b67e:	3301      	adds	r3, #1
    b680:	105b      	asrs	r3, r3, #1
    b682:	1af6      	subs	r6, r6, r3
    b684:	b2f6      	uxtb	r6, r6
    b686:	9602      	str	r6, [sp, #8]
		
		for (uint16_t i = 0; i < height; i++) {
    b688:	2600      	movs	r6, #0
    b68a:	8963      	ldrh	r3, [r4, #10]
    b68c:	429e      	cmp	r6, r3
    b68e:	d228      	bcs.n	b6e2 <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0x8e>
			uint8_t* rambuffer = (uint8_t*)buf + (height - 1 - i) * ((width + 1) / 2);
    b690:	3b01      	subs	r3, #1
    b692:	1b9a      	subs	r2, r3, r6
    b694:	8923      	ldrh	r3, [r4, #8]
			
			
			for (uint16_t j = 0; j < (width + 1)/2; j++) {
    b696:	2700      	movs	r7, #0
	file->seekSet(offset);
	if (depth == 4) {
		uint8_t dif = rowSize - ((width + 1) / 2);
		
		for (uint16_t i = 0; i < height; i++) {
			uint8_t* rambuffer = (uint8_t*)buf + (height - 1 - i) * ((width + 1) / 2);
    b698:	3301      	adds	r3, #1
    b69a:	105b      	asrs	r3, r3, #1
    b69c:	4353      	muls	r3, r2
    b69e:	9a05      	ldr	r2, [sp, #20]
    b6a0:	18d3      	adds	r3, r2, r3
    b6a2:	9303      	str	r3, [sp, #12]
			
			
			for (uint16_t j = 0; j < (width + 1)/2; j++) {
    b6a4:	8923      	ldrh	r3, [r4, #8]
    b6a6:	3301      	adds	r3, #1
    b6a8:	105b      	asrs	r3, r3, #1
    b6aa:	429f      	cmp	r7, r3
    b6ac:	da12      	bge.n	b6d4 <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0x80>
				uint8_t b = file->read();
    b6ae:	682b      	ldr	r3, [r5, #0]
    b6b0:	1c28      	adds	r0, r5, #0
    b6b2:	68db      	ldr	r3, [r3, #12]
    b6b4:	4798      	blx	r3
				uint8_t u = b >> 4;
				uint8_t l = b & 0x0F;
				u = indexMap[u];
				l = indexMap[l];
    b6b6:	220f      	movs	r2, #15
    b6b8:	4002      	ands	r2, r0
			uint8_t* rambuffer = (uint8_t*)buf + (height - 1 - i) * ((width + 1) / 2);
			
			
			for (uint16_t j = 0; j < (width + 1)/2; j++) {
				uint8_t b = file->read();
				uint8_t u = b >> 4;
    b6ba:	b2c0      	uxtb	r0, r0
    b6bc:	1100      	asrs	r0, r0, #4
				uint8_t l = b & 0x0F;
				u = indexMap[u];
    b6be:	1820      	adds	r0, r4, r0
				l = indexMap[l];
				rambuffer[j] = (u << 4) | l;
    b6c0:	7b83      	ldrb	r3, [r0, #14]
			for (uint16_t j = 0; j < (width + 1)/2; j++) {
				uint8_t b = file->read();
				uint8_t u = b >> 4;
				uint8_t l = b & 0x0F;
				u = indexMap[u];
				l = indexMap[l];
    b6c2:	18a2      	adds	r2, r4, r2
				rambuffer[j] = (u << 4) | l;
    b6c4:	7b92      	ldrb	r2, [r2, #14]
    b6c6:	011b      	lsls	r3, r3, #4
    b6c8:	9903      	ldr	r1, [sp, #12]
    b6ca:	4313      	orrs	r3, r2
    b6cc:	55cb      	strb	r3, [r1, r7]
		
		for (uint16_t i = 0; i < height; i++) {
			uint8_t* rambuffer = (uint8_t*)buf + (height - 1 - i) * ((width + 1) / 2);
			
			
			for (uint16_t j = 0; j < (width + 1)/2; j++) {
    b6ce:	3701      	adds	r7, #1
    b6d0:	b2bf      	uxth	r7, r7
    b6d2:	e7e7      	b.n	b6a4 <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0x50>
				uint8_t l = b & 0x0F;
				u = indexMap[u];
				l = indexMap[l];
				rambuffer[j] = (u << 4) | l;
			}
			file->seekCur(dif);
    b6d4:	9804      	ldr	r0, [sp, #16]
    b6d6:	9902      	ldr	r1, [sp, #8]
	uint32_t rowSize = getRowSize();
	file->seekSet(offset);
	if (depth == 4) {
		uint8_t dif = rowSize - ((width + 1) / 2);
		
		for (uint16_t i = 0; i < height; i++) {
    b6d8:	3601      	adds	r6, #1
				uint8_t l = b & 0x0F;
				u = indexMap[u];
				l = indexMap[l];
				rambuffer[j] = (u << 4) | l;
			}
			file->seekCur(dif);
    b6da:	f7ff fdd5 	bl	b288 <_ZN7FatFile7seekCurEl>
	uint32_t rowSize = getRowSize();
	file->seekSet(offset);
	if (depth == 4) {
		uint8_t dif = rowSize - ((width + 1) / 2);
		
		for (uint16_t i = 0; i < height; i++) {
    b6de:	b2b6      	uxth	r6, r6
    b6e0:	e7d3      	b.n	b68a <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0x36>
			}
			file->seekCur(dif);
		}
	} else {
		uint8_t dif = rowSize - (width * 3);
		for (uint16_t i = 0; i < height; i++) {
    b6e2:	9801      	ldr	r0, [sp, #4]
    b6e4:	e070      	b.n	b7c8 <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0x174>
				rambuffer[j] = (u << 4) | l;
			}
			file->seekCur(dif);
		}
	} else {
		uint8_t dif = rowSize - (width * 3);
    b6e6:	009a      	lsls	r2, r3, #2
    b6e8:	1a9b      	subs	r3, r3, r2
    b6ea:	18f6      	adds	r6, r6, r3
    b6ec:	b2f6      	uxtb	r6, r6
		for (uint16_t i = 0; i < height; i++) {
    b6ee:	2200      	movs	r2, #0
				rambuffer[j] = (u << 4) | l;
			}
			file->seekCur(dif);
		}
	} else {
		uint8_t dif = rowSize - (width * 3);
    b6f0:	9606      	str	r6, [sp, #24]
		for (uint16_t i = 0; i < height; i++) {
    b6f2:	9202      	str	r2, [sp, #8]
    b6f4:	8963      	ldrh	r3, [r4, #10]
    b6f6:	9902      	ldr	r1, [sp, #8]
    b6f8:	4299      	cmp	r1, r3
    b6fa:	d2f2      	bcs.n	b6e2 <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0x8e>
			uint16_t* rambuffer = buf + (height - 1 - i) * width;
    b6fc:	9902      	ldr	r1, [sp, #8]
    b6fe:	8922      	ldrh	r2, [r4, #8]
    b700:	3b01      	subs	r3, #1
    b702:	1a5b      	subs	r3, r3, r1
    b704:	4353      	muls	r3, r2
    b706:	9a05      	ldr	r2, [sp, #20]
    b708:	005b      	lsls	r3, r3, #1
    b70a:	18d3      	adds	r3, r2, r3
    b70c:	9303      	str	r3, [sp, #12]
			
			for (uint16_t j = 0; j < width; j++) {
    b70e:	2700      	movs	r7, #0
    b710:	8922      	ldrh	r2, [r4, #8]
    b712:	7823      	ldrb	r3, [r4, #0]
    b714:	42ba      	cmp	r2, r7
    b716:	d94c      	bls.n	b7b2 <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0x15e>
				uint8_t c[4];
				if (depth == 24) {
    b718:	2600      	movs	r6, #0
    b71a:	2b18      	cmp	r3, #24
    b71c:	d112      	bne.n	b744 <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0xf0>
					c[2] = file->read();
    b71e:	682b      	ldr	r3, [r5, #0]
    b720:	1c28      	adds	r0, r5, #0
    b722:	68db      	ldr	r3, [r3, #12]
    b724:	4798      	blx	r3
					c[1] = file->read();
    b726:	682b      	ldr	r3, [r5, #0]
			uint16_t* rambuffer = buf + (height - 1 - i) * width;
			
			for (uint16_t j = 0; j < width; j++) {
				uint8_t c[4];
				if (depth == 24) {
					c[2] = file->read();
    b728:	ae09      	add	r6, sp, #36	; 0x24
    b72a:	70b0      	strb	r0, [r6, #2]
					c[1] = file->read();
    b72c:	68db      	ldr	r3, [r3, #12]
    b72e:	1c28      	adds	r0, r5, #0
    b730:	4798      	blx	r3
					c[0] = file->read();
    b732:	682b      	ldr	r3, [r5, #0]
			
			for (uint16_t j = 0; j < width; j++) {
				uint8_t c[4];
				if (depth == 24) {
					c[2] = file->read();
					c[1] = file->read();
    b734:	7070      	strb	r0, [r6, #1]
					c[0] = file->read();
    b736:	68db      	ldr	r3, [r3, #12]
    b738:	1c28      	adds	r0, r5, #0
    b73a:	4798      	blx	r3
					c[3] = 0xFF; // assume no transparency
    b73c:	23ff      	movs	r3, #255	; 0xff
			for (uint16_t j = 0; j < width; j++) {
				uint8_t c[4];
				if (depth == 24) {
					c[2] = file->read();
					c[1] = file->read();
					c[0] = file->read();
    b73e:	7030      	strb	r0, [r6, #0]
					c[3] = 0xFF; // assume no transparency
    b740:	70f3      	strb	r3, [r6, #3]
    b742:	e00c      	b.n	b75e <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0x10a>
    b744:	19a3      	adds	r3, r4, r6
				} else {
					for (uint8_t k = 0; k < 4; k++) {
						c[indexMap[k]] = file->read();
    b746:	7b9b      	ldrb	r3, [r3, #14]
    b748:	1c28      	adds	r0, r5, #0
    b74a:	9307      	str	r3, [sp, #28]
    b74c:	682b      	ldr	r3, [r5, #0]
    b74e:	3601      	adds	r6, #1
    b750:	68db      	ldr	r3, [r3, #12]
    b752:	4798      	blx	r3
    b754:	9907      	ldr	r1, [sp, #28]
    b756:	ab09      	add	r3, sp, #36	; 0x24
    b758:	5458      	strb	r0, [r3, r1]
					c[2] = file->read();
					c[1] = file->read();
					c[0] = file->read();
					c[3] = 0xFF; // assume no transparency
				} else {
					for (uint8_t k = 0; k < 4; k++) {
    b75a:	2e04      	cmp	r6, #4
    b75c:	d1f2      	bne.n	b744 <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0xf0>
						c[indexMap[k]] = file->read();
					}
				}
				
				if (c[3] > 0x80) {
    b75e:	ab09      	add	r3, sp, #36	; 0x24
    b760:	78da      	ldrb	r2, [r3, #3]
    b762:	2a80      	cmp	r2, #128	; 0x80
    b764:	d91a      	bls.n	b79c <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0x148>
					uint16_t col = rgb888Torgb565({c[0], c[1], c[2]});
    b766:	781a      	ldrb	r2, [r3, #0]
    b768:	a908      	add	r1, sp, #32
    b76a:	700a      	strb	r2, [r1, #0]
    b76c:	785a      	ldrb	r2, [r3, #1]
    b76e:	2121      	movs	r1, #33	; 0x21
    b770:	4469      	add	r1, sp
    b772:	700a      	strb	r2, [r1, #0]
    b774:	789b      	ldrb	r3, [r3, #2]
    b776:	2222      	movs	r2, #34	; 0x22
    b778:	446a      	add	r2, sp
    b77a:	7013      	strb	r3, [r2, #0]
    b77c:	9808      	ldr	r0, [sp, #32]
    b77e:	f001 f807 	bl	c790 <_ZN14Gamebuino_Meta14rgb888Torgb565ENS_6RGB888E>
					if (transparentColor && col == transparentColor) {
    b782:	9b01      	ldr	r3, [sp, #4]
    b784:	2b00      	cmp	r3, #0
    b786:	d005      	beq.n	b794 <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0x140>
    b788:	4298      	cmp	r0, r3
    b78a:	d103      	bne.n	b794 <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0x140>
						return transparentColor + 1;
    b78c:	1c18      	adds	r0, r3, #0
    b78e:	3001      	adds	r0, #1
    b790:	b280      	uxth	r0, r0
    b792:	e019      	b.n	b7c8 <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0x174>
					}
					rambuffer[j] = col;
    b794:	9903      	ldr	r1, [sp, #12]
    b796:	007b      	lsls	r3, r7, #1
    b798:	5258      	strh	r0, [r3, r1]
    b79a:	e005      	b.n	b7a8 <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0x154>
				} else {
					// ok we have a transparent pixel
					if (!transparentColor) {
    b79c:	9a01      	ldr	r2, [sp, #4]
    b79e:	2a00      	cmp	r2, #0
    b7a0:	d005      	beq.n	b7ae <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0x15a>
						return 1;
					}
					rambuffer[j] = transparentColor;
    b7a2:	9903      	ldr	r1, [sp, #12]
    b7a4:	007b      	lsls	r3, r7, #1
    b7a6:	525a      	strh	r2, [r3, r1]
	} else {
		uint8_t dif = rowSize - (width * 3);
		for (uint16_t i = 0; i < height; i++) {
			uint16_t* rambuffer = buf + (height - 1 - i) * width;
			
			for (uint16_t j = 0; j < width; j++) {
    b7a8:	1c7b      	adds	r3, r7, #1
    b7aa:	b29f      	uxth	r7, r3
    b7ac:	e7b0      	b.n	b710 <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0xbc>
					}
					rambuffer[j] = col;
				} else {
					// ok we have a transparent pixel
					if (!transparentColor) {
						return 1;
    b7ae:	2001      	movs	r0, #1
    b7b0:	e00a      	b.n	b7c8 <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0x174>
					}
					rambuffer[j] = transparentColor;
				}
			}
			if (depth != 32) { // 32-bit always has dif 0
    b7b2:	2b20      	cmp	r3, #32
    b7b4:	d003      	beq.n	b7be <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0x16a>
				file->seekCur(dif);
    b7b6:	9804      	ldr	r0, [sp, #16]
    b7b8:	9906      	ldr	r1, [sp, #24]
    b7ba:	f7ff fd65 	bl	b288 <_ZN7FatFile7seekCurEl>
			}
			file->seekCur(dif);
		}
	} else {
		uint8_t dif = rowSize - (width * 3);
		for (uint16_t i = 0; i < height; i++) {
    b7be:	9b02      	ldr	r3, [sp, #8]
    b7c0:	3301      	adds	r3, #1
    b7c2:	b29b      	uxth	r3, r3
    b7c4:	9302      	str	r3, [sp, #8]
    b7c6:	e795      	b.n	b6f4 <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File+0xa0>
				file->seekCur(dif);
			}
		}
	}
	return transparentColor;
}
    b7c8:	b00b      	add	sp, #44	; 0x2c
    b7ca:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000b7cc <_ZN14Gamebuino_Meta3BMP9readFrameEtPttP4File>:

uint16_t BMP::readFrame(uint16_t frame, uint16_t* buf, uint16_t transparentColor, File* file) {
    b7cc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    b7ce:	1c04      	adds	r4, r0, #0
    b7d0:	1c16      	adds	r6, r2, #0
    b7d2:	1c1d      	adds	r5, r3, #0
    b7d4:	1c0f      	adds	r7, r1, #0
	uint32_t size = getRowSize() * height;
    b7d6:	f7ff fe7c 	bl	b4d2 <_ZN14Gamebuino_Meta3BMP10getRowSizeEv>
	uint32_t offset = size * (frames - frame - 1);
    b7da:	89a2      	ldrh	r2, [r4, #12]
	return readBuffer(buf, image_offset + offset, transparentColor, file);
    b7dc:	78a3      	ldrb	r3, [r4, #2]
	return transparentColor;
}

uint16_t BMP::readFrame(uint16_t frame, uint16_t* buf, uint16_t transparentColor, File* file) {
	uint32_t size = getRowSize() * height;
	uint32_t offset = size * (frames - frame - 1);
    b7de:	1bd7      	subs	r7, r2, r7
	}
	return transparentColor;
}

uint16_t BMP::readFrame(uint16_t frame, uint16_t* buf, uint16_t transparentColor, File* file) {
	uint32_t size = getRowSize() * height;
    b7e0:	8962      	ldrh	r2, [r4, #10]
	uint32_t offset = size * (frames - frame - 1);
    b7e2:	3f01      	subs	r7, #1
	}
	return transparentColor;
}

uint16_t BMP::readFrame(uint16_t frame, uint16_t* buf, uint16_t transparentColor, File* file) {
	uint32_t size = getRowSize() * height;
    b7e4:	437a      	muls	r2, r7
	uint32_t offset = size * (frames - frame - 1);
    b7e6:	4342      	muls	r2, r0
	return readBuffer(buf, image_offset + offset, transparentColor, file);
    b7e8:	18d2      	adds	r2, r2, r3
    b7ea:	9b08      	ldr	r3, [sp, #32]
    b7ec:	1c31      	adds	r1, r6, #0
    b7ee:	9300      	str	r3, [sp, #0]
    b7f0:	1c20      	adds	r0, r4, #0
    b7f2:	1c2b      	adds	r3, r5, #0
    b7f4:	f7ff ff2e 	bl	b654 <_ZN14Gamebuino_Meta3BMP10readBufferEPtmtP4File>
}
    b7f8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0000b7fa <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File>:

void BMP::writeBuffer(uint16_t* buffer, uint16_t transparentColor, File* file) {
    b7fa:	b5f0      	push	{r4, r5, r6, r7, lr}
    b7fc:	1c1c      	adds	r4, r3, #0
    b7fe:	b087      	sub	sp, #28
	if (depth == 4) {
    b800:	7803      	ldrb	r3, [r0, #0]
	uint32_t size = getRowSize() * height;
	uint32_t offset = size * (frames - frame - 1);
	return readBuffer(buf, image_offset + offset, transparentColor, file);
}

void BMP::writeBuffer(uint16_t* buffer, uint16_t transparentColor, File* file) {
    b802:	9105      	str	r1, [sp, #20]
    b804:	9204      	str	r2, [sp, #16]
    b806:	1c05      	adds	r5, r0, #0
    b808:	8907      	ldrh	r7, [r0, #8]
    b80a:	8946      	ldrh	r6, [r0, #10]
	if (depth == 4) {
    b80c:	2b04      	cmp	r3, #4
    b80e:	d132      	bne.n	b876 <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File+0x7c>
		uint8_t halfwidth = (width + 1) / 2;
    b810:	3701      	adds	r7, #1
    b812:	107f      	asrs	r7, r7, #1
    b814:	b2f9      	uxtb	r1, r7
    b816:	9701      	str	r7, [sp, #4]
    b818:	9102      	str	r1, [sp, #8]
		uint8_t j = getRowSize() - halfwidth;
    b81a:	f7ff fe5a 	bl	b4d2 <_ZN14Gamebuino_Meta3BMP10getRowSizeEv>
    b81e:	9a02      	ldr	r2, [sp, #8]
		for (int8_t y = height - 1; y >= 0; y--) {
    b820:	3e01      	subs	r6, #1
}

void BMP::writeBuffer(uint16_t* buffer, uint16_t transparentColor, File* file) {
	if (depth == 4) {
		uint8_t halfwidth = (width + 1) / 2;
		uint8_t j = getRowSize() - halfwidth;
    b822:	1a80      	subs	r0, r0, r2
		for (int8_t y = height - 1; y >= 0; y--) {
    b824:	b2f6      	uxtb	r6, r6
}

void BMP::writeBuffer(uint16_t* buffer, uint16_t transparentColor, File* file) {
	if (depth == 4) {
		uint8_t halfwidth = (width + 1) / 2;
		uint8_t j = getRowSize() - halfwidth;
    b826:	b2c0      	uxtb	r0, r0
		for (int8_t y = height - 1; y >= 0; y--) {
    b828:	9604      	str	r6, [sp, #16]
}

void BMP::writeBuffer(uint16_t* buffer, uint16_t transparentColor, File* file) {
	if (depth == 4) {
		uint8_t halfwidth = (width + 1) / 2;
		uint8_t j = getRowSize() - halfwidth;
    b82a:	9003      	str	r0, [sp, #12]
		for (int8_t y = height - 1; y >= 0; y--) {
    b82c:	2600      	movs	r6, #0
    b82e:	9a04      	ldr	r2, [sp, #16]
    b830:	1b97      	subs	r7, r2, r6
    b832:	b27f      	sxtb	r7, r7
    b834:	2f00      	cmp	r7, #0
    b836:	db64      	blt.n	b902 <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File+0x108>
			uint8_t* buf = (uint8_t*)buffer + y*halfwidth;
    b838:	9901      	ldr	r1, [sp, #4]
    b83a:	9a05      	ldr	r2, [sp, #20]
    b83c:	b2cb      	uxtb	r3, r1
    b83e:	435f      	muls	r7, r3
    b840:	19d7      	adds	r7, r2, r7
			for (uint8_t x = 0; x < halfwidth; x++) {
    b842:	1c3d      	adds	r5, r7, #0
    b844:	1beb      	subs	r3, r5, r7
    b846:	9902      	ldr	r1, [sp, #8]
    b848:	b2db      	uxtb	r3, r3
    b84a:	428b      	cmp	r3, r1
    b84c:	d206      	bcs.n	b85c <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File+0x62>
				file->write(buf[x]);
    b84e:	6823      	ldr	r3, [r4, #0]
    b850:	7829      	ldrb	r1, [r5, #0]
    b852:	681b      	ldr	r3, [r3, #0]
    b854:	1c20      	adds	r0, r4, #0
    b856:	4798      	blx	r3
    b858:	3501      	adds	r5, #1
    b85a:	e7f3      	b.n	b844 <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File+0x4a>
	if (depth == 4) {
		uint8_t halfwidth = (width + 1) / 2;
		uint8_t j = getRowSize() - halfwidth;
		for (int8_t y = height - 1; y >= 0; y--) {
			uint8_t* buf = (uint8_t*)buffer + y*halfwidth;
			for (uint8_t x = 0; x < halfwidth; x++) {
    b85c:	9d03      	ldr	r5, [sp, #12]
				file->write(buf[x]);
			}
			uint8_t i = j;
			while (i--) {
    b85e:	2d00      	cmp	r5, #0
    b860:	d007      	beq.n	b872 <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File+0x78>
				// time to add padding
				file->write((uint8_t)0);
    b862:	6823      	ldr	r3, [r4, #0]
    b864:	1c20      	adds	r0, r4, #0
    b866:	681b      	ldr	r3, [r3, #0]
    b868:	2100      	movs	r1, #0
    b86a:	3d01      	subs	r5, #1
    b86c:	4798      	blx	r3
    b86e:	b2ed      	uxtb	r5, r5
    b870:	e7f5      	b.n	b85e <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File+0x64>
    b872:	3601      	adds	r6, #1
    b874:	e7db      	b.n	b82e <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File+0x34>
			}
		}
	} else {
		uint8_t j = getRowSize() - (3*width);
    b876:	f7ff fe2c 	bl	b4d2 <_ZN14Gamebuino_Meta3BMP10getRowSizeEv>
    b87a:	00bb      	lsls	r3, r7, #2
    b87c:	1aff      	subs	r7, r7, r3
    b87e:	19c7      	adds	r7, r0, r7
		for (int8_t y = height - 1; y >= 0; y--) {
    b880:	3e01      	subs	r6, #1
				// time to add padding
				file->write((uint8_t)0);
			}
		}
	} else {
		uint8_t j = getRowSize() - (3*width);
    b882:	b2ff      	uxtb	r7, r7
		for (int8_t y = height - 1; y >= 0; y--) {
    b884:	b2f6      	uxtb	r6, r6
				// time to add padding
				file->write((uint8_t)0);
			}
		}
	} else {
		uint8_t j = getRowSize() - (3*width);
    b886:	9701      	str	r7, [sp, #4]
		for (int8_t y = height - 1; y >= 0; y--) {
    b888:	9602      	str	r6, [sp, #8]
    b88a:	2700      	movs	r7, #0
    b88c:	9902      	ldr	r1, [sp, #8]
    b88e:	1bcb      	subs	r3, r1, r7
    b890:	b25b      	sxtb	r3, r3
    b892:	2b00      	cmp	r3, #0
    b894:	db35      	blt.n	b902 <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File+0x108>
			uint16_t* buf = buffer + (y*width);
    b896:	892a      	ldrh	r2, [r5, #8]
    b898:	9905      	ldr	r1, [sp, #20]
    b89a:	4353      	muls	r3, r2
    b89c:	005b      	lsls	r3, r3, #1
    b89e:	18cb      	adds	r3, r1, r3
    b8a0:	9303      	str	r3, [sp, #12]
			for (uint8_t x = 0; x < width; x++) {
    b8a2:	2600      	movs	r6, #0
    b8a4:	892a      	ldrh	r2, [r5, #8]
    b8a6:	782b      	ldrb	r3, [r5, #0]
    b8a8:	42b2      	cmp	r2, r6
    b8aa:	d91b      	bls.n	b8e4 <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File+0xea>
				uint16_t b = buf[x];
    b8ac:	9903      	ldr	r1, [sp, #12]
    b8ae:	0072      	lsls	r2, r6, #1
    b8b0:	5a50      	ldrh	r0, [r2, r1]
				if (depth == 24) {
    b8b2:	2b18      	cmp	r3, #24
    b8b4:	d103      	bne.n	b8be <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File+0xc4>
					writeAsRGB(b, file);
    b8b6:	1c21      	adds	r1, r4, #0
    b8b8:	f7ff fcec 	bl	b294 <_ZN14Gamebuino_Meta10writeAsRGBEtP4File>
    b8bc:	e00f      	b.n	b8de <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File+0xe4>
				} else if (b == transparentColor) {
    b8be:	9a04      	ldr	r2, [sp, #16]
    b8c0:	4290      	cmp	r0, r2
    b8c2:	d104      	bne.n	b8ce <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File+0xd4>
					f_write32(0x00000000, file);
    b8c4:	2000      	movs	r0, #0
    b8c6:	1c21      	adds	r1, r4, #0
    b8c8:	f000 ff9a 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
    b8cc:	e007      	b.n	b8de <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File+0xe4>
				} else {
					writeAsRGB(b, file);
    b8ce:	1c21      	adds	r1, r4, #0
    b8d0:	f7ff fce0 	bl	b294 <_ZN14Gamebuino_Meta10writeAsRGBEtP4File>
					file->write((uint8_t)0xFF);
    b8d4:	6823      	ldr	r3, [r4, #0]
    b8d6:	1c20      	adds	r0, r4, #0
    b8d8:	681b      	ldr	r3, [r3, #0]
    b8da:	21ff      	movs	r1, #255	; 0xff
    b8dc:	4798      	blx	r3
		}
	} else {
		uint8_t j = getRowSize() - (3*width);
		for (int8_t y = height - 1; y >= 0; y--) {
			uint16_t* buf = buffer + (y*width);
			for (uint8_t x = 0; x < width; x++) {
    b8de:	3601      	adds	r6, #1
    b8e0:	b2f6      	uxtb	r6, r6
    b8e2:	e7df      	b.n	b8a4 <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File+0xaa>
				} else {
					writeAsRGB(b, file);
					file->write((uint8_t)0xFF);
				}
			}
			if (depth == 24) {
    b8e4:	2b18      	cmp	r3, #24
    b8e6:	d10a      	bne.n	b8fe <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File+0x104>
    b8e8:	9e01      	ldr	r6, [sp, #4]
				uint8_t i = j;
				while (i--) {
    b8ea:	2e00      	cmp	r6, #0
    b8ec:	d007      	beq.n	b8fe <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File+0x104>
					// time to add padding
					file->write((uint8_t)0);
    b8ee:	6823      	ldr	r3, [r4, #0]
    b8f0:	1c20      	adds	r0, r4, #0
    b8f2:	681b      	ldr	r3, [r3, #0]
    b8f4:	2100      	movs	r1, #0
    b8f6:	3e01      	subs	r6, #1
    b8f8:	4798      	blx	r3
    b8fa:	b2f6      	uxtb	r6, r6
    b8fc:	e7f5      	b.n	b8ea <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File+0xf0>
    b8fe:	3701      	adds	r7, #1
    b900:	e7c4      	b.n	b88c <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File+0x92>
				}
			}
		}
	}
}
    b902:	b007      	add	sp, #28
    b904:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000b906 <_ZN14Gamebuino_Meta3BMP10writeFrameEtPttP4File>:

void BMP::writeFrame(uint16_t frame, uint16_t* buf, uint16_t transparentColor, File* file) {
    b906:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b908:	1c04      	adds	r4, r0, #0
    b90a:	1c16      	adds	r6, r2, #0
    b90c:	1c1d      	adds	r5, r3, #0
    b90e:	1c0f      	adds	r7, r1, #0
	uint32_t size = getRowSize() * height;
    b910:	f7ff fddf 	bl	b4d2 <_ZN14Gamebuino_Meta3BMP10getRowSizeEv>
	uint32_t offset = size * (frames - frame - 1);
    b914:	89a1      	ldrh	r1, [r4, #12]
	file->seekSet(image_offset + offset);
    b916:	9b06      	ldr	r3, [sp, #24]
	}
}

void BMP::writeFrame(uint16_t frame, uint16_t* buf, uint16_t transparentColor, File* file) {
	uint32_t size = getRowSize() * height;
	uint32_t offset = size * (frames - frame - 1);
    b918:	1bcf      	subs	r7, r1, r7
		}
	}
}

void BMP::writeFrame(uint16_t frame, uint16_t* buf, uint16_t transparentColor, File* file) {
	uint32_t size = getRowSize() * height;
    b91a:	8961      	ldrh	r1, [r4, #10]
	uint32_t offset = size * (frames - frame - 1);
    b91c:	3f01      	subs	r7, #1
		}
	}
}

void BMP::writeFrame(uint16_t frame, uint16_t* buf, uint16_t transparentColor, File* file) {
	uint32_t size = getRowSize() * height;
    b91e:	4379      	muls	r1, r7
	uint32_t offset = size * (frames - frame - 1);
    b920:	4341      	muls	r1, r0
	file->seekSet(image_offset + offset);
    b922:	78a2      	ldrb	r2, [r4, #2]
    b924:	3310      	adds	r3, #16
    b926:	1889      	adds	r1, r1, r2
    b928:	1c18      	adds	r0, r3, #0
    b92a:	f001 fc31 	bl	d190 <_ZN7FatFile7seekSetEm>
	writeBuffer(buf, transparentColor, file);
    b92e:	1c31      	adds	r1, r6, #0
    b930:	1c2a      	adds	r2, r5, #0
    b932:	1c20      	adds	r0, r4, #0
    b934:	9b06      	ldr	r3, [sp, #24]
    b936:	f7ff ff60 	bl	b7fa <_ZN14Gamebuino_Meta3BMP11writeBufferEPttP4File>
}
    b93a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000b93c <_ZN7FatFile4readEv>:
  /** Read the next byte from a file.
   *
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    b93c:	b513      	push	{r0, r1, r4, lr}
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    b93e:	466c      	mov	r4, sp
    b940:	3407      	adds	r4, #7
    b942:	1c21      	adds	r1, r4, #0
    b944:	2201      	movs	r2, #1
    b946:	f001 fb2f 	bl	cfa8 <_ZN7FatFile4readEPvj>
    b94a:	2801      	cmp	r0, #1
    b94c:	d101      	bne.n	b952 <_ZN7FatFile4readEv+0x16>
    b94e:	7820      	ldrb	r0, [r4, #0]
    b950:	e001      	b.n	b956 <_ZN7FatFile4readEv+0x1a>
    b952:	2001      	movs	r0, #1
    b954:	4240      	negs	r0, r0
  }
    b956:	bd16      	pop	{r1, r2, r4, pc}

0000b958 <_ZN14Gamebuino_Meta3GMVC1Ev>:

#include <Gamebuino-Meta.h>

namespace Gamebuino_Meta {

GMV::GMV() {
    b958:	b510      	push	{r4, lr}
    b95a:	1c04      	adds	r4, r0, #0
    b95c:	f7fa f9ea 	bl	5d34 <_ZN4FileC1Ev>
	valid = false;
    b960:	1c23      	adds	r3, r4, #0
    b962:	3338      	adds	r3, #56	; 0x38
    b964:	2200      	movs	r2, #0
}
    b966:	1c20      	adds	r0, r4, #0
#include <Gamebuino-Meta.h>

namespace Gamebuino_Meta {

GMV::GMV() {
	valid = false;
    b968:	701a      	strb	r2, [r3, #0]
}
    b96a:	bd10      	pop	{r4, pc}

0000b96c <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageE>:

GMV::GMV(Image* _img) {
    b96c:	b538      	push	{r3, r4, r5, lr}
    b96e:	1c04      	adds	r4, r0, #0
    b970:	1c0d      	adds	r5, r1, #0
    b972:	f7fa f9df 	bl	5d34 <_ZN4FileC1Ev>
	img = _img;
    b976:	6365      	str	r5, [r4, #52]	; 0x34
}
    b978:	1c20      	adds	r0, r4, #0
    b97a:	bd38      	pop	{r3, r4, r5, pc}

0000b97c <_ZN14Gamebuino_Meta3GMV7isValidEv>:
	
	valid = true;
}

bool GMV::isValid() {
	return valid;
    b97c:	3038      	adds	r0, #56	; 0x38
    b97e:	7800      	ldrb	r0, [r0, #0]
}
    b980:	4770      	bx	lr

0000b982 <_ZN14Gamebuino_Meta3GMV2isEPNS_5ImageE>:

bool GMV::is(Image* _img) {
	return img == _img;
    b982:	6b40      	ldr	r0, [r0, #52]	; 0x34
    b984:	1a40      	subs	r0, r0, r1
    b986:	4243      	negs	r3, r0
    b988:	4158      	adcs	r0, r3
    b98a:	b2c0      	uxtb	r0, r0
}
    b98c:	4770      	bx	lr
	...

0000b990 <_ZN14Gamebuino_Meta3GMV10writeColorEP4Fileth>:

void GMV::writeFrame() {
	writeFrame(&file);
}

void GMV::writeColor(File* f, uint16_t color, uint8_t count) {
    b990:	b570      	push	{r4, r5, r6, lr}
    b992:	1c06      	adds	r6, r0, #0
    b994:	1c0c      	adds	r4, r1, #0
    b996:	1c15      	adds	r5, r2, #0
	if (count > 1) {
    b998:	2b01      	cmp	r3, #1
    b99a:	d905      	bls.n	b9a8 <_ZN14Gamebuino_Meta3GMV10writeColorEP4Fileth+0x18>
		count |= 0x80;
		f->write(count);
    b99c:	680a      	ldr	r2, [r1, #0]
	writeFrame(&file);
}

void GMV::writeColor(File* f, uint16_t color, uint8_t count) {
	if (count > 1) {
		count |= 0x80;
    b99e:	2180      	movs	r1, #128	; 0x80
		f->write(count);
    b9a0:	4319      	orrs	r1, r3
    b9a2:	6812      	ldr	r2, [r2, #0]
    b9a4:	1c20      	adds	r0, r4, #0
    b9a6:	4790      	blx	r2
	}
	if (img->transparentColor && color == img->transparentColor) {
    b9a8:	6b73      	ldr	r3, [r6, #52]	; 0x34
    b9aa:	891b      	ldrh	r3, [r3, #8]
    b9ac:	2b00      	cmp	r3, #0
    b9ae:	d007      	beq.n	b9c0 <_ZN14Gamebuino_Meta3GMV10writeColorEP4Fileth+0x30>
    b9b0:	429d      	cmp	r5, r3
    b9b2:	d105      	bne.n	b9c0 <_ZN14Gamebuino_Meta3GMV10writeColorEP4Fileth+0x30>
		f->write((uint8_t)0x7F);
    b9b4:	6823      	ldr	r3, [r4, #0]
    b9b6:	1c20      	adds	r0, r4, #0
    b9b8:	681b      	ldr	r3, [r3, #0]
    b9ba:	217f      	movs	r1, #127	; 0x7f
    b9bc:	4798      	blx	r3
		return;
    b9be:	e018      	b.n	b9f2 <_ZN14Gamebuino_Meta3GMV10writeColorEP4Fileth+0x62>
	}
	uint16_t* index = (uint16_t*)img->colorIndex;
    b9c0:	4b0c      	ldr	r3, [pc, #48]	; (b9f4 <_ZN14Gamebuino_Meta3GMV10writeColorEP4Fileth+0x64>)
    b9c2:	681a      	ldr	r2, [r3, #0]
    b9c4:	2300      	movs	r3, #0
    b9c6:	0058      	lsls	r0, r3, #1
	for (uint8_t i = 0; i < 16; i++) {
		if (index[i] == color) {
    b9c8:	5a10      	ldrh	r0, [r2, r0]
    b9ca:	b2d9      	uxtb	r1, r3
    b9cc:	42a8      	cmp	r0, r5
    b9ce:	d104      	bne.n	b9da <_ZN14Gamebuino_Meta3GMV10writeColorEP4Fileth+0x4a>
			f->write(i);
    b9d0:	6823      	ldr	r3, [r4, #0]
    b9d2:	1c20      	adds	r0, r4, #0
    b9d4:	681b      	ldr	r3, [r3, #0]
    b9d6:	4798      	blx	r3
			return;
    b9d8:	e00b      	b.n	b9f2 <_ZN14Gamebuino_Meta3GMV10writeColorEP4Fileth+0x62>
    b9da:	3301      	adds	r3, #1
	if (img->transparentColor && color == img->transparentColor) {
		f->write((uint8_t)0x7F);
		return;
	}
	uint16_t* index = (uint16_t*)img->colorIndex;
	for (uint8_t i = 0; i < 16; i++) {
    b9dc:	2b10      	cmp	r3, #16
    b9de:	d1f2      	bne.n	b9c6 <_ZN14Gamebuino_Meta3GMV10writeColorEP4Fileth+0x36>
		if (index[i] == color) {
			f->write(i);
			return;
		}
	}
	f->write(0x80);
    b9e0:	6823      	ldr	r3, [r4, #0]
    b9e2:	2180      	movs	r1, #128	; 0x80
    b9e4:	681b      	ldr	r3, [r3, #0]
    b9e6:	1c20      	adds	r0, r4, #0
    b9e8:	4798      	blx	r3
	f_write16(color, f);
    b9ea:	1c28      	adds	r0, r5, #0
    b9ec:	1c21      	adds	r1, r4, #0
    b9ee:	f000 ff10 	bl	c812 <_ZN14Gamebuino_Meta9f_write16EtP4File>
}
    b9f2:	bd70      	pop	{r4, r5, r6, pc}
    b9f4:	20000050 	.word	0x20000050

0000b9f8 <_ZN14Gamebuino_Meta3GMV11writeHeaderEP4File>:

void GMV::writeHeader(File* f) {
    b9f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	f->rewind();
    b9fa:	1c0e      	adds	r6, r1, #0
    b9fc:	3610      	adds	r6, #16
	}
	f->write(0x80);
	f_write16(color, f);
}

void GMV::writeHeader(File* f) {
    b9fe:	1c0c      	adds	r4, r1, #0
    ba00:	1c05      	adds	r5, r0, #0
   * the value false is returned for failure.
   */
  static bool remove(FatFile* dirFile, const char* path);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    ba02:	2100      	movs	r1, #0
    ba04:	1c30      	adds	r0, r6, #0
    ba06:	f001 fbc3 	bl	d190 <_ZN7FatFile7seekSetEm>
	f->rewind();
	f_write16(0x5647, f); // header "GV"
    ba0a:	4826      	ldr	r0, [pc, #152]	; (baa4 <_ZN14Gamebuino_Meta3GMV11writeHeaderEP4File+0xac>)
    ba0c:	1c21      	adds	r1, r4, #0
    ba0e:	f000 ff00 	bl	c812 <_ZN14Gamebuino_Meta9f_write16EtP4File>
	f_write16(0, f); // header size, fill in later
    ba12:	2000      	movs	r0, #0
    ba14:	1c21      	adds	r1, r4, #0
    ba16:	f000 fefc 	bl	c812 <_ZN14Gamebuino_Meta9f_write16EtP4File>
	f->write((uint8_t)0); // version
    ba1a:	6823      	ldr	r3, [r4, #0]
    ba1c:	2100      	movs	r1, #0
    ba1e:	681b      	ldr	r3, [r3, #0]
    ba20:	1c20      	adds	r0, r4, #0
    ba22:	4798      	blx	r3
	f_write16(img->_width, f); // image width
    ba24:	6b6a      	ldr	r2, [r5, #52]	; 0x34
    ba26:	1c21      	adds	r1, r4, #0
    ba28:	8a10      	ldrh	r0, [r2, #16]
    ba2a:	f000 fef2 	bl	c812 <_ZN14Gamebuino_Meta9f_write16EtP4File>
	f_write16(img->_height, f); // image height
    ba2e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
    ba30:	1c21      	adds	r1, r4, #0
    ba32:	8a58      	ldrh	r0, [r3, #18]
    ba34:	f000 feed 	bl	c812 <_ZN14Gamebuino_Meta9f_write16EtP4File>
	f_write16(img->frames, f); // number of frames
    ba38:	6b6a      	ldr	r2, [r5, #52]	; 0x34
    ba3a:	1c21      	adds	r1, r4, #0
    ba3c:	8b10      	ldrh	r0, [r2, #24]
    ba3e:	f000 fee8 	bl	c812 <_ZN14Gamebuino_Meta9f_write16EtP4File>
	bool indexed = img->colorMode == ColorMode::index;
    ba42:	6b6b      	ldr	r3, [r5, #52]	; 0x34
	f->write(indexed ? 1 : 0); // indexed?
    ba44:	1c20      	adds	r0, r4, #0
	f_write16(0, f); // header size, fill in later
	f->write((uint8_t)0); // version
	f_write16(img->_width, f); // image width
	f_write16(img->_height, f); // image height
	f_write16(img->frames, f); // number of frames
	bool indexed = img->colorMode == ColorMode::index;
    ba46:	7a9f      	ldrb	r7, [r3, #10]
    ba48:	3f01      	subs	r7, #1
    ba4a:	427b      	negs	r3, r7
    ba4c:	415f      	adcs	r7, r3
	f->write(indexed ? 1 : 0); // indexed?
    ba4e:	6823      	ldr	r3, [r4, #0]
	f_write16(0, f); // header size, fill in later
	f->write((uint8_t)0); // version
	f_write16(img->_width, f); // image width
	f_write16(img->_height, f); // image height
	f_write16(img->frames, f); // number of frames
	bool indexed = img->colorMode == ColorMode::index;
    ba50:	b2ff      	uxtb	r7, r7
	f->write(indexed ? 1 : 0); // indexed?
    ba52:	681b      	ldr	r3, [r3, #0]
    ba54:	1c39      	adds	r1, r7, #0
    ba56:	4798      	blx	r3
    ba58:	6b6b      	ldr	r3, [r5, #52]	; 0x34
	// write the transparent color!
	if (indexed) {
    ba5a:	2f00      	cmp	r7, #0
    ba5c:	d00b      	beq.n	ba76 <_ZN14Gamebuino_Meta3GMV11writeHeaderEP4File+0x7e>
		f->write(img->transparentColorIndex);
    ba5e:	6822      	ldr	r2, [r4, #0]
    ba60:	7a19      	ldrb	r1, [r3, #8]
    ba62:	1c20      	adds	r0, r4, #0
    ba64:	6813      	ldr	r3, [r2, #0]
    ba66:	4798      	blx	r3
		f->write((uint8_t)img->useTransparentIndex);
    ba68:	6823      	ldr	r3, [r4, #0]
    ba6a:	6b6a      	ldr	r2, [r5, #52]	; 0x34
    ba6c:	681b      	ldr	r3, [r3, #0]
    ba6e:	7a51      	ldrb	r1, [r2, #9]
    ba70:	1c20      	adds	r0, r4, #0
    ba72:	4798      	blx	r3
    ba74:	e003      	b.n	ba7e <_ZN14Gamebuino_Meta3GMV11writeHeaderEP4File+0x86>
	} else {
		f_write16(img->transparentColor, f);
    ba76:	8918      	ldrh	r0, [r3, #8]
    ba78:	1c21      	adds	r1, r4, #0
    ba7a:	f000 feca 	bl	c812 <_ZN14Gamebuino_Meta9f_write16EtP4File>
	}
	header_size = 14; // currently it is still all static
    ba7e:	230e      	movs	r3, #14
    ba80:	876b      	strh	r3, [r5, #58]	; 0x3a
	f->seekSet(2);
    ba82:	1c30      	adds	r0, r6, #0
    ba84:	2102      	movs	r1, #2
    ba86:	f001 fb83 	bl	d190 <_ZN7FatFile7seekSetEm>
	f_write16(header_size, f); // fill in header size!
    ba8a:	8f68      	ldrh	r0, [r5, #58]	; 0x3a
    ba8c:	1c21      	adds	r1, r4, #0
    ba8e:	f000 fec0 	bl	c812 <_ZN14Gamebuino_Meta9f_write16EtP4File>
	f->flush();
    ba92:	6823      	ldr	r3, [r4, #0]
    ba94:	1c20      	adds	r0, r4, #0
    ba96:	695b      	ldr	r3, [r3, #20]
    ba98:	4798      	blx	r3
	f->seekSet(header_size);
    ba9a:	8f69      	ldrh	r1, [r5, #58]	; 0x3a
    ba9c:	1c30      	adds	r0, r6, #0
    ba9e:	f001 fb77 	bl	d190 <_ZN7FatFile7seekSetEm>
}
    baa2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    baa4:	00005647 	.word	0x00005647

0000baa8 <_ZN14Gamebuino_Meta3GMV11writeHeaderEv>:
	}
	bmp.setCreatorBits(CONVERT_MAGIC, &file);
	f.close();
}

void GMV::writeHeader() {
    baa8:	b508      	push	{r3, lr}
    baaa:	1c01      	adds	r1, r0, #0
	writeHeader(&file);
    baac:	f7ff ffa4 	bl	b9f8 <_ZN14Gamebuino_Meta3GMV11writeHeaderEP4File>
}
    bab0:	bd08      	pop	{r3, pc}
	...

0000bab4 <_ZN14Gamebuino_Meta3GMV8initSaveEPc>:

bool GMV::is(Image* _img) {
	return img == _img;
}

bool GMV::initSave(char* filename) {
    bab4:	b5f0      	push	{r4, r5, r6, r7, lr}
    bab6:	b091      	sub	sp, #68	; 0x44
    bab8:	af00      	add	r7, sp, #0
    baba:	1c04      	adds	r4, r0, #0
	// make sure our file ends in .GMV
	uint16_t name_len = strlen(filename);
    babc:	1c08      	adds	r0, r1, #0

bool GMV::is(Image* _img) {
	return img == _img;
}

bool GMV::initSave(char* filename) {
    babe:	1c0e      	adds	r6, r1, #0
	// make sure our file ends in .GMV
	uint16_t name_len = strlen(filename);
    bac0:	f005 feac 	bl	1181c <strlen>
    bac4:	b285      	uxth	r5, r0
	char _filename[name_len + 1];
    bac6:	1c2b      	adds	r3, r5, #0
    bac8:	3308      	adds	r3, #8
    baca:	08db      	lsrs	r3, r3, #3
    bacc:	00db      	lsls	r3, r3, #3
    bace:	4668      	mov	r0, sp
    bad0:	1ac0      	subs	r0, r0, r3
    bad2:	4685      	mov	sp, r0
    bad4:	466a      	mov	r2, sp
	strcpy(_filename, filename);
    bad6:	1c31      	adds	r1, r6, #0
}

bool GMV::initSave(char* filename) {
	// make sure our file ends in .GMV
	uint16_t name_len = strlen(filename);
	char _filename[name_len + 1];
    bad8:	607a      	str	r2, [r7, #4]
	strcpy(_filename, filename);
    bada:	f005 fe97 	bl	1180c <strcpy>
	
	_filename[name_len - 4] = '.';
    bade:	4668      	mov	r0, sp
    bae0:	1943      	adds	r3, r0, r5
    bae2:	1f1a      	subs	r2, r3, #4
    bae4:	212e      	movs	r1, #46	; 0x2e
    bae6:	7011      	strb	r1, [r2, #0]
	_filename[name_len - 3] = 'G';
    bae8:	1eda      	subs	r2, r3, #3
    baea:	2147      	movs	r1, #71	; 0x47
    baec:	7011      	strb	r1, [r2, #0]
	_filename[name_len - 2] = 'M';
    baee:	1e9a      	subs	r2, r3, #2
    baf0:	214d      	movs	r1, #77	; 0x4d
    baf2:	7011      	strb	r1, [r2, #0]
	_filename[name_len - 1] = 'V';
    baf4:	3b01      	subs	r3, #1
	_filename[name_len] = '\0';
    baf6:	6879      	ldr	r1, [r7, #4]
	strcpy(_filename, filename);
	
	_filename[name_len - 4] = '.';
	_filename[name_len - 3] = 'G';
	_filename[name_len - 2] = 'M';
	_filename[name_len - 1] = 'V';
    baf8:	2256      	movs	r2, #86	; 0x56
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return vwd()->exists(path);
    bafa:	4e1b      	ldr	r6, [pc, #108]	; (bb68 <_ZN14Gamebuino_Meta3GMV8initSaveEPc+0xb4>)
    bafc:	701a      	strb	r2, [r3, #0]
	_filename[name_len] = '\0';
    bafe:	2300      	movs	r3, #0
    bb00:	554b      	strb	r3, [r1, r5]
    bb02:	1c30      	adds	r0, r6, #0
    bb04:	4669      	mov	r1, sp
    bb06:	f7fa f8fa 	bl	5cfe <_ZN7FatFile6existsEPKc>
	if (SD.exists(_filename) && !SD.remove(_filename)) {
    bb0a:	2800      	cmp	r0, #0
    bb0c:	d007      	beq.n	bb1e <_ZN14Gamebuino_Meta3GMV8initSaveEPc+0x6a>
  *
  * \return The value true is returned for success and
  * the value false is returned for failure.
  */
  bool remove(const char* path) {
    return FatFile::remove(vwd(), path);
    bb0e:	1c30      	adds	r0, r6, #0
    bb10:	4669      	mov	r1, sp
    bb12:	f001 fcc7 	bl	d4a4 <_ZN7FatFile6removeEPS_PKc>
    bb16:	2800      	cmp	r0, #0
    bb18:	d101      	bne.n	bb1e <_ZN14Gamebuino_Meta3GMV8initSaveEPc+0x6a>
		return false;
    bb1a:	2000      	movs	r0, #0
    bb1c:	e020      	b.n	bb60 <_ZN14Gamebuino_Meta3GMV8initSaveEPc+0xac>
   * \param[in] path location of file to be opened.
   * \param[in] mode open mode flags.
   * \return a File object.
   */
  File open(const char *path, uint8_t mode = FILE_READ) {
    File tmpFile;
    bb1e:	1c38      	adds	r0, r7, #0
    tmpFile.open(vwd(), path, mode);
    bb20:	1c3d      	adds	r5, r7, #0
    bb22:	351c      	adds	r5, #28
   * \param[in] path location of file to be opened.
   * \param[in] mode open mode flags.
   * \return a File object.
   */
  File open(const char *path, uint8_t mode = FILE_READ) {
    File tmpFile;
    bb24:	300c      	adds	r0, #12
    bb26:	f7fa f905 	bl	5d34 <_ZN4FileC1Ev>
    tmpFile.open(vwd(), path, mode);
    bb2a:	687a      	ldr	r2, [r7, #4]
    bb2c:	1c31      	adds	r1, r6, #0
    bb2e:	1c28      	adds	r0, r5, #0
    bb30:	2363      	movs	r3, #99	; 0x63
    bb32:	f001 fc68 	bl	d406 <_ZN7FatFile4openEPS_PKch>
/**
 * \class File
 * \brief Arduino SD.h style File API
 */
#if ARDUINO_FILE_USES_STREAM
class File : public FatFile, public Stream {
    bb36:	1c23      	adds	r3, r4, #0
    bb38:	3310      	adds	r3, #16
    bb3a:	cd07      	ldmia	r5!, {r0, r1, r2}
    bb3c:	c307      	stmia	r3!, {r0, r1, r2}
    bb3e:	cd07      	ldmia	r5!, {r0, r1, r2}
    bb40:	c307      	stmia	r3!, {r0, r1, r2}
    bb42:	cd07      	ldmia	r5!, {r0, r1, r2}
    bb44:	c307      	stmia	r3!, {r0, r1, r2}
    bb46:	697b      	ldr	r3, [r7, #20]
#define DEC 10
#define HEX 16
#define OCT 8
#define BIN 2

class Print
    bb48:	693a      	ldr	r2, [r7, #16]
    bb4a:	60a3      	str	r3, [r4, #8]
    bb4c:	69b8      	ldr	r0, [r7, #24]
	}
	file = SD.open(_filename, FILE_WRITE);
	if (!file) {
    bb4e:	7c23      	ldrb	r3, [r4, #16]
    bb50:	6062      	str	r2, [r4, #4]
    bb52:	60e0      	str	r0, [r4, #12]
    bb54:	2b00      	cmp	r3, #0
    bb56:	d0e0      	beq.n	bb1a <_ZN14Gamebuino_Meta3GMV8initSaveEPc+0x66>
		return false;
	}
	writeHeader();
    bb58:	1c20      	adds	r0, r4, #0
    bb5a:	f7ff ffa5 	bl	baa8 <_ZN14Gamebuino_Meta3GMV11writeHeaderEv>
	return true;
    bb5e:	2001      	movs	r0, #1
}
    bb60:	46bd      	mov	sp, r7
    bb62:	b011      	add	sp, #68	; 0x44
    bb64:	bdf0      	pop	{r4, r5, r6, r7, pc}
    bb66:	46c0      	nop			; (mov r8, r8)
    bb68:	20000a04 	.word	0x20000a04

0000bb6c <_ZN14Gamebuino_Meta3GMV10writeFrameEP4File>:
	f_write16(header_size, f); // fill in header size!
	f->flush();
	f->seekSet(header_size);
}

void GMV::writeFrame(File* f) {
    bb6c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    bb6e:	1c06      	adds	r6, r0, #0
	if (img->colorMode == ColorMode::index) {
    bb70:	6b40      	ldr	r0, [r0, #52]	; 0x34
	f_write16(header_size, f); // fill in header size!
	f->flush();
	f->seekSet(header_size);
}

void GMV::writeFrame(File* f) {
    bb72:	1c0c      	adds	r4, r1, #0
	if (img->colorMode == ColorMode::index) {
    bb74:	7a81      	ldrb	r1, [r0, #10]
    bb76:	6945      	ldr	r5, [r0, #20]
    bb78:	9100      	str	r1, [sp, #0]
    bb7a:	2901      	cmp	r1, #1
    bb7c:	d12d      	bne.n	bbda <_ZN14Gamebuino_Meta3GMV10writeFrameEP4File+0x6e>
		uint8_t* buf = (uint8_t*)img->_buffer;
		uint16_t bytes = img->getBufferSize();
    bb7e:	f7ff f8df 	bl	ad40 <_ZN14Gamebuino_Meta5Image13getBufferSizeEv>
		uint16_t i = 1;
		uint8_t b = buf[0];
    bb82:	782f      	ldrb	r7, [r5, #0]
		uint16_t count = 1;
    bb84:	9900      	ldr	r1, [sp, #0]
}

void GMV::writeFrame(File* f) {
	if (img->colorMode == ColorMode::index) {
		uint8_t* buf = (uint8_t*)img->_buffer;
		uint16_t bytes = img->getBufferSize();
    bb86:	9001      	str	r0, [sp, #4]
		uint16_t i = 1;
		uint8_t b = buf[0];
		uint16_t count = 1;
		for (; i < bytes; i++) {
    bb88:	1c2e      	adds	r6, r5, #0
    bb8a:	1b73      	subs	r3, r6, r5
    bb8c:	3301      	adds	r3, #1
    bb8e:	9a01      	ldr	r2, [sp, #4]
    bb90:	b29b      	uxth	r3, r3
    bb92:	4293      	cmp	r3, r2
    bb94:	d216      	bcs.n	bbc4 <_ZN14Gamebuino_Meta3GMV10writeFrameEP4File+0x58>
			if (buf[i] == b && count < 0xFF) {
    bb96:	7873      	ldrb	r3, [r6, #1]
    bb98:	42bb      	cmp	r3, r7
    bb9a:	d104      	bne.n	bba6 <_ZN14Gamebuino_Meta3GMV10writeFrameEP4File+0x3a>
    bb9c:	29fe      	cmp	r1, #254	; 0xfe
    bb9e:	d802      	bhi.n	bba6 <_ZN14Gamebuino_Meta3GMV10writeFrameEP4File+0x3a>
				count++;
    bba0:	3101      	adds	r1, #1
    bba2:	b289      	uxth	r1, r1
				continue;
    bba4:	e00b      	b.n	bbbe <_ZN14Gamebuino_Meta3GMV10writeFrameEP4File+0x52>
			}
			f->write(count);
    bba6:	6823      	ldr	r3, [r4, #0]
    bba8:	b2c9      	uxtb	r1, r1
    bbaa:	681b      	ldr	r3, [r3, #0]
    bbac:	1c20      	adds	r0, r4, #0
    bbae:	4798      	blx	r3
			f->write(b);
    bbb0:	6823      	ldr	r3, [r4, #0]
    bbb2:	1c39      	adds	r1, r7, #0
    bbb4:	681b      	ldr	r3, [r3, #0]
    bbb6:	1c20      	adds	r0, r4, #0
    bbb8:	4798      	blx	r3
			count = 1;
			b = buf[i];
    bbba:	7873      	ldrb	r3, [r6, #1]
				count++;
				continue;
			}
			f->write(count);
			f->write(b);
			count = 1;
    bbbc:	2101      	movs	r1, #1
    bbbe:	3601      	adds	r6, #1
	if (img->colorMode == ColorMode::index) {
		uint8_t* buf = (uint8_t*)img->_buffer;
		uint16_t bytes = img->getBufferSize();
		uint16_t i = 1;
		uint8_t b = buf[0];
		uint16_t count = 1;
    bbc0:	1c1f      	adds	r7, r3, #0
    bbc2:	e7e2      	b.n	bb8a <_ZN14Gamebuino_Meta3GMV10writeFrameEP4File+0x1e>
			f->write(count);
			f->write(b);
			count = 1;
			b = buf[i];
		}
		f->write(count);
    bbc4:	6823      	ldr	r3, [r4, #0]
    bbc6:	b2c9      	uxtb	r1, r1
    bbc8:	681b      	ldr	r3, [r3, #0]
    bbca:	1c20      	adds	r0, r4, #0
    bbcc:	4798      	blx	r3
		f->write(b);
    bbce:	6823      	ldr	r3, [r4, #0]
    bbd0:	1c20      	adds	r0, r4, #0
    bbd2:	681b      	ldr	r3, [r3, #0]
    bbd4:	1c39      	adds	r1, r7, #0
    bbd6:	4798      	blx	r3
    bbd8:	e025      	b.n	bc26 <_ZN14Gamebuino_Meta3GMV10writeFrameEP4File+0xba>
	} else {
		uint16_t* buf = img->_buffer;
		uint16_t pixels = (img->getBufferSize() + 1) / 2; 
    bbda:	f7ff f8b1 	bl	ad40 <_ZN14Gamebuino_Meta5Image13getBufferSizeEv>
    bbde:	3001      	adds	r0, #1
    bbe0:	1040      	asrs	r0, r0, #1
    bbe2:	b280      	uxth	r0, r0
		uint16_t i = 1;
		uint16_t color = buf[0];
		uint16_t count = 1;
    bbe4:	2301      	movs	r3, #1
		f->write(b);
	} else {
		uint16_t* buf = img->_buffer;
		uint16_t pixels = (img->getBufferSize() + 1) / 2; 
		uint16_t i = 1;
		uint16_t color = buf[0];
    bbe6:	882a      	ldrh	r2, [r5, #0]
		}
		f->write(count);
		f->write(b);
	} else {
		uint16_t* buf = img->_buffer;
		uint16_t pixels = (img->getBufferSize() + 1) / 2; 
    bbe8:	9000      	str	r0, [sp, #0]
    bbea:	3502      	adds	r5, #2
		uint16_t i = 1;
    bbec:	1c1f      	adds	r7, r3, #0
		uint16_t color = buf[0];
		uint16_t count = 1;
		for (; i < pixels; i++) {
    bbee:	9900      	ldr	r1, [sp, #0]
    bbf0:	428f      	cmp	r7, r1
    bbf2:	d213      	bcs.n	bc1c <_ZN14Gamebuino_Meta3GMV10writeFrameEP4File+0xb0>
			if (buf[i] == color && count < 0x7F) {
    bbf4:	8829      	ldrh	r1, [r5, #0]
    bbf6:	4291      	cmp	r1, r2
    bbf8:	d104      	bne.n	bc04 <_ZN14Gamebuino_Meta3GMV10writeFrameEP4File+0x98>
    bbfa:	2b7e      	cmp	r3, #126	; 0x7e
    bbfc:	d802      	bhi.n	bc04 <_ZN14Gamebuino_Meta3GMV10writeFrameEP4File+0x98>
				count++;
    bbfe:	3301      	adds	r3, #1
    bc00:	b29b      	uxth	r3, r3
				continue;
    bc02:	e006      	b.n	bc12 <_ZN14Gamebuino_Meta3GMV10writeFrameEP4File+0xa6>
			}
			// ok we need to write stuff
			writeColor(f, color, count);
    bc04:	b2db      	uxtb	r3, r3
    bc06:	1c21      	adds	r1, r4, #0
    bc08:	1c30      	adds	r0, r6, #0
    bc0a:	f7ff fec1 	bl	b990 <_ZN14Gamebuino_Meta3GMV10writeColorEP4Fileth>
			count = 1;
			color = buf[i];
    bc0e:	8829      	ldrh	r1, [r5, #0]
				count++;
				continue;
			}
			// ok we need to write stuff
			writeColor(f, color, count);
			count = 1;
    bc10:	2301      	movs	r3, #1
		uint16_t* buf = img->_buffer;
		uint16_t pixels = (img->getBufferSize() + 1) / 2; 
		uint16_t i = 1;
		uint16_t color = buf[0];
		uint16_t count = 1;
		for (; i < pixels; i++) {
    bc12:	3701      	adds	r7, #1
    bc14:	b2bf      	uxth	r7, r7
    bc16:	3502      	adds	r5, #2
    bc18:	1c0a      	adds	r2, r1, #0
    bc1a:	e7e8      	b.n	bbee <_ZN14Gamebuino_Meta3GMV10writeFrameEP4File+0x82>
			// ok we need to write stuff
			writeColor(f, color, count);
			count = 1;
			color = buf[i];
		}
		writeColor(f, color, count);
    bc1c:	b2db      	uxtb	r3, r3
    bc1e:	1c30      	adds	r0, r6, #0
    bc20:	1c21      	adds	r1, r4, #0
    bc22:	f7ff feb5 	bl	b990 <_ZN14Gamebuino_Meta3GMV10writeColorEP4Fileth>
	}
}
    bc26:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

0000bc28 <_ZN14Gamebuino_Meta3GMV14convertFromBMPERNS_3BMPEPc>:
	}
	writeHeader();
	return true;
}

void GMV::convertFromBMP(BMP& bmp, char* newname) {
    bc28:	b5f0      	push	{r4, r5, r6, r7, lr}
    bc2a:	1c04      	adds	r4, r0, #0
    bc2c:	b093      	sub	sp, #76	; 0x4c
	img->allocateBuffer();
    bc2e:	6b40      	ldr	r0, [r0, #52]	; 0x34
	}
	writeHeader();
	return true;
}

void GMV::convertFromBMP(BMP& bmp, char* newname) {
    bc30:	9103      	str	r1, [sp, #12]
    bc32:	1c17      	adds	r7, r2, #0
	img->allocateBuffer();
    bc34:	f7ff f8db 	bl	adee <_ZN14Gamebuino_Meta5Image14allocateBufferEv>
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return vwd()->exists(path);
    bc38:	4e2e      	ldr	r6, [pc, #184]	; (bcf4 <_ZN14Gamebuino_Meta3GMV14convertFromBMPERNS_3BMPEPc+0xcc>)
    bc3a:	1c39      	adds	r1, r7, #0
    bc3c:	1c30      	adds	r0, r6, #0
    bc3e:	f7fa f85e 	bl	5cfe <_ZN7FatFile6existsEPKc>
	if (SD.exists(newname) && !SD.remove(newname)) {
    bc42:	2800      	cmp	r0, #0
    bc44:	d005      	beq.n	bc52 <_ZN14Gamebuino_Meta3GMV14convertFromBMPERNS_3BMPEPc+0x2a>
  *
  * \return The value true is returned for success and
  * the value false is returned for failure.
  */
  bool remove(const char* path) {
    return FatFile::remove(vwd(), path);
    bc46:	1c30      	adds	r0, r6, #0
    bc48:	1c39      	adds	r1, r7, #0
    bc4a:	f001 fc2b 	bl	d4a4 <_ZN7FatFile6removeEPS_PKc>
    bc4e:	2800      	cmp	r0, #0
    bc50:	d04d      	beq.n	bcee <_ZN14Gamebuino_Meta3GMV14convertFromBMPERNS_3BMPEPc+0xc6>
   * \param[in] mode open mode flags.
   * \return a File object.
   */
  File open(const char *path, uint8_t mode = FILE_READ) {
    File tmpFile;
    tmpFile.open(vwd(), path, mode);
    bc52:	ad09      	add	r5, sp, #36	; 0x24
   * \param[in] path location of file to be opened.
   * \param[in] mode open mode flags.
   * \return a File object.
   */
  File open(const char *path, uint8_t mode = FILE_READ) {
    File tmpFile;
    bc54:	a805      	add	r0, sp, #20
    bc56:	f7fa f86d 	bl	5d34 <_ZN4FileC1Ev>
    tmpFile.open(vwd(), path, mode);
    bc5a:	2363      	movs	r3, #99	; 0x63
    bc5c:	1c28      	adds	r0, r5, #0
    bc5e:	1c31      	adds	r1, r6, #0
    bc60:	1c3a      	adds	r2, r7, #0
    bc62:	f001 fbd0 	bl	d406 <_ZN7FatFile4openEPS_PKch>
		return;
	}
	File f = SD.open(newname, FILE_WRITE);
	if (!f) {
    bc66:	782b      	ldrb	r3, [r5, #0]
    bc68:	2b00      	cmp	r3, #0
    bc6a:	d040      	beq.n	bcee <_ZN14Gamebuino_Meta3GMV14convertFromBMPERNS_3BMPEPc+0xc6>
		return;
	}
	writeHeader(&f);
    bc6c:	1c20      	adds	r0, r4, #0
    bc6e:	a905      	add	r1, sp, #20
    bc70:	f7ff fec2 	bl	b9f8 <_ZN14Gamebuino_Meta3GMV11writeHeaderEP4File>
	uint16_t transparentColor = 0;
    bc74:	2600      	movs	r6, #0
	
	bool success;
	do {
		success = true;
		f.seekSet(header_size);
    bc76:	8f61      	ldrh	r1, [r4, #58]	; 0x3a
    bc78:	1c28      	adds	r0, r5, #0
    bc7a:	f001 fa89 	bl	d190 <_ZN7FatFile7seekSetEm>
		for (uint16_t frame = 0; frame < img->frames; frame++) {
    bc7e:	2700      	movs	r7, #0
    bc80:	6b63      	ldr	r3, [r4, #52]	; 0x34
    bc82:	8b1a      	ldrh	r2, [r3, #24]
    bc84:	42ba      	cmp	r2, r7
    bc86:	d91d      	bls.n	bcc4 <_ZN14Gamebuino_Meta3GMV14convertFromBMPERNS_3BMPEPc+0x9c>
			uint32_t t = bmp.readFrame(frame, img->_buffer, transparentColor, &file);
    bc88:	695a      	ldr	r2, [r3, #20]
    bc8a:	9803      	ldr	r0, [sp, #12]
    bc8c:	9400      	str	r4, [sp, #0]
    bc8e:	1c39      	adds	r1, r7, #0
    bc90:	1c33      	adds	r3, r6, #0
    bc92:	f7ff fd9b 	bl	b7cc <_ZN14Gamebuino_Meta3BMP9readFrameEtPttP4File>
			if (t != transparentColor) {
    bc96:	42b0      	cmp	r0, r6
    bc98:	d003      	beq.n	bca2 <_ZN14Gamebuino_Meta3GMV14convertFromBMPERNS_3BMPEPc+0x7a>
				if (t) {
    bc9a:	2800      	cmp	r0, #0
    bc9c:	d001      	beq.n	bca2 <_ZN14Gamebuino_Meta3GMV14convertFromBMPERNS_3BMPEPc+0x7a>
	bool success;
	do {
		success = true;
		f.seekSet(header_size);
		for (uint16_t frame = 0; frame < img->frames; frame++) {
			uint32_t t = bmp.readFrame(frame, img->_buffer, transparentColor, &file);
    bc9e:	1c06      	adds	r6, r0, #0
    bca0:	e7e9      	b.n	bc76 <_ZN14Gamebuino_Meta3GMV14convertFromBMPERNS_3BMPEPc+0x4e>
					success = false;
					// trigger a restart
					break;
				}
			}
			if (img->colorMode == ColorMode::rgb565) {
    bca2:	6b63      	ldr	r3, [r4, #52]	; 0x34
    bca4:	7a9a      	ldrb	r2, [r3, #10]
    bca6:	2a00      	cmp	r2, #0
    bca8:	d105      	bne.n	bcb6 <_ZN14Gamebuino_Meta3GMV14convertFromBMPERNS_3BMPEPc+0x8e>
				if (transparentColor != 0xFFFF) {
    bcaa:	4913      	ldr	r1, [pc, #76]	; (bcf8 <_ZN14Gamebuino_Meta3GMV14convertFromBMPERNS_3BMPEPc+0xd0>)
    bcac:	428e      	cmp	r6, r1
    bcae:	d001      	beq.n	bcb4 <_ZN14Gamebuino_Meta3GMV14convertFromBMPERNS_3BMPEPc+0x8c>
					img->transparentColor = transparentColor;
    bcb0:	811e      	strh	r6, [r3, #8]
    bcb2:	e000      	b.n	bcb6 <_ZN14Gamebuino_Meta3GMV14convertFromBMPERNS_3BMPEPc+0x8e>
				} else {
					img->transparentColor = 0;
    bcb4:	811a      	strh	r2, [r3, #8]
				}
			}
			writeFrame(&f);
    bcb6:	1c20      	adds	r0, r4, #0
    bcb8:	a905      	add	r1, sp, #20
	
	bool success;
	do {
		success = true;
		f.seekSet(header_size);
		for (uint16_t frame = 0; frame < img->frames; frame++) {
    bcba:	3701      	adds	r7, #1
					img->transparentColor = transparentColor;
				} else {
					img->transparentColor = 0;
				}
			}
			writeFrame(&f);
    bcbc:	f7ff ff56 	bl	bb6c <_ZN14Gamebuino_Meta3GMV10writeFrameEP4File>
	
	bool success;
	do {
		success = true;
		f.seekSet(header_size);
		for (uint16_t frame = 0; frame < img->frames; frame++) {
    bcc0:	b2bf      	uxth	r7, r7
    bcc2:	e7dd      	b.n	bc80 <_ZN14Gamebuino_Meta3GMV14convertFromBMPERNS_3BMPEPc+0x58>
			}
			writeFrame(&f);
		}
	} while(!success);
	
	if (img->colorMode == ColorMode::rgb565) {
    bcc4:	7a9b      	ldrb	r3, [r3, #10]
    bcc6:	2b00      	cmp	r3, #0
    bcc8:	d108      	bne.n	bcdc <_ZN14Gamebuino_Meta3GMV14convertFromBMPERNS_3BMPEPc+0xb4>
		f.seekSet(12);
    bcca:	210c      	movs	r1, #12
    bccc:	1c28      	adds	r0, r5, #0
    bcce:	f001 fa5f 	bl	d190 <_ZN7FatFile7seekSetEm>
		f_write16(img->transparentColor, &f);
    bcd2:	6b63      	ldr	r3, [r4, #52]	; 0x34
    bcd4:	a905      	add	r1, sp, #20
    bcd6:	8918      	ldrh	r0, [r3, #8]
    bcd8:	f000 fd9b 	bl	c812 <_ZN14Gamebuino_Meta9f_write16EtP4File>
	}
	bmp.setCreatorBits(CONVERT_MAGIC, &file);
    bcdc:	21a1      	movs	r1, #161	; 0xa1
    bcde:	9803      	ldr	r0, [sp, #12]
    bce0:	0609      	lsls	r1, r1, #24
    bce2:	1c22      	adds	r2, r4, #0
    bce4:	f7ff fbe8 	bl	b4b8 <_ZN14Gamebuino_Meta3BMP14setCreatorBitsEmP4File>
	f.close();
    bce8:	1c28      	adds	r0, r5, #0
    bcea:	f001 fb85 	bl	d3f8 <_ZN7FatFile5closeEv>
}
    bcee:	b013      	add	sp, #76	; 0x4c
    bcf0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    bcf2:	46c0      	nop			; (mov r8, r8)
    bcf4:	20000a04 	.word	0x20000a04
    bcf8:	0000ffff 	.word	0x0000ffff

0000bcfc <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc>:

GMV::GMV(Image* _img) {
	img = _img;
}

GMV::GMV(Image* _img, char* filename) {
    bcfc:	b5f0      	push	{r4, r5, r6, r7, lr}
    bcfe:	b09b      	sub	sp, #108	; 0x6c
    bd00:	1c04      	adds	r4, r0, #0
    bd02:	af00      	add	r7, sp, #0
    bd04:	1c0d      	adds	r5, r1, #0
    bd06:	1c16      	adds	r6, r2, #0
    bd08:	f7fa f814 	bl	5d34 <_ZN4FileC1Ev>
	valid = false;
    bd0c:	1c23      	adds	r3, r4, #0
    bd0e:	3338      	adds	r3, #56	; 0x38
    bd10:	2000      	movs	r0, #0
    bd12:	7018      	strb	r0, [r3, #0]
	img = _img;
	img->frames = 1;
    bd14:	2301      	movs	r3, #1
	img = _img;
}

GMV::GMV(Image* _img, char* filename) {
	valid = false;
	img = _img;
    bd16:	6365      	str	r5, [r4, #52]	; 0x34
   * \param[in] path location of file to be opened.
   * \param[in] mode open mode flags.
   * \return a File object.
   */
  File open(const char *path, uint8_t mode = FILE_READ) {
    File tmpFile;
    bd18:	1c38      	adds	r0, r7, #0
	img->frames = 1;
    bd1a:	832b      	strh	r3, [r5, #24]
    tmpFile.open(vwd(), path, mode);
    bd1c:	1c3d      	adds	r5, r7, #0
    bd1e:	3544      	adds	r5, #68	; 0x44
   * \param[in] path location of file to be opened.
   * \param[in] mode open mode flags.
   * \return a File object.
   */
  File open(const char *path, uint8_t mode = FILE_READ) {
    File tmpFile;
    bd20:	3034      	adds	r0, #52	; 0x34
    bd22:	f7fa f807 	bl	5d34 <_ZN4FileC1Ev>
    tmpFile.open(vwd(), path, mode);
    bd26:	4973      	ldr	r1, [pc, #460]	; (bef4 <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x1f8>)
    bd28:	1c32      	adds	r2, r6, #0
    bd2a:	1c28      	adds	r0, r5, #0
    bd2c:	2363      	movs	r3, #99	; 0x63
    bd2e:	f001 fb6a 	bl	d406 <_ZN7FatFile4openEPS_PKch>
    bd32:	1c23      	adds	r3, r4, #0
    bd34:	3310      	adds	r3, #16
    bd36:	cd07      	ldmia	r5!, {r0, r1, r2}
    bd38:	c307      	stmia	r3!, {r0, r1, r2}
    bd3a:	cd07      	ldmia	r5!, {r0, r1, r2}
    bd3c:	c307      	stmia	r3!, {r0, r1, r2}
    bd3e:	cd07      	ldmia	r5!, {r0, r1, r2}
    bd40:	c307      	stmia	r3!, {r0, r1, r2}
    bd42:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    bd44:	6bb9      	ldr	r1, [r7, #56]	; 0x38
    bd46:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    bd48:	60e3      	str	r3, [r4, #12]
	file = SD.open(filename, FILE_WRITE);
	if (!file) {
    bd4a:	7c23      	ldrb	r3, [r4, #16]
    bd4c:	1c25      	adds	r5, r4, #0
    bd4e:	6061      	str	r1, [r4, #4]
    bd50:	60a2      	str	r2, [r4, #8]
    bd52:	3510      	adds	r5, #16
    bd54:	2b00      	cmp	r3, #0
    bd56:	d102      	bne.n	bd5e <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x62>
		// couldn't find file, perhaps SD isn't inited yet, falling back to lazy init...
		img->frames = 0;
    bd58:	6b60      	ldr	r0, [r4, #52]	; 0x34
    bd5a:	8303      	strh	r3, [r0, #24]
		return;
    bd5c:	e0c5      	b.n	beea <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x1ee>
    bd5e:	2100      	movs	r1, #0
    bd60:	1c28      	adds	r0, r5, #0
    bd62:	f001 fa15 	bl	d190 <_ZN7FatFile7seekSetEm>
	}
	file.rewind();
	uint16_t header = f_read16(&file);
    bd66:	1c20      	adds	r0, r4, #0
    bd68:	f000 fd38 	bl	c7dc <_ZN14Gamebuino_Meta8f_read16EP4File>
	if (header == 0x4D42) {
    bd6c:	4b62      	ldr	r3, [pc, #392]	; (bef8 <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x1fc>)
    bd6e:	4298      	cmp	r0, r3
    bd70:	d16e      	bne.n	be50 <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x154>
    bd72:	466a      	mov	r2, sp
		// we got a BMP image!
		BMP bmp = BMP(&file, img);
    bd74:	1c38      	adds	r0, r7, #0
    bd76:	607a      	str	r2, [r7, #4]
    bd78:	3014      	adds	r0, #20
    bd7a:	1c21      	adds	r1, r4, #0
    bd7c:	6b62      	ldr	r2, [r4, #52]	; 0x34
    bd7e:	f7ff fab9 	bl	b2f4 <_ZN14Gamebuino_Meta3BMPC1EP4FilePNS_5ImageE>
		if (!bmp.isValid()) {
    bd82:	1c38      	adds	r0, r7, #0
    bd84:	3014      	adds	r0, #20
    bd86:	f7ff fb93 	bl	b4b0 <_ZN14Gamebuino_Meta3BMP7isValidEv>
    bd8a:	2800      	cmp	r0, #0
    bd8c:	d103      	bne.n	bd96 <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x9a>
			file.close();
    bd8e:	1c28      	adds	r0, r5, #0
    bd90:	f001 fb32 	bl	d3f8 <_ZN7FatFile5closeEv>
			return;
    bd94:	e059      	b.n	be4a <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x14e>
		}
		uint16_t name_len = strlen(filename);
    bd96:	1c30      	adds	r0, r6, #0
    bd98:	f005 fd40 	bl	1181c <strlen>
    bd9c:	b280      	uxth	r0, r0
		char _filename[name_len + 1];
    bd9e:	1c03      	adds	r3, r0, #0
    bda0:	3308      	adds	r3, #8
    bda2:	08db      	lsrs	r3, r3, #3
    bda4:	00db      	lsls	r3, r3, #3
    bda6:	60f8      	str	r0, [r7, #12]
    bda8:	4668      	mov	r0, sp
    bdaa:	1ac0      	subs	r0, r0, r3
    bdac:	4685      	mov	sp, r0
    bdae:	466a      	mov	r2, sp
		strcpy(_filename, filename);
    bdb0:	1c31      	adds	r1, r6, #0
		if (!bmp.isValid()) {
			file.close();
			return;
		}
		uint16_t name_len = strlen(filename);
		char _filename[name_len + 1];
    bdb2:	60ba      	str	r2, [r7, #8]
		strcpy(_filename, filename);
    bdb4:	f005 fd2a 	bl	1180c <strcpy>
		
		_filename[name_len - 4] = '.';
    bdb8:	68fb      	ldr	r3, [r7, #12]
    bdba:	212e      	movs	r1, #46	; 0x2e
    bdbc:	446b      	add	r3, sp
    bdbe:	1f1a      	subs	r2, r3, #4
    bdc0:	7011      	strb	r1, [r2, #0]
		_filename[name_len - 3] = 'G';
    bdc2:	1eda      	subs	r2, r3, #3
    bdc4:	2147      	movs	r1, #71	; 0x47
    bdc6:	7011      	strb	r1, [r2, #0]
		_filename[name_len - 2] = 'M';
    bdc8:	1e9a      	subs	r2, r3, #2
    bdca:	214d      	movs	r1, #77	; 0x4d
    bdcc:	7011      	strb	r1, [r2, #0]
		_filename[name_len - 1] = 'V';
    bdce:	3b01      	subs	r3, #1
    bdd0:	2256      	movs	r2, #86	; 0x56
    bdd2:	701a      	strb	r2, [r3, #0]
		_filename[name_len] = '\0';
    bdd4:	68f8      	ldr	r0, [r7, #12]
    bdd6:	68bb      	ldr	r3, [r7, #8]
    bdd8:	2100      	movs	r1, #0
    bdda:	5419      	strb	r1, [r3, r0]
		
		uint32_t creatorBits = bmp.getCreatorBits();
    bddc:	1c38      	adds	r0, r7, #0
    bdde:	3014      	adds	r0, #20
    bde0:	f7ff fb68 	bl	b4b4 <_ZN14Gamebuino_Meta3BMP14getCreatorBitsEv>
		if ((creatorBits & CONERT_MASK) != CONVERT_MAGIC || !SD.exists(_filename)) {
    bde4:	0e00      	lsrs	r0, r0, #24
    bde6:	28a1      	cmp	r0, #161	; 0xa1
    bde8:	d178      	bne.n	bedc <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x1e0>
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return vwd()->exists(path);
    bdea:	4842      	ldr	r0, [pc, #264]	; (bef4 <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x1f8>)
    bdec:	4669      	mov	r1, sp
    bdee:	f7f9 ff86 	bl	5cfe <_ZN7FatFile6existsEPKc>
    bdf2:	2800      	cmp	r0, #0
    bdf4:	d072      	beq.n	bedc <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x1e0>
			// we still need to convert...
			convertFromBMP(bmp, _filename);
		}
		file.close();
    bdf6:	1c28      	adds	r0, r5, #0
    bdf8:	f001 fafe 	bl	d3f8 <_ZN7FatFile5closeEv>
   * \param[in] mode open mode flags.
   * \return a File object.
   */
  File open(const char *path, uint8_t mode = FILE_READ) {
    File tmpFile;
    tmpFile.open(vwd(), path, mode);
    bdfc:	1c3e      	adds	r6, r7, #0
   * \param[in] path location of file to be opened.
   * \param[in] mode open mode flags.
   * \return a File object.
   */
  File open(const char *path, uint8_t mode = FILE_READ) {
    File tmpFile;
    bdfe:	1c38      	adds	r0, r7, #0
    tmpFile.open(vwd(), path, mode);
    be00:	3644      	adds	r6, #68	; 0x44
   * \param[in] path location of file to be opened.
   * \param[in] mode open mode flags.
   * \return a File object.
   */
  File open(const char *path, uint8_t mode = FILE_READ) {
    File tmpFile;
    be02:	3034      	adds	r0, #52	; 0x34
    be04:	f7f9 ff96 	bl	5d34 <_ZN4FileC1Ev>
    tmpFile.open(vwd(), path, mode);
    be08:	68ba      	ldr	r2, [r7, #8]
    be0a:	493a      	ldr	r1, [pc, #232]	; (bef4 <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x1f8>)
    be0c:	1c30      	adds	r0, r6, #0
    be0e:	2363      	movs	r3, #99	; 0x63
    be10:	f001 faf9 	bl	d406 <_ZN7FatFile4openEPS_PKch>
    be14:	1c23      	adds	r3, r4, #0
    be16:	3310      	adds	r3, #16
    be18:	ce07      	ldmia	r6!, {r0, r1, r2}
    be1a:	c307      	stmia	r3!, {r0, r1, r2}
    be1c:	ce07      	ldmia	r6!, {r0, r1, r2}
    be1e:	c307      	stmia	r3!, {r0, r1, r2}
    be20:	ce07      	ldmia	r6!, {r0, r1, r2}
    be22:	c307      	stmia	r3!, {r0, r1, r2}
    be24:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    be26:	6bba      	ldr	r2, [r7, #56]	; 0x38
    be28:	60a3      	str	r3, [r4, #8]
    be2a:	6c38      	ldr	r0, [r7, #64]	; 0x40
		file = SD.open(_filename, FILE_WRITE);
		if (!file) {
    be2c:	7c23      	ldrb	r3, [r4, #16]
    be2e:	6062      	str	r2, [r4, #4]
    be30:	60e0      	str	r0, [r4, #12]
    be32:	2b00      	cmp	r3, #0
    be34:	d009      	beq.n	be4a <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x14e>
    be36:	2100      	movs	r1, #0
    be38:	1c28      	adds	r0, r5, #0
    be3a:	f001 f9a9 	bl	d190 <_ZN7FatFile7seekSetEm>
			return;
		}
		file.rewind();
		header = f_read16(&file);
    be3e:	1c20      	adds	r0, r4, #0
    be40:	f000 fccc 	bl	c7dc <_ZN14Gamebuino_Meta8f_read16EP4File>
    be44:	6879      	ldr	r1, [r7, #4]
    be46:	468d      	mov	sp, r1
    be48:	e002      	b.n	be50 <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x154>
	if (header == 0x4D42) {
		// we got a BMP image!
		BMP bmp = BMP(&file, img);
		if (!bmp.isValid()) {
			file.close();
			return;
    be4a:	687a      	ldr	r2, [r7, #4]
    be4c:	4695      	mov	sp, r2
    be4e:	e04c      	b.n	beea <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x1ee>
			return;
		}
		file.rewind();
		header = f_read16(&file);
	}
	if (header != 0x5647) { // header "GV"
    be50:	4b2a      	ldr	r3, [pc, #168]	; (befc <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x200>)
    be52:	4298      	cmp	r0, r3
    be54:	d149      	bne.n	beea <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x1ee>
		// invalid header!
		return;
	}
	header_size = f_read16(&file);
    be56:	1c20      	adds	r0, r4, #0
    be58:	f000 fcc0 	bl	c7dc <_ZN14Gamebuino_Meta8f_read16EP4File>
  /** Set the files position to current position + \a pos. See seekSet().
   * \param[in] offset The new position in bytes from the current position.
   * \return true for success or false for failure.
   */
  bool seekCur(int32_t offset) {
    return seekSet(m_curPosition + offset);
    be5c:	6a61      	ldr	r1, [r4, #36]	; 0x24
    be5e:	8760      	strh	r0, [r4, #58]	; 0x3a
    be60:	3101      	adds	r1, #1
    be62:	1c28      	adds	r0, r5, #0
    be64:	f001 f994 	bl	d190 <_ZN7FatFile7seekSetEm>
		return;
	}
	img->_width = w;
	img->_height = h;
#else
	img->_width = f_read16(&file);
    be68:	1c20      	adds	r0, r4, #0
    be6a:	6b66      	ldr	r6, [r4, #52]	; 0x34
    be6c:	f000 fcb6 	bl	c7dc <_ZN14Gamebuino_Meta8f_read16EP4File>
    be70:	8230      	strh	r0, [r6, #16]
	img->_height = f_read16(&file);
    be72:	1c20      	adds	r0, r4, #0
    be74:	6b66      	ldr	r6, [r4, #52]	; 0x34
    be76:	f000 fcb1 	bl	c7dc <_ZN14Gamebuino_Meta8f_read16EP4File>
    be7a:	8270      	strh	r0, [r6, #18]
#endif
	img->frames = f_read16(&file);
    be7c:	1c20      	adds	r0, r4, #0
    be7e:	6b66      	ldr	r6, [r4, #52]	; 0x34
    be80:	f000 fcac 	bl	c7dc <_ZN14Gamebuino_Meta8f_read16EP4File>
    be84:	8330      	strh	r0, [r6, #24]
   *
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
    return FatFile::read();
    be86:	1c28      	adds	r0, r5, #0
    be88:	f7ff fd58 	bl	b93c <_ZN7FatFile4readEv>
	uint8_t flags = file.read();
	img->colorMode = flags & 0x01 ? (ColorMode::index) : (ColorMode::rgb565);
    be8c:	6b66      	ldr	r6, [r4, #52]	; 0x34
    be8e:	2301      	movs	r3, #1
    be90:	4018      	ands	r0, r3
    be92:	72b0      	strb	r0, [r6, #10]

	if (img->colorMode == ColorMode::index) {
    be94:	4298      	cmp	r0, r3
    be96:	d10b      	bne.n	beb0 <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x1b4>
    be98:	1c28      	adds	r0, r5, #0
    be9a:	f7ff fd4f 	bl	b93c <_ZN7FatFile4readEv>
		img->transparentColorIndex = file.read();
    be9e:	7230      	strb	r0, [r6, #8]
    bea0:	1c28      	adds	r0, r5, #0
		img->useTransparentIndex = (bool)file.read();
    bea2:	6b66      	ldr	r6, [r4, #52]	; 0x34
    bea4:	f7ff fd4a 	bl	b93c <_ZN7FatFile4readEv>
    bea8:	1e43      	subs	r3, r0, #1
    beaa:	4198      	sbcs	r0, r3
    beac:	7270      	strb	r0, [r6, #9]
    beae:	e003      	b.n	beb8 <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x1bc>
	} else {
		img->transparentColor = f_read16(&file);
    beb0:	1c20      	adds	r0, r4, #0
    beb2:	f000 fc93 	bl	c7dc <_ZN14Gamebuino_Meta8f_read16EP4File>
    beb6:	8130      	strh	r0, [r6, #8]
	}
	file.seekSet(header_size);
    beb8:	8f61      	ldrh	r1, [r4, #58]	; 0x3a
    beba:	1c28      	adds	r0, r5, #0
    bebc:	f001 f968 	bl	d190 <_ZN7FatFile7seekSetEm>
		if (img->getBufferSize() > img->bufferSize) {
			return;
		}
	}
#endif
	img->allocateBuffer();
    bec0:	6b60      	ldr	r0, [r4, #52]	; 0x34
    bec2:	f7fe ff94 	bl	adee <_ZN14Gamebuino_Meta5Image14allocateBufferEv>
	
	if (!img->_buffer) {
    bec6:	6b62      	ldr	r2, [r4, #52]	; 0x34
    bec8:	2301      	movs	r3, #1
    beca:	6950      	ldr	r0, [r2, #20]
    becc:	2800      	cmp	r0, #0
    bece:	d101      	bne.n	bed4 <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x1d8>
		// sorry, nope
		img->frames = 1;
    bed0:	8313      	strh	r3, [r2, #24]
		return;
    bed2:	e00a      	b.n	beea <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x1ee>
	}
	
	valid = true;
    bed4:	1c22      	adds	r2, r4, #0
    bed6:	3238      	adds	r2, #56	; 0x38
    bed8:	7013      	strb	r3, [r2, #0]
    beda:	e006      	b.n	beea <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0x1ee>
		_filename[name_len] = '\0';
		
		uint32_t creatorBits = bmp.getCreatorBits();
		if ((creatorBits & CONERT_MASK) != CONVERT_MAGIC || !SD.exists(_filename)) {
			// we still need to convert...
			convertFromBMP(bmp, _filename);
    bedc:	1c39      	adds	r1, r7, #0
    bede:	1c20      	adds	r0, r4, #0
    bee0:	3114      	adds	r1, #20
    bee2:	68ba      	ldr	r2, [r7, #8]
    bee4:	f7ff fea0 	bl	bc28 <_ZN14Gamebuino_Meta3GMV14convertFromBMPERNS_3BMPEPc>
    bee8:	e785      	b.n	bdf6 <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc+0xfa>
		img->frames = 1;
		return;
	}
	
	valid = true;
}
    beea:	1c20      	adds	r0, r4, #0
    beec:	46bd      	mov	sp, r7
    beee:	b01b      	add	sp, #108	; 0x6c
    bef0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    bef2:	46c0      	nop			; (mov r8, r8)
    bef4:	20000a04 	.word	0x20000a04
    bef8:	00004d42 	.word	0x00004d42
    befc:	00005647 	.word	0x00005647

0000bf00 <_ZN14Gamebuino_Meta3GMV10writeFrameEv>:

void GMV::writeHeader() {
	writeHeader(&file);
}

void GMV::writeFrame() {
    bf00:	b508      	push	{r3, lr}
    bf02:	1c01      	adds	r1, r0, #0
	writeFrame(&file);
    bf04:	f7ff fe32 	bl	bb6c <_ZN14Gamebuino_Meta3GMV10writeFrameEP4File>
}
    bf08:	bd08      	pop	{r3, pc}
	...

0000bf0c <_ZN14Gamebuino_Meta3GMV9readFrameEv>:
		}
		writeColor(f, color, count);
	}
}

void GMV::readFrame() {
    bf0c:	b5f0      	push	{r4, r5, r6, r7, lr}
    bf0e:	1c07      	adds	r7, r0, #0
	if (img->colorMode == ColorMode::index) {
    bf10:	6b40      	ldr	r0, [r0, #52]	; 0x34
		}
		writeColor(f, color, count);
	}
}

void GMV::readFrame() {
    bf12:	b087      	sub	sp, #28
	if (img->colorMode == ColorMode::index) {
    bf14:	7a83      	ldrb	r3, [r0, #10]
    bf16:	6941      	ldr	r1, [r0, #20]
    bf18:	9100      	str	r1, [sp, #0]
    bf1a:	2b01      	cmp	r3, #1
    bf1c:	d11d      	bne.n	bf5a <_ZN14Gamebuino_Meta3GMV9readFrameEv+0x4e>
		uint8_t* buf = (uint8_t*)img->_buffer;
		uint16_t bytes = img->getBufferSize();
    bf1e:	f7fe ff0f 	bl	ad40 <_ZN14Gamebuino_Meta5Image13getBufferSizeEv>
		uint16_t bytes_current = 0;
    bf22:	2400      	movs	r4, #0
}

void GMV::readFrame() {
	if (img->colorMode == ColorMode::index) {
		uint8_t* buf = (uint8_t*)img->_buffer;
		uint16_t bytes = img->getBufferSize();
    bf24:	9001      	str	r0, [sp, #4]
    bf26:	1c3e      	adds	r6, r7, #0
    bf28:	3610      	adds	r6, #16
    bf2a:	1c30      	adds	r0, r6, #0
    bf2c:	f7ff fd06 	bl	b93c <_ZN7FatFile4readEv>
		uint16_t bytes_current = 0;
		uint8_t count;
		uint8_t b;
		do {
			count = file.read();
    bf30:	b2c5      	uxtb	r5, r0
    bf32:	1c30      	adds	r0, r6, #0
    bf34:	f7ff fd02 	bl	b93c <_ZN7FatFile4readEv>
			b = file.read();
			for (uint8_t i = 0; i < count; i++) {
    bf38:	1c23      	adds	r3, r4, #0
		uint16_t bytes_current = 0;
		uint8_t count;
		uint8_t b;
		do {
			count = file.read();
			b = file.read();
    bf3a:	b2c0      	uxtb	r0, r0
    bf3c:	1b1a      	subs	r2, r3, r4
			for (uint8_t i = 0; i < count; i++) {
    bf3e:	b2d2      	uxtb	r2, r2
    bf40:	42aa      	cmp	r2, r5
    bf42:	d204      	bcs.n	bf4e <_ZN14Gamebuino_Meta3GMV9readFrameEv+0x42>
				buf[bytes_current] = b;
    bf44:	9a00      	ldr	r2, [sp, #0]
    bf46:	54d0      	strb	r0, [r2, r3]
				bytes_current++;
    bf48:	3301      	adds	r3, #1
    bf4a:	b29b      	uxth	r3, r3
    bf4c:	e7f6      	b.n	bf3c <_ZN14Gamebuino_Meta3GMV9readFrameEv+0x30>
    bf4e:	192c      	adds	r4, r5, r4
		uint8_t* buf = (uint8_t*)img->_buffer;
		uint16_t bytes = img->getBufferSize();
		uint16_t bytes_current = 0;
		uint8_t count;
		uint8_t b;
		do {
    bf50:	9b01      	ldr	r3, [sp, #4]
    bf52:	b2a4      	uxth	r4, r4
    bf54:	429c      	cmp	r4, r3
    bf56:	d3e6      	bcc.n	bf26 <_ZN14Gamebuino_Meta3GMV9readFrameEv+0x1a>
    bf58:	e071      	b.n	c03e <_ZN14Gamebuino_Meta3GMV9readFrameEv+0x132>
				bytes_current++;
			}
		} while (bytes_current < bytes);
	} else {
		uint16_t* buf = img->_buffer;
		uint16_t pixels = (img->getBufferSize() + 1) / 2; 
    bf5a:	f7fe fef1 	bl	ad40 <_ZN14Gamebuino_Meta5Image13getBufferSizeEv>
		uint16_t pixels_current = 0;
		
		uint16_t* index = (uint16_t*)img->colorIndex;
    bf5e:	4b39      	ldr	r3, [pc, #228]	; (c044 <_ZN14Gamebuino_Meta3GMV9readFrameEv+0x138>)
				bytes_current++;
			}
		} while (bytes_current < bytes);
	} else {
		uint16_t* buf = img->_buffer;
		uint16_t pixels = (img->getBufferSize() + 1) / 2; 
    bf60:	3001      	adds	r0, #1
		uint16_t pixels_current = 0;
		
		uint16_t* index = (uint16_t*)img->colorIndex;
    bf62:	681b      	ldr	r3, [r3, #0]
				bytes_current++;
			}
		} while (bytes_current < bytes);
	} else {
		uint16_t* buf = img->_buffer;
		uint16_t pixels = (img->getBufferSize() + 1) / 2; 
    bf64:	1040      	asrs	r0, r0, #1
    bf66:	9001      	str	r0, [sp, #4]
		uint16_t pixels_current = 0;
		
		uint16_t* index = (uint16_t*)img->colorIndex;
    bf68:	9302      	str	r3, [sp, #8]
				bytes_current++;
			}
		} while (bytes_current < bytes);
	} else {
		uint16_t* buf = img->_buffer;
		uint16_t pixels = (img->getBufferSize() + 1) / 2; 
    bf6a:	b280      	uxth	r0, r0
		
		uint16_t* index = (uint16_t*)img->colorIndex;
		
		uint8_t count;
		uint8_t i;
		uint16_t color = 0;
    bf6c:	2400      	movs	r4, #0
    bf6e:	466b      	mov	r3, sp
				bytes_current++;
			}
		} while (bytes_current < bytes);
	} else {
		uint16_t* buf = img->_buffer;
		uint16_t pixels = (img->getBufferSize() + 1) / 2; 
    bf70:	9003      	str	r0, [sp, #12]
		
		uint16_t* index = (uint16_t*)img->colorIndex;
		
		uint8_t count;
		uint8_t i;
		uint16_t color = 0;
    bf72:	82dc      	strh	r4, [r3, #22]
    bf74:	1c3d      	adds	r5, r7, #0
    bf76:	3510      	adds	r5, #16
    bf78:	1c28      	adds	r0, r5, #0
    bf7a:	f7ff fcdf 	bl	b93c <_ZN7FatFile4readEv>
		do {
			int16_t read = file.read();
			if (read == -1) {
    bf7e:	b203      	sxth	r3, r0
    bf80:	3301      	adds	r3, #1
    bf82:	d05c      	beq.n	c03e <_ZN14Gamebuino_Meta3GMV9readFrameEv+0x132>
				break;
			}
			count = read;
    bf84:	b2c3      	uxtb	r3, r0
			if (count == 0x80) {
    bf86:	2b80      	cmp	r3, #128	; 0x80
    bf88:	d10d      	bne.n	bfa6 <_ZN14Gamebuino_Meta3GMV9readFrameEv+0x9a>
				// we have a single, un-altered pixel
				file.read(&color, 2);
    bf8a:	466e      	mov	r6, sp
    bf8c:	3616      	adds	r6, #22
    bf8e:	1c31      	adds	r1, r6, #0
    bf90:	2202      	movs	r2, #2
    bf92:	1c28      	adds	r0, r5, #0
    bf94:	f001 f808 	bl	cfa8 <_ZN7FatFile4readEPvj>
				buf[pixels_current] = color;
    bf98:	8832      	ldrh	r2, [r6, #0]
    bf9a:	9900      	ldr	r1, [sp, #0]
    bf9c:	0063      	lsls	r3, r4, #1
				pixels_current++;
    bf9e:	3401      	adds	r4, #1
			}
			count = read;
			if (count == 0x80) {
				// we have a single, un-altered pixel
				file.read(&color, 2);
				buf[pixels_current] = color;
    bfa0:	52ca      	strh	r2, [r1, r3]
				pixels_current++;
    bfa2:	b2a4      	uxth	r4, r4
				continue;
    bfa4:	e048      	b.n	c038 <_ZN14Gamebuino_Meta3GMV9readFrameEv+0x12c>
			}
			if (!(count & 0x80)) {
    bfa6:	0602      	lsls	r2, r0, #24
    bfa8:	d414      	bmi.n	bfd4 <_ZN14Gamebuino_Meta3GMV9readFrameEv+0xc8>
    bfaa:	0062      	lsls	r2, r4, #1
				// single indexed color
				if (count == 0x7F) {
    bfac:	2b7f      	cmp	r3, #127	; 0x7f
    bfae:	d104      	bne.n	bfba <_ZN14Gamebuino_Meta3GMV9readFrameEv+0xae>
					buf[pixels_current] = img->transparentColor;
    bfb0:	6b78      	ldr	r0, [r7, #52]	; 0x34
    bfb2:	9900      	ldr	r1, [sp, #0]
    bfb4:	8903      	ldrh	r3, [r0, #8]
    bfb6:	528b      	strh	r3, [r1, r2]
    bfb8:	e009      	b.n	bfce <_ZN14Gamebuino_Meta3GMV9readFrameEv+0xc2>
    bfba:	1c19      	adds	r1, r3, #0
    bfbc:	2b0f      	cmp	r3, #15
    bfbe:	d900      	bls.n	bfc2 <_ZN14Gamebuino_Meta3GMV9readFrameEv+0xb6>
    bfc0:	210f      	movs	r1, #15
				} else {
					if (count >= 16) { // sanity check
						count = 15;
					}
					buf[pixels_current] = index[count];
    bfc2:	9802      	ldr	r0, [sp, #8]
    bfc4:	b2c9      	uxtb	r1, r1
    bfc6:	0049      	lsls	r1, r1, #1
    bfc8:	5a0b      	ldrh	r3, [r1, r0]
    bfca:	9900      	ldr	r1, [sp, #0]
    bfcc:	528b      	strh	r3, [r1, r2]
				}
				pixels_current++;
    bfce:	3401      	adds	r4, #1
    bfd0:	b2a4      	uxth	r4, r4
				continue;
    bfd2:	e031      	b.n	c038 <_ZN14Gamebuino_Meta3GMV9readFrameEv+0x12c>
			}
			// ok we actually have multiple pixels
			count &= 0x7F;
    bfd4:	267f      	movs	r6, #127	; 0x7f
    bfd6:	1c28      	adds	r0, r5, #0
    bfd8:	401e      	ands	r6, r3
    bfda:	f7ff fcaf 	bl	b93c <_ZN7FatFile4readEv>
    bfde:	4669      	mov	r1, sp
			i = file.read();
    bfe0:	b2c0      	uxtb	r0, r0
    bfe2:	3116      	adds	r1, #22
			if (i == 0x80) {
    bfe4:	2880      	cmp	r0, #128	; 0x80
    bfe6:	d104      	bne.n	bff2 <_ZN14Gamebuino_Meta3GMV9readFrameEv+0xe6>
				file.read(&color, 2);
    bfe8:	1c28      	adds	r0, r5, #0
    bfea:	2202      	movs	r2, #2
    bfec:	f000 ffdc 	bl	cfa8 <_ZN7FatFile4readEPvj>
    bff0:	e00f      	b.n	c012 <_ZN14Gamebuino_Meta3GMV9readFrameEv+0x106>
			} else if (i == 0x7F) {
    bff2:	287f      	cmp	r0, #127	; 0x7f
    bff4:	d103      	bne.n	bffe <_ZN14Gamebuino_Meta3GMV9readFrameEv+0xf2>
				color = img->transparentColor;
    bff6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    bff8:	8913      	ldrh	r3, [r2, #8]
    bffa:	800b      	strh	r3, [r1, #0]
    bffc:	e009      	b.n	c012 <_ZN14Gamebuino_Meta3GMV9readFrameEv+0x106>
    bffe:	1c03      	adds	r3, r0, #0
    c000:	280f      	cmp	r0, #15
    c002:	d900      	bls.n	c006 <_ZN14Gamebuino_Meta3GMV9readFrameEv+0xfa>
    c004:	230f      	movs	r3, #15
			} else {
				if (i >= 16) {
					i = 15; // sanity check
				}
				color = index[i];
    c006:	b2db      	uxtb	r3, r3
    c008:	9802      	ldr	r0, [sp, #8]
    c00a:	005b      	lsls	r3, r3, #1
    c00c:	5a1a      	ldrh	r2, [r3, r0]
    c00e:	466b      	mov	r3, sp
    c010:	82da      	strh	r2, [r3, #22]
			}
			if ((pixels_current + count) > pixels) {
    c012:	9901      	ldr	r1, [sp, #4]
    c014:	19a3      	adds	r3, r4, r6
    c016:	428b      	cmp	r3, r1
    c018:	dc11      	bgt.n	c03e <_ZN14Gamebuino_Meta3GMV9readFrameEv+0x132>
    c01a:	1c23      	adds	r3, r4, #0
    c01c:	1b1a      	subs	r2, r3, r4
				// sanity check...
				break;
			}
			for (i = 0; i < count; i++) {
    c01e:	b2d2      	uxtb	r2, r2
    c020:	42b2      	cmp	r2, r6
    c022:	d207      	bcs.n	c034 <_ZN14Gamebuino_Meta3GMV9readFrameEv+0x128>
				buf[pixels_current] = color;
    c024:	466a      	mov	r2, sp
    c026:	8ad1      	ldrh	r1, [r2, #22]
    c028:	9800      	ldr	r0, [sp, #0]
    c02a:	005a      	lsls	r2, r3, #1
				pixels_current++;
    c02c:	3301      	adds	r3, #1
			if ((pixels_current + count) > pixels) {
				// sanity check...
				break;
			}
			for (i = 0; i < count; i++) {
				buf[pixels_current] = color;
    c02e:	5281      	strh	r1, [r0, r2]
				pixels_current++;
    c030:	b29b      	uxth	r3, r3
    c032:	e7f3      	b.n	c01c <_ZN14Gamebuino_Meta3GMV9readFrameEv+0x110>
    c034:	1934      	adds	r4, r6, r4
    c036:	b2a4      	uxth	r4, r4
		uint16_t* index = (uint16_t*)img->colorIndex;
		
		uint8_t count;
		uint8_t i;
		uint16_t color = 0;
		do {
    c038:	9903      	ldr	r1, [sp, #12]
    c03a:	428c      	cmp	r4, r1
    c03c:	d39a      	bcc.n	bf74 <_ZN14Gamebuino_Meta3GMV9readFrameEv+0x68>
				buf[pixels_current] = color;
				pixels_current++;
			}
		} while (pixels_current < pixels);
	}
}
    c03e:	b007      	add	sp, #28
    c040:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c042:	46c0      	nop			; (mov r8, r8)
    c044:	20000050 	.word	0x20000050

0000c048 <_ZN14Gamebuino_Meta3GMV8setFrameEt>:

void GMV::setFrame(uint16_t frame) {
    c048:	b570      	push	{r4, r5, r6, lr}
    c04a:	1c05      	adds	r5, r0, #0
    c04c:	1c0e      	adds	r6, r1, #0
	file.seekSet(header_size);
    c04e:	3010      	adds	r0, #16
    c050:	8f69      	ldrh	r1, [r5, #58]	; 0x3a
	if (!frame) {
    c052:	2400      	movs	r4, #0
		} while (pixels_current < pixels);
	}
}

void GMV::setFrame(uint16_t frame) {
	file.seekSet(header_size);
    c054:	f001 f89c 	bl	d190 <_ZN7FatFile7seekSetEm>
	if (!frame) {
    c058:	42a6      	cmp	r6, r4
    c05a:	d006      	beq.n	c06a <_ZN14Gamebuino_Meta3GMV8setFrameEt+0x22>
		return;
	}
	for (uint16_t f = 0; f < frame; f++) {
    c05c:	3401      	adds	r4, #1
		readFrame(); // unfortunatelly we don't have a better way
    c05e:	1c28      	adds	r0, r5, #0
void GMV::setFrame(uint16_t frame) {
	file.seekSet(header_size);
	if (!frame) {
		return;
	}
	for (uint16_t f = 0; f < frame; f++) {
    c060:	b2a4      	uxth	r4, r4
		readFrame(); // unfortunatelly we don't have a better way
    c062:	f7ff ff53 	bl	bf0c <_ZN14Gamebuino_Meta3GMV9readFrameEv>
void GMV::setFrame(uint16_t frame) {
	file.seekSet(header_size);
	if (!frame) {
		return;
	}
	for (uint16_t f = 0; f < frame; f++) {
    c066:	42b4      	cmp	r4, r6
    c068:	d1f8      	bne.n	c05c <_ZN14Gamebuino_Meta3GMV8setFrameEt+0x14>
		readFrame(); // unfortunatelly we don't have a better way
	}
}
    c06a:	bd70      	pop	{r4, r5, r6, pc}

0000c06c <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E>:

void GMV::finishSave(char* filename, uint16_t frames, bool output, Display_ST7735* tft) {
    c06c:	b5f0      	push	{r4, r5, r6, r7, lr}
    c06e:	b0a1      	sub	sp, #132	; 0x84
    c070:	1c07      	adds	r7, r0, #0
    c072:	1c0d      	adds	r5, r1, #0
    c074:	9205      	str	r2, [sp, #20]
    c076:	9304      	str	r3, [sp, #16]
    c078:	9c26      	ldr	r4, [sp, #152]	; 0x98
	if(output){
    c07a:	2b00      	cmp	r3, #0
    c07c:	d037      	beq.n	c0ee <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x82>
		tft->setColor(Color::brown);
    c07e:	49ab      	ldr	r1, [pc, #684]	; (c32c <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2c0>)
    c080:	1c20      	adds	r0, r4, #0
    c082:	f7fd fea7 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
		tft->drawRect(0, 0, tft->width(), tft->height());
    c086:	6823      	ldr	r3, [r4, #0]
    c088:	1c20      	adds	r0, r4, #0
    c08a:	6a5e      	ldr	r6, [r3, #36]	; 0x24
    c08c:	f7fd ffbc 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
    c090:	9003      	str	r0, [sp, #12]
    c092:	1c20      	adds	r0, r4, #0
    c094:	f7fd ffc8 	bl	a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>
    c098:	2100      	movs	r1, #0
    c09a:	1c0a      	adds	r2, r1, #0
    c09c:	9000      	str	r0, [sp, #0]
    c09e:	9b03      	ldr	r3, [sp, #12]
    c0a0:	1c20      	adds	r0, r4, #0
    c0a2:	47b0      	blx	r6
		tft->drawRect(1, 1, tft->width()-2, tft->height()-2);
    c0a4:	6823      	ldr	r3, [r4, #0]
    c0a6:	1c20      	adds	r0, r4, #0
    c0a8:	6a5e      	ldr	r6, [r3, #36]	; 0x24
    c0aa:	f7fd ffad 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
    c0ae:	9003      	str	r0, [sp, #12]
    c0b0:	1c20      	adds	r0, r4, #0
    c0b2:	f7fd ffb9 	bl	a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>
    c0b6:	9b03      	ldr	r3, [sp, #12]
    c0b8:	3802      	subs	r0, #2
    c0ba:	2101      	movs	r1, #1
    c0bc:	b200      	sxth	r0, r0
    c0be:	3b02      	subs	r3, #2
    c0c0:	b21b      	sxth	r3, r3
    c0c2:	1c0a      	adds	r2, r1, #0
    c0c4:	9000      	str	r0, [sp, #0]
    c0c6:	1c20      	adds	r0, r4, #0
    c0c8:	47b0      	blx	r6
		//white on brown, large font
		tft->setColor(Color::white, Color::brown);
    c0ca:	1c20      	adds	r0, r4, #0
    c0cc:	4998      	ldr	r1, [pc, #608]	; (c330 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2c4>)
    c0ce:	4a97      	ldr	r2, [pc, #604]	; (c32c <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2c0>)
    c0d0:	f7fd feb6 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
		tft->cursorX = 0;
    c0d4:	4b97      	ldr	r3, [pc, #604]	; (c334 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2c8>)
    c0d6:	2200      	movs	r2, #0
    c0d8:	801a      	strh	r2, [r3, #0]
		tft->cursorY = 1;
    c0da:	4b97      	ldr	r3, [pc, #604]	; (c338 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2cc>)
    c0dc:	2201      	movs	r2, #1
    c0de:	801a      	strh	r2, [r3, #0]
		tft->fontSize = 2;
    c0e0:	4b96      	ldr	r3, [pc, #600]	; (c33c <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2d0>)
    c0e2:	2202      	movs	r2, #2
		tft->println(" SAVE VIDEO    ");
    c0e4:	1c20      	adds	r0, r4, #0
    c0e6:	4996      	ldr	r1, [pc, #600]	; (c340 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2d4>)
		tft->drawRect(1, 1, tft->width()-2, tft->height()-2);
		//white on brown, large font
		tft->setColor(Color::white, Color::brown);
		tft->cursorX = 0;
		tft->cursorY = 1;
		tft->fontSize = 2;
    c0e8:	701a      	strb	r2, [r3, #0]
		tft->println(" SAVE VIDEO    ");
    c0ea:	f003 fd55 	bl	fb98 <_ZN5Print7printlnEPKc>
	}
	
	
	file.seekSet(9);
    c0ee:	1c3e      	adds	r6, r7, #0
    c0f0:	3610      	adds	r6, #16
    c0f2:	2109      	movs	r1, #9
    c0f4:	1c30      	adds	r0, r6, #0
    c0f6:	9603      	str	r6, [sp, #12]
    c0f8:	f001 f84a 	bl	d190 <_ZN7FatFile7seekSetEm>
	f_write16(frames, &file); // fill in the number of frames!
    c0fc:	9805      	ldr	r0, [sp, #20]
    c0fe:	1c39      	adds	r1, r7, #0
    c100:	f000 fb87 	bl	c812 <_ZN14Gamebuino_Meta9f_write16EtP4File>
	if (!filename) {
		file.close();
    c104:	9803      	ldr	r0, [sp, #12]
	}
	
	
	file.seekSet(9);
	f_write16(frames, &file); // fill in the number of frames!
	if (!filename) {
    c106:	2d00      	cmp	r5, #0
    c108:	d100      	bne.n	c10c <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0xa0>
    c10a:	e10b      	b.n	c324 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2b8>
    uint32_t n = FatFile::available();
    return n > INT_MAX ? INT_MAX : n;
  }
  /** Ensure that any bytes written to the file are saved to the SD card. */
  void flush() {
    FatFile::sync();
    c10c:	f001 f92c 	bl	d368 <_ZN7FatFile4syncEv>
    c110:	ae17      	add	r6, sp, #92	; 0x5c
   * \param[in] path location of file to be opened.
   * \param[in] mode open mode flags.
   * \return a File object.
   */
  File open(const char *path, uint8_t mode = FILE_READ) {
    File tmpFile;
    c112:	a813      	add	r0, sp, #76	; 0x4c
    c114:	f7f9 fe0e 	bl	5d34 <_ZN4FileC1Ev>
    tmpFile.open(vwd(), path, mode);
    c118:	2363      	movs	r3, #99	; 0x63
    c11a:	1c30      	adds	r0, r6, #0
    c11c:	4989      	ldr	r1, [pc, #548]	; (c344 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2d8>)
    c11e:	1c2a      	adds	r2, r5, #0
    c120:	f001 f971 	bl	d406 <_ZN7FatFile4openEPS_PKch>
		file.close();
		return;
	}
	file.flush();
	File f = SD.open(filename, FILE_WRITE);
	if (!f) {
    c124:	7833      	ldrb	r3, [r6, #0]
    c126:	2b00      	cmp	r3, #0
    c128:	d108      	bne.n	c13c <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0xd0>
		if (output) {
    c12a:	9e04      	ldr	r6, [sp, #16]
    c12c:	2e00      	cmp	r6, #0
    c12e:	d100      	bne.n	c132 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0xc6>
    c130:	e0fa      	b.n	c328 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2bc>
			tft->println("Couldn't create BMP!");
    c132:	1c20      	adds	r0, r4, #0
    c134:	4984      	ldr	r1, [pc, #528]	; (c348 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2dc>)
    c136:	f003 fd2f 	bl	fb98 <_ZN5Print7printlnEPKc>
    c13a:	e0f5      	b.n	c328 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2bc>
		}
		return;
	}
	BMP bmp = BMP(img, frames);
    c13c:	6b79      	ldr	r1, [r7, #52]	; 0x34
    c13e:	9a05      	ldr	r2, [sp, #20]
    c140:	a80b      	add	r0, sp, #44	; 0x2c
    c142:	f7ff f8c2 	bl	b2ca <_ZN14Gamebuino_Meta3BMPC1EPNS_5ImageEt>
	uint32_t image_size = bmp.writeHeader(&f);
    c146:	a80b      	add	r0, sp, #44	; 0x2c
    c148:	a913      	add	r1, sp, #76	; 0x4c
    c14a:	f7ff f9d3 	bl	b4f4 <_ZN14Gamebuino_Meta3BMP11writeHeaderEP4File>
	uint8_t x, y;
	if (output) {
    c14e:	9e04      	ldr	r6, [sp, #16]
			tft->println("Couldn't create BMP!");
		}
		return;
	}
	BMP bmp = BMP(img, frames);
	uint32_t image_size = bmp.writeHeader(&f);
    c150:	9002      	str	r0, [sp, #8]
	uint8_t x, y;
	if (output) {
    c152:	2e00      	cmp	r6, #0
    c154:	d017      	beq.n	c186 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x11a>
		tft->print(" Creating file:\n ");
    c156:	497d      	ldr	r1, [pc, #500]	; (c34c <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2e0>)
    c158:	1c20      	adds	r0, r4, #0
    c15a:	f003 fd0b 	bl	fb74 <_ZN5Print5printEPKc>
		x = tft->cursorX;
    c15e:	4b75      	ldr	r3, [pc, #468]	; (c334 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2c8>)
		y = tft->cursorY;
		tft->print("      /");
    c160:	497b      	ldr	r1, [pc, #492]	; (c350 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2e4>)
	BMP bmp = BMP(img, frames);
	uint32_t image_size = bmp.writeHeader(&f);
	uint8_t x, y;
	if (output) {
		tft->print(" Creating file:\n ");
		x = tft->cursorX;
    c162:	781b      	ldrb	r3, [r3, #0]
		y = tft->cursorY;
		tft->print("      /");
    c164:	1c20      	adds	r0, r4, #0
	BMP bmp = BMP(img, frames);
	uint32_t image_size = bmp.writeHeader(&f);
	uint8_t x, y;
	if (output) {
		tft->print(" Creating file:\n ");
		x = tft->cursorX;
    c166:	9306      	str	r3, [sp, #24]
		y = tft->cursorY;
    c168:	4b73      	ldr	r3, [pc, #460]	; (c338 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2cc>)
    c16a:	781b      	ldrb	r3, [r3, #0]
    c16c:	9307      	str	r3, [sp, #28]
		tft->print("      /");
    c16e:	f003 fd01 	bl	fb74 <_ZN5Print5printEPKc>
		tft->print(image_size / 1024);
    c172:	9e02      	ldr	r6, [sp, #8]
    c174:	1c20      	adds	r0, r4, #0
    c176:	0ab1      	lsrs	r1, r6, #10
    c178:	220a      	movs	r2, #10
    c17a:	f003 fd60 	bl	fc3e <_ZN5Print5printEmi>
		tft->println("KB");
    c17e:	1c20      	adds	r0, r4, #0
    c180:	4974      	ldr	r1, [pc, #464]	; (c354 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2e8>)
    c182:	f003 fd09 	bl	fb98 <_ZN5Print7printlnEPKc>
	}
	for (uint32_t i = 0; i < image_size; i+=4) {
    c186:	2500      	movs	r5, #0
    c188:	9e02      	ldr	r6, [sp, #8]
    c18a:	42b5      	cmp	r5, r6
    c18c:	d238      	bcs.n	c200 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x194>
		f_write32(0, &f);
    c18e:	2000      	movs	r0, #0
    c190:	a913      	add	r1, sp, #76	; 0x4c
		if (((i % 65536) == 0) && output) {
    c192:	b2ae      	uxth	r6, r5
		tft->print("      /");
		tft->print(image_size / 1024);
		tft->println("KB");
	}
	for (uint32_t i = 0; i < image_size; i+=4) {
		f_write32(0, &f);
    c194:	f000 fb34 	bl	c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>
		if (((i % 65536) == 0) && output) {
    c198:	9608      	str	r6, [sp, #32]
    c19a:	2e00      	cmp	r6, #0
    c19c:	d12e      	bne.n	c1fc <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x190>
    c19e:	9e04      	ldr	r6, [sp, #16]
    c1a0:	2e00      	cmp	r6, #0
    c1a2:	d02b      	beq.n	c1fc <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x190>
			tft->cursorX = x;
    c1a4:	4b63      	ldr	r3, [pc, #396]	; (c334 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2c8>)
    c1a6:	9e06      	ldr	r6, [sp, #24]
			tft->cursorY = y;
			tft->setColor(Color::white, Color::brown);
    c1a8:	1c20      	adds	r0, r4, #0
		tft->println("KB");
	}
	for (uint32_t i = 0; i < image_size; i+=4) {
		f_write32(0, &f);
		if (((i % 65536) == 0) && output) {
			tft->cursorX = x;
    c1aa:	801e      	strh	r6, [r3, #0]
			tft->cursorY = y;
    c1ac:	4b62      	ldr	r3, [pc, #392]	; (c338 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2cc>)
    c1ae:	9e07      	ldr	r6, [sp, #28]
			tft->setColor(Color::white, Color::brown);
    c1b0:	495f      	ldr	r1, [pc, #380]	; (c330 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2c4>)
    c1b2:	4a5e      	ldr	r2, [pc, #376]	; (c32c <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2c0>)
	}
	for (uint32_t i = 0; i < image_size; i+=4) {
		f_write32(0, &f);
		if (((i % 65536) == 0) && output) {
			tft->cursorX = x;
			tft->cursorY = y;
    c1b4:	801e      	strh	r6, [r3, #0]
			tft->setColor(Color::white, Color::brown);
    c1b6:	f7fd fe43 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
			tft->println(i / 1024);
    c1ba:	220a      	movs	r2, #10
    c1bc:	0aa9      	lsrs	r1, r5, #10
    c1be:	1c20      	adds	r0, r4, #0
    c1c0:	f003 fd4b 	bl	fc5a <_ZN5Print7printlnEmi>
			tft->setColor(Color::brown);
    c1c4:	4959      	ldr	r1, [pc, #356]	; (c32c <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2c0>)
    c1c6:	1c20      	adds	r0, r4, #0
    c1c8:	f7fd fe04 	bl	9dd4 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorE>
			tft->fillRect(0, tft->height() - 10, (i * tft->width()) / image_size, 8);
    c1cc:	6823      	ldr	r3, [r4, #0]
    c1ce:	1c20      	adds	r0, r4, #0
    c1d0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    c1d2:	9309      	str	r3, [sp, #36]	; 0x24
    c1d4:	f7fd ff28 	bl	a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>
    c1d8:	1c06      	adds	r6, r0, #0
    c1da:	1c20      	adds	r0, r4, #0
    c1dc:	f7fd ff14 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
    c1e0:	9902      	ldr	r1, [sp, #8]
    c1e2:	4368      	muls	r0, r5
    c1e4:	f005 f8d8 	bl	11398 <__aeabi_uidiv>
    c1e8:	3e0a      	subs	r6, #10
    c1ea:	b236      	sxth	r6, r6
    c1ec:	2208      	movs	r2, #8
    c1ee:	b203      	sxth	r3, r0
    c1f0:	9200      	str	r2, [sp, #0]
    c1f2:	1c20      	adds	r0, r4, #0
    c1f4:	1c32      	adds	r2, r6, #0
    c1f6:	9908      	ldr	r1, [sp, #32]
    c1f8:	9e09      	ldr	r6, [sp, #36]	; 0x24
    c1fa:	47b0      	blx	r6
		y = tft->cursorY;
		tft->print("      /");
		tft->print(image_size / 1024);
		tft->println("KB");
	}
	for (uint32_t i = 0; i < image_size; i+=4) {
    c1fc:	3504      	adds	r5, #4
    c1fe:	e7c3      	b.n	c188 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x11c>
			tft->println(i / 1024);
			tft->setColor(Color::brown);
			tft->fillRect(0, tft->height() - 10, (i * tft->width()) / image_size, 8);
		}
	}
	if(output){
    c200:	9e04      	ldr	r6, [sp, #16]
    c202:	2e00      	cmp	r6, #0
    c204:	d032      	beq.n	c26c <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x200>
		tft->fillRect(0, tft->height() - 10, tft->width(), 8);
    c206:	6823      	ldr	r3, [r4, #0]
    c208:	1c20      	adds	r0, r4, #0
    c20a:	6a9d      	ldr	r5, [r3, #40]	; 0x28
    c20c:	f7fd ff0c 	bl	a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>
    c210:	1c06      	adds	r6, r0, #0
    c212:	1c20      	adds	r0, r4, #0
    c214:	f7fd fef8 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
    c218:	3e0a      	subs	r6, #10
    c21a:	2108      	movs	r1, #8
    c21c:	1c03      	adds	r3, r0, #0
    c21e:	b232      	sxth	r2, r6
    c220:	9100      	str	r1, [sp, #0]
    c222:	1c20      	adds	r0, r4, #0
    c224:	2100      	movs	r1, #0
    c226:	47a8      	blx	r5
		tft->setColor(Color::white, Color::brown);
    c228:	1c20      	adds	r0, r4, #0
    c22a:	4941      	ldr	r1, [pc, #260]	; (c330 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2c4>)
    c22c:	4a3f      	ldr	r2, [pc, #252]	; (c32c <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2c0>)
    c22e:	f7fd fe07 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
	}
	
	if (output) {
		tft->cursorX = x;
    c232:	4e40      	ldr	r6, [pc, #256]	; (c334 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2c8>)
    c234:	9a06      	ldr	r2, [sp, #24]
		tft->cursorY = y;
    c236:	9b07      	ldr	r3, [sp, #28]
		tft->fillRect(0, tft->height() - 10, tft->width(), 8);
		tft->setColor(Color::white, Color::brown);
	}
	
	if (output) {
		tft->cursorX = x;
    c238:	8032      	strh	r2, [r6, #0]
		tft->cursorY = y;
		tft->println(image_size / 1024);
    c23a:	9a02      	ldr	r2, [sp, #8]
		tft->setColor(Color::white, Color::brown);
	}
	
	if (output) {
		tft->cursorX = x;
		tft->cursorY = y;
    c23c:	4d3e      	ldr	r5, [pc, #248]	; (c338 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2cc>)
		tft->println(image_size / 1024);
    c23e:	0a91      	lsrs	r1, r2, #10
    c240:	1c20      	adds	r0, r4, #0
    c242:	220a      	movs	r2, #10
		tft->setColor(Color::white, Color::brown);
	}
	
	if (output) {
		tft->cursorX = x;
		tft->cursorY = y;
    c244:	802b      	strh	r3, [r5, #0]
		tft->println(image_size / 1024);
    c246:	f003 fd08 	bl	fc5a <_ZN5Print7printlnEmi>
		tft->print(" Converting frames:\n ");
    c24a:	4943      	ldr	r1, [pc, #268]	; (c358 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2ec>)
    c24c:	1c20      	adds	r0, r4, #0
    c24e:	f003 fc91 	bl	fb74 <_ZN5Print5printEPKc>
		x = tft->cursorX;
    c252:	7836      	ldrb	r6, [r6, #0]
		y = tft->cursorY;
    c254:	782d      	ldrb	r5, [r5, #0]
		tft->print("      /");
    c256:	493e      	ldr	r1, [pc, #248]	; (c350 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2e4>)
    c258:	1c20      	adds	r0, r4, #0
	if (output) {
		tft->cursorX = x;
		tft->cursorY = y;
		tft->println(image_size / 1024);
		tft->print(" Converting frames:\n ");
		x = tft->cursorX;
    c25a:	9606      	str	r6, [sp, #24]
		y = tft->cursorY;
    c25c:	9507      	str	r5, [sp, #28]
		tft->print("      /");
    c25e:	f003 fc89 	bl	fb74 <_ZN5Print5printEPKc>
		tft->print(frames);
    c262:	1c20      	adds	r0, r4, #0
    c264:	9905      	ldr	r1, [sp, #20]
    c266:	220a      	movs	r2, #10
    c268:	f003 fce5 	bl	fc36 <_ZN5Print5printEii>
	}
	setFrame(0);
    c26c:	1c38      	adds	r0, r7, #0
    c26e:	2100      	movs	r1, #0
    c270:	f7ff feea 	bl	c048 <_ZN14Gamebuino_Meta3GMV8setFrameEt>
	for (uint16_t i = 0; i < frames; i++) {
    c274:	2500      	movs	r5, #0
    c276:	9a05      	ldr	r2, [sp, #20]
    c278:	b2ae      	uxth	r6, r5
    c27a:	9602      	str	r6, [sp, #8]
    c27c:	4296      	cmp	r6, r2
    c27e:	d233      	bcs.n	c2e8 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x27c>
		if (output) {
    c280:	9e04      	ldr	r6, [sp, #16]
    c282:	2e00      	cmp	r6, #0
    c284:	d022      	beq.n	c2cc <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x260>
			tft->cursorX = x;
    c286:	4b2b      	ldr	r3, [pc, #172]	; (c334 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2c8>)
    c288:	9e06      	ldr	r6, [sp, #24]
			tft->cursorY = y;
			tft->print(i+1); // +1 for human-readability
    c28a:	220a      	movs	r2, #10
		tft->print(frames);
	}
	setFrame(0);
	for (uint16_t i = 0; i < frames; i++) {
		if (output) {
			tft->cursorX = x;
    c28c:	801e      	strh	r6, [r3, #0]
			tft->cursorY = y;
    c28e:	4b2a      	ldr	r3, [pc, #168]	; (c338 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2cc>)
    c290:	9e07      	ldr	r6, [sp, #28]
    c292:	1c69      	adds	r1, r5, #1
			tft->print(i+1); // +1 for human-readability
    c294:	1c20      	adds	r0, r4, #0
	}
	setFrame(0);
	for (uint16_t i = 0; i < frames; i++) {
		if (output) {
			tft->cursorX = x;
			tft->cursorY = y;
    c296:	801e      	strh	r6, [r3, #0]
			tft->print(i+1); // +1 for human-readability
    c298:	f003 fccd 	bl	fc36 <_ZN5Print5printEii>
			tft->fillRect(0, tft->height() - 8, (i * tft->width()) / frames, 8);
    c29c:	6823      	ldr	r3, [r4, #0]
    c29e:	1c20      	adds	r0, r4, #0
    c2a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    c2a2:	9308      	str	r3, [sp, #32]
    c2a4:	f7fd fec0 	bl	a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>
    c2a8:	1c06      	adds	r6, r0, #0
    c2aa:	1c20      	adds	r0, r4, #0
    c2ac:	f7fd feac 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
    c2b0:	9905      	ldr	r1, [sp, #20]
    c2b2:	4368      	muls	r0, r5
    c2b4:	f005 f8be 	bl	11434 <__aeabi_idiv>
    c2b8:	3e08      	subs	r6, #8
    c2ba:	b236      	sxth	r6, r6
    c2bc:	2208      	movs	r2, #8
    c2be:	b203      	sxth	r3, r0
    c2c0:	9200      	str	r2, [sp, #0]
    c2c2:	1c20      	adds	r0, r4, #0
    c2c4:	1c32      	adds	r2, r6, #0
    c2c6:	2100      	movs	r1, #0
    c2c8:	9e08      	ldr	r6, [sp, #32]
    c2ca:	47b0      	blx	r6
		}
		readFrame();
    c2cc:	1c38      	adds	r0, r7, #0
    c2ce:	f7ff fe1d 	bl	bf0c <_ZN14Gamebuino_Meta3GMV9readFrameEv>
		bmp.writeFrame(i, img->_buffer, img->transparentColor, &f);
    c2d2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    c2d4:	a913      	add	r1, sp, #76	; 0x4c
    c2d6:	695a      	ldr	r2, [r3, #20]
    c2d8:	a80b      	add	r0, sp, #44	; 0x2c
    c2da:	891b      	ldrh	r3, [r3, #8]
    c2dc:	9100      	str	r1, [sp, #0]
    c2de:	9902      	ldr	r1, [sp, #8]
    c2e0:	f7ff fb11 	bl	b906 <_ZN14Gamebuino_Meta3BMP10writeFrameEtPttP4File>
    c2e4:	3501      	adds	r5, #1
    c2e6:	e7c6      	b.n	c276 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x20a>
	}
	if (output) {
    c2e8:	9e04      	ldr	r6, [sp, #16]
    c2ea:	2e00      	cmp	r6, #0
    c2ec:	d010      	beq.n	c310 <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E+0x2a4>
		tft->fillRect(0, tft->height() - 8, tft->width(), 8);
    c2ee:	6823      	ldr	r3, [r4, #0]
    c2f0:	1c20      	adds	r0, r4, #0
    c2f2:	6a9d      	ldr	r5, [r3, #40]	; 0x28
    c2f4:	f7fd fe98 	bl	a028 <_ZNK14Gamebuino_Meta8Graphics6heightEv>
    c2f8:	1c06      	adds	r6, r0, #0
    c2fa:	1c20      	adds	r0, r4, #0
    c2fc:	f7fd fe84 	bl	a008 <_ZNK14Gamebuino_Meta8Graphics5widthEv>
    c300:	3e08      	subs	r6, #8
    c302:	2108      	movs	r1, #8
    c304:	1c03      	adds	r3, r0, #0
    c306:	9100      	str	r1, [sp, #0]
    c308:	b232      	sxth	r2, r6
    c30a:	1c20      	adds	r0, r4, #0
    c30c:	2100      	movs	r1, #0
    c30e:	47a8      	blx	r5
	}
	bmp.setCreatorBits(CONVERT_MAGIC, &f); // ok we know that we have the GMV so why not?
    c310:	21a1      	movs	r1, #161	; 0xa1
    c312:	a80b      	add	r0, sp, #44	; 0x2c
    c314:	0609      	lsls	r1, r1, #24
    c316:	aa13      	add	r2, sp, #76	; 0x4c
    c318:	f7ff f8ce 	bl	b4b8 <_ZN14Gamebuino_Meta3BMP14setCreatorBitsEmP4File>
	f.close();
    c31c:	a817      	add	r0, sp, #92	; 0x5c
    c31e:	f001 f86b 	bl	d3f8 <_ZN7FatFile5closeEv>
	file.close();
    c322:	9803      	ldr	r0, [sp, #12]
    c324:	f001 f868 	bl	d3f8 <_ZN7FatFile5closeEv>
}
    c328:	b021      	add	sp, #132	; 0x84
    c32a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c32c:	0000cc68 	.word	0x0000cc68
    c330:	0000ffff 	.word	0x0000ffff
    c334:	20000cdc 	.word	0x20000cdc
    c338:	20000cc4 	.word	0x20000cc4
    c33c:	20000cd4 	.word	0x20000cd4
    c340:	000154cb 	.word	0x000154cb
    c344:	20000a04 	.word	0x20000a04
    c348:	000154db 	.word	0x000154db
    c34c:	000154f0 	.word	0x000154f0
    c350:	00015502 	.word	0x00015502
    c354:	0001550a 	.word	0x0001550a
    c358:	0001550d 	.word	0x0001550d

0000c35c <_ZN14Gamebuino_Meta16Frame_Handler_SDD1Ev>:
		delete gmv; // no need to keep you
		gmv = 0;
	}
}

Frame_Handler_SD::~Frame_Handler_SD() {
    c35c:	b510      	push	{r4, lr}
    c35e:	4b09      	ldr	r3, [pc, #36]	; (c384 <_ZN14Gamebuino_Meta16Frame_Handler_SDD1Ev+0x28>)
	if (img->frames && gmv) {
    c360:	6842      	ldr	r2, [r0, #4]
		delete gmv; // no need to keep you
		gmv = 0;
	}
}

Frame_Handler_SD::~Frame_Handler_SD() {
    c362:	3308      	adds	r3, #8
    c364:	6003      	str	r3, [r0, #0]
	if (img->frames && gmv) {
    c366:	8b13      	ldrh	r3, [r2, #24]
		delete gmv; // no need to keep you
		gmv = 0;
	}
}

Frame_Handler_SD::~Frame_Handler_SD() {
    c368:	1c04      	adds	r4, r0, #0
	if (img->frames && gmv) {
    c36a:	2b00      	cmp	r3, #0
    c36c:	d004      	beq.n	c378 <_ZN14Gamebuino_Meta16Frame_Handler_SDD1Ev+0x1c>
    c36e:	6900      	ldr	r0, [r0, #16]
    c370:	2800      	cmp	r0, #0
    c372:	d001      	beq.n	c378 <_ZN14Gamebuino_Meta16Frame_Handler_SDD1Ev+0x1c>
		delete gmv;
    c374:	f003 ff64 	bl	10240 <_ZdlPv>
	}
}
    c378:	1c20      	adds	r0, r4, #0
    c37a:	f7fd fe65 	bl	a048 <_ZN14Gamebuino_Meta13Frame_HandlerD1Ev>
    c37e:	1c20      	adds	r0, r4, #0
    c380:	bd10      	pop	{r4, pc}
    c382:	46c0      	nop			; (mov r8, r8)
    c384:	00015528 	.word	0x00015528

0000c388 <_ZN14Gamebuino_Meta16Frame_Handler_SDD0Ev>:
		delete gmv; // no need to keep you
		gmv = 0;
	}
}

Frame_Handler_SD::~Frame_Handler_SD() {
    c388:	b510      	push	{r4, lr}
    c38a:	1c04      	adds	r4, r0, #0
	if (img->frames && gmv) {
		delete gmv;
	}
}
    c38c:	f7ff ffe6 	bl	c35c <_ZN14Gamebuino_Meta16Frame_Handler_SDD1Ev>
    c390:	1c20      	adds	r0, r4, #0
    c392:	f003 ff55 	bl	10240 <_ZdlPv>
    c396:	1c20      	adds	r0, r4, #0
    c398:	bd10      	pop	{r4, pc}
	...

0000c39c <_ZN14Gamebuino_Meta16Frame_Handler_SDC1EPNS_5ImageE>:


Recording_Image* recording_images[MAX_IMAGE_RECORDING];
Display_ST7735* tft;

Frame_Handler_SD::Frame_Handler_SD(Image* img) : Frame_Handler(img) {
    c39c:	b510      	push	{r4, lr}
    c39e:	1c04      	adds	r4, r0, #0
    c3a0:	f7fe fc44 	bl	ac2c <_ZN14Gamebuino_Meta13Frame_HandlerC1EPNS_5ImageE>
    c3a4:	4b03      	ldr	r3, [pc, #12]	; (c3b4 <_ZN14Gamebuino_Meta16Frame_Handler_SDC1EPNS_5ImageE+0x18>)
	gmv = 0;
}
    c3a6:	1c20      	adds	r0, r4, #0


Recording_Image* recording_images[MAX_IMAGE_RECORDING];
Display_ST7735* tft;

Frame_Handler_SD::Frame_Handler_SD(Image* img) : Frame_Handler(img) {
    c3a8:	3308      	adds	r3, #8
    c3aa:	6023      	str	r3, [r4, #0]
	gmv = 0;
    c3ac:	2300      	movs	r3, #0
    c3ae:	6123      	str	r3, [r4, #16]
}
    c3b0:	bd10      	pop	{r4, pc}
    c3b2:	46c0      	nop			; (mov r8, r8)
    c3b4:	00015528 	.word	0x00015528

0000c3b8 <_ZN14Gamebuino_Meta16Frame_Handler_SD4initEPc>:

void Frame_Handler_SD::init(char* filename) {
    c3b8:	b570      	push	{r4, r5, r6, lr}
    c3ba:	1c04      	adds	r4, r0, #0
	gmv = new GMV(img, filename);
    c3bc:	203c      	movs	r0, #60	; 0x3c

Frame_Handler_SD::Frame_Handler_SD(Image* img) : Frame_Handler(img) {
	gmv = 0;
}

void Frame_Handler_SD::init(char* filename) {
    c3be:	1c0e      	adds	r6, r1, #0
	gmv = new GMV(img, filename);
    c3c0:	f003 ff36 	bl	10230 <_Znwj>
    c3c4:	6861      	ldr	r1, [r4, #4]
    c3c6:	1c05      	adds	r5, r0, #0
    c3c8:	1c32      	adds	r2, r6, #0
    c3ca:	f7ff fc97 	bl	bcfc <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageEPc>
    c3ce:	6125      	str	r5, [r4, #16]
	if (!gmv->isValid()) {
    c3d0:	1c28      	adds	r0, r5, #0
    c3d2:	f7ff fad3 	bl	b97c <_ZN14Gamebuino_Meta3GMV7isValidEv>
    c3d6:	6863      	ldr	r3, [r4, #4]
		if (img->frames == 0) {
    c3d8:	8b1b      	ldrh	r3, [r3, #24]
	gmv = 0;
}

void Frame_Handler_SD::init(char* filename) {
	gmv = new GMV(img, filename);
	if (!gmv->isValid()) {
    c3da:	2800      	cmp	r0, #0
    c3dc:	d106      	bne.n	c3ec <_ZN14Gamebuino_Meta16Frame_Handler_SD4initEPc+0x34>
		if (img->frames == 0) {
    c3de:	2b00      	cmp	r3, #0
    c3e0:	d10e      	bne.n	c400 <_ZN14Gamebuino_Meta16Frame_Handler_SD4initEPc+0x48>
			delete gmv;
    c3e2:	6920      	ldr	r0, [r4, #16]
    c3e4:	f003 ff2c 	bl	10240 <_ZdlPv>
			lazy_filename = filename;
    c3e8:	6126      	str	r6, [r4, #16]
    c3ea:	e009      	b.n	c400 <_ZN14Gamebuino_Meta16Frame_Handler_SD4initEPc+0x48>
		}
		return;
	}
	if (img->frames == 1) {
    c3ec:	2b01      	cmp	r3, #1
    c3ee:	d107      	bne.n	c400 <_ZN14Gamebuino_Meta16Frame_Handler_SD4initEPc+0x48>
		gmv->readFrame();
    c3f0:	6920      	ldr	r0, [r4, #16]
    c3f2:	f7ff fd8b 	bl	bf0c <_ZN14Gamebuino_Meta3GMV9readFrameEv>
		delete gmv; // no need to keep you
    c3f6:	6920      	ldr	r0, [r4, #16]
    c3f8:	f003 ff22 	bl	10240 <_ZdlPv>
		gmv = 0;
    c3fc:	2300      	movs	r3, #0
    c3fe:	6123      	str	r3, [r4, #16]
	}
}
    c400:	bd70      	pop	{r4, r5, r6, pc}

0000c402 <_ZN14Gamebuino_Meta16Frame_Handler_SD9lazy_initEv>:
	if (img->frames && gmv) {
		delete gmv;
	}
}

void Frame_Handler_SD::lazy_init() {
    c402:	b538      	push	{r3, r4, r5, lr}
	if (img->frames) {
    c404:	6842      	ldr	r2, [r0, #4]
	if (img->frames && gmv) {
		delete gmv;
	}
}

void Frame_Handler_SD::lazy_init() {
    c406:	1c04      	adds	r4, r0, #0
	if (img->frames) {
    c408:	8b13      	ldrh	r3, [r2, #24]
    c40a:	2b00      	cmp	r3, #0
    c40c:	d10e      	bne.n	c42c <_ZN14Gamebuino_Meta16Frame_Handler_SD9lazy_initEv+0x2a>
		// we already inited
		return;
	}
	init(lazy_filename);
    c40e:	6921      	ldr	r1, [r4, #16]
    c410:	f7ff ffd2 	bl	c3b8 <_ZN14Gamebuino_Meta16Frame_Handler_SD4initEPc>
	if (!gmv->isValid()) {
    c414:	6920      	ldr	r0, [r4, #16]
    c416:	f7ff fab1 	bl	b97c <_ZN14Gamebuino_Meta3GMV7isValidEv>
    c41a:	1e05      	subs	r5, r0, #0
    c41c:	d106      	bne.n	c42c <_ZN14Gamebuino_Meta16Frame_Handler_SD9lazy_initEv+0x2a>
		// we are lost
		delete gmv;
    c41e:	6920      	ldr	r0, [r4, #16]
    c420:	f003 ff0e 	bl	10240 <_ZdlPv>
		gmv = 0;
		img->frames = 1;
    c424:	6863      	ldr	r3, [r4, #4]
    c426:	2201      	movs	r2, #1
	}
	init(lazy_filename);
	if (!gmv->isValid()) {
		// we are lost
		delete gmv;
		gmv = 0;
    c428:	6125      	str	r5, [r4, #16]
		img->frames = 1;
    c42a:	831a      	strh	r2, [r3, #24]
	}
}
    c42c:	bd38      	pop	{r3, r4, r5, pc}

0000c42e <_ZN14Gamebuino_Meta16Frame_Handler_SD4nextEv>:

void Frame_Handler_SD::next() {
    c42e:	b510      	push	{r4, lr}
    c430:	1c04      	adds	r4, r0, #0
	lazy_init();
    c432:	f7ff ffe6 	bl	c402 <_ZN14Gamebuino_Meta16Frame_Handler_SD9lazy_initEv>
	if (gmv) {
    c436:	6920      	ldr	r0, [r4, #16]
    c438:	2800      	cmp	r0, #0
    c43a:	d001      	beq.n	c440 <_ZN14Gamebuino_Meta16Frame_Handler_SD4nextEv+0x12>
		gmv->readFrame();
    c43c:	f7ff fd66 	bl	bf0c <_ZN14Gamebuino_Meta3GMV9readFrameEv>
	}
}
    c440:	bd10      	pop	{r4, pc}

0000c442 <_ZN14Gamebuino_Meta16Frame_Handler_SD3setEt>:

void Frame_Handler_SD::set(uint16_t frame) {
    c442:	b538      	push	{r3, r4, r5, lr}
    c444:	1c04      	adds	r4, r0, #0
    c446:	1c0d      	adds	r5, r1, #0
	lazy_init();
    c448:	f7ff ffdb 	bl	c402 <_ZN14Gamebuino_Meta16Frame_Handler_SD9lazy_initEv>
	if (gmv) {
    c44c:	6920      	ldr	r0, [r4, #16]
    c44e:	2800      	cmp	r0, #0
    c450:	d005      	beq.n	c45e <_ZN14Gamebuino_Meta16Frame_Handler_SD3setEt+0x1c>
		gmv->setFrame(frame);
    c452:	1c29      	adds	r1, r5, #0
    c454:	f7ff fdf8 	bl	c048 <_ZN14Gamebuino_Meta3GMV8setFrameEt>
		gmv->readFrame();
    c458:	6920      	ldr	r0, [r4, #16]
    c45a:	f7ff fd57 	bl	bf0c <_ZN14Gamebuino_Meta3GMV9readFrameEv>
	}
}
    c45e:	bd38      	pop	{r3, r4, r5, pc}

0000c460 <_ZN14Gamebuino_Meta15Recording_ImageC1ERNS_3GMVE>:


Recording_Image::Recording_Image(GMV& _gmv) {
    c460:	b570      	push	{r4, r5, r6, lr}
    c462:	1c0d      	adds	r5, r1, #0
    c464:	1c04      	adds	r4, r0, #0
    c466:	3004      	adds	r0, #4
    c468:	f7ff fa76 	bl	b958 <_ZN14Gamebuino_Meta3GMVC1Ev>
/**
 * \class File
 * \brief Arduino SD.h style File API
 */
#if ARDUINO_FILE_USES_STREAM
class File : public FatFile, public Stream {
    c46c:	1c2a      	adds	r2, r5, #0
    c46e:	1c23      	adds	r3, r4, #0
    c470:	3314      	adds	r3, #20
    c472:	3210      	adds	r2, #16
    c474:	ca43      	ldmia	r2!, {r0, r1, r6}
    c476:	c343      	stmia	r3!, {r0, r1, r6}
    c478:	ca43      	ldmia	r2!, {r0, r1, r6}
    c47a:	c343      	stmia	r3!, {r0, r1, r6}
    c47c:	ca43      	ldmia	r2!, {r0, r1, r6}
    c47e:	c343      	stmia	r3!, {r0, r1, r6}
    c480:	68eb      	ldr	r3, [r5, #12]
    c482:	6868      	ldr	r0, [r5, #4]
    c484:	68a9      	ldr	r1, [r5, #8]
#include "../Display-ST7735.h"
#include "../Graphics.h"

namespace Gamebuino_Meta {

class GMV {
    c486:	6b6e      	ldr	r6, [r5, #52]	; 0x34
    c488:	6123      	str	r3, [r4, #16]
    c48a:	1c2b      	adds	r3, r5, #0
    c48c:	60a0      	str	r0, [r4, #8]
    c48e:	63a6      	str	r6, [r4, #56]	; 0x38
    c490:	60e1      	str	r1, [r4, #12]
    c492:	3338      	adds	r3, #56	; 0x38
    c494:	781a      	ldrb	r2, [r3, #0]
    c496:	1c23      	adds	r3, r4, #0
    c498:	333c      	adds	r3, #60	; 0x3c
    c49a:	701a      	strb	r2, [r3, #0]
    c49c:	8f6b      	ldrh	r3, [r5, #58]	; 0x3a
	gmv = _gmv;
	frames = 0;
    c49e:	1ca2      	adds	r2, r4, #2
    c4a0:	87e3      	strh	r3, [r4, #62]	; 0x3e
    c4a2:	2300      	movs	r3, #0
    c4a4:	87d3      	strh	r3, [r2, #62]	; 0x3e
	bmp_filename = 0;
}
    c4a6:	1c20      	adds	r0, r4, #0


Recording_Image::Recording_Image(GMV& _gmv) {
	gmv = _gmv;
	frames = 0;
	bmp_filename = 0;
    c4a8:	6023      	str	r3, [r4, #0]
}
    c4aa:	bd70      	pop	{r4, r5, r6, pc}

0000c4ac <_ZN14Gamebuino_Meta15Recording_ImageD1Ev>:

Recording_Image::~Recording_Image() {
    c4ac:	b510      	push	{r4, lr}
    c4ae:	1c04      	adds	r4, r0, #0
	if (bmp_filename) {
    c4b0:	6800      	ldr	r0, [r0, #0]
    c4b2:	2800      	cmp	r0, #0
    c4b4:	d001      	beq.n	c4ba <_ZN14Gamebuino_Meta15Recording_ImageD1Ev+0xe>
		free(bmp_filename);
    c4b6:	f005 f867 	bl	11588 <free>
	}
}
    c4ba:	1c20      	adds	r0, r4, #0
    c4bc:	bd10      	pop	{r4, pc}

0000c4be <_ZN14Gamebuino_Meta15Recording_Image6updateEv>:

void Recording_Image::update() {
    c4be:	b510      	push	{r4, lr}
    c4c0:	1c04      	adds	r4, r0, #0
	gmv.writeFrame();
	frames++;
    c4c2:	3402      	adds	r4, #2
		free(bmp_filename);
	}
}

void Recording_Image::update() {
	gmv.writeFrame();
    c4c4:	3004      	adds	r0, #4
    c4c6:	f7ff fd1b 	bl	bf00 <_ZN14Gamebuino_Meta3GMV10writeFrameEv>
	frames++;
    c4ca:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
    c4cc:	3301      	adds	r3, #1
    c4ce:	87e3      	strh	r3, [r4, #62]	; 0x3e
}
    c4d0:	bd10      	pop	{r4, pc}
	...

0000c4d4 <_ZN14Gamebuino_Meta15Recording_Image6finishEb>:

bool Recording_Image::is(Image* img) {
	return gmv.is(img);
}

void Recording_Image::finish(bool output) {
    c4d4:	b513      	push	{r0, r1, r4, lr}
    c4d6:	1c0b      	adds	r3, r1, #0
	gmv.finishSave(bmp_filename, frames, output, tft);
    c4d8:	1d04      	adds	r4, r0, #4
    c4da:	6801      	ldr	r1, [r0, #0]
    c4dc:	3002      	adds	r0, #2
    c4de:	8fc2      	ldrh	r2, [r0, #62]	; 0x3e
    c4e0:	4803      	ldr	r0, [pc, #12]	; (c4f0 <_ZN14Gamebuino_Meta15Recording_Image6finishEb+0x1c>)
    c4e2:	6800      	ldr	r0, [r0, #0]
    c4e4:	9000      	str	r0, [sp, #0]
    c4e6:	1c20      	adds	r0, r4, #0
    c4e8:	f7ff fdc0 	bl	c06c <_ZN14Gamebuino_Meta3GMV10finishSaveEPctbPNS_14Display_ST7735E>
}
    c4ec:	bd13      	pop	{r0, r1, r4, pc}
    c4ee:	46c0      	nop			; (mov r8, r8)
    c4f0:	20000ce8 	.word	0x20000ce8

0000c4f4 <_ZN14Gamebuino_Meta15Recording_Image14setBmpFilenameEPc>:

void Recording_Image::setBmpFilename(char* filename) {
    c4f4:	b530      	push	{r4, r5, lr}
    c4f6:	1c04      	adds	r4, r0, #0
    c4f8:	b08f      	sub	sp, #60	; 0x3c
	bmp_filename = (char*)malloc(strlen(filename) + 1);
    c4fa:	1c08      	adds	r0, r1, #0

void Recording_Image::finish(bool output) {
	gmv.finishSave(bmp_filename, frames, output, tft);
}

void Recording_Image::setBmpFilename(char* filename) {
    c4fc:	1c0d      	adds	r5, r1, #0
	bmp_filename = (char*)malloc(strlen(filename) + 1);
    c4fe:	f005 f98d 	bl	1181c <strlen>
    c502:	3001      	adds	r0, #1
    c504:	f005 f836 	bl	11574 <malloc>
	strcpy(bmp_filename, filename);
    c508:	1c29      	adds	r1, r5, #0
void Recording_Image::finish(bool output) {
	gmv.finishSave(bmp_filename, frames, output, tft);
}

void Recording_Image::setBmpFilename(char* filename) {
	bmp_filename = (char*)malloc(strlen(filename) + 1);
    c50a:	6020      	str	r0, [r4, #0]
	strcpy(bmp_filename, filename);
    c50c:	f005 f97e 	bl	1180c <strcpy>
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
    c510:	23fa      	movs	r3, #250	; 0xfa
    c512:	009b      	lsls	r3, r3, #2
    c514:	9303      	str	r3, [sp, #12]
#else  // ARDUINO_FILE_USES_STREAM
class File : public FatFile, public Print {
#endif  // ARDUINO_FILE_USES_STREAM
 public:
  File() {}
    c516:	4b0b      	ldr	r3, [pc, #44]	; (c544 <_ZN14Gamebuino_Meta15Recording_Image14setBmpFilenameEPc+0x50>)
	File f = SD.open(bmp_filename, FILE_WRITE);
    c518:	6822      	ldr	r2, [r4, #0]
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
    c51a:	2500      	movs	r5, #0
    c51c:	ac01      	add	r4, sp, #4
    c51e:	9301      	str	r3, [sp, #4]
    c520:	7425      	strb	r5, [r4, #16]
    c522:	2363      	movs	r3, #99	; 0x63
    c524:	7465      	strb	r5, [r4, #17]
    c526:	a805      	add	r0, sp, #20
    c528:	4907      	ldr	r1, [pc, #28]	; (c548 <_ZN14Gamebuino_Meta15Recording_Image14setBmpFilenameEPc+0x54>)
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    c52a:	9502      	str	r5, [sp, #8]
    c52c:	f000 ff6b 	bl	d406 <_ZN7FatFile4openEPS_PKch>
	f.write((uint8_t)0); // make sure we already create it
    c530:	1c29      	adds	r1, r5, #0
    c532:	1c20      	adds	r0, r4, #0
    c534:	f7f9 fbd9 	bl	5cea <_ZN4File5writeEh>
	f.close();
    c538:	a805      	add	r0, sp, #20
    c53a:	f000 ff5d 	bl	d3f8 <_ZN7FatFile5closeEv>
}
    c53e:	b00f      	add	sp, #60	; 0x3c
    c540:	bd30      	pop	{r4, r5, pc}
    c542:	46c0      	nop			; (mov r8, r8)
    c544:	00014a40 	.word	0x00014a40
    c548:	20000a04 	.word	0x20000a04

0000c54c <_ZN14Gamebuino_Meta11Graphics_SD14startRecordingEPNS_5ImageEPc>:


bool Graphics_SD::startRecording(Image* img, char* filename) {
    c54c:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t i = 0;
	for (; i < MAX_IMAGE_RECORDING; i++) {
		if (!recording_images[i]) {
    c54e:	4f1f      	ldr	r7, [pc, #124]	; (c5cc <_ZN14Gamebuino_Meta11Graphics_SD14startRecordingEPNS_5ImageEPc+0x80>)
	f.write((uint8_t)0); // make sure we already create it
	f.close();
}


bool Graphics_SD::startRecording(Image* img, char* filename) {
    c550:	b093      	sub	sp, #76	; 0x4c
	uint8_t i = 0;
	for (; i < MAX_IMAGE_RECORDING; i++) {
		if (!recording_images[i]) {
    c552:	683b      	ldr	r3, [r7, #0]
	f.write((uint8_t)0); // make sure we already create it
	f.close();
}


bool Graphics_SD::startRecording(Image* img, char* filename) {
    c554:	1c05      	adds	r5, r0, #0
    c556:	1c0c      	adds	r4, r1, #0
	uint8_t i = 0;
	for (; i < MAX_IMAGE_RECORDING; i++) {
		if (!recording_images[i]) {
    c558:	2b00      	cmp	r3, #0
    c55a:	d005      	beq.n	c568 <_ZN14Gamebuino_Meta11Graphics_SD14startRecordingEPNS_5ImageEPc+0x1c>
    c55c:	687a      	ldr	r2, [r7, #4]
    c55e:	2a00      	cmp	r2, #0
    c560:	d001      	beq.n	c566 <_ZN14Gamebuino_Meta11Graphics_SD14startRecordingEPNS_5ImageEPc+0x1a>
			break;
		}
	}
	if (i == MAX_IMAGE_RECORDING) {
		return false; // no empty slot
    c562:	2500      	movs	r5, #0
    c564:	e02e      	b.n	c5c4 <_ZN14Gamebuino_Meta11Graphics_SD14startRecordingEPNS_5ImageEPc+0x78>
}


bool Graphics_SD::startRecording(Image* img, char* filename) {
	uint8_t i = 0;
	for (; i < MAX_IMAGE_RECORDING; i++) {
    c566:	2301      	movs	r3, #1
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return vwd()->exists(path);
    c568:	4e19      	ldr	r6, [pc, #100]	; (c5d0 <_ZN14Gamebuino_Meta11Graphics_SD14startRecordingEPNS_5ImageEPc+0x84>)
    c56a:	1c21      	adds	r1, r4, #0
    c56c:	1c30      	adds	r0, r6, #0
    c56e:	9301      	str	r3, [sp, #4]
    c570:	f7f9 fbc5 	bl	5cfe <_ZN7FatFile6existsEPKc>
	}
	if (i == MAX_IMAGE_RECORDING) {
		return false; // no empty slot
	}
	bool convert_bmp = true;
	if (convert_bmp && SD.exists(filename) && !SD.remove(filename)) {
    c574:	2800      	cmp	r0, #0
    c576:	d005      	beq.n	c584 <_ZN14Gamebuino_Meta11Graphics_SD14startRecordingEPNS_5ImageEPc+0x38>
  *
  * \return The value true is returned for success and
  * the value false is returned for failure.
  */
  bool remove(const char* path) {
    return FatFile::remove(vwd(), path);
    c578:	4815      	ldr	r0, [pc, #84]	; (c5d0 <_ZN14Gamebuino_Meta11Graphics_SD14startRecordingEPNS_5ImageEPc+0x84>)
    c57a:	1c21      	adds	r1, r4, #0
    c57c:	f000 ff92 	bl	d4a4 <_ZN7FatFile6removeEPS_PKc>
    c580:	2800      	cmp	r0, #0
    c582:	d0ee      	beq.n	c562 <_ZN14Gamebuino_Meta11Graphics_SD14startRecordingEPNS_5ImageEPc+0x16>
		return false;
	}
	GMV gmv = GMV(img);
    c584:	1c29      	adds	r1, r5, #0
    c586:	a803      	add	r0, sp, #12
    c588:	f7ff f9f0 	bl	b96c <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageE>
	if (!gmv.initSave(filename)) {
    c58c:	a803      	add	r0, sp, #12
    c58e:	1c21      	adds	r1, r4, #0
    c590:	f7ff fa90 	bl	bab4 <_ZN14Gamebuino_Meta3GMV8initSaveEPc>
    c594:	1e05      	subs	r5, r0, #0
    c596:	d0e4      	beq.n	c562 <_ZN14Gamebuino_Meta11Graphics_SD14startRecordingEPNS_5ImageEPc+0x16>
		return false;
	}
	Recording_Image* rec = new Recording_Image(gmv);
    c598:	2044      	movs	r0, #68	; 0x44
    c59a:	f003 fe49 	bl	10230 <_Znwj>
    c59e:	a903      	add	r1, sp, #12
    c5a0:	1c06      	adds	r6, r0, #0
    c5a2:	f7ff ff5d 	bl	c460 <_ZN14Gamebuino_Meta15Recording_ImageC1ERNS_3GMVE>
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return vwd()->exists(path);
    c5a6:	480a      	ldr	r0, [pc, #40]	; (c5d0 <_ZN14Gamebuino_Meta11Graphics_SD14startRecordingEPNS_5ImageEPc+0x84>)
    c5a8:	1c21      	adds	r1, r4, #0
    c5aa:	f7f9 fba8 	bl	5cfe <_ZN7FatFile6existsEPKc>
	if (convert_bmp && !SD.exists(filename)) {
    c5ae:	2800      	cmp	r0, #0
    c5b0:	d003      	beq.n	c5ba <_ZN14Gamebuino_Meta11Graphics_SD14startRecordingEPNS_5ImageEPc+0x6e>
		rec->setBmpFilename(filename);
	}
	recording_images[i] = rec;
    c5b2:	9a01      	ldr	r2, [sp, #4]
    c5b4:	0093      	lsls	r3, r2, #2
    c5b6:	50fe      	str	r6, [r7, r3]
	return true;
    c5b8:	e004      	b.n	c5c4 <_ZN14Gamebuino_Meta11Graphics_SD14startRecordingEPNS_5ImageEPc+0x78>
	if (!gmv.initSave(filename)) {
		return false;
	}
	Recording_Image* rec = new Recording_Image(gmv);
	if (convert_bmp && !SD.exists(filename)) {
		rec->setBmpFilename(filename);
    c5ba:	1c30      	adds	r0, r6, #0
    c5bc:	1c21      	adds	r1, r4, #0
    c5be:	f7ff ff99 	bl	c4f4 <_ZN14Gamebuino_Meta15Recording_Image14setBmpFilenameEPc>
    c5c2:	e7f6      	b.n	c5b2 <_ZN14Gamebuino_Meta11Graphics_SD14startRecordingEPNS_5ImageEPc+0x66>
	}
	recording_images[i] = rec;
	return true;
}
    c5c4:	1c28      	adds	r0, r5, #0
    c5c6:	b013      	add	sp, #76	; 0x4c
    c5c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c5ca:	46c0      	nop			; (mov r8, r8)
    c5cc:	20000ce0 	.word	0x20000ce0
    c5d0:	20000a04 	.word	0x20000a04

0000c5d4 <_ZN14Gamebuino_Meta11Graphics_SD13stopRecordingEPNS_5ImageEb>:

void Graphics_SD::stopRecording(Image* img, bool output) {
    c5d4:	b570      	push	{r4, r5, r6, lr}
	uint8_t i = 0;
	for (; i < MAX_IMAGE_RECORDING; i++) {
		if (!recording_images[i]) {
    c5d6:	4c14      	ldr	r4, [pc, #80]	; (c628 <_ZN14Gamebuino_Meta11Graphics_SD13stopRecordingEPNS_5ImageEb+0x54>)
	}
	recording_images[i] = rec;
	return true;
}

void Graphics_SD::stopRecording(Image* img, bool output) {
    c5d8:	1c05      	adds	r5, r0, #0
	uint8_t i = 0;
	for (; i < MAX_IMAGE_RECORDING; i++) {
		if (!recording_images[i]) {
    c5da:	6820      	ldr	r0, [r4, #0]
	}
	recording_images[i] = rec;
	return true;
}

void Graphics_SD::stopRecording(Image* img, bool output) {
    c5dc:	1c0e      	adds	r6, r1, #0
	uint8_t i = 0;
	for (; i < MAX_IMAGE_RECORDING; i++) {
		if (!recording_images[i]) {
    c5de:	2800      	cmp	r0, #0
    c5e0:	d005      	beq.n	c5ee <_ZN14Gamebuino_Meta11Graphics_SD13stopRecordingEPNS_5ImageEb+0x1a>
	gmv.writeFrame();
	frames++;
}

bool Recording_Image::is(Image* img) {
	return gmv.is(img);
    c5e2:	3004      	adds	r0, #4
    c5e4:	1c29      	adds	r1, r5, #0
    c5e6:	f7ff f9cc 	bl	b982 <_ZN14Gamebuino_Meta3GMV2isEPNS_5ImageE>
	uint8_t i = 0;
	for (; i < MAX_IMAGE_RECORDING; i++) {
		if (!recording_images[i]) {
			continue;
		}
		if (recording_images[i]->is(img)) {
    c5ea:	2800      	cmp	r0, #0
    c5ec:	d10a      	bne.n	c604 <_ZN14Gamebuino_Meta11Graphics_SD13stopRecordingEPNS_5ImageEb+0x30>
}

void Graphics_SD::stopRecording(Image* img, bool output) {
	uint8_t i = 0;
	for (; i < MAX_IMAGE_RECORDING; i++) {
		if (!recording_images[i]) {
    c5ee:	6860      	ldr	r0, [r4, #4]
    c5f0:	2800      	cmp	r0, #0
    c5f2:	d018      	beq.n	c626 <_ZN14Gamebuino_Meta11Graphics_SD13stopRecordingEPNS_5ImageEb+0x52>
	gmv.writeFrame();
	frames++;
}

bool Recording_Image::is(Image* img) {
	return gmv.is(img);
    c5f4:	3004      	adds	r0, #4
    c5f6:	1c29      	adds	r1, r5, #0
    c5f8:	f7ff f9c3 	bl	b982 <_ZN14Gamebuino_Meta3GMV2isEPNS_5ImageE>
	uint8_t i = 0;
	for (; i < MAX_IMAGE_RECORDING; i++) {
		if (!recording_images[i]) {
			continue;
		}
		if (recording_images[i]->is(img)) {
    c5fc:	2800      	cmp	r0, #0
    c5fe:	d012      	beq.n	c626 <_ZN14Gamebuino_Meta11Graphics_SD13stopRecordingEPNS_5ImageEb+0x52>
}

void Graphics_SD::stopRecording(Image* img, bool output) {
	uint8_t i = 0;
	for (; i < MAX_IMAGE_RECORDING; i++) {
		if (!recording_images[i]) {
    c600:	2501      	movs	r5, #1
    c602:	e000      	b.n	c606 <_ZN14Gamebuino_Meta11Graphics_SD13stopRecordingEPNS_5ImageEb+0x32>
    c604:	2500      	movs	r5, #0
		}
	}
	if (i == MAX_IMAGE_RECORDING) {
		return; // image not found
	}
	recording_images[i]->finish(output);
    c606:	00ad      	lsls	r5, r5, #2
    c608:	1c31      	adds	r1, r6, #0
    c60a:	5960      	ldr	r0, [r4, r5]
    c60c:	f7ff ff62 	bl	c4d4 <_ZN14Gamebuino_Meta15Recording_Image6finishEb>
	delete recording_images[i];
    c610:	5966      	ldr	r6, [r4, r5]
    c612:	2e00      	cmp	r6, #0
    c614:	d005      	beq.n	c622 <_ZN14Gamebuino_Meta11Graphics_SD13stopRecordingEPNS_5ImageEb+0x4e>
    c616:	1c30      	adds	r0, r6, #0
    c618:	f7ff ff48 	bl	c4ac <_ZN14Gamebuino_Meta15Recording_ImageD1Ev>
    c61c:	1c30      	adds	r0, r6, #0
    c61e:	f003 fe0f 	bl	10240 <_ZdlPv>
	recording_images[i] = 0;
    c622:	2300      	movs	r3, #0
    c624:	5163      	str	r3, [r4, r5]
}
    c626:	bd70      	pop	{r4, r5, r6, pc}
    c628:	20000ce0 	.word	0x20000ce0

0000c62c <_ZN14Gamebuino_Meta11Graphics_SD4saveEPNS_5ImageEPc>:

bool Graphics_SD::save(Image* img, char* filename) {
    c62c:	b570      	push	{r4, r5, r6, lr}
    c62e:	4e1c      	ldr	r6, [pc, #112]	; (c6a0 <_ZN14Gamebuino_Meta11Graphics_SD4saveEPNS_5ImageEPc+0x74>)
    c630:	b0a0      	sub	sp, #128	; 0x80
    c632:	1c05      	adds	r5, r0, #0
    c634:	1c30      	adds	r0, r6, #0
    c636:	1c0c      	adds	r4, r1, #0
    c638:	f7f9 fb61 	bl	5cfe <_ZN7FatFile6existsEPKc>
	bool convert_bmp = true; // for saving single frames we always convert
	if (convert_bmp && SD.exists(filename) && !SD.remove(filename)) {
    c63c:	2800      	cmp	r0, #0
    c63e:	d007      	beq.n	c650 <_ZN14Gamebuino_Meta11Graphics_SD4saveEPNS_5ImageEPc+0x24>
  *
  * \return The value true is returned for success and
  * the value false is returned for failure.
  */
  bool remove(const char* path) {
    return FatFile::remove(vwd(), path);
    c640:	1c30      	adds	r0, r6, #0
    c642:	1c21      	adds	r1, r4, #0
    c644:	f000 ff2e 	bl	d4a4 <_ZN7FatFile6removeEPS_PKc>
    c648:	2800      	cmp	r0, #0
    c64a:	d101      	bne.n	c650 <_ZN14Gamebuino_Meta11Graphics_SD4saveEPNS_5ImageEPc+0x24>
		return false;
    c64c:	2500      	movs	r5, #0
    c64e:	e023      	b.n	c698 <_ZN14Gamebuino_Meta11Graphics_SD4saveEPNS_5ImageEPc+0x6c>
	}
	GMV gmv = GMV(img);
    c650:	1c29      	adds	r1, r5, #0
    c652:	4668      	mov	r0, sp
    c654:	f7ff f98a 	bl	b96c <_ZN14Gamebuino_Meta3GMVC1EPNS_5ImageE>
	if (!gmv.initSave(filename)) {
    c658:	4668      	mov	r0, sp
    c65a:	1c21      	adds	r1, r4, #0
    c65c:	f7ff fa2a 	bl	bab4 <_ZN14Gamebuino_Meta3GMV8initSaveEPc>
    c660:	1e05      	subs	r5, r0, #0
    c662:	d0f3      	beq.n	c64c <_ZN14Gamebuino_Meta11Graphics_SD4saveEPNS_5ImageEPc+0x20>
		return false;
	}
	Recording_Image rec = Recording_Image(gmv);
    c664:	4669      	mov	r1, sp
    c666:	a80f      	add	r0, sp, #60	; 0x3c
    c668:	f7ff fefa 	bl	c460 <_ZN14Gamebuino_Meta15Recording_ImageC1ERNS_3GMVE>
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return vwd()->exists(path);
    c66c:	1c30      	adds	r0, r6, #0
    c66e:	1c21      	adds	r1, r4, #0
    c670:	f7f9 fb45 	bl	5cfe <_ZN7FatFile6existsEPKc>
	if (convert_bmp && !SD.exists(filename)) {
    c674:	2800      	cmp	r0, #0
    c676:	d00a      	beq.n	c68e <_ZN14Gamebuino_Meta11Graphics_SD4saveEPNS_5ImageEPc+0x62>
		rec.setBmpFilename(filename);
	}
	rec.update();
    c678:	a80f      	add	r0, sp, #60	; 0x3c
    c67a:	f7ff ff20 	bl	c4be <_ZN14Gamebuino_Meta15Recording_Image6updateEv>
	rec.finish(false);
    c67e:	a80f      	add	r0, sp, #60	; 0x3c
    c680:	2100      	movs	r1, #0
    c682:	f7ff ff27 	bl	c4d4 <_ZN14Gamebuino_Meta15Recording_Image6finishEb>
	return true;
    c686:	a80f      	add	r0, sp, #60	; 0x3c
    c688:	f7ff ff10 	bl	c4ac <_ZN14Gamebuino_Meta15Recording_ImageD1Ev>
    c68c:	e004      	b.n	c698 <_ZN14Gamebuino_Meta11Graphics_SD4saveEPNS_5ImageEPc+0x6c>
	if (!gmv.initSave(filename)) {
		return false;
	}
	Recording_Image rec = Recording_Image(gmv);
	if (convert_bmp && !SD.exists(filename)) {
		rec.setBmpFilename(filename);
    c68e:	a80f      	add	r0, sp, #60	; 0x3c
    c690:	1c21      	adds	r1, r4, #0
    c692:	f7ff ff2f 	bl	c4f4 <_ZN14Gamebuino_Meta15Recording_Image14setBmpFilenameEPc>
    c696:	e7ef      	b.n	c678 <_ZN14Gamebuino_Meta11Graphics_SD4saveEPNS_5ImageEPc+0x4c>
	}
	rec.update();
	rec.finish(false);
	return true;
}
    c698:	1c28      	adds	r0, r5, #0
    c69a:	b020      	add	sp, #128	; 0x80
    c69c:	bd70      	pop	{r4, r5, r6, pc}
    c69e:	46c0      	nop			; (mov r8, r8)
    c6a0:	20000a04 	.word	0x20000a04

0000c6a4 <_ZN14Gamebuino_Meta11Graphics_SD6updateEv>:

void Graphics_SD::update() {
	for (uint8_t i = 0; i < MAX_IMAGE_RECORDING; i++) {
		if (recording_images[i]) {
    c6a4:	4b06      	ldr	r3, [pc, #24]	; (c6c0 <_ZN14Gamebuino_Meta11Graphics_SD6updateEv+0x1c>)
	rec.update();
	rec.finish(false);
	return true;
}

void Graphics_SD::update() {
    c6a6:	b510      	push	{r4, lr}
	for (uint8_t i = 0; i < MAX_IMAGE_RECORDING; i++) {
		if (recording_images[i]) {
    c6a8:	6818      	ldr	r0, [r3, #0]
    c6aa:	1c1c      	adds	r4, r3, #0
    c6ac:	2800      	cmp	r0, #0
    c6ae:	d001      	beq.n	c6b4 <_ZN14Gamebuino_Meta11Graphics_SD6updateEv+0x10>
			recording_images[i]->update();
    c6b0:	f7ff ff05 	bl	c4be <_ZN14Gamebuino_Meta15Recording_Image6updateEv>
	return true;
}

void Graphics_SD::update() {
	for (uint8_t i = 0; i < MAX_IMAGE_RECORDING; i++) {
		if (recording_images[i]) {
    c6b4:	6860      	ldr	r0, [r4, #4]
    c6b6:	2800      	cmp	r0, #0
    c6b8:	d001      	beq.n	c6be <_ZN14Gamebuino_Meta11Graphics_SD6updateEv+0x1a>
			recording_images[i]->update();
    c6ba:	f7ff ff00 	bl	c4be <_ZN14Gamebuino_Meta15Recording_Image6updateEv>
		}
	}
}
    c6be:	bd10      	pop	{r4, pc}
    c6c0:	20000ce0 	.word	0x20000ce0

0000c6c4 <_ZN14Gamebuino_Meta11Graphics_SD6setTftEPNS_14Display_ST7735E>:

void Graphics_SD::setTft(Display_ST7735* _tft) {
	tft = _tft;
    c6c4:	4b01      	ldr	r3, [pc, #4]	; (c6cc <_ZN14Gamebuino_Meta11Graphics_SD6setTftEPNS_14Display_ST7735E+0x8>)
    c6c6:	6018      	str	r0, [r3, #0]
}
    c6c8:	4770      	bx	lr
    c6ca:	46c0      	nop			; (mov r8, r8)
    c6cc:	20000ce8 	.word	0x20000ce8

0000c6d0 <_ZN14Gamebuino_Meta8Language14setCurrentLangENS_8LangCodeE>:
LangCode Language::getCurrentLang() {
	return currentLang;
}

void Language::setCurrentLang(LangCode c) {
	currentLang = c;
    c6d0:	4b01      	ldr	r3, [pc, #4]	; (c6d8 <_ZN14Gamebuino_Meta8Language14setCurrentLangENS_8LangCodeE+0x8>)
    c6d2:	6018      	str	r0, [r3, #0]
}
    c6d4:	4770      	bx	lr
    c6d6:	46c0      	nop			; (mov r8, r8)
    c6d8:	20000078 	.word	0x20000078

0000c6dc <_ZN14Gamebuino_Meta8Language3getEPKNS_9MultiLangEh>:

const char* Language::get(const MultiLang* l, uint8_t num) {
	const char* def = 0;
	for (uint8_t i = 0; i < num; i++) {
		if (l[i].code == currentLang) {
    c6dc:	4b0b      	ldr	r3, [pc, #44]	; (c70c <_ZN14Gamebuino_Meta8Language3getEPKNS_9MultiLangEh+0x30>)
	currentLang = c;
}

const char* Language::get(const MultiLang* l, uint8_t num) {
	const char* def = 0;
	for (uint8_t i = 0; i < num; i++) {
    c6de:	2200      	movs	r2, #0

void Language::setCurrentLang(LangCode c) {
	currentLang = c;
}

const char* Language::get(const MultiLang* l, uint8_t num) {
    c6e0:	b530      	push	{r4, r5, lr}
	const char* def = 0;
	for (uint8_t i = 0; i < num; i++) {
		if (l[i].code == currentLang) {
    c6e2:	681d      	ldr	r5, [r3, #0]
void Language::setCurrentLang(LangCode c) {
	currentLang = c;
}

const char* Language::get(const MultiLang* l, uint8_t num) {
	const char* def = 0;
    c6e4:	1c13      	adds	r3, r2, #0
	for (uint8_t i = 0; i < num; i++) {
    c6e6:	428a      	cmp	r2, r1
    c6e8:	d00d      	beq.n	c706 <_ZN14Gamebuino_Meta8Language3getEPKNS_9MultiLangEh+0x2a>
		if (l[i].code == currentLang) {
    c6ea:	6804      	ldr	r4, [r0, #0]
    c6ec:	42ac      	cmp	r4, r5
    c6ee:	d101      	bne.n	c6f4 <_ZN14Gamebuino_Meta8Language3getEPKNS_9MultiLangEh+0x18>
			return l[i].str;
    c6f0:	6840      	ldr	r0, [r0, #4]
    c6f2:	e009      	b.n	c708 <_ZN14Gamebuino_Meta8Language3getEPKNS_9MultiLangEh+0x2c>
		}
		if (!def) {
    c6f4:	2b00      	cmp	r3, #0
    c6f6:	d001      	beq.n	c6fc <_ZN14Gamebuino_Meta8Language3getEPKNS_9MultiLangEh+0x20>
			def = l[i].str;
		} else if (l[i].code == LangCode::en) {
    c6f8:	2c28      	cmp	r4, #40	; 0x28
    c6fa:	d100      	bne.n	c6fe <_ZN14Gamebuino_Meta8Language3getEPKNS_9MultiLangEh+0x22>
			def = l[i].str;
    c6fc:	6843      	ldr	r3, [r0, #4]
	currentLang = c;
}

const char* Language::get(const MultiLang* l, uint8_t num) {
	const char* def = 0;
	for (uint8_t i = 0; i < num; i++) {
    c6fe:	3201      	adds	r2, #1
    c700:	b2d2      	uxtb	r2, r2
    c702:	3008      	adds	r0, #8
    c704:	e7ef      	b.n	c6e6 <_ZN14Gamebuino_Meta8Language3getEPKNS_9MultiLangEh+0xa>
    c706:	1c18      	adds	r0, r3, #0
		} else if (l[i].code == LangCode::en) {
			def = l[i].str;
		}
	}
	return def;
}
    c708:	bd30      	pop	{r4, r5, pc}
    c70a:	46c0      	nop			; (mov r8, r8)
    c70c:	20000078 	.word	0x20000078

0000c710 <_ZN14Gamebuino_Meta8intToStrElPc>:

// create a unique path thing
// call via etc.
// char name[] = "/TMP0000.BIN";
// sd_path_no_duplicate(name, 4, 4); // returns true on success, false on no success
void intToStr(int32_t i, char* buf) {
    c710:	b538      	push	{r3, r4, r5, lr}
    c712:	1c04      	adds	r4, r0, #0
    c714:	1c0d      	adds	r5, r1, #0
	while (true) {
		*(buf) = '0' + (i % 10);
    c716:	1c20      	adds	r0, r4, #0
    c718:	210a      	movs	r1, #10
    c71a:	f004 fee1 	bl	114e0 <__aeabi_idivmod>
    c71e:	3130      	adds	r1, #48	; 0x30
    c720:	7029      	strb	r1, [r5, #0]
		if (i < 10) {
    c722:	2c09      	cmp	r4, #9
    c724:	dd06      	ble.n	c734 <_ZN14Gamebuino_Meta8intToStrElPc+0x24>
			break;
		}
		i /= 10;
    c726:	1c20      	adds	r0, r4, #0
    c728:	210a      	movs	r1, #10
    c72a:	f004 fe83 	bl	11434 <__aeabi_idiv>
		buf--;
    c72e:	3d01      	subs	r5, #1
	while (true) {
		*(buf) = '0' + (i % 10);
		if (i < 10) {
			break;
		}
		i /= 10;
    c730:	1c04      	adds	r4, r0, #0

// create a unique path thing
// call via etc.
// char name[] = "/TMP0000.BIN";
// sd_path_no_duplicate(name, 4, 4); // returns true on success, false on no success
void intToStr(int32_t i, char* buf) {
    c732:	e7f0      	b.n	c716 <_ZN14Gamebuino_Meta8intToStrElPc+0x6>
			break;
		}
		i /= 10;
		buf--;
	}
}
    c734:	bd38      	pop	{r3, r4, r5, pc}
	...

0000c738 <_ZN14Gamebuino_Meta17sdPathNoDuplicateEPchhl>:

int32_t sdPathNoDuplicate(char* name, uint8_t offset, uint8_t digits, int32_t start) {
    c738:	b5f0      	push	{r4, r5, r6, r7, lr}
    c73a:	1c1c      	adds	r4, r3, #0
    c73c:	b08b      	sub	sp, #44	; 0x2c
    c73e:	1c06      	adds	r6, r0, #0
	int32_t power = 1;
	for (uint8_t j = 0; j < digits; j++) {
    c740:	2300      	movs	r3, #0
		buf--;
	}
}

int32_t sdPathNoDuplicate(char* name, uint8_t offset, uint8_t digits, int32_t start) {
	int32_t power = 1;
    c742:	2501      	movs	r5, #1
	for (uint8_t j = 0; j < digits; j++) {
    c744:	4293      	cmp	r3, r2
    c746:	d004      	beq.n	c752 <_ZN14Gamebuino_Meta17sdPathNoDuplicateEPchhl+0x1a>
		power *= 10;
    c748:	200a      	movs	r0, #10
	}
}

int32_t sdPathNoDuplicate(char* name, uint8_t offset, uint8_t digits, int32_t start) {
	int32_t power = 1;
	for (uint8_t j = 0; j < digits; j++) {
    c74a:	3301      	adds	r3, #1
		power *= 10;
    c74c:	4345      	muls	r5, r0
	}
}

int32_t sdPathNoDuplicate(char* name, uint8_t offset, uint8_t digits, int32_t start) {
	int32_t power = 1;
	for (uint8_t j = 0; j < digits; j++) {
    c74e:	b2db      	uxtb	r3, r3
    c750:	e7f8      	b.n	c744 <_ZN14Gamebuino_Meta17sdPathNoDuplicateEPchhl+0xc>
		power *= 10;
	}
	
	char* buf = name + offset + digits - 1;
    c752:	3901      	subs	r1, #1
    c754:	18cb      	adds	r3, r1, r3
    c756:	18f7      	adds	r7, r6, r3
	for (int32_t i = start; i < power; i++) {
    c758:	42ac      	cmp	r4, r5
    c75a:	da10      	bge.n	c77e <_ZN14Gamebuino_Meta17sdPathNoDuplicateEPchhl+0x46>
		intToStr(i, buf);
    c75c:	1c20      	adds	r0, r4, #0
    c75e:	1c39      	adds	r1, r7, #0
    c760:	f7ff ffd6 	bl	c710 <_ZN14Gamebuino_Meta8intToStrElPc>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
    c764:	2300      	movs	r3, #0
    c766:	a801      	add	r0, sp, #4
    c768:	7003      	strb	r3, [r0, #0]
    c76a:	7043      	strb	r3, [r0, #1]
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile file;
    return file.open(this, path, O_READ);
    c76c:	4907      	ldr	r1, [pc, #28]	; (c78c <_ZN14Gamebuino_Meta17sdPathNoDuplicateEPchhl+0x54>)
    c76e:	1c32      	adds	r2, r6, #0
    c770:	2301      	movs	r3, #1
    c772:	f000 fe48 	bl	d406 <_ZN7FatFile4openEPS_PKch>
		if (!SD.exists(name)) {
    c776:	2800      	cmp	r0, #0
    c778:	d004      	beq.n	c784 <_ZN14Gamebuino_Meta17sdPathNoDuplicateEPchhl+0x4c>
	for (uint8_t j = 0; j < digits; j++) {
		power *= 10;
	}
	
	char* buf = name + offset + digits - 1;
	for (int32_t i = start; i < power; i++) {
    c77a:	3401      	adds	r4, #1
    c77c:	e7ec      	b.n	c758 <_ZN14Gamebuino_Meta17sdPathNoDuplicateEPchhl+0x20>
		intToStr(i, buf);
		if (!SD.exists(name)) {
			return i; // we are done folks!
		}
	}
	return -1;
    c77e:	2001      	movs	r0, #1
    c780:	4240      	negs	r0, r0
    c782:	e000      	b.n	c786 <_ZN14Gamebuino_Meta17sdPathNoDuplicateEPchhl+0x4e>
    c784:	1c20      	adds	r0, r4, #0
}
    c786:	b00b      	add	sp, #44	; 0x2c
    c788:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c78a:	46c0      	nop			; (mov r8, r8)
    c78c:	20000a04 	.word	0x20000a04

0000c790 <_ZN14Gamebuino_Meta14rgb888Torgb565ENS_6RGB888E>:

uint16_t rgb888Torgb565(RGB888 c) {
    c790:	1c02      	adds	r2, r0, #0
    c792:	1c03      	adds	r3, r0, #0
	return ((c.r & 0xF8) << 8) | ((c.g & 0xFC) << 3) | (c.b >> 3);
    c794:	21f8      	movs	r1, #248	; 0xf8
    c796:	400a      	ands	r2, r1
		}
	}
	return -1;
}

uint16_t rgb888Torgb565(RGB888 c) {
    c798:	0a1b      	lsrs	r3, r3, #8
	return ((c.r & 0xF8) << 8) | ((c.g & 0xFC) << 3) | (c.b >> 3);
    c79a:	21fc      	movs	r1, #252	; 0xfc
    c79c:	400b      	ands	r3, r1
    c79e:	0212      	lsls	r2, r2, #8
    c7a0:	00db      	lsls	r3, r3, #3
    c7a2:	4313      	orrs	r3, r2
    c7a4:	0201      	lsls	r1, r0, #8
    c7a6:	0ec9      	lsrs	r1, r1, #27
    c7a8:	1c18      	adds	r0, r3, #0
		}
	}
	return -1;
}

uint16_t rgb888Torgb565(RGB888 c) {
    c7aa:	b082      	sub	sp, #8
	return ((c.r & 0xF8) << 8) | ((c.g & 0xFC) << 3) | (c.b >> 3);
    c7ac:	4308      	orrs	r0, r1
}
    c7ae:	b002      	add	sp, #8
    c7b0:	4770      	bx	lr

0000c7b2 <_ZN14Gamebuino_Meta14rgb565Torgb888Et>:

RGB888 rgb565Torgb888(uint16_t c) {
    c7b2:	b537      	push	{r0, r1, r2, r4, r5, lr}
	RGB888 out;
	
	out.r = (uint8_t)((c >> 8) & 0xF8);
    c7b4:	2307      	movs	r3, #7
    c7b6:	1202      	asrs	r2, r0, #8
    c7b8:	439a      	bics	r2, r3
	out.r |= out.r >> 5;
	
	out.g = (uint8_t)((c >> 3) & 0xFC);
    c7ba:	10c1      	asrs	r1, r0, #3
    c7bc:	23fc      	movs	r3, #252	; 0xfc
	out.g |= out.g >> 6;
	
	out.b = (uint8_t)(c << 3);
    c7be:	00c0      	lsls	r0, r0, #3
	RGB888 out;
	
	out.r = (uint8_t)((c >> 8) & 0xF8);
	out.r |= out.r >> 5;
	
	out.g = (uint8_t)((c >> 3) & 0xFC);
    c7c0:	400b      	ands	r3, r1
	out.g |= out.g >> 6;
	
	out.b = (uint8_t)(c << 3);
    c7c2:	b2c0      	uxtb	r0, r0

RGB888 rgb565Torgb888(uint16_t c) {
	RGB888 out;
	
	out.r = (uint8_t)((c >> 8) & 0xF8);
	out.r |= out.r >> 5;
    c7c4:	1155      	asrs	r5, r2, #5
	
	out.g = (uint8_t)((c >> 3) & 0xFC);
	out.g |= out.g >> 6;
    c7c6:	119c      	asrs	r4, r3, #6
	
	out.b = (uint8_t)(c << 3);
	out.b |= out.b >> 5;
    c7c8:	1141      	asrs	r1, r0, #5
	return out;
    c7ca:	432a      	orrs	r2, r5
    c7cc:	4323      	orrs	r3, r4
    c7ce:	4308      	orrs	r0, r1
    c7d0:	0401      	lsls	r1, r0, #16
    c7d2:	021b      	lsls	r3, r3, #8
    c7d4:	1c10      	adds	r0, r2, #0
    c7d6:	4318      	orrs	r0, r3
    c7d8:	4308      	orrs	r0, r1
}
    c7da:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

0000c7dc <_ZN14Gamebuino_Meta8f_read16EP4File>:

uint16_t f_read16(File* f) {
    c7dc:	b513      	push	{r0, r1, r4, lr}
	uint16_t result;
	f->read(&result, 2);
    c7de:	466c      	mov	r4, sp
    c7e0:	3406      	adds	r4, #6
    c7e2:	1c21      	adds	r1, r4, #0
    c7e4:	2202      	movs	r2, #2
    c7e6:	3010      	adds	r0, #16
    c7e8:	f000 fbde 	bl	cfa8 <_ZN7FatFile4readEPvj>
	return result;
    c7ec:	8820      	ldrh	r0, [r4, #0]
}
    c7ee:	bd16      	pop	{r1, r2, r4, pc}

0000c7f0 <_ZN14Gamebuino_Meta8f_read32EP4File>:

uint32_t f_read32(File* f) {
    c7f0:	b507      	push	{r0, r1, r2, lr}
	uint32_t result;
	f->read(&result, 4);
    c7f2:	3010      	adds	r0, #16
    c7f4:	a901      	add	r1, sp, #4
    c7f6:	2204      	movs	r2, #4
    c7f8:	f000 fbd6 	bl	cfa8 <_ZN7FatFile4readEPvj>
	return result;
}
    c7fc:	9801      	ldr	r0, [sp, #4]
    c7fe:	bd0e      	pop	{r1, r2, r3, pc}

0000c800 <_ZN14Gamebuino_Meta9f_write32EmP4File>:

void f_write32(uint32_t b, File* f) {
    c800:	b507      	push	{r0, r1, r2, lr}
    c802:	9001      	str	r0, [sp, #4]
	//Write four bytes
	//Luckily our MCU is little endian so byte order like this is fine
	f->write(&b, 4);
    c804:	1c08      	adds	r0, r1, #0
    c806:	3010      	adds	r0, #16
    c808:	a901      	add	r1, sp, #4
    c80a:	2204      	movs	r2, #4
    c80c:	f000 ff68 	bl	d6e0 <_ZN7FatFile5writeEPKvj>
}
    c810:	bd07      	pop	{r0, r1, r2, pc}

0000c812 <_ZN14Gamebuino_Meta9f_write16EtP4File>:

void f_write16(uint16_t b, File* f) {
    c812:	b507      	push	{r0, r1, r2, lr}
    c814:	466b      	mov	r3, sp
    c816:	80d8      	strh	r0, [r3, #6]
    c818:	3306      	adds	r3, #6
	//Write two bytes
	//Luckily our MCU is little endian so byte order like this is fine
	f->write(&b, 2);
    c81a:	1c08      	adds	r0, r1, #0
    c81c:	3010      	adds	r0, #16
    c81e:	1c19      	adds	r1, r3, #0
    c820:	2202      	movs	r2, #2
    c822:	f000 ff5d 	bl	d6e0 <_ZN7FatFile5writeEPKvj>
}
    c826:	bd07      	pop	{r0, r1, r2, pc}

0000c828 <_ZN14Gamebuino_Meta4SaveC1EPNS_14Display_ST7735EPKcS4_>:
#define SAVEHEADER_SIZE 10
#define SAVEFILE_PAYLOAD_START (SAVEHEADER_SIZE + (blocks * 5))

#define MIN(x, y) ((x < y) ? x : y)

Save::Save(Display_ST7735 *_tft, const char* _savefile, const char* _checkbytes) {
    c828:	b530      	push	{r4, r5, lr}
    c82a:	25fa      	movs	r5, #250	; 0xfa
    c82c:	00ad      	lsls	r5, r5, #2
    c82e:	60c5      	str	r5, [r0, #12]
class File : public FatFile, public Stream {
#else  // ARDUINO_FILE_USES_STREAM
class File : public FatFile, public Print {
#endif  // ARDUINO_FILE_USES_STREAM
 public:
  File() {}
    c830:	4d0a      	ldr	r5, [pc, #40]	; (c85c <_ZN14Gamebuino_Meta4SaveC1EPNS_14Display_ST7735EPKcS4_+0x34>)
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
    c832:	2400      	movs	r4, #0
    c834:	6045      	str	r5, [r0, #4]
    c836:	1c05      	adds	r5, r0, #0
    c838:	3538      	adds	r5, #56	; 0x38
    c83a:	7504      	strb	r4, [r0, #20]
    c83c:	7544      	strb	r4, [r0, #21]
    c83e:	6084      	str	r4, [r0, #8]
    c840:	702c      	strb	r4, [r5, #0]
    c842:	706c      	strb	r4, [r5, #1]
	tft = _tft;
	savefile = _savefile;
	checkbytes = _checkbytes;
    c844:	63c3      	str	r3, [r0, #60]	; 0x3c
	
	defaults = 0;
	num_defaults = 0;
    c846:	1d83      	adds	r3, r0, #6

#define MIN(x, y) ((x < y) ? x : y)

Save::Save(Display_ST7735 *_tft, const char* _savefile, const char* _checkbytes) {
	tft = _tft;
	savefile = _savefile;
    c848:	6402      	str	r2, [r0, #64]	; 0x40
#define SAVEHEADER_SIZE 10
#define SAVEFILE_PAYLOAD_START (SAVEHEADER_SIZE + (blocks * 5))

#define MIN(x, y) ((x < y) ? x : y)

Save::Save(Display_ST7735 *_tft, const char* _savefile, const char* _checkbytes) {
    c84a:	6484      	str	r4, [r0, #72]	; 0x48
	tft = _tft;
    c84c:	6001      	str	r1, [r0, #0]
	savefile = _savefile;
	checkbytes = _checkbytes;
	
	defaults = 0;
    c84e:	64c4      	str	r4, [r0, #76]	; 0x4c
	num_defaults = 0;
	blocks = SAVEBLOCK_NUM;
    c850:	3302      	adds	r3, #2
	tft = _tft;
	savefile = _savefile;
	checkbytes = _checkbytes;
	
	defaults = 0;
	num_defaults = 0;
    c852:	879c      	strh	r4, [r3, #60]	; 0x3c
	blocks = SAVEBLOCK_NUM;
    c854:	2240      	movs	r2, #64	; 0x40
    c856:	87da      	strh	r2, [r3, #62]	; 0x3e
}
    c858:	bd30      	pop	{r4, r5, pc}
    c85a:	46c0      	nop			; (mov r8, r8)
    c85c:	00014a40 	.word	0x00014a40

0000c860 <_ZN14Gamebuino_Meta4Save6configEtPKNS_11SaveDefaultEt>:

void Save::config(const SaveDefault* _defaults, uint16_t _num_defaults) {
	config(SAVEBLOCK_NUM, _defaults, _num_defaults);
}

void Save::config(uint16_t _blocks, const SaveDefault* _defaults, uint16_t _num_defaults) {
    c860:	b510      	push	{r4, lr}
    c862:	1c0c      	adds	r4, r1, #0
    c864:	4299      	cmp	r1, r3
    c866:	d200      	bcs.n	c86a <_ZN14Gamebuino_Meta4Save6configEtPKNS_11SaveDefaultEt+0xa>
    c868:	1c1c      	adds	r4, r3, #0
	blocks = _blocks > _num_defaults ? _blocks : _num_defaults;
    c86a:	1c01      	adds	r1, r0, #0
    c86c:	3108      	adds	r1, #8
    c86e:	87cc      	strh	r4, [r1, #62]	; 0x3e
	defaults = _defaults;
    c870:	64c2      	str	r2, [r0, #76]	; 0x4c
	num_defaults = _num_defaults;
    c872:	3006      	adds	r0, #6
    c874:	87c3      	strh	r3, [r0, #62]	; 0x3e
}
    c876:	bd10      	pop	{r4, pc}

0000c878 <_ZN14Gamebuino_Meta4Save5errorEPKc>:

void Save::error(const char *s) {
    c878:	b538      	push	{r3, r4, r5, lr}
    c87a:	1c0d      	adds	r5, r1, #0
	tft->setCursor(0, 0);
    c87c:	2100      	movs	r1, #0
	blocks = _blocks > _num_defaults ? _blocks : _num_defaults;
	defaults = _defaults;
	num_defaults = _num_defaults;
}

void Save::error(const char *s) {
    c87e:	1c04      	adds	r4, r0, #0
	tft->setCursor(0, 0);
    c880:	1c0a      	adds	r2, r1, #0
    c882:	6800      	ldr	r0, [r0, #0]
    c884:	f7fd fb06 	bl	9e94 <_ZN14Gamebuino_Meta8Graphics9setCursorEss>
	tft->setColor(Color::red, Color::black);
    c888:	2200      	movs	r2, #0
    c88a:	6820      	ldr	r0, [r4, #0]
    c88c:	4908      	ldr	r1, [pc, #32]	; (c8b0 <_ZN14Gamebuino_Meta4Save5errorEPKc+0x38>)
    c88e:	f7fd fad7 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
	tft->print("SAVE ERROR ");
    c892:	4908      	ldr	r1, [pc, #32]	; (c8b4 <_ZN14Gamebuino_Meta4Save5errorEPKc+0x3c>)
    c894:	6820      	ldr	r0, [r4, #0]
    c896:	f003 f96d 	bl	fb74 <_ZN5Print5printEPKc>
	tft->setColor(Color::white, Color::black);
    c89a:	6820      	ldr	r0, [r4, #0]
    c89c:	4906      	ldr	r1, [pc, #24]	; (c8b8 <_ZN14Gamebuino_Meta4Save5errorEPKc+0x40>)
    c89e:	2200      	movs	r2, #0
    c8a0:	f7fd face 	bl	9e40 <_ZN14Gamebuino_Meta8Graphics8setColorENS_5ColorES1_>
	tft->print(s);
    c8a4:	6820      	ldr	r0, [r4, #0]
    c8a6:	1c29      	adds	r1, r5, #0
    c8a8:	f003 f964 	bl	fb74 <_ZN5Print5printEPKc>
    c8ac:	e7fe      	b.n	c8ac <_ZN14Gamebuino_Meta4Save5errorEPKc+0x34>
    c8ae:	46c0      	nop			; (mov r8, r8)
    c8b0:	0000d8e4 	.word	0x0000d8e4
    c8b4:	00015548 	.word	0x00015548
    c8b8:	0000ffff 	.word	0x0000ffff

0000c8bc <_ZN14Gamebuino_Meta4Save10getVarInfoEt>:
	while(1);
}


SaveVar Save::getVarInfo(uint16_t i) {
    c8bc:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (i >= blocks) {
    c8be:	1c03      	adds	r3, r0, #0
    c8c0:	3308      	adds	r3, #8
    c8c2:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
	tft->print(s);
	while(1);
}


SaveVar Save::getVarInfo(uint16_t i) {
    c8c4:	1c04      	adds	r4, r0, #0
	if (i >= blocks) {
    c8c6:	428b      	cmp	r3, r1
    c8c8:	d802      	bhi.n	c8d0 <_ZN14Gamebuino_Meta4Save10getVarInfoEt+0x14>
		// Trying to access bad block...
		error("accessing non-existing block");
    c8ca:	490e      	ldr	r1, [pc, #56]	; (c904 <_ZN14Gamebuino_Meta4Save10getVarInfoEt+0x48>)
    c8cc:	f7ff ffd4 	bl	c878 <_ZN14Gamebuino_Meta4Save5errorEPKc>
	}
	SaveVar s;
	f.seekSet(SAVEHEADER_SIZE + i);
    c8d0:	1c06      	adds	r6, r0, #0
    c8d2:	3614      	adds	r6, #20
	uint8_t b;
	if (!f.read(&b, 1)) {
    c8d4:	466d      	mov	r5, sp
	if (i >= blocks) {
		// Trying to access bad block...
		error("accessing non-existing block");
	}
	SaveVar s;
	f.seekSet(SAVEHEADER_SIZE + i);
    c8d6:	310a      	adds	r1, #10
    c8d8:	1c30      	adds	r0, r6, #0
	uint8_t b;
	if (!f.read(&b, 1)) {
    c8da:	3503      	adds	r5, #3
	if (i >= blocks) {
		// Trying to access bad block...
		error("accessing non-existing block");
	}
	SaveVar s;
	f.seekSet(SAVEHEADER_SIZE + i);
    c8dc:	f000 fc58 	bl	d190 <_ZN7FatFile7seekSetEm>
	uint8_t b;
	if (!f.read(&b, 1)) {
    c8e0:	1c30      	adds	r0, r6, #0
    c8e2:	1c29      	adds	r1, r5, #0
    c8e4:	2201      	movs	r2, #1
    c8e6:	f000 fb5f 	bl	cfa8 <_ZN7FatFile4readEPvj>
    c8ea:	2800      	cmp	r0, #0
    c8ec:	d103      	bne.n	c8f6 <_ZN14Gamebuino_Meta4Save10getVarInfoEt+0x3a>
		error("file I/O");
    c8ee:	1c20      	adds	r0, r4, #0
    c8f0:	4905      	ldr	r1, [pc, #20]	; (c908 <_ZN14Gamebuino_Meta4Save10getVarInfoEt+0x4c>)
    c8f2:	f7ff ffc1 	bl	c878 <_ZN14Gamebuino_Meta4Save5errorEPKc>
		while(1);
	}
	s.defined = (b & 0x80) ? true : false;
    c8f6:	782b      	ldrb	r3, [r5, #0]
	s.type = b & 0x07;
	return s;
    c8f8:	2207      	movs	r2, #7
    c8fa:	09d8      	lsrs	r0, r3, #7
    c8fc:	4013      	ands	r3, r2
    c8fe:	021b      	lsls	r3, r3, #8
    c900:	4318      	orrs	r0, r3
}
    c902:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    c904:	00015554 	.word	0x00015554
    c908:	00015571 	.word	0x00015571

0000c90c <_ZN14Gamebuino_Meta4Save4_getEt>:
}




uint32_t Save::_get(uint16_t i) {
    c90c:	b513      	push	{r0, r1, r4, lr}
	uint32_t val;
	f.seekSet(SAVEHEADER_SIZE + blocks + (4*i));
    c90e:	1c04      	adds	r4, r0, #0
    c910:	3008      	adds	r0, #8
    c912:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
    c914:	3414      	adds	r4, #20
    c916:	330a      	adds	r3, #10
    c918:	0089      	lsls	r1, r1, #2
    c91a:	1859      	adds	r1, r3, r1
    c91c:	1c20      	adds	r0, r4, #0
    c91e:	f000 fc37 	bl	d190 <_ZN7FatFile7seekSetEm>
	f.read(&val, 4);
    c922:	1c20      	adds	r0, r4, #0
    c924:	a901      	add	r1, sp, #4
    c926:	2204      	movs	r2, #4
    c928:	f000 fb3e 	bl	cfa8 <_ZN7FatFile4readEPvj>
	return val;
}
    c92c:	9801      	ldr	r0, [sp, #4]
    c92e:	bd16      	pop	{r1, r2, r4, pc}

0000c930 <_ZN14Gamebuino_Meta4Save4_setEtm>:
}




void Save::_set(uint16_t i, uint32_t b) {
    c930:	b513      	push	{r0, r1, r4, lr}
	f.seekSet(SAVEHEADER_SIZE + blocks + (4*i));
    c932:	1c04      	adds	r4, r0, #0
}




void Save::_set(uint16_t i, uint32_t b) {
    c934:	9201      	str	r2, [sp, #4]
	f.seekSet(SAVEHEADER_SIZE + blocks + (4*i));
    c936:	3008      	adds	r0, #8
    c938:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
    c93a:	3414      	adds	r4, #20
    c93c:	330a      	adds	r3, #10
    c93e:	0089      	lsls	r1, r1, #2
    c940:	1859      	adds	r1, r3, r1
    c942:	1c20      	adds	r0, r4, #0
    c944:	f000 fc24 	bl	d190 <_ZN7FatFile7seekSetEm>
	f.write(&b, 4);
    c948:	1c20      	adds	r0, r4, #0
    c94a:	a901      	add	r1, sp, #4
    c94c:	2204      	movs	r2, #4
    c94e:	f000 fec7 	bl	d6e0 <_ZN7FatFile5writeEPKvj>
}
    c952:	bd13      	pop	{r0, r1, r4, pc}

0000c954 <_ZN14Gamebuino_Meta4Save3delEt>:
	return true;
}



void Save::del(uint16_t i) {
    c954:	b5f0      	push	{r4, r5, r6, r7, lr}
    c956:	1c04      	adds	r4, r0, #0
    c958:	b087      	sub	sp, #28
    c95a:	1c0f      	adds	r7, r1, #0
	openFile();
    c95c:	f000 f89e 	bl	ca9c <_ZN14Gamebuino_Meta4Save8openFileEv>
	if (readOnly) {
    c960:	1c23      	adds	r3, r4, #0
    c962:	3339      	adds	r3, #57	; 0x39
    c964:	781e      	ldrb	r6, [r3, #0]
    c966:	2e00      	cmp	r6, #0
    c968:	d000      	beq.n	c96c <_ZN14Gamebuino_Meta4Save3delEt+0x18>
    c96a:	e094      	b.n	ca96 <_ZN14Gamebuino_Meta4Save3delEt+0x142>
		return;
	}
	SaveVar s = getVarInfo(i);
    c96c:	1c20      	adds	r0, r4, #0
    c96e:	1c39      	adds	r1, r7, #0
    c970:	f7ff ffa4 	bl	c8bc <_ZN14Gamebuino_Meta4Save10getVarInfoEt>
    c974:	b283      	uxth	r3, r0
    c976:	0a1b      	lsrs	r3, r3, #8
	if (!s.defined) {
    c978:	b2c0      	uxtb	r0, r0
void Save::del(uint16_t i) {
	openFile();
	if (readOnly) {
		return;
	}
	SaveVar s = getVarInfo(i);
    c97a:	9300      	str	r3, [sp, #0]
	if (!s.defined) {
    c97c:	2800      	cmp	r0, #0
    c97e:	d100      	bne.n	c982 <_ZN14Gamebuino_Meta4Save3delEt+0x2e>
    c980:	e089      	b.n	ca96 <_ZN14Gamebuino_Meta4Save3delEt+0x142>
		return; // nothing to do!
	}
	
	// let's delete the entry first
	f.seekSet(SAVEHEADER_SIZE + i);
    c982:	1c25      	adds	r5, r4, #0
    c984:	3514      	adds	r5, #20
    c986:	1c39      	adds	r1, r7, #0
    c988:	310a      	adds	r1, #10
    c98a:	1c28      	adds	r0, r5, #0
    c98c:	f000 fc00 	bl	d190 <_ZN7FatFile7seekSetEm>
	f.write((uint8_t)0);
    c990:	1d20      	adds	r0, r4, #4
    c992:	1c31      	adds	r1, r6, #0
    c994:	9001      	str	r0, [sp, #4]
    c996:	f7f9 f9a8 	bl	5cea <_ZN4File5writeEh>
	
	if (s.type == SAVETYPE_INT) {
    c99a:	9900      	ldr	r1, [sp, #0]
    c99c:	2900      	cmp	r1, #0
    c99e:	d077      	beq.n	ca90 <_ZN14Gamebuino_Meta4Save3delEt+0x13c>
		f.flush();
		return; // with ints that is all what is left to do
	}
	
	// ok, we have a blob, so we must get rid of the payload...
	uint32_t b = _get(i);
    c9a0:	1c39      	adds	r1, r7, #0
    c9a2:	1c20      	adds	r0, r4, #0
    c9a4:	f7ff ffb2 	bl	c90c <_ZN14Gamebuino_Meta4Save4_getEt>
	
	// determine the size of the payload
	f.seekSet(SAVEFILE_PAYLOAD_START + b);
    c9a8:	1c23      	adds	r3, r4, #0
    c9aa:	3308      	adds	r3, #8
    c9ac:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
    c9ae:	2105      	movs	r1, #5
    c9b0:	4359      	muls	r1, r3
    c9b2:	310a      	adds	r1, #10
    c9b4:	1809      	adds	r1, r1, r0
		f.flush();
		return; // with ints that is all what is left to do
	}
	
	// ok, we have a blob, so we must get rid of the payload...
	uint32_t b = _get(i);
    c9b6:	1c07      	adds	r7, r0, #0
	
	// determine the size of the payload
	f.seekSet(SAVEFILE_PAYLOAD_START + b);
    c9b8:	1c28      	adds	r0, r5, #0
    c9ba:	f000 fbe9 	bl	d190 <_ZN7FatFile7seekSetEm>
	uint32_t size;
	f.read(&size, 4);
    c9be:	1c28      	adds	r0, r5, #0
    c9c0:	a905      	add	r1, sp, #20
    c9c2:	2204      	movs	r2, #4
    c9c4:	f000 faf0 	bl	cfa8 <_ZN7FatFile4readEPvj>
	size += 4; // we need to also delete the size bytes
    c9c8:	9b05      	ldr	r3, [sp, #20]
    c9ca:	3304      	adds	r3, #4
    c9cc:	9305      	str	r3, [sp, #20]
	
	// now we need to loop all blocks and shift those with a payload pointer that is greater down a bit
	for (i = 0; i < blocks; i++) {
    c9ce:	1c23      	adds	r3, r4, #0
    c9d0:	3308      	adds	r3, #8
    c9d2:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
    c9d4:	42b3      	cmp	r3, r6
    c9d6:	d919      	bls.n	ca0c <_ZN14Gamebuino_Meta4Save3delEt+0xb8>
		s = getVarInfo(i);
    c9d8:	1c20      	adds	r0, r4, #0
    c9da:	1c31      	adds	r1, r6, #0
    c9dc:	f7ff ff6e 	bl	c8bc <_ZN14Gamebuino_Meta4Save10getVarInfoEt>
    c9e0:	b283      	uxth	r3, r0
		if (s.defined && s.type == SAVETYPE_BLOB) {
    c9e2:	b2c0      	uxtb	r0, r0
	f.read(&size, 4);
	size += 4; // we need to also delete the size bytes
	
	// now we need to loop all blocks and shift those with a payload pointer that is greater down a bit
	for (i = 0; i < blocks; i++) {
		s = getVarInfo(i);
    c9e4:	0a1b      	lsrs	r3, r3, #8
		if (s.defined && s.type == SAVETYPE_BLOB) {
    c9e6:	2800      	cmp	r0, #0
    c9e8:	d00d      	beq.n	ca06 <_ZN14Gamebuino_Meta4Save3delEt+0xb2>
    c9ea:	2b01      	cmp	r3, #1
    c9ec:	d10b      	bne.n	ca06 <_ZN14Gamebuino_Meta4Save3delEt+0xb2>
			uint32_t c = _get(i);
    c9ee:	1c20      	adds	r0, r4, #0
    c9f0:	1c31      	adds	r1, r6, #0
    c9f2:	f7ff ff8b 	bl	c90c <_ZN14Gamebuino_Meta4Save4_getEt>
			if (c > b) {
    c9f6:	42b8      	cmp	r0, r7
    c9f8:	d905      	bls.n	ca06 <_ZN14Gamebuino_Meta4Save3delEt+0xb2>
				// we just adjust the pointer here, we do all the shifting later on
				c -= size;
    c9fa:	9b05      	ldr	r3, [sp, #20]
				_set(i, c);
    c9fc:	1c31      	adds	r1, r6, #0
		s = getVarInfo(i);
		if (s.defined && s.type == SAVETYPE_BLOB) {
			uint32_t c = _get(i);
			if (c > b) {
				// we just adjust the pointer here, we do all the shifting later on
				c -= size;
    c9fe:	1ac2      	subs	r2, r0, r3
				_set(i, c);
    ca00:	1c20      	adds	r0, r4, #0
    ca02:	f7ff ff95 	bl	c930 <_ZN14Gamebuino_Meta4Save4_setEtm>
	uint32_t size;
	f.read(&size, 4);
	size += 4; // we need to also delete the size bytes
	
	// now we need to loop all blocks and shift those with a payload pointer that is greater down a bit
	for (i = 0; i < blocks; i++) {
    ca06:	3601      	adds	r6, #1
    ca08:	b2b6      	uxth	r6, r6
    ca0a:	e7e0      	b.n	c9ce <_ZN14Gamebuino_Meta4Save3delEt+0x7a>
    ca0c:	2600      	movs	r6, #0
				_set(i, c);
			}
		}
	}
	// ok now we actually need to shift the payload data
	for (uint32_t j = 0; j < (payload_size-b-size); j++) {
    ca0e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    ca10:	9905      	ldr	r1, [sp, #20]
    ca12:	1c20      	adds	r0, r4, #0
    ca14:	1bda      	subs	r2, r3, r7
    ca16:	3008      	adds	r0, #8
    ca18:	1a52      	subs	r2, r2, r1
    ca1a:	9000      	str	r0, [sp, #0]
    ca1c:	4296      	cmp	r6, r2
    ca1e:	d221      	bcs.n	ca64 <_ZN14Gamebuino_Meta4Save3delEt+0x110>
		uint8_t c;
		f.seekSet(SAVEFILE_PAYLOAD_START + b + size + j);
    ca20:	9800      	ldr	r0, [sp, #0]
    ca22:	2205      	movs	r2, #5
    ca24:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
    ca26:	310a      	adds	r1, #10
    ca28:	4353      	muls	r3, r2
    ca2a:	18c9      	adds	r1, r1, r3
    ca2c:	19c9      	adds	r1, r1, r7
    ca2e:	1989      	adds	r1, r1, r6
    ca30:	1c28      	adds	r0, r5, #0
    ca32:	f000 fbad 	bl	d190 <_ZN7FatFile7seekSetEm>
		f.read(&c, 1);
    ca36:	4669      	mov	r1, sp
    ca38:	2201      	movs	r2, #1
    ca3a:	310f      	adds	r1, #15
    ca3c:	1c28      	adds	r0, r5, #0
    ca3e:	f000 fab3 	bl	cfa8 <_ZN7FatFile4readEPvj>
		f.seekSet(SAVEFILE_PAYLOAD_START + b + j);
    ca42:	9b00      	ldr	r3, [sp, #0]
    ca44:	2005      	movs	r0, #5
    ca46:	8fd9      	ldrh	r1, [r3, #62]	; 0x3e
    ca48:	4341      	muls	r1, r0
    ca4a:	310a      	adds	r1, #10
    ca4c:	19c9      	adds	r1, r1, r7
    ca4e:	1989      	adds	r1, r1, r6
    ca50:	1c28      	adds	r0, r5, #0
    ca52:	f000 fb9d 	bl	d190 <_ZN7FatFile7seekSetEm>
		f.write(c);
    ca56:	466a      	mov	r2, sp
    ca58:	7bd1      	ldrb	r1, [r2, #15]
    ca5a:	9801      	ldr	r0, [sp, #4]
    ca5c:	f7f9 f945 	bl	5cea <_ZN4File5writeEh>
				_set(i, c);
			}
		}
	}
	// ok now we actually need to shift the payload data
	for (uint32_t j = 0; j < (payload_size-b-size); j++) {
    ca60:	3601      	adds	r6, #1
    ca62:	e7d4      	b.n	ca0e <_ZN14Gamebuino_Meta4Save3delEt+0xba>
		f.seekSet(SAVEFILE_PAYLOAD_START + b + j);
		f.write(c);
	}
	
	// now all that is left to do is to adjust the payload and filesize
	payload_size -= size;
    ca64:	1a59      	subs	r1, r3, r1
    ca66:	64a1      	str	r1, [r4, #72]	; 0x48
	f.seekSet(6);
    ca68:	1c28      	adds	r0, r5, #0
    ca6a:	2106      	movs	r1, #6
    ca6c:	f000 fb90 	bl	d190 <_ZN7FatFile7seekSetEm>
	f.write(&payload_size, 4);
    ca70:	1c21      	adds	r1, r4, #0
    ca72:	3148      	adds	r1, #72	; 0x48
    ca74:	2204      	movs	r2, #4
    ca76:	1c28      	adds	r0, r5, #0
    ca78:	f000 fe32 	bl	d6e0 <_ZN7FatFile5writeEPKvj>
	f.truncate(SAVEFILE_PAYLOAD_START + payload_size);
    ca7c:	9900      	ldr	r1, [sp, #0]
    ca7e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    ca80:	8fca      	ldrh	r2, [r1, #62]	; 0x3e
    ca82:	2105      	movs	r1, #5
    ca84:	4351      	muls	r1, r2
    ca86:	330a      	adds	r3, #10
    ca88:	1859      	adds	r1, r3, r1
    ca8a:	1c28      	adds	r0, r5, #0
    ca8c:	f000 fddc 	bl	d648 <_ZN7FatFile8truncateEm>
    uint32_t n = FatFile::available();
    return n > INT_MAX ? INT_MAX : n;
  }
  /** Ensure that any bytes written to the file are saved to the SD card. */
  void flush() {
    FatFile::sync();
    ca90:	1c28      	adds	r0, r5, #0
    ca92:	f000 fc69 	bl	d368 <_ZN7FatFile4syncEv>
	f.flush();
}
    ca96:	b007      	add	sp, #28
    ca98:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0000ca9c <_ZN14Gamebuino_Meta4Save8openFileEv>:
	s.defined = (b & 0x80) ? true : false;
	s.type = b & 0x07;
	return s;
}

void Save::openFile() {
    ca9c:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (open) {
    ca9e:	1c07      	adds	r7, r0, #0
    caa0:	3738      	adds	r7, #56	; 0x38
    caa2:	783e      	ldrb	r6, [r7, #0]
	s.defined = (b & 0x80) ? true : false;
	s.type = b & 0x07;
	return s;
}

void Save::openFile() {
    caa4:	b091      	sub	sp, #68	; 0x44
    caa6:	1c05      	adds	r5, r0, #0
	if (open) {
    caa8:	2e00      	cmp	r6, #0
    caaa:	d000      	beq.n	caae <_ZN14Gamebuino_Meta4Save8openFileEv+0x12>
    caac:	e15b      	b.n	cd66 <_ZN14Gamebuino_Meta4Save8openFileEv+0x2ca>
    caae:	ac03      	add	r4, sp, #12
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile file;
    return file.open(this, path, O_READ);
    cab0:	1c20      	adds	r0, r4, #0
    cab2:	49ae      	ldr	r1, [pc, #696]	; (cd6c <_ZN14Gamebuino_Meta4Save8openFileEv+0x2d0>)
    cab4:	6c2a      	ldr	r2, [r5, #64]	; 0x40
    cab6:	2301      	movs	r3, #1
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
    cab8:	7026      	strb	r6, [r4, #0]
    caba:	7066      	strb	r6, [r4, #1]
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile file;
    return file.open(this, path, O_READ);
    cabc:	f000 fca3 	bl	d406 <_ZN7FatFile4openEPS_PKch>
    cac0:	23fa      	movs	r3, #250	; 0xfa
    cac2:	009b      	lsls	r3, r3, #2
    cac4:	60a3      	str	r3, [r4, #8]
class File : public FatFile, public Stream {
#else  // ARDUINO_FILE_USES_STREAM
class File : public FatFile, public Print {
#endif  // ARDUINO_FILE_USES_STREAM
 public:
  File() {}
    cac6:	4baa      	ldr	r3, [pc, #680]	; (cd70 <_ZN14Gamebuino_Meta4Save8openFileEv+0x2d4>)
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
    cac8:	7426      	strb	r6, [r4, #16]
    caca:	7466      	strb	r6, [r4, #17]
    cacc:	6066      	str	r6, [r4, #4]
   * \param[in] mode open mode flags.
   * \return a File object.
   */
  File open(const char *path, uint8_t mode = FILE_READ) {
    File tmpFile;
    tmpFile.open(vwd(), path, mode);
    cace:	ae07      	add	r6, sp, #28
    cad0:	6c2a      	ldr	r2, [r5, #64]	; 0x40
    cad2:	49a6      	ldr	r1, [pc, #664]	; (cd6c <_ZN14Gamebuino_Meta4Save8openFileEv+0x2d0>)
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile file;
    return file.open(this, path, O_READ);
    cad4:	9001      	str	r0, [sp, #4]
    cad6:	9303      	str	r3, [sp, #12]
    cad8:	1c30      	adds	r0, r6, #0
    cada:	2363      	movs	r3, #99	; 0x63
    cadc:	f000 fc93 	bl	d406 <_ZN7FatFile4openEPS_PKch>
/**
 * \class File
 * \brief Arduino SD.h style File API
 */
#if ARDUINO_FILE_USES_STREAM
class File : public FatFile, public Stream {
    cae0:	1c2b      	adds	r3, r5, #0
    cae2:	3314      	adds	r3, #20
    cae4:	ce07      	ldmia	r6!, {r0, r1, r2}
    cae6:	c307      	stmia	r3!, {r0, r1, r2}
    cae8:	ce07      	ldmia	r6!, {r0, r1, r2}
    caea:	c307      	stmia	r3!, {r0, r1, r2}
    caec:	ce07      	ldmia	r6!, {r0, r1, r2}
    caee:	c307      	stmia	r3!, {r0, r1, r2}
    SKIP_WHITESPACE // Only tabs, spaces, line feeds & carriage returns are skipped.
};

#define NO_IGNORE_CHAR  '\x01' // a char not found in a valid ASCII numeric field

class Stream : public Print
    caf0:	68a0      	ldr	r0, [r4, #8]
    caf2:	68e4      	ldr	r4, [r4, #12]
#define DEC 10
#define HEX 16
#define OCT 8
#define BIN 2

class Print
    caf4:	9b04      	ldr	r3, [sp, #16]
		return;
	}
	bool exists = SD.exists(savefile);
	f = SD.open(savefile, FILE_WRITE);
	if (!f) {
    caf6:	7d2a      	ldrb	r2, [r5, #20]
    caf8:	612c      	str	r4, [r5, #16]
    cafa:	1c2c      	adds	r4, r5, #0
    cafc:	60ab      	str	r3, [r5, #8]
    cafe:	60e8      	str	r0, [r5, #12]
    cb00:	3414      	adds	r4, #20
    cb02:	2301      	movs	r3, #1
    cb04:	2a00      	cmp	r2, #0
    cb06:	d103      	bne.n	cb10 <_ZN14Gamebuino_Meta4Save8openFileEv+0x74>
		// eeeeeh, can't open it so we are read-only
		open = true;
		readOnly = true;
    cb08:	3539      	adds	r5, #57	; 0x39
	}
	bool exists = SD.exists(savefile);
	f = SD.open(savefile, FILE_WRITE);
	if (!f) {
		// eeeeeh, can't open it so we are read-only
		open = true;
    cb0a:	703b      	strb	r3, [r7, #0]
		readOnly = true;
    cb0c:	702b      	strb	r3, [r5, #0]
		return;
    cb0e:	e12a      	b.n	cd66 <_ZN14Gamebuino_Meta4Save8openFileEv+0x2ca>
	}
	open = true;
	if (!exists) {
    cb10:	9a01      	ldr	r2, [sp, #4]
void Save::openFile() {
	if (open) {
		return;
	}
	bool exists = SD.exists(savefile);
	f = SD.open(savefile, FILE_WRITE);
    cb12:	1d29      	adds	r1, r5, #4
		// eeeeeh, can't open it so we are read-only
		open = true;
		readOnly = true;
		return;
	}
	open = true;
    cb14:	703b      	strb	r3, [r7, #0]
    cb16:	1c2f      	adds	r7, r5, #0
void Save::openFile() {
	if (open) {
		return;
	}
	bool exists = SD.exists(savefile);
	f = SD.open(savefile, FILE_WRITE);
    cb18:	9100      	str	r1, [sp, #0]
    cb1a:	3708      	adds	r7, #8
		open = true;
		readOnly = true;
		return;
	}
	open = true;
	if (!exists) {
    cb1c:	2a00      	cmp	r2, #0
    cb1e:	d11a      	bne.n	cb56 <_ZN14Gamebuino_Meta4Save8openFileEv+0xba>
		// the file doesn't exist yet, so let's create it
		f.write(checkbytes, 4);
    cb20:	6be9      	ldr	r1, [r5, #60]	; 0x3c
    cb22:	2204      	movs	r2, #4
    cb24:	1c20      	adds	r0, r4, #0
    cb26:	f000 fddb 	bl	d6e0 <_ZN7FatFile5writeEPKvj>
		f.write(&blocks, 2); // write the amount of blocks
    cb2a:	1c29      	adds	r1, r5, #0
    cb2c:	1c20      	adds	r0, r4, #0
    cb2e:	3146      	adds	r1, #70	; 0x46
    cb30:	2202      	movs	r2, #2
    cb32:	f000 fdd5 	bl	d6e0 <_ZN7FatFile5writeEPKvj>
		
		// +4 because of 4-byte payload size
		for (uint32_t i = 0; i < (5*blocks) + 4; i++) {
    cb36:	9e01      	ldr	r6, [sp, #4]
    cb38:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
    cb3a:	2205      	movs	r2, #5
    cb3c:	4353      	muls	r3, r2
    cb3e:	3304      	adds	r3, #4
    cb40:	429e      	cmp	r6, r3
    cb42:	d205      	bcs.n	cb50 <_ZN14Gamebuino_Meta4Save8openFileEv+0xb4>
			f.write((uint8_t)0);
    cb44:	9800      	ldr	r0, [sp, #0]
    cb46:	2100      	movs	r1, #0
    cb48:	f7f9 f8cf 	bl	5cea <_ZN4File5writeEh>
		// the file doesn't exist yet, so let's create it
		f.write(checkbytes, 4);
		f.write(&blocks, 2); // write the amount of blocks
		
		// +4 because of 4-byte payload size
		for (uint32_t i = 0; i < (5*blocks) + 4; i++) {
    cb4c:	3601      	adds	r6, #1
    cb4e:	e7f3      	b.n	cb38 <_ZN14Gamebuino_Meta4Save8openFileEv+0x9c>
    uint32_t n = FatFile::available();
    return n > INT_MAX ? INT_MAX : n;
  }
  /** Ensure that any bytes written to the file are saved to the SD card. */
  void flush() {
    FatFile::sync();
    cb50:	1c20      	adds	r0, r4, #0
    cb52:	f000 fc09 	bl	d368 <_ZN7FatFile4syncEv>
	f.rewind(); // rewind it so that we can read its properties
	// the file already exists, so time to read some properties!
	
	// first check that the checkbytes match!
	// we use the payload_size for this because that is just yet another free 4-byte buffer
	f.read(&payload_size, 4);
    cb56:	1c2e      	adds	r6, r5, #0
   * the value false is returned for failure.
   */
  static bool remove(FatFile* dirFile, const char* path);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    cb58:	2100      	movs	r1, #0
    cb5a:	3648      	adds	r6, #72	; 0x48
    cb5c:	1c20      	adds	r0, r4, #0
    cb5e:	f000 fb17 	bl	d190 <_ZN7FatFile7seekSetEm>
    cb62:	1c31      	adds	r1, r6, #0
    cb64:	2204      	movs	r2, #4
    cb66:	1c20      	adds	r0, r4, #0
    cb68:	f000 fa1e 	bl	cfa8 <_ZN7FatFile4readEPvj>
	if (memcmp(&payload_size, checkbytes, 4) != 0) {
    cb6c:	1c30      	adds	r0, r6, #0
    cb6e:	6be9      	ldr	r1, [r5, #60]	; 0x3c
    cb70:	2204      	movs	r2, #4
    cb72:	f004 fd13 	bl	1159c <memcmp>
    cb76:	9001      	str	r0, [sp, #4]
    cb78:	2800      	cmp	r0, #0
    cb7a:	d003      	beq.n	cb84 <_ZN14Gamebuino_Meta4Save8openFileEv+0xe8>
		error("Invalid save file");
    cb7c:	1c28      	adds	r0, r5, #0
    cb7e:	497d      	ldr	r1, [pc, #500]	; (cd74 <_ZN14Gamebuino_Meta4Save8openFileEv+0x2d8>)
    cb80:	f7ff fe7a 	bl	c878 <_ZN14Gamebuino_Meta4Save5errorEPKc>
	}
	uint16_t blocks_old;
	f.read(&blocks_old, 2); // how many blocks do we have?
    cb84:	a902      	add	r1, sp, #8
    cb86:	2202      	movs	r2, #2
    cb88:	1c20      	adds	r0, r4, #0
    cb8a:	f000 fa0d 	bl	cfa8 <_ZN7FatFile4readEPvj>
	f.read(&payload_size, 4); // let's grab the payload size!
    cb8e:	1c31      	adds	r1, r6, #0
    cb90:	1c20      	adds	r0, r4, #0
    cb92:	2204      	movs	r2, #4
    cb94:	f000 fa08 	bl	cfa8 <_ZN7FatFile4readEPvj>
	
	if (blocks_old == blocks) {
    cb98:	4668      	mov	r0, sp
    cb9a:	8903      	ldrh	r3, [r0, #8]
    cb9c:	8ffe      	ldrh	r6, [r7, #62]	; 0x3e
    cb9e:	42b3      	cmp	r3, r6
    cba0:	d100      	bne.n	cba4 <_ZN14Gamebuino_Meta4Save8openFileEv+0x108>
    cba2:	e0e0      	b.n	cd66 <_ZN14Gamebuino_Meta4Save8openFileEv+0x2ca>
		return; // everything is OK, nothing more to do
	}
	uint16_t blocks_new = blocks;
    cba4:	8146      	strh	r6, [r0, #10]
	blocks = blocks_old;
    cba6:	87fb      	strh	r3, [r7, #62]	; 0x3e
	if (blocks_old > blocks_new) {
    cba8:	d957      	bls.n	cc5a <_ZN14Gamebuino_Meta4Save8openFileEv+0x1be>
		// we need to shrink the block size
		
		// first we delete the unneeded variables (due to payload maybe being off)
		for (uint16_t i = blocks_new; i < blocks_old; i++) {
    cbaa:	466a      	mov	r2, sp
    cbac:	8913      	ldrh	r3, [r2, #8]
    cbae:	42b3      	cmp	r3, r6
    cbb0:	d906      	bls.n	cbc0 <_ZN14Gamebuino_Meta4Save8openFileEv+0x124>
			del(i);
    cbb2:	1c31      	adds	r1, r6, #0
    cbb4:	1c28      	adds	r0, r5, #0
	blocks = blocks_old;
	if (blocks_old > blocks_new) {
		// we need to shrink the block size
		
		// first we delete the unneeded variables (due to payload maybe being off)
		for (uint16_t i = blocks_new; i < blocks_old; i++) {
    cbb6:	3601      	adds	r6, #1
			del(i);
    cbb8:	f7ff fecc 	bl	c954 <_ZN14Gamebuino_Meta4Save3delEt>
	blocks = blocks_old;
	if (blocks_old > blocks_new) {
		// we need to shrink the block size
		
		// first we delete the unneeded variables (due to payload maybe being off)
		for (uint16_t i = blocks_new; i < blocks_old; i++) {
    cbbc:	b2b6      	uxth	r6, r6
    cbbe:	e7f4      	b.n	cbaa <_ZN14Gamebuino_Meta4Save8openFileEv+0x10e>
    cbc0:	2700      	movs	r7, #0
			del(i);
		}
		
		// next we offset the blocks
		for (uint16_t i = 0; i < blocks_new; i++) {
    cbc2:	466e      	mov	r6, sp
    cbc4:	360a      	adds	r6, #10
    cbc6:	8833      	ldrh	r3, [r6, #0]
    cbc8:	42bb      	cmp	r3, r7
    cbca:	d91c      	bls.n	cc06 <_ZN14Gamebuino_Meta4Save8openFileEv+0x16a>
			uint32_t b;
			f.seekSet(SAVEHEADER_SIZE + blocks_old + i*4);
    cbcc:	4668      	mov	r0, sp
    cbce:	8901      	ldrh	r1, [r0, #8]
    cbd0:	00bb      	lsls	r3, r7, #2
    cbd2:	310a      	adds	r1, #10
    cbd4:	18c9      	adds	r1, r1, r3
    cbd6:	1c20      	adds	r0, r4, #0
    cbd8:	9301      	str	r3, [sp, #4]
    cbda:	f000 fad9 	bl	d190 <_ZN7FatFile7seekSetEm>
			f.read(&b, 4);
    cbde:	a903      	add	r1, sp, #12
    cbe0:	2204      	movs	r2, #4
    cbe2:	1c20      	adds	r0, r4, #0
    cbe4:	f000 f9e0 	bl	cfa8 <_ZN7FatFile4readEPvj>
			f.seekSet(SAVEHEADER_SIZE + blocks_new + i*4);
    cbe8:	8831      	ldrh	r1, [r6, #0]
    cbea:	9a01      	ldr	r2, [sp, #4]
    cbec:	310a      	adds	r1, #10
    cbee:	1889      	adds	r1, r1, r2
    cbf0:	1c20      	adds	r0, r4, #0
    cbf2:	f000 facd 	bl	d190 <_ZN7FatFile7seekSetEm>
		for (uint16_t i = blocks_new; i < blocks_old; i++) {
			del(i);
		}
		
		// next we offset the blocks
		for (uint16_t i = 0; i < blocks_new; i++) {
    cbf6:	3701      	adds	r7, #1
			uint32_t b;
			f.seekSet(SAVEHEADER_SIZE + blocks_old + i*4);
			f.read(&b, 4);
			f.seekSet(SAVEHEADER_SIZE + blocks_new + i*4);
			f.write(&b, 4);
    cbf8:	1c20      	adds	r0, r4, #0
    cbfa:	a903      	add	r1, sp, #12
    cbfc:	2204      	movs	r2, #4
    cbfe:	f000 fd6f 	bl	d6e0 <_ZN7FatFile5writeEPKvj>
		for (uint16_t i = blocks_new; i < blocks_old; i++) {
			del(i);
		}
		
		// next we offset the blocks
		for (uint16_t i = 0; i < blocks_new; i++) {
    cc02:	b2bf      	uxth	r7, r7
    cc04:	e7dd      	b.n	cbc2 <_ZN14Gamebuino_Meta4Save8openFileEv+0x126>
    cc06:	2600      	movs	r6, #0
			f.seekSet(SAVEHEADER_SIZE + blocks_new + i*4);
			f.write(&b, 4);
		}
		
		// now we fix the payload
		for (uint32_t i = 0; i < payload_size; i++) {
    cc08:	6cab      	ldr	r3, [r5, #72]	; 0x48
    cc0a:	2705      	movs	r7, #5
    cc0c:	429e      	cmp	r6, r3
    cc0e:	d21b      	bcs.n	cc48 <_ZN14Gamebuino_Meta4Save8openFileEv+0x1ac>
			uint8_t b;
			f.seek(SAVEHEADER_SIZE + (blocks_old * 5) + i);
    cc10:	466b      	mov	r3, sp
    cc12:	8919      	ldrh	r1, [r3, #8]
   *
   * \param[in] pos the new file position.
   * \return true for success else false.
   */
  bool seek(uint32_t pos) {
    return seekSet(pos);
    cc14:	1c20      	adds	r0, r4, #0
    cc16:	4379      	muls	r1, r7
    cc18:	310a      	adds	r1, #10
    cc1a:	1989      	adds	r1, r1, r6
    cc1c:	f000 fab8 	bl	d190 <_ZN7FatFile7seekSetEm>
			f.read(&b, 1);
    cc20:	2201      	movs	r2, #1
    cc22:	a903      	add	r1, sp, #12
    cc24:	1c20      	adds	r0, r4, #0
    cc26:	f000 f9bf 	bl	cfa8 <_ZN7FatFile4readEPvj>
			f.seek(SAVEHEADER_SIZE + (blocks_new * 5) + i);
    cc2a:	466b      	mov	r3, sp
    cc2c:	8959      	ldrh	r1, [r3, #10]
    cc2e:	1c20      	adds	r0, r4, #0
    cc30:	4379      	muls	r1, r7
    cc32:	310a      	adds	r1, #10
    cc34:	1989      	adds	r1, r1, r6
    cc36:	f000 faab 	bl	d190 <_ZN7FatFile7seekSetEm>
			f.write(&b, 1);
    cc3a:	9800      	ldr	r0, [sp, #0]
    cc3c:	a903      	add	r1, sp, #12
    cc3e:	2201      	movs	r2, #1
    cc40:	f7f9 f806 	bl	5c50 <_ZN4File5writeEPKhj>
			f.seekSet(SAVEHEADER_SIZE + blocks_new + i*4);
			f.write(&b, 4);
		}
		
		// now we fix the payload
		for (uint32_t i = 0; i < payload_size; i++) {
    cc44:	3601      	adds	r6, #1
    cc46:	e7df      	b.n	cc08 <_ZN14Gamebuino_Meta4Save8openFileEv+0x16c>
			f.seek(SAVEHEADER_SIZE + (blocks_old * 5) + i);
			f.read(&b, 1);
			f.seek(SAVEHEADER_SIZE + (blocks_new * 5) + i);
			f.write(&b, 1);
		}
		f.truncate(SAVEHEADER_SIZE + (blocks_new * 5) + payload_size);
    cc48:	466a      	mov	r2, sp
    cc4a:	8951      	ldrh	r1, [r2, #10]
    cc4c:	1c20      	adds	r0, r4, #0
    cc4e:	4379      	muls	r1, r7
    cc50:	310a      	adds	r1, #10
    cc52:	18c9      	adds	r1, r1, r3
    cc54:	f000 fcf8 	bl	d648 <_ZN7FatFile8truncateEm>
    cc58:	e074      	b.n	cd44 <_ZN14Gamebuino_Meta4Save8openFileEv+0x2a8>
	} else {
		// we need to grow the block size
		
		// first we grow the file by the desired amount
		f.seekSet(SAVEHEADER_SIZE + (blocks_old * 5) + payload_size);
    cc5a:	2205      	movs	r2, #5
    cc5c:	4353      	muls	r3, r2
    cc5e:	6ca9      	ldr	r1, [r5, #72]	; 0x48
    cc60:	1c20      	adds	r0, r4, #0
    cc62:	310a      	adds	r1, #10
    cc64:	18c9      	adds	r1, r1, r3
    cc66:	f000 fa93 	bl	d190 <_ZN7FatFile7seekSetEm>
		for (uint32_t i = 0; i < (blocks_new - blocks_old)*5; i++) {
    cc6a:	9e01      	ldr	r6, [sp, #4]
    cc6c:	4668      	mov	r0, sp
    cc6e:	8942      	ldrh	r2, [r0, #10]
    cc70:	8903      	ldrh	r3, [r0, #8]
    cc72:	1ad3      	subs	r3, r2, r3
    cc74:	2205      	movs	r2, #5
    cc76:	4353      	muls	r3, r2
    cc78:	429e      	cmp	r6, r3
    cc7a:	d205      	bcs.n	cc88 <_ZN14Gamebuino_Meta4Save8openFileEv+0x1ec>
			f.write((uint8_t)0);
    cc7c:	9800      	ldr	r0, [sp, #0]
    cc7e:	2100      	movs	r1, #0
    cc80:	f7f9 f833 	bl	5cea <_ZN4File5writeEh>
	} else {
		// we need to grow the block size
		
		// first we grow the file by the desired amount
		f.seekSet(SAVEHEADER_SIZE + (blocks_old * 5) + payload_size);
		for (uint32_t i = 0; i < (blocks_new - blocks_old)*5; i++) {
    cc84:	3601      	adds	r6, #1
    cc86:	e7f1      	b.n	cc6c <_ZN14Gamebuino_Meta4Save8openFileEv+0x1d0>
    cc88:	2600      	movs	r6, #0
			f.write((uint8_t)0);
		}
		
		// next we shift the payload back
		for (uint32_t i = 0; i < payload_size; i++) {
    cc8a:	6ca9      	ldr	r1, [r5, #72]	; 0x48
    cc8c:	428e      	cmp	r6, r1
    cc8e:	d220      	bcs.n	ccd2 <_ZN14Gamebuino_Meta4Save8openFileEv+0x236>
			uint8_t b;
			f.seek(SAVEHEADER_SIZE + (blocks_old * 5) + (payload_size - i - 1));
    cc90:	466a      	mov	r2, sp
    cc92:	8913      	ldrh	r3, [r2, #8]
    cc94:	2705      	movs	r7, #5
    cc96:	437b      	muls	r3, r7
    cc98:	3109      	adds	r1, #9
    cc9a:	18c9      	adds	r1, r1, r3
    cc9c:	1b89      	subs	r1, r1, r6
    cc9e:	1c20      	adds	r0, r4, #0
    cca0:	f000 fa76 	bl	d190 <_ZN7FatFile7seekSetEm>
			f.read(&b, 1);
    cca4:	2201      	movs	r2, #1
    cca6:	a903      	add	r1, sp, #12
    cca8:	1c20      	adds	r0, r4, #0
    ccaa:	f000 f97d 	bl	cfa8 <_ZN7FatFile4readEPvj>
			f.seek(SAVEHEADER_SIZE + (blocks_new * 5) + (payload_size - i - 1));
    ccae:	466b      	mov	r3, sp
    ccb0:	330a      	adds	r3, #10
    ccb2:	881b      	ldrh	r3, [r3, #0]
    ccb4:	6ca9      	ldr	r1, [r5, #72]	; 0x48
    ccb6:	435f      	muls	r7, r3
    ccb8:	3109      	adds	r1, #9
    ccba:	19c9      	adds	r1, r1, r7
    ccbc:	1b89      	subs	r1, r1, r6
    ccbe:	1c20      	adds	r0, r4, #0
    ccc0:	f000 fa66 	bl	d190 <_ZN7FatFile7seekSetEm>
			f.write(&b, 1);
    ccc4:	9800      	ldr	r0, [sp, #0]
    ccc6:	a903      	add	r1, sp, #12
    ccc8:	2201      	movs	r2, #1
    ccca:	f7f8 ffc1 	bl	5c50 <_ZN4File5writeEPKhj>
		for (uint32_t i = 0; i < (blocks_new - blocks_old)*5; i++) {
			f.write((uint8_t)0);
		}
		
		// next we shift the payload back
		for (uint32_t i = 0; i < payload_size; i++) {
    ccce:	3601      	adds	r6, #1
    ccd0:	e7db      	b.n	cc8a <_ZN14Gamebuino_Meta4Save8openFileEv+0x1ee>
    ccd2:	2600      	movs	r6, #0
			f.write(&b, 1);
		}
		
		// next we offset the blocks
		
		for (uint16_t i = 0; i < blocks_old; i++) {
    ccd4:	4669      	mov	r1, sp
    ccd6:	890b      	ldrh	r3, [r1, #8]
    ccd8:	1c19      	adds	r1, r3, #0
    ccda:	310a      	adds	r1, #10
    ccdc:	429e      	cmp	r6, r3
    ccde:	d220      	bcs.n	cd22 <_ZN14Gamebuino_Meta4Save8openFileEv+0x286>
			uint32_t b;
			f.seekSet(SAVEHEADER_SIZE + blocks_old + (blocks_old - i - 1)*4);
    cce0:	1b9b      	subs	r3, r3, r6
    cce2:	3b01      	subs	r3, #1
    cce4:	009b      	lsls	r3, r3, #2
    cce6:	18c9      	adds	r1, r1, r3
    cce8:	1c20      	adds	r0, r4, #0
    ccea:	f000 fa51 	bl	d190 <_ZN7FatFile7seekSetEm>
			f.read(&b, 4);
    ccee:	2204      	movs	r2, #4
    ccf0:	a903      	add	r1, sp, #12
    ccf2:	1c20      	adds	r0, r4, #0
    ccf4:	f000 f958 	bl	cfa8 <_ZN7FatFile4readEPvj>
			f.seekSet(SAVEHEADER_SIZE + blocks_new + (blocks_old - i - 1)*4);
    ccf8:	4668      	mov	r0, sp
    ccfa:	8901      	ldrh	r1, [r0, #8]
    ccfc:	466b      	mov	r3, sp
    ccfe:	330a      	adds	r3, #10
    cd00:	881b      	ldrh	r3, [r3, #0]
    cd02:	1b89      	subs	r1, r1, r6
    cd04:	3901      	subs	r1, #1
    cd06:	330a      	adds	r3, #10
    cd08:	0089      	lsls	r1, r1, #2
    cd0a:	1859      	adds	r1, r3, r1
    cd0c:	1c20      	adds	r0, r4, #0
    cd0e:	f000 fa3f 	bl	d190 <_ZN7FatFile7seekSetEm>
			f.write(&b, 1);
		}
		
		// next we offset the blocks
		
		for (uint16_t i = 0; i < blocks_old; i++) {
    cd12:	3601      	adds	r6, #1
			uint32_t b;
			f.seekSet(SAVEHEADER_SIZE + blocks_old + (blocks_old - i - 1)*4);
			f.read(&b, 4);
			f.seekSet(SAVEHEADER_SIZE + blocks_new + (blocks_old - i - 1)*4);
			f.write(&b, 4);
    cd14:	1c20      	adds	r0, r4, #0
    cd16:	a903      	add	r1, sp, #12
    cd18:	2204      	movs	r2, #4
    cd1a:	f000 fce1 	bl	d6e0 <_ZN7FatFile5writeEPKvj>
			f.write(&b, 1);
		}
		
		// next we offset the blocks
		
		for (uint16_t i = 0; i < blocks_old; i++) {
    cd1e:	b2b6      	uxth	r6, r6
    cd20:	e7d8      	b.n	ccd4 <_ZN14Gamebuino_Meta4Save8openFileEv+0x238>
			f.seekSet(SAVEHEADER_SIZE + blocks_new + (blocks_old - i - 1)*4);
			f.write(&b, 4);
		}
		
		// finally we nullate the new block metadata
		f.seekSet(SAVEHEADER_SIZE + blocks_old);
    cd22:	1c20      	adds	r0, r4, #0
    cd24:	f000 fa34 	bl	d190 <_ZN7FatFile7seekSetEm>
		for (uint16_t i = blocks_old; i < blocks_new; i++) {
    cd28:	466a      	mov	r2, sp
    cd2a:	8916      	ldrh	r6, [r2, #8]
    cd2c:	466b      	mov	r3, sp
    cd2e:	330a      	adds	r3, #10
    cd30:	881b      	ldrh	r3, [r3, #0]
    cd32:	42b3      	cmp	r3, r6
    cd34:	d906      	bls.n	cd44 <_ZN14Gamebuino_Meta4Save8openFileEv+0x2a8>
			f.write((uint8_t)0);
    cd36:	9800      	ldr	r0, [sp, #0]
    cd38:	2100      	movs	r1, #0
			f.write(&b, 4);
		}
		
		// finally we nullate the new block metadata
		f.seekSet(SAVEHEADER_SIZE + blocks_old);
		for (uint16_t i = blocks_old; i < blocks_new; i++) {
    cd3a:	3601      	adds	r6, #1
			f.write((uint8_t)0);
    cd3c:	f7f8 ffd5 	bl	5cea <_ZN4File5writeEh>
			f.write(&b, 4);
		}
		
		// finally we nullate the new block metadata
		f.seekSet(SAVEHEADER_SIZE + blocks_old);
		for (uint16_t i = blocks_old; i < blocks_new; i++) {
    cd40:	b2b6      	uxth	r6, r6
    cd42:	e7f3      	b.n	cd2c <_ZN14Gamebuino_Meta4Save8openFileEv+0x290>
			f.write((uint8_t)0);
		}
	}
	blocks = blocks_new;
    cd44:	466e      	mov	r6, sp
    cd46:	8973      	ldrh	r3, [r6, #10]
    cd48:	3508      	adds	r5, #8
    cd4a:	87eb      	strh	r3, [r5, #62]	; 0x3e
	f.seekSet(4);
    cd4c:	2104      	movs	r1, #4
		f.seekSet(SAVEHEADER_SIZE + blocks_old);
		for (uint16_t i = blocks_old; i < blocks_new; i++) {
			f.write((uint8_t)0);
		}
	}
	blocks = blocks_new;
    cd4e:	360a      	adds	r6, #10
	f.seekSet(4);
    cd50:	1c20      	adds	r0, r4, #0
    cd52:	f000 fa1d 	bl	d190 <_ZN7FatFile7seekSetEm>
	f.write(&blocks_new, 2);
    cd56:	1c20      	adds	r0, r4, #0
    cd58:	1c31      	adds	r1, r6, #0
    cd5a:	2202      	movs	r2, #2
    cd5c:	f000 fcc0 	bl	d6e0 <_ZN7FatFile5writeEPKvj>
    uint32_t n = FatFile::available();
    return n > INT_MAX ? INT_MAX : n;
  }
  /** Ensure that any bytes written to the file are saved to the SD card. */
  void flush() {
    FatFile::sync();
    cd60:	1c20      	adds	r0, r4, #0
    cd62:	f000 fb01 	bl	d368 <_ZN7FatFile4syncEv>
	f.flush();
}
    cd66:	b011      	add	sp, #68	; 0x44
    cd68:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cd6a:	46c0      	nop			; (mov r8, r8)
    cd6c:	20000a04 	.word	0x20000a04
    cd70:	00014a40 	.word	0x00014a40
    cd74:	0001557a 	.word	0x0001557a

0000cd78 <_ZN14Gamebuino_Meta4Save3getEt>:
	f.seekSet(SAVEHEADER_SIZE + blocks + (4*i));
	f.read(&val, 4);
	return val;
}

int32_t Save::get(uint16_t i) {
    cd78:	b537      	push	{r0, r1, r2, r4, r5, lr}
    cd7a:	1c04      	adds	r4, r0, #0
    cd7c:	1c0d      	adds	r5, r1, #0
	openFile();
    cd7e:	f7ff fe8d 	bl	ca9c <_ZN14Gamebuino_Meta4Save8openFileEv>
	SaveVar s = getVarInfo(i);
    cd82:	1c20      	adds	r0, r4, #0
    cd84:	1c29      	adds	r1, r5, #0
    cd86:	f7ff fd99 	bl	c8bc <_ZN14Gamebuino_Meta4Save10getVarInfoEt>
    cd8a:	ab01      	add	r3, sp, #4
    cd8c:	8018      	strh	r0, [r3, #0]
	if (!s.defined) {
    cd8e:	b2c0      	uxtb	r0, r0
    cd90:	2800      	cmp	r0, #0
    cd92:	d117      	bne.n	cdc4 <_ZN14Gamebuino_Meta4Save3getEt+0x4c>
		for (uint16_t j = 0; j < num_defaults; j++) {
    cd94:	1da3      	adds	r3, r4, #6
    cd96:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
    cd98:	b283      	uxth	r3, r0
    cd9a:	4293      	cmp	r3, r2
    cd9c:	d210      	bcs.n	cdc0 <_ZN14Gamebuino_Meta4Save3getEt+0x48>
    cd9e:	230c      	movs	r3, #12
    cda0:	4343      	muls	r3, r0
			if (defaults[j].i == i) {
    cda2:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
    cda4:	3001      	adds	r0, #1
    cda6:	18cb      	adds	r3, r1, r3
    cda8:	8819      	ldrh	r1, [r3, #0]
    cdaa:	42a9      	cmp	r1, r5
    cdac:	d1f4      	bne.n	cd98 <_ZN14Gamebuino_Meta4Save3getEt+0x20>
				// we found our element!
				if (defaults[j].type != SAVETYPE_INT) {
    cdae:	789a      	ldrb	r2, [r3, #2]
    cdb0:	2a00      	cmp	r2, #0
    cdb2:	d003      	beq.n	cdbc <_ZN14Gamebuino_Meta4Save3getEt+0x44>
					error("trying to get from a non-int type");
    cdb4:	1c20      	adds	r0, r4, #0
    cdb6:	4907      	ldr	r1, [pc, #28]	; (cdd4 <_ZN14Gamebuino_Meta4Save3getEt+0x5c>)
    cdb8:	f7ff fd5e 	bl	c878 <_ZN14Gamebuino_Meta4Save5errorEPKc>
				}
				return defaults[j].val.ival;
    cdbc:	6858      	ldr	r0, [r3, #4]
    cdbe:	e008      	b.n	cdd2 <_ZN14Gamebuino_Meta4Save3getEt+0x5a>
			}
		}
		return 0;
    cdc0:	2000      	movs	r0, #0
    cdc2:	e006      	b.n	cdd2 <_ZN14Gamebuino_Meta4Save3getEt+0x5a>
	}
	if (s.type != SAVETYPE_INT) {
    cdc4:	785b      	ldrb	r3, [r3, #1]
    cdc6:	2b00      	cmp	r3, #0
    cdc8:	d1f4      	bne.n	cdb4 <_ZN14Gamebuino_Meta4Save3getEt+0x3c>
		error("trying to get from a non-int type");
	}
	return (int32_t)_get(i);
    cdca:	1c20      	adds	r0, r4, #0
    cdcc:	1c29      	adds	r1, r5, #0
    cdce:	f7ff fd9d 	bl	c90c <_ZN14Gamebuino_Meta4Save4_getEt>
}
    cdd2:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    cdd4:	0001558c 	.word	0x0001558c

0000cdd8 <_ZN14Gamebuino_Meta4Save3setEtl>:
void Save::_set(uint16_t i, uint32_t b) {
	f.seekSet(SAVEHEADER_SIZE + blocks + (4*i));
	f.write(&b, 4);
}

bool Save::set(uint16_t i, int32_t num) {
    cdd8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    cdda:	1c04      	adds	r4, r0, #0
    cddc:	1c0d      	adds	r5, r1, #0
    cdde:	1c16      	adds	r6, r2, #0
	openFile();
    cde0:	f7ff fe5c 	bl	ca9c <_ZN14Gamebuino_Meta4Save8openFileEv>
	if (readOnly) {
    cde4:	1c23      	adds	r3, r4, #0
    cde6:	3339      	adds	r3, #57	; 0x39
    cde8:	781b      	ldrb	r3, [r3, #0]
		return false;
    cdea:	2000      	movs	r0, #0
	f.write(&b, 4);
}

bool Save::set(uint16_t i, int32_t num) {
	openFile();
	if (readOnly) {
    cdec:	4283      	cmp	r3, r0
    cdee:	d136      	bne.n	ce5e <_ZN14Gamebuino_Meta4Save3setEtl+0x86>
		return false;
	}
	SaveVar s = getVarInfo(i);
    cdf0:	1c20      	adds	r0, r4, #0
    cdf2:	1c29      	adds	r1, r5, #0
    cdf4:	f7ff fd62 	bl	c8bc <_ZN14Gamebuino_Meta4Save10getVarInfoEt>
    cdf8:	ab01      	add	r3, sp, #4
    cdfa:	8018      	strh	r0, [r3, #0]
	if (s.defined && s.type != SAVETYPE_INT) {
    cdfc:	b2c0      	uxtb	r0, r0
    cdfe:	2800      	cmp	r0, #0
    ce00:	d002      	beq.n	ce08 <_ZN14Gamebuino_Meta4Save3setEtl+0x30>
    ce02:	785b      	ldrb	r3, [r3, #1]
    ce04:	2b00      	cmp	r3, #0
    ce06:	d110      	bne.n	ce2a <_ZN14Gamebuino_Meta4Save3setEtl+0x52>
		// trying to store an int in a non-int
		error("trying set to a non-int type");
	}
	for (uint16_t j = 0; j < num_defaults; j++) {
    ce08:	1da3      	adds	r3, r4, #6
    ce0a:	8fd9      	ldrh	r1, [r3, #62]	; 0x3e
    ce0c:	2300      	movs	r3, #0
    ce0e:	b29a      	uxth	r2, r3
    ce10:	428a      	cmp	r2, r1
    ce12:	d20e      	bcs.n	ce32 <_ZN14Gamebuino_Meta4Save3setEtl+0x5a>
    ce14:	220c      	movs	r2, #12
    ce16:	435a      	muls	r2, r3
		if (defaults[j].i == i) {
    ce18:	6ce7      	ldr	r7, [r4, #76]	; 0x4c
    ce1a:	3301      	adds	r3, #1
    ce1c:	18ba      	adds	r2, r7, r2
    ce1e:	8817      	ldrh	r7, [r2, #0]
    ce20:	42af      	cmp	r7, r5
    ce22:	d1f4      	bne.n	ce0e <_ZN14Gamebuino_Meta4Save3setEtl+0x36>
			// we found our element!
			if (defaults[j].type != SAVETYPE_INT) {
    ce24:	7893      	ldrb	r3, [r2, #2]
    ce26:	2b00      	cmp	r3, #0
    ce28:	d003      	beq.n	ce32 <_ZN14Gamebuino_Meta4Save3setEtl+0x5a>
		return false;
	}
	SaveVar s = getVarInfo(i);
	if (s.defined && s.type != SAVETYPE_INT) {
		// trying to store an int in a non-int
		error("trying set to a non-int type");
    ce2a:	1c20      	adds	r0, r4, #0
    ce2c:	490c      	ldr	r1, [pc, #48]	; (ce60 <_ZN14Gamebuino_Meta4Save3setEtl+0x88>)
    ce2e:	f7ff fd23 	bl	c878 <_ZN14Gamebuino_Meta4Save5errorEPKc>
    ce32:	1c27      	adds	r7, r4, #0
    ce34:	3714      	adds	r7, #20
				error("trying set to a non-int type");
			}
			break;
		}
	}
	if (!s.defined) {
    ce36:	2800      	cmp	r0, #0
    ce38:	d108      	bne.n	ce4c <_ZN14Gamebuino_Meta4Save3setEtl+0x74>
		f.seekSet(SAVEHEADER_SIZE + i);
    ce3a:	1c29      	adds	r1, r5, #0
    ce3c:	310a      	adds	r1, #10
    ce3e:	1c38      	adds	r0, r7, #0
    ce40:	f000 f9a6 	bl	d190 <_ZN7FatFile7seekSetEm>
		f.write((uint8_t)(0x80 | SAVETYPE_INT));
    ce44:	1d20      	adds	r0, r4, #4
    ce46:	2180      	movs	r1, #128	; 0x80
    ce48:	f7f8 ff4f 	bl	5cea <_ZN4File5writeEh>
	}
	_set(i, (uint32_t)num);
    ce4c:	1c20      	adds	r0, r4, #0
    ce4e:	1c29      	adds	r1, r5, #0
    ce50:	1c32      	adds	r2, r6, #0
    ce52:	f7ff fd6d 	bl	c930 <_ZN14Gamebuino_Meta4Save4_setEtm>
    ce56:	1c38      	adds	r0, r7, #0
    ce58:	f000 fa86 	bl	d368 <_ZN7FatFile4syncEv>
	f.flush();
	return true;
    ce5c:	2001      	movs	r0, #1
}
    ce5e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    ce60:	000155d1 	.word	0x000155d1

0000ce64 <_ZN9FatVolume9cacheSyncEv>:
  FatCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t blockNumber, uint8_t options) {
    return m_fatCache.read(blockNumber,
                           options | FatCache::CACHE_STATUS_MIRROR_FAT);
  }
  bool cacheSync() {
    ce64:	b510      	push	{r4, lr}
    ce66:	1c04      	adds	r4, r0, #0
    return m_cache.sync() && m_fatCache.sync();
    ce68:	3024      	adds	r0, #36	; 0x24
    ce6a:	f001 f951 	bl	e110 <_ZN8FatCache4syncEv>
    ce6e:	1c03      	adds	r3, r0, #0
    ce70:	2000      	movs	r0, #0
    ce72:	4283      	cmp	r3, r0
    ce74:	d004      	beq.n	ce80 <_ZN9FatVolume9cacheSyncEv+0x1c>
    ce76:	238c      	movs	r3, #140	; 0x8c
    ce78:	009b      	lsls	r3, r3, #2
    ce7a:	18e0      	adds	r0, r4, r3
    ce7c:	f001 f948 	bl	e110 <_ZN8FatCache4syncEv>
  }
    ce80:	bd10      	pop	{r4, pc}

0000ce82 <_ZN7FatFile10addClusterEv>:
FatFile* FatFile::m_cwd = 0;
// Callback function for date/time.
void (*FatFile::m_dateTime)(uint16_t* date, uint16_t* time) = 0;
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    ce82:	b508      	push	{r3, lr}
  m_flags |= F_FILE_DIR_DIRTY;
    ce84:	2380      	movs	r3, #128	; 0x80
    ce86:	7881      	ldrb	r1, [r0, #2]
    ce88:	425b      	negs	r3, r3
FatFile* FatFile::m_cwd = 0;
// Callback function for date/time.
void (*FatFile::m_dateTime)(uint16_t* date, uint16_t* time) = 0;
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    ce8a:	1c02      	adds	r2, r0, #0
  m_flags |= F_FILE_DIR_DIRTY;
    ce8c:	430b      	orrs	r3, r1
    ce8e:	7083      	strb	r3, [r0, #2]
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
    ce90:	6911      	ldr	r1, [r2, #16]
    ce92:	6880      	ldr	r0, [r0, #8]
    ce94:	3210      	adds	r2, #16
    ce96:	f001 f9ef 	bl	e278 <_ZN9FatVolume15allocateClusterEmPm>
}
    ce9a:	bd08      	pop	{r3, pc}

0000ce9c <_ZN7FatFile13addDirClusterEv>:
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first block of cluster in the cache.
bool FatFile::addDirCluster() {
    ce9c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  bool isRoot32() const {
    return m_attr & FILE_ATTR_ROOT32;
  }
  /** \return True if this is the FAT12 of FAT16 root directory. */
  bool isRootFixed() const {
    return m_attr & FILE_ATTR_ROOT_FIXED;
    ce9e:	7805      	ldrb	r5, [r0, #0]
  uint32_t block;
  cache_t* pc;

  if (isRootFixed()) {
    cea0:	2320      	movs	r3, #32
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
}
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first block of cluster in the cache.
bool FatFile::addDirCluster() {
    cea2:	1c04      	adds	r4, r0, #0
  uint32_t block;
  cache_t* pc;

  if (isRootFixed()) {
    cea4:	401d      	ands	r5, r3
    cea6:	d001      	beq.n	ceac <_ZN7FatFile13addDirClusterEv+0x10>
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += 512UL*m_vol->blocksPerCluster();
  return true;

fail:
  return false;
    cea8:	2600      	movs	r6, #0
    ceaa:	e02d      	b.n	cf08 <_ZN7FatFile13addDirClusterEv+0x6c>
  if (isRootFixed()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // max folder size
  if (m_curPosition >= 512UL*4095) {
    ceac:	4b17      	ldr	r3, [pc, #92]	; (cf0c <_ZN7FatFile13addDirClusterEv+0x70>)
    ceae:	6942      	ldr	r2, [r0, #20]
    ceb0:	429a      	cmp	r2, r3
    ceb2:	d8f9      	bhi.n	cea8 <_ZN7FatFile13addDirClusterEv+0xc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    ceb4:	f7ff ffe5 	bl	ce82 <_ZN7FatFile10addClusterEv>
    ceb8:	1e06      	subs	r6, r0, #0
    ceba:	d0f5      	beq.n	cea8 <_ZN7FatFile13addDirClusterEv+0xc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  block = m_vol->clusterStartBlock(m_curCluster);
    cebc:	6921      	ldr	r1, [r4, #16]
    cebe:	68a0      	ldr	r0, [r4, #8]
    cec0:	f001 f972 	bl	e1a8 <_ZNK9FatVolume17clusterStartBlockEm>
    cec4:	9001      	str	r0, [sp, #4]
  bool cacheSync() {
    return m_cache.sync();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t blockNumber, uint8_t options) {
    return m_cache.read(blockNumber, options);
    cec6:	68a0      	ldr	r0, [r4, #8]
    cec8:	9901      	ldr	r1, [sp, #4]
    ceca:	3024      	adds	r0, #36	; 0x24
    cecc:	2205      	movs	r2, #5
    cece:	f001 f946 	bl	e15e <_ZN8FatCache4readEmh>
    ced2:	1e07      	subs	r7, r0, #0
  pc = m_vol->cacheFetchData(block, FatCache::CACHE_RESERVE_FOR_WRITE);
  if (!pc) {
    ced4:	d0e8      	beq.n	cea8 <_ZN7FatFile13addDirClusterEv+0xc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, 512);
    ced6:	2280      	movs	r2, #128	; 0x80
    ced8:	1c29      	adds	r1, r5, #0
    ceda:	0092      	lsls	r2, r2, #2
    cedc:	f004 fb76 	bl	115cc <memset>
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->blocksPerCluster(); i++) {
    cee0:	2501      	movs	r5, #1
    cee2:	68a0      	ldr	r0, [r4, #8]
  }
  if (!addCluster()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  block = m_vol->clusterStartBlock(m_curCluster);
    cee4:	7903      	ldrb	r3, [r0, #4]
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, 512);
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->blocksPerCluster(); i++) {
    cee6:	429d      	cmp	r5, r3
    cee8:	d20a      	bcs.n	cf00 <_ZN7FatFile13addDirClusterEv+0x64>
    if (!m_vol->writeBlock(block + i, pc->data)) {
    ceea:	9a01      	ldr	r2, [sp, #4]
    ceec:	6803      	ldr	r3, [r0, #0]
    ceee:	18a9      	adds	r1, r5, r2
    cef0:	685b      	ldr	r3, [r3, #4]
    cef2:	1c3a      	adds	r2, r7, #0
    cef4:	4798      	blx	r3
    cef6:	2800      	cmp	r0, #0
    cef8:	d0d6      	beq.n	cea8 <_ZN7FatFile13addDirClusterEv+0xc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, 512);
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->blocksPerCluster(); i++) {
    cefa:	3501      	adds	r5, #1
    cefc:	b2ed      	uxtb	r5, r5
    cefe:	e7f0      	b.n	cee2 <_ZN7FatFile13addDirClusterEv+0x46>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += 512UL*m_vol->blocksPerCluster();
    cf00:	6962      	ldr	r2, [r4, #20]
    cf02:	025b      	lsls	r3, r3, #9
    cf04:	18d3      	adds	r3, r2, r3
    cf06:	6163      	str	r3, [r4, #20]
  return true;

fail:
  return false;
}
    cf08:	1c30      	adds	r0, r6, #0
    cf0a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    cf0c:	001ffdff 	.word	0x001ffdff

0000cf10 <_ZN7FatFile13cacheDirEntryEh>:
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
dir_t* FatFile::cacheDirEntry(uint8_t action) {
    cf10:	b510      	push	{r4, lr}
    cf12:	1c04      	adds	r4, r0, #0
    cf14:	6880      	ldr	r0, [r0, #8]
    cf16:	1c0a      	adds	r2, r1, #0
    cf18:	3024      	adds	r0, #36	; 0x24
    cf1a:	69a1      	ldr	r1, [r4, #24]
    cf1c:	f001 f91f 	bl	e15e <_ZN8FatCache4readEmh>
  cache_t* pc;
  pc = m_vol->cacheFetchData(m_dirBlock, action);
  if (!pc) {
    cf20:	2800      	cmp	r0, #0
    cf22:	d004      	beq.n	cf2e <_ZN7FatFile13cacheDirEntryEh+0x1e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return pc->dir + (m_dirIndex & 0XF);
    cf24:	88a2      	ldrh	r2, [r4, #4]
    cf26:	230f      	movs	r3, #15
    cf28:	4013      	ands	r3, r2
    cf2a:	015b      	lsls	r3, r3, #5
    cf2c:	18c0      	adds	r0, r0, r3

fail:
  return 0;
}
    cf2e:	bd10      	pop	{r4, pc}

0000cf30 <_ZN7FatFile7dirNameEPK14directoryEntryPc>:

fail:
  return false;
}
//------------------------------------------------------------------------------
uint8_t FatFile::dirName(const dir_t* dir, char* name) {
    cf30:	2200      	movs	r2, #0
    cf32:	b570      	push	{r4, r5, r6, lr}
  uint8_t j = 0;
    cf34:	1c13      	adds	r3, r2, #0
  uint8_t lcBit = DIR_NT_LC_BASE;
    cf36:	2508      	movs	r5, #8
  for (uint8_t i = 0; i < 11; i++) {
    if (dir->name[i] == ' ') {
    cf38:	5c84      	ldrb	r4, [r0, r2]
    cf3a:	2c20      	cmp	r4, #32
    cf3c:	d014      	beq.n	cf68 <_ZN7FatFile7dirNameEPK14directoryEntryPc+0x38>
      continue;
    }
    if (i == 8) {
    cf3e:	b2d4      	uxtb	r4, r2
    cf40:	2c08      	cmp	r4, #8
    cf42:	d104      	bne.n	cf4e <_ZN7FatFile7dirNameEPK14directoryEntryPc+0x1e>
      // Position bit for extension.
      lcBit = DIR_NT_LC_EXT;
      name[j++] = '.';
    cf44:	252e      	movs	r5, #46	; 0x2e
    cf46:	1c5c      	adds	r4, r3, #1
    cf48:	54cd      	strb	r5, [r1, r3]
    cf4a:	b2e3      	uxtb	r3, r4
    if (dir->name[i] == ' ') {
      continue;
    }
    if (i == 8) {
      // Position bit for extension.
      lcBit = DIR_NT_LC_EXT;
    cf4c:	2510      	movs	r5, #16
      name[j++] = '.';
    }
    char c = dir->name[i];
    cf4e:	5c84      	ldrb	r4, [r0, r2]
    if ('A' <= c && c <= 'Z' && (lcBit & dir->reservedNT)) {
    cf50:	1c26      	adds	r6, r4, #0
    cf52:	3e41      	subs	r6, #65	; 0x41
    cf54:	2e19      	cmp	r6, #25
    cf56:	d804      	bhi.n	cf62 <_ZN7FatFile7dirNameEPK14directoryEntryPc+0x32>
    cf58:	7b06      	ldrb	r6, [r0, #12]
    cf5a:	422e      	tst	r6, r5
    cf5c:	d001      	beq.n	cf62 <_ZN7FatFile7dirNameEPK14directoryEntryPc+0x32>
      c += 'a' - 'A';
    cf5e:	3420      	adds	r4, #32
    cf60:	b2e4      	uxtb	r4, r4
    }
    name[j++] = c;
    cf62:	1c5e      	adds	r6, r3, #1
    cf64:	54cc      	strb	r4, [r1, r3]
    cf66:	b2f3      	uxtb	r3, r6
    cf68:	3201      	adds	r2, #1
}
//------------------------------------------------------------------------------
uint8_t FatFile::dirName(const dir_t* dir, char* name) {
  uint8_t j = 0;
  uint8_t lcBit = DIR_NT_LC_BASE;
  for (uint8_t i = 0; i < 11; i++) {
    cf6a:	2a0b      	cmp	r2, #11
    cf6c:	d1e4      	bne.n	cf38 <_ZN7FatFile7dirNameEPK14directoryEntryPc+0x8>
    if ('A' <= c && c <= 'Z' && (lcBit & dir->reservedNT)) {
      c += 'a' - 'A';
    }
    name[j++] = c;
  }
  name[j] = 0;
    cf6e:	2200      	movs	r2, #0
  return j;
}
    cf70:	1c18      	adds	r0, r3, #0
    if ('A' <= c && c <= 'Z' && (lcBit & dir->reservedNT)) {
      c += 'a' - 'A';
    }
    name[j++] = c;
  }
  name[j] = 0;
    cf72:	54ca      	strb	r2, [r1, r3]
  return j;
}
    cf74:	bd70      	pop	{r4, r5, r6, pc}

0000cf76 <_ZN7FatFile8openRootEP9FatVolume>:
fail:
  return false;
}
#endif  // DOXYGEN_SHOULD_SKIP_THIS
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    cf76:	b570      	push	{r4, r5, r6, lr}
  // error if file is already open
  if (isOpen()) {
    cf78:	7803      	ldrb	r3, [r0, #0]
  // read only
  m_flags = O_READ;
  return true;

fail:
  return false;
    cf7a:	2500      	movs	r5, #0
fail:
  return false;
}
#endif  // DOXYGEN_SHOULD_SKIP_THIS
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    cf7c:	1c04      	adds	r4, r0, #0
    cf7e:	1c0e      	adds	r6, r1, #0
  // error if file is already open
  if (isOpen()) {
    cf80:	42ab      	cmp	r3, r5
    cf82:	d10f      	bne.n	cfa4 <_ZN7FatFile8openRootEP9FatVolume+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(FatFile));
    cf84:	1c29      	adds	r1, r5, #0
    cf86:	2224      	movs	r2, #36	; 0x24
    cf88:	f004 fb20 	bl	115cc <memset>

  m_vol = vol;
    cf8c:	60a6      	str	r6, [r4, #8]
  switch (vol->fatType()) {
    cf8e:	79f3      	ldrb	r3, [r6, #7]
    cf90:	2b10      	cmp	r3, #16
    cf92:	d003      	beq.n	cf9c <_ZN7FatFile8openRootEP9FatVolume+0x26>
    cf94:	2b20      	cmp	r3, #32
    cf96:	d105      	bne.n	cfa4 <_ZN7FatFile8openRootEP9FatVolume+0x2e>
  case 16:
    m_attr = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attr = FILE_ATTR_ROOT32;
    cf98:	2340      	movs	r3, #64	; 0x40
    cf9a:	e000      	b.n	cf9e <_ZN7FatFile8openRootEP9FatVolume+0x28>
  switch (vol->fatType()) {
#if FAT12_SUPPORT
  case 12:
#endif  // FAT12_SUPPORT
  case 16:
    m_attr = FILE_ATTR_ROOT_FIXED;
    cf9c:	2320      	movs	r3, #32
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = O_READ;
    cf9e:	2501      	movs	r5, #1
  case 16:
    m_attr = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attr = FILE_ATTR_ROOT32;
    cfa0:	7023      	strb	r3, [r4, #0]
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = O_READ;
    cfa2:	70a5      	strb	r5, [r4, #2]
  return true;

fail:
  return false;
}
    cfa4:	1c28      	adds	r0, r5, #0
    cfa6:	bd70      	pop	{r4, r5, r6, pc}

0000cfa8 <_ZN7FatFile4readEPvj>:
    setpos(&pos);
  }
  return c;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    cfa8:	b5f0      	push	{r4, r5, r6, r7, lr}
    cfaa:	7803      	ldrb	r3, [r0, #0]
    cfac:	b085      	sub	sp, #20
    cfae:	1c04      	adds	r4, r0, #0
    cfb0:	9103      	str	r1, [sp, #12]
    cfb2:	9201      	str	r2, [sp, #4]
  size_t toRead;
  uint32_t block;  // raw device block number
  cache_t* pc;

  // error if not open for read
  if (!isOpen() || !(m_flags & O_READ)) {
    cfb4:	2b00      	cmp	r3, #0
    cfb6:	d013      	beq.n	cfe0 <_ZN7FatFile4readEPvj+0x38>
    cfb8:	7882      	ldrb	r2, [r0, #2]
    cfba:	07d1      	lsls	r1, r2, #31
    cfbc:	d510      	bpl.n	cfe0 <_ZN7FatFile4readEPvj+0x38>
    cfbe:	e016      	b.n	cfee <_ZN7FatFile4readEPvj+0x46>
  }
//------------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t blockOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterBlockMask;
    cfc0:	7945      	ldrb	r5, [r0, #5]
    cfc2:	400d      	ands	r5, r1
    cfc4:	9502      	str	r5, [sp, #8]
    offset = m_curPosition & 0X1FF;  // offset in block
    if (isRootFixed()) {
      block = m_vol->rootDirStart() + (m_curPosition >> 9);
    } else {
      blockOfCluster = m_vol->blockOfCluster(m_curPosition);
      if (offset == 0 && blockOfCluster == 0) {
    cfc6:	2f00      	cmp	r7, #0
    cfc8:	d143      	bne.n	d052 <_ZN7FatFile4readEPvj+0xaa>
    cfca:	2d00      	cmp	r5, #0
    cfcc:	d141      	bne.n	d052 <_ZN7FatFile4readEPvj+0xaa>
        // start of new cluster
        if (m_curPosition == 0) {
    cfce:	2b00      	cmp	r3, #0
    cfd0:	d031      	beq.n	d036 <_ZN7FatFile4readEPvj+0x8e>
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    cfd2:	1c22      	adds	r2, r4, #0
    cfd4:	6921      	ldr	r1, [r4, #16]
    cfd6:	3210      	adds	r2, #16
    cfd8:	f001 f8ec 	bl	e1b4 <_ZN9FatVolume6fatGetEmPm>
          if (fg < 0) {
    cfdc:	2800      	cmp	r0, #0
    cfde:	da31      	bge.n	d044 <_ZN7FatFile4readEPvj+0x9c>
    toRead -= n;
  }
  return nbyte - toRead;

fail:
  m_error |= READ_ERROR;
    cfe0:	7863      	ldrb	r3, [r4, #1]
    cfe2:	2202      	movs	r2, #2
    cfe4:	4313      	orrs	r3, r2
  return -1;
    cfe6:	2001      	movs	r0, #1
    toRead -= n;
  }
  return nbyte - toRead;

fail:
  m_error |= READ_ERROR;
    cfe8:	7063      	strb	r3, [r4, #1]
  return -1;
    cfea:	4240      	negs	r0, r0
    cfec:	e098      	b.n	d120 <_ZN7FatFile4readEPvj+0x178>
  if (!isOpen() || !(m_flags & O_READ)) {
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
    cfee:	071a      	lsls	r2, r3, #28
    cff0:	d503      	bpl.n	cffa <_ZN7FatFile4readEPvj+0x52>
    uint32_t tmp32 = m_fileSize - m_curPosition;
    cff2:	69e2      	ldr	r2, [r4, #28]
    cff4:	6965      	ldr	r5, [r4, #20]
    cff6:	1b53      	subs	r3, r2, r5
    cff8:	e007      	b.n	d00a <_ZN7FatFile4readEPvj+0x62>
    if (nbyte >= tmp32) {
      nbyte = tmp32;
    }
  } else if (isRootFixed()) {
    cffa:	0699      	lsls	r1, r3, #26
    cffc:	d509      	bpl.n	d012 <_ZN7FatFile4readEPvj+0x6a>
    uint16_t tmp16 = 32*m_vol->m_rootDirEntryCount - (uint16_t)m_curPosition;
    cffe:	68a2      	ldr	r2, [r4, #8]
    d000:	6965      	ldr	r5, [r4, #20]
    d002:	8913      	ldrh	r3, [r2, #8]
    d004:	015b      	lsls	r3, r3, #5
    d006:	1b5b      	subs	r3, r3, r5
    if (nbyte > tmp16) {
    d008:	b29b      	uxth	r3, r3
    d00a:	9d01      	ldr	r5, [sp, #4]
    d00c:	429d      	cmp	r5, r3
    d00e:	d900      	bls.n	d012 <_ZN7FatFile4readEPvj+0x6a>
    d010:	9301      	str	r3, [sp, #4]
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
    d012:	9d01      	ldr	r5, [sp, #4]
    d014:	9500      	str	r5, [sp, #0]
  return c;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
  int8_t fg;
  uint8_t blockOfCluster = 0;
    d016:	2500      	movs	r5, #0
    d018:	9502      	str	r5, [sp, #8]
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    d01a:	9d00      	ldr	r5, [sp, #0]
    d01c:	2d00      	cmp	r5, #0
    d01e:	d029      	beq.n	d074 <_ZN7FatFile4readEPvj+0xcc>
    size_t n;
    offset = m_curPosition & 0X1FF;  // offset in block
    d020:	6963      	ldr	r3, [r4, #20]
    setpos(&pos);
  }
  return c;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    d022:	7822      	ldrb	r2, [r4, #0]
    }
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & 0X1FF;  // offset in block
    d024:	05df      	lsls	r7, r3, #23
    d026:	0dff      	lsrs	r7, r7, #23
    d028:	68a0      	ldr	r0, [r4, #8]
    d02a:	0a59      	lsrs	r1, r3, #9
    if (isRootFixed()) {
    d02c:	0695      	lsls	r5, r2, #26
    d02e:	d5c7      	bpl.n	cfc0 <_ZN7FatFile4readEPvj+0x18>
      block = m_vol->rootDirStart() + (m_curPosition >> 9);
    d030:	6a05      	ldr	r5, [r0, #32]
    d032:	194d      	adds	r5, r1, r5
    d034:	e013      	b.n	d05e <_ZN7FatFile4readEPvj+0xb6>
      blockOfCluster = m_vol->blockOfCluster(m_curPosition);
      if (offset == 0 && blockOfCluster == 0) {
        // start of new cluster
        if (m_curPosition == 0) {
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    d036:	0651      	lsls	r1, r2, #25
    d038:	d501      	bpl.n	d03e <_ZN7FatFile4readEPvj+0x96>
    uint32_t tmp32 = m_fileSize - m_curPosition;
    if (nbyte >= tmp32) {
      nbyte = tmp32;
    }
  } else if (isRootFixed()) {
    uint16_t tmp16 = 32*m_vol->m_rootDirEntryCount - (uint16_t)m_curPosition;
    d03a:	6a03      	ldr	r3, [r0, #32]
    d03c:	e000      	b.n	d040 <_ZN7FatFile4readEPvj+0x98>
      blockOfCluster = m_vol->blockOfCluster(m_curPosition);
      if (offset == 0 && blockOfCluster == 0) {
        // start of new cluster
        if (m_curPosition == 0) {
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    d03e:	6a23      	ldr	r3, [r4, #32]
    d040:	6123      	str	r3, [r4, #16]
    d042:	e006      	b.n	d052 <_ZN7FatFile4readEPvj+0xaa>
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
          if (fg < 0) {
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
    d044:	2800      	cmp	r0, #0
    d046:	d104      	bne.n	d052 <_ZN7FatFile4readEPvj+0xaa>
   * the value false, is returned for failure.
   */  
  bool getSFN(char* name);
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_attr & FILE_ATTR_DIR;
    d048:	7822      	ldrb	r2, [r4, #0]
            if (isDir()) {
    d04a:	2370      	movs	r3, #112	; 0x70
    d04c:	421a      	tst	r2, r3
    d04e:	d111      	bne.n	d074 <_ZN7FatFile4readEPvj+0xcc>
    d050:	e7c6      	b.n	cfe0 <_ZN7FatFile4readEPvj+0x38>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      }
      block = m_vol->clusterStartBlock(m_curCluster) + blockOfCluster;
    d052:	68a0      	ldr	r0, [r4, #8]
    d054:	6921      	ldr	r1, [r4, #16]
    d056:	f001 f8a7 	bl	e1a8 <_ZNK9FatVolume17clusterStartBlockEm>
    d05a:	9a02      	ldr	r2, [sp, #8]
    d05c:	1885      	adds	r5, r0, r2
    d05e:	68a0      	ldr	r0, [r4, #8]
    }
    if (offset != 0 || toRead < 512 || block == m_vol->cacheBlockNumber()) {
    d060:	2f00      	cmp	r7, #0
    d062:	d143      	bne.n	d0ec <_ZN7FatFile4readEPvj+0x144>
    d064:	4b2f      	ldr	r3, [pc, #188]	; (d124 <_ZN7FatFile4readEPvj+0x17c>)
    d066:	9900      	ldr	r1, [sp, #0]
    d068:	4299      	cmp	r1, r3
    d06a:	d93f      	bls.n	d0ec <_ZN7FatFile4readEPvj+0x144>
  }
  cache_t *cacheAddress() {
    return m_cache.block();
  }
  uint32_t cacheBlockNumber() {
    return m_cache.lbn();
    d06c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    d06e:	429d      	cmp	r5, r3
    d070:	d104      	bne.n	d07c <_ZN7FatFile4readEPvj+0xd4>
    d072:	e03b      	b.n	d0ec <_ZN7FatFile4readEPvj+0x144>
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return nbyte - toRead;
    d074:	9d01      	ldr	r5, [sp, #4]
    d076:	9900      	ldr	r1, [sp, #0]
    d078:	1a68      	subs	r0, r5, r1
    d07a:	e051      	b.n	d120 <_ZN7FatFile4readEPvj+0x178>
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_BLOCK_IO
    } else if (toRead >= 1024) {
    d07c:	4a2a      	ldr	r2, [pc, #168]	; (d128 <_ZN7FatFile4readEPvj+0x180>)
    d07e:	9900      	ldr	r1, [sp, #0]
    d080:	4291      	cmp	r1, r2
    d082:	d920      	bls.n	d0c6 <_ZN7FatFile4readEPvj+0x11e>
      uint8_t nb = toRead >> 9;
    d084:	9a00      	ldr	r2, [sp, #0]
    d086:	0a57      	lsrs	r7, r2, #9
  bool isRoot32() const {
    return m_attr & FILE_ATTR_ROOT32;
  }
  /** \return True if this is the FAT12 of FAT16 root directory. */
  bool isRootFixed() const {
    return m_attr & FILE_ATTR_ROOT_FIXED;
    d088:	7822      	ldrb	r2, [r4, #0]
    d08a:	b2ff      	uxtb	r7, r7
      if (!isRootFixed()) {
    d08c:	0691      	lsls	r1, r2, #26
    d08e:	d408      	bmi.n	d0a2 <_ZN7FatFile4readEPvj+0xfa>
        uint8_t mb = m_vol->blocksPerCluster() - blockOfCluster;
    d090:	9a02      	ldr	r2, [sp, #8]
    d092:	7901      	ldrb	r1, [r0, #4]
    d094:	1a89      	subs	r1, r1, r2
    d096:	b2c9      	uxtb	r1, r1
    d098:	1c0a      	adds	r2, r1, #0
    d09a:	42b9      	cmp	r1, r7
    d09c:	d900      	bls.n	d0a0 <_ZN7FatFile4readEPvj+0xf8>
    d09e:	1c3a      	adds	r2, r7, #0
    d0a0:	b2d7      	uxtb	r7, r2
        if (mb < nb) {
          nb = mb;
        }
      }
      n = 512*nb;
    d0a2:	027e      	lsls	r6, r7, #9
      if (m_vol->cacheBlockNumber() <= block
          && block < (m_vol->cacheBlockNumber() + nb)) {
    d0a4:	42ab      	cmp	r3, r5
    d0a6:	d90a      	bls.n	d0be <_ZN7FatFile4readEPvj+0x116>
        if (!m_vol->cacheSync()) {
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
      if (!m_vol->readBlocks(block, dst, nb)) {
    d0a8:	68a0      	ldr	r0, [r4, #8]
    d0aa:	9a03      	ldr	r2, [sp, #12]
    d0ac:	6803      	ldr	r3, [r0, #0]
    d0ae:	6899      	ldr	r1, [r3, #8]
    d0b0:	1c3b      	adds	r3, r7, #0
    d0b2:	468c      	mov	ip, r1
    d0b4:	1c29      	adds	r1, r5, #0
    d0b6:	47e0      	blx	ip
    d0b8:	2800      	cmp	r0, #0
    d0ba:	d10d      	bne.n	d0d8 <_ZN7FatFile4readEPvj+0x130>
    d0bc:	e790      	b.n	cfe0 <_ZN7FatFile4readEPvj+0x38>
          nb = mb;
        }
      }
      n = 512*nb;
      if (m_vol->cacheBlockNumber() <= block
          && block < (m_vol->cacheBlockNumber() + nb)) {
    d0be:	18fb      	adds	r3, r7, r3
    d0c0:	429d      	cmp	r5, r3
    d0c2:	d328      	bcc.n	d116 <_ZN7FatFile4readEPvj+0x16e>
    d0c4:	e7f0      	b.n	d0a8 <_ZN7FatFile4readEPvj+0x100>
      }
#endif  // USE_MULTI_BLOCK_IO
    } else {
      // read single block
      n = 512;
      if (!m_vol->readBlock(block, dst)) {
    d0c6:	6803      	ldr	r3, [r0, #0]
    d0c8:	1c29      	adds	r1, r5, #0
    d0ca:	681b      	ldr	r3, [r3, #0]
    d0cc:	9a03      	ldr	r2, [sp, #12]
    d0ce:	4798      	blx	r3
    d0d0:	2800      	cmp	r0, #0
    d0d2:	d085      	beq.n	cfe0 <_ZN7FatFile4readEPvj+0x38>
        goto fail;
      }
#endif  // USE_MULTI_BLOCK_IO
    } else {
      // read single block
      n = 512;
    d0d4:	2680      	movs	r6, #128	; 0x80
    d0d6:	00b6      	lsls	r6, r6, #2
      if (!m_vol->readBlock(block, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    d0d8:	9d03      	ldr	r5, [sp, #12]
    m_curPosition += n;
    d0da:	6961      	ldr	r1, [r4, #20]
      if (!m_vol->readBlock(block, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    d0dc:	19ad      	adds	r5, r5, r6
    d0de:	9503      	str	r5, [sp, #12]
    m_curPosition += n;
    toRead -= n;
    d0e0:	9d00      	ldr	r5, [sp, #0]
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    d0e2:	198b      	adds	r3, r1, r6
    toRead -= n;
    d0e4:	1bad      	subs	r5, r5, r6
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    d0e6:	6163      	str	r3, [r4, #20]
    toRead -= n;
    d0e8:	9500      	str	r5, [sp, #0]
    d0ea:	e796      	b.n	d01a <_ZN7FatFile4readEPvj+0x72>
  bool cacheSync() {
    return m_cache.sync();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t blockNumber, uint8_t options) {
    return m_cache.read(blockNumber, options);
    d0ec:	3024      	adds	r0, #36	; 0x24
    d0ee:	1c29      	adds	r1, r5, #0
    d0f0:	2200      	movs	r2, #0
    d0f2:	f001 f834 	bl	e15e <_ZN8FatCache4readEmh>
      if (n > toRead) {
        n = toRead;
      }
      // read block to cache and copy data to caller
      pc = m_vol->cacheFetchData(block, FatCache::CACHE_FOR_READ);
      if (!pc) {
    d0f6:	2800      	cmp	r0, #0
    d0f8:	d100      	bne.n	d0fc <_ZN7FatFile4readEPvj+0x154>
    d0fa:	e771      	b.n	cfe0 <_ZN7FatFile4readEPvj+0x38>
      }
      block = m_vol->clusterStartBlock(m_curCluster) + blockOfCluster;
    }
    if (offset != 0 || toRead < 512 || block == m_vol->cacheBlockNumber()) {
      // amount to be read from current block
      n = 512 - offset;
    d0fc:	2380      	movs	r3, #128	; 0x80
    d0fe:	9e00      	ldr	r6, [sp, #0]
    d100:	009b      	lsls	r3, r3, #2
    d102:	1bdb      	subs	r3, r3, r7
    d104:	429e      	cmp	r6, r3
    d106:	d900      	bls.n	d10a <_ZN7FatFile4readEPvj+0x162>
    d108:	1c1e      	adds	r6, r3, #0
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
    d10a:	19c1      	adds	r1, r0, r7
    d10c:	1c32      	adds	r2, r6, #0
    d10e:	9803      	ldr	r0, [sp, #12]
    d110:	f004 fa53 	bl	115ba <memcpy>
    d114:	e7e0      	b.n	d0d8 <_ZN7FatFile4readEPvj+0x130>
      }
      n = 512*nb;
      if (m_vol->cacheBlockNumber() <= block
          && block < (m_vol->cacheBlockNumber() + nb)) {
        // flush cache if a block is in the cache
        if (!m_vol->cacheSync()) {
    d116:	f7ff fea5 	bl	ce64 <_ZN9FatVolume9cacheSyncEv>
    d11a:	2800      	cmp	r0, #0
    d11c:	d1c4      	bne.n	d0a8 <_ZN7FatFile4readEPvj+0x100>
    d11e:	e75f      	b.n	cfe0 <_ZN7FatFile4readEPvj+0x38>
  return nbyte - toRead;

fail:
  m_error |= READ_ERROR;
  return -1;
}
    d120:	b005      	add	sp, #20
    d122:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d124:	000001ff 	.word	0x000001ff
    d128:	000003ff 	.word	0x000003ff

0000d12c <_ZN7FatFile4peekEv>:

fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::peek() {
    d12c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    d12e:	466f      	mov	r7, sp
    d130:	3707      	adds	r7, #7
    d132:	1c39      	adds	r1, r7, #0
    d134:	2201      	movs	r2, #1
    d136:	1c04      	adds	r4, r0, #0
  str[n] = '\0';
  return n;
}
//------------------------------------------------------------------------------
void FatFile::getpos(FatPos_t* pos) {
  pos->position = m_curPosition;
    d138:	6946      	ldr	r6, [r0, #20]
  pos->cluster = m_curCluster;
    d13a:	6905      	ldr	r5, [r0, #16]
    d13c:	f7ff ff34 	bl	cfa8 <_ZN7FatFile4readEPvj>
    d140:	2801      	cmp	r0, #1
    d142:	d105      	bne.n	d150 <_ZN7FatFile4peekEv+0x24>
    d144:	7838      	ldrb	r0, [r7, #0]
//------------------------------------------------------------------------------
int FatFile::peek() {
  FatPos_t pos;
  getpos(&pos);
  int c = read();
  if (c >= 0) {
    d146:	1c43      	adds	r3, r0, #1
    d148:	d004      	beq.n	d154 <_ZN7FatFile4peekEv+0x28>
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
void FatFile::setpos(FatPos_t* pos) {
  m_curPosition = pos->position;
    d14a:	6166      	str	r6, [r4, #20]
  m_curCluster = pos->cluster;
    d14c:	6125      	str	r5, [r4, #16]
    d14e:	e001      	b.n	d154 <_ZN7FatFile4peekEv+0x28>
    d150:	2001      	movs	r0, #1
    d152:	4240      	negs	r0, r0
  int c = read();
  if (c >= 0) {
    setpos(&pos);
  }
  return c;
}
    d154:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0000d156 <_ZN7FatFile12readDirCacheEb>:
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
dir_t* FatFile::readDirCache(bool skipReadOk) {
//  uint8_t b;
  uint8_t i = (m_curPosition >> 5) & 0XF;
    d156:	6943      	ldr	r3, [r0, #20]
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
dir_t* FatFile::readDirCache(bool skipReadOk) {
    d158:	b537      	push	{r0, r1, r2, r4, r5, lr}
//  uint8_t b;
  uint8_t i = (m_curPosition >> 5) & 0XF;
    d15a:	05dd      	lsls	r5, r3, #23
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
dir_t* FatFile::readDirCache(bool skipReadOk) {
    d15c:	1c04      	adds	r4, r0, #0
//  uint8_t b;
  uint8_t i = (m_curPosition >> 5) & 0XF;
    d15e:	0f2d      	lsrs	r5, r5, #28

  if (i == 0 || !skipReadOk) {
    d160:	d001      	beq.n	d166 <_ZN7FatFile12readDirCacheEb+0x10>
    d162:	2900      	cmp	r1, #0
    d164:	d10d      	bne.n	d182 <_ZN7FatFile12readDirCacheEb+0x2c>
    int8_t n = read(&n, 1);
    d166:	4669      	mov	r1, sp
    d168:	1c20      	adds	r0, r4, #0
    d16a:	3107      	adds	r1, #7
    d16c:	2201      	movs	r2, #1
    d16e:	f7ff ff1b 	bl	cfa8 <_ZN7FatFile4readEPvj>
    if  (n != 1) {
    d172:	b240      	sxtb	r0, r0
    d174:	2801      	cmp	r0, #1
    d176:	d001      	beq.n	d17c <_ZN7FatFile12readDirCacheEb+0x26>
  }
  // return pointer to entry
  return m_vol->cacheAddress()->dir + i;

fail:
  return 0;
    d178:	2000      	movs	r0, #0
    d17a:	e008      	b.n	d18e <_ZN7FatFile12readDirCacheEb+0x38>
      if (n != 0) {
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    m_curPosition += 31;
    d17c:	6963      	ldr	r3, [r4, #20]
    d17e:	331f      	adds	r3, #31
    d180:	e000      	b.n	d184 <_ZN7FatFile12readDirCacheEb+0x2e>
  } else {
    m_curPosition += 32;
    d182:	3320      	adds	r3, #32
  }
  // return pointer to entry
  return m_vol->cacheAddress()->dir + i;
    d184:	68a0      	ldr	r0, [r4, #8]
    d186:	016d      	lsls	r5, r5, #5
    d188:	3030      	adds	r0, #48	; 0x30
      }
      goto fail;
    }
    m_curPosition += 31;
  } else {
    m_curPosition += 32;
    d18a:	6163      	str	r3, [r4, #20]
  }
  // return pointer to entry
  return m_vol->cacheAddress()->dir + i;
    d18c:	1940      	adds	r0, r0, r5

fail:
  return 0;
}
    d18e:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

0000d190 <_ZN7FatFile7seekSetEm>:

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    d190:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    d192:	6906      	ldr	r6, [r0, #16]

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    d194:	7802      	ldrb	r2, [r0, #0]
    d196:	1c04      	adds	r4, r0, #0
    d198:	1c0d      	adds	r5, r1, #0
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    d19a:	9601      	str	r6, [sp, #4]
  // error if file not open
  if (!isOpen()) {
    d19c:	2a00      	cmp	r2, #0
    d19e:	d037      	beq.n	d210 <_ZN7FatFile7seekSetEm+0x80>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    d1a0:	6941      	ldr	r1, [r0, #20]
    d1a2:	428d      	cmp	r5, r1
    d1a4:	d038      	beq.n	d218 <_ZN7FatFile7seekSetEm+0x88>
    return true;
  }
  if (pos == 0) {
    d1a6:	2d00      	cmp	r5, #0
    d1a8:	d101      	bne.n	d1ae <_ZN7FatFile7seekSetEm+0x1e>
    // set position to start of file
    m_curCluster = 0;
    d1aa:	6105      	str	r5, [r0, #16]
    goto done;
    d1ac:	e02e      	b.n	d20c <_ZN7FatFile7seekSetEm+0x7c>
  }
  if (isFile()) {
    d1ae:	0713      	lsls	r3, r2, #28
    d1b0:	d503      	bpl.n	d1ba <_ZN7FatFile7seekSetEm+0x2a>
    if (pos > m_fileSize) {
    d1b2:	69c6      	ldr	r6, [r0, #28]
    d1b4:	42b5      	cmp	r5, r6
    d1b6:	d82b      	bhi.n	d210 <_ZN7FatFile7seekSetEm+0x80>
    d1b8:	e007      	b.n	d1ca <_ZN7FatFile7seekSetEm+0x3a>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (isRootFixed()) {
    d1ba:	0693      	lsls	r3, r2, #26
    d1bc:	d505      	bpl.n	d1ca <_ZN7FatFile7seekSetEm+0x3a>
    if (pos <= 32*m_vol->rootDirEntryCount()) {
    d1be:	6886      	ldr	r6, [r0, #8]
    d1c0:	8933      	ldrh	r3, [r6, #8]
    d1c2:	015b      	lsls	r3, r3, #5
    d1c4:	429d      	cmp	r5, r3
    d1c6:	d823      	bhi.n	d210 <_ZN7FatFile7seekSetEm+0x80>
    d1c8:	e020      	b.n	d20c <_ZN7FatFile7seekSetEm+0x7c>
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for cur and new position
  nCur = (m_curPosition - 1) >> (m_vol->clusterSizeShift() + 9);
    d1ca:	68a7      	ldr	r7, [r4, #8]
  nNew = (pos - 1) >> (m_vol->clusterSizeShift() + 9);
    d1cc:	1e6e      	subs	r6, r5, #1
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for cur and new position
  nCur = (m_curPosition - 1) >> (m_vol->clusterSizeShift() + 9);
    d1ce:	79bb      	ldrb	r3, [r7, #6]
    d1d0:	1e48      	subs	r0, r1, #1
    d1d2:	3309      	adds	r3, #9
  nNew = (pos - 1) >> (m_vol->clusterSizeShift() + 9);
    d1d4:	40de      	lsrs	r6, r3
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for cur and new position
  nCur = (m_curPosition - 1) >> (m_vol->clusterSizeShift() + 9);
    d1d6:	40d8      	lsrs	r0, r3
  nNew = (pos - 1) >> (m_vol->clusterSizeShift() + 9);
    d1d8:	1e33      	subs	r3, r6, #0

  if (nNew < nCur || m_curPosition == 0) {
    d1da:	4283      	cmp	r3, r0
    d1dc:	d301      	bcc.n	d1e2 <_ZN7FatFile7seekSetEm+0x52>
    d1de:	2900      	cmp	r1, #0
    d1e0:	d106      	bne.n	d1f0 <_ZN7FatFile7seekSetEm+0x60>
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    d1e2:	0651      	lsls	r1, r2, #25
    d1e4:	d501      	bpl.n	d1ea <_ZN7FatFile7seekSetEm+0x5a>
    if (pos > m_fileSize) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (isRootFixed()) {
    if (pos <= 32*m_vol->rootDirEntryCount()) {
    d1e6:	6a3a      	ldr	r2, [r7, #32]
    d1e8:	e000      	b.n	d1ec <_ZN7FatFile7seekSetEm+0x5c>
  nCur = (m_curPosition - 1) >> (m_vol->clusterSizeShift() + 9);
  nNew = (pos - 1) >> (m_vol->clusterSizeShift() + 9);

  if (nNew < nCur || m_curPosition == 0) {
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    d1ea:	6a22      	ldr	r2, [r4, #32]
    d1ec:	6122      	str	r2, [r4, #16]
    d1ee:	e000      	b.n	d1f2 <_ZN7FatFile7seekSetEm+0x62>
  } else {
    // advance from curPosition
    nNew -= nCur;
    d1f0:	1a33      	subs	r3, r6, r0
  nCur = (m_curPosition - 1) >> (m_vol->clusterSizeShift() + 9);
  nNew = (pos - 1) >> (m_vol->clusterSizeShift() + 9);

  if (nNew < nCur || m_curPosition == 0) {
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    d1f2:	1c1f      	adds	r7, r3, #0
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    d1f4:	2f00      	cmp	r7, #0
    d1f6:	d009      	beq.n	d20c <_ZN7FatFile7seekSetEm+0x7c>
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    d1f8:	1c22      	adds	r2, r4, #0
    d1fa:	68a0      	ldr	r0, [r4, #8]
    d1fc:	6921      	ldr	r1, [r4, #16]
    d1fe:	3210      	adds	r2, #16
    d200:	f000 ffd8 	bl	e1b4 <_ZN9FatVolume6fatGetEmPm>
    d204:	3f01      	subs	r7, #1
    d206:	2800      	cmp	r0, #0
    d208:	dcf4      	bgt.n	d1f4 <_ZN7FatFile7seekSetEm+0x64>
    d20a:	e001      	b.n	d210 <_ZN7FatFile7seekSetEm+0x80>
      goto fail;
    }
  }

done:
  m_curPosition = pos;
    d20c:	6165      	str	r5, [r4, #20]
    d20e:	e003      	b.n	d218 <_ZN7FatFile7seekSetEm+0x88>
  return true;

fail:
  m_curCluster = tmp;
    d210:	9e01      	ldr	r6, [sp, #4]
  return false;
    d212:	2000      	movs	r0, #0
done:
  m_curPosition = pos;
  return true;

fail:
  m_curCluster = tmp;
    d214:	6126      	str	r6, [r4, #16]
  return false;
    d216:	e000      	b.n	d21a <_ZN7FatFile7seekSetEm+0x8a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    d218:	2001      	movs	r0, #1
  return true;

fail:
  m_curCluster = tmp;
  return false;
}
    d21a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0000d21c <_ZN7FatFile15openCachedEntryEPS_thh>:
}
//------------------------------------------------------------------------------
// open a cached directory entry.

bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              uint8_t oflag, uint8_t lfnOrd) {
    d21c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    d21e:	1c1d      	adds	r5, r3, #0
    d220:	ab08      	add	r3, sp, #32
    d222:	781b      	ldrb	r3, [r3, #0]
    d224:	1c0f      	adds	r7, r1, #0
    d226:	1c16      	adds	r6, r2, #0
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    d228:	2100      	movs	r1, #0
    d22a:	2224      	movs	r2, #36	; 0x24
}
//------------------------------------------------------------------------------
// open a cached directory entry.

bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              uint8_t oflag, uint8_t lfnOrd) {
    d22c:	1c04      	adds	r4, r0, #0
    d22e:	9301      	str	r3, [sp, #4]
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    d230:	f004 f9cc 	bl	115cc <memset>
  // location of entry in cache
  m_vol = dirFile->m_vol;
    d234:	68b8      	ldr	r0, [r7, #8]
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
  dir_t* dir = &m_vol->cacheAddress()->dir[0XF & dirIndex];
    d236:	220f      	movs	r2, #15
                              uint8_t oflag, uint8_t lfnOrd) {
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
  m_dirIndex = dirIndex;
    d238:	80a6      	strh	r6, [r4, #4]
  m_dirCluster = dirFile->m_firstCluster;
    d23a:	6a3f      	ldr	r7, [r7, #32]
  dir_t* dir = &m_vol->cacheAddress()->dir[0XF & dirIndex];
    d23c:	4016      	ands	r6, r2
    d23e:	1c03      	adds	r3, r0, #0
    d240:	3330      	adds	r3, #48	; 0x30
    d242:	0176      	lsls	r6, r6, #5
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              uint8_t oflag, uint8_t lfnOrd) {
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
    d244:	60a0      	str	r0, [r4, #8]
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    d246:	60e7      	str	r7, [r4, #12]
  dir_t* dir = &m_vol->cacheAddress()->dir[0XF & dirIndex];
    d248:	199e      	adds	r6, r3, r6
    d24a:	7af3      	ldrb	r3, [r6, #11]
 * \param[in] dir Pointer to a directory entry.
 *
 * \return true if the entry is for a normal file or subdirectory else false.
 */
static inline uint8_t DIR_IS_FILE_OR_SUBDIR(const dir_t* dir) {
  return (dir->attributes & DIR_ATT_VOLUME_ID) == 0;
    d24c:	2208      	movs	r2, #8

  // Must be file or subdirectory.
  if (!DIR_IS_FILE_OR_SUBDIR(dir)) {
    d24e:	4213      	tst	r3, r2
    d250:	d002      	beq.n	d258 <_ZN7FatFile15openCachedEntryEPS_thh+0x3c>
    goto fail;
  }
  return true;

fail:
  m_attr = FILE_ATTR_CLOSED;
    d252:	2000      	movs	r0, #0
    d254:	7020      	strb	r0, [r4, #0]
  return false;
    d256:	e045      	b.n	d2e4 <_ZN7FatFile15openCachedEntryEPS_thh+0xc8>
  // Must be file or subdirectory.
  if (!DIR_IS_FILE_OR_SUBDIR(dir)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attr = dir->attributes & FILE_ATTR_COPY;
    d258:	2117      	movs	r1, #23
    d25a:	400b      	ands	r3, r1
    d25c:	7023      	strb	r3, [r4, #0]
 * \param[in] dir Pointer to a directory entry.
 *
 * \return true if the entry is for a normal file else false.
 */
static inline uint8_t DIR_IS_FILE(const dir_t* dir) {
  return (dir->attributes & DIR_ATT_FILE_TYPE_MASK) == 0;
    d25e:	7af7      	ldrb	r7, [r6, #11]
  if (DIR_IS_FILE(dir)) {
    d260:	2118      	movs	r1, #24
    d262:	420f      	tst	r7, r1
    d264:	d101      	bne.n	d26a <_ZN7FatFile15openCachedEntryEPS_thh+0x4e>
    m_attr |= FILE_ATTR_FILE;
    d266:	4313      	orrs	r3, r2
    d268:	7023      	strb	r3, [r4, #0]
  }
  m_lfnOrd = lfnOrd;
    d26a:	9b01      	ldr	r3, [sp, #4]
    d26c:	70e3      	strb	r3, [r4, #3]
  // Write, truncate, or at end is an error for a directory or read-only file.
  if (oflag & (O_WRITE | O_TRUNC | O_AT_END)) {
    d26e:	2332      	movs	r3, #50	; 0x32
    d270:	421d      	tst	r5, r3
    d272:	d003      	beq.n	d27c <_ZN7FatFile15openCachedEntryEPS_thh+0x60>
    d274:	7822      	ldrb	r2, [r4, #0]
    if (isSubDir() || isReadOnly()) {
    d276:	2311      	movs	r3, #17
    d278:	421a      	tst	r2, r3
    d27a:	d1ea      	bne.n	d252 <_ZN7FatFile15openCachedEntryEPS_thh+0x36>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // save open flags for read/write
  m_flags = oflag & F_OFLAG;
    d27c:	230f      	movs	r3, #15
    d27e:	402b      	ands	r3, r5
    d280:	70a3      	strb	r3, [r4, #2]

  m_dirBlock = m_vol->cacheBlockNumber();
    d282:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    d284:	61a3      	str	r3, [r4, #24]

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)dir->firstClusterHigh << 16)
    d286:	7d73      	ldrb	r3, [r6, #21]
    d288:	7d32      	ldrb	r2, [r6, #20]
    d28a:	021b      	lsls	r3, r3, #8
                 | dir->firstClusterLow;
    d28c:	7ef1      	ldrb	r1, [r6, #27]
  m_flags = oflag & F_OFLAG;

  m_dirBlock = m_vol->cacheBlockNumber();

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)dir->firstClusterHigh << 16)
    d28e:	4313      	orrs	r3, r2
                 | dir->firstClusterLow;
    d290:	7eb2      	ldrb	r2, [r6, #26]
    d292:	0209      	lsls	r1, r1, #8
  m_flags = oflag & F_OFLAG;

  m_dirBlock = m_vol->cacheBlockNumber();

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)dir->firstClusterHigh << 16)
    d294:	041b      	lsls	r3, r3, #16
                 | dir->firstClusterLow;
    d296:	4311      	orrs	r1, r2
    d298:	4319      	orrs	r1, r3

  if (oflag & O_TRUNC) {
    d29a:	06eb      	lsls	r3, r5, #27
    d29c:	d506      	bpl.n	d2ac <_ZN7FatFile15openCachedEntryEPS_thh+0x90>
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
    d29e:	2900      	cmp	r1, #0
    d2a0:	d019      	beq.n	d2d6 <_ZN7FatFile15openCachedEntryEPS_thh+0xba>
    d2a2:	f001 f821 	bl	e2e8 <_ZN9FatVolume9freeChainEm>
    d2a6:	2800      	cmp	r0, #0
    d2a8:	d115      	bne.n	d2d6 <_ZN7FatFile15openCachedEntryEPS_thh+0xba>
    d2aa:	e7d2      	b.n	d252 <_ZN7FatFile15openCachedEntryEPS_thh+0x36>
      goto fail;
    }
    // need to update directory entry
    m_flags |= F_FILE_DIR_DIRTY;
  } else {
    m_firstCluster = firstCluster;
    d2ac:	6221      	str	r1, [r4, #32]
    m_fileSize = dir->fileSize;
    d2ae:	7f73      	ldrb	r3, [r6, #29]
    d2b0:	7f32      	ldrb	r2, [r6, #28]
    d2b2:	021b      	lsls	r3, r3, #8
    d2b4:	4313      	orrs	r3, r2
    d2b6:	7fb2      	ldrb	r2, [r6, #30]
    d2b8:	0412      	lsls	r2, r2, #16
    d2ba:	4313      	orrs	r3, r2
    d2bc:	7ff2      	ldrb	r2, [r6, #31]
    d2be:	0612      	lsls	r2, r2, #24
    d2c0:	4313      	orrs	r3, r2
    d2c2:	61e3      	str	r3, [r4, #28]
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    d2c4:	06ab      	lsls	r3, r5, #26
    d2c6:	d50c      	bpl.n	d2e2 <_ZN7FatFile15openCachedEntryEPS_thh+0xc6>
    d2c8:	1c20      	adds	r0, r4, #0
    d2ca:	69e1      	ldr	r1, [r4, #28]
    d2cc:	f7ff ff60 	bl	d190 <_ZN7FatFile7seekSetEm>
    d2d0:	2800      	cmp	r0, #0
    d2d2:	d106      	bne.n	d2e2 <_ZN7FatFile15openCachedEntryEPS_thh+0xc6>
    d2d4:	e7bd      	b.n	d252 <_ZN7FatFile15openCachedEntryEPS_thh+0x36>
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // need to update directory entry
    m_flags |= F_FILE_DIR_DIRTY;
    d2d6:	78a2      	ldrb	r2, [r4, #2]
    d2d8:	2380      	movs	r3, #128	; 0x80
    d2da:	425b      	negs	r3, r3
    d2dc:	4313      	orrs	r3, r2
    d2de:	70a3      	strb	r3, [r4, #2]
    d2e0:	e7f0      	b.n	d2c4 <_ZN7FatFile15openCachedEntryEPS_thh+0xa8>
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return true;
    d2e2:	2001      	movs	r0, #1

fail:
  m_attr = FILE_ATTR_CLOSED;
  return false;
}
    d2e4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0000d2e6 <_ZN7FatFile8openNextEPS_h>:
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, uint8_t oflag) {
    d2e6:	b5f0      	push	{r4, r5, r6, r7, lr}
  ldir_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    d2e8:	7803      	ldrb	r3, [r0, #0]
fail:
  m_attr = FILE_ATTR_CLOSED;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, uint8_t oflag) {
    d2ea:	b085      	sub	sp, #20
    d2ec:	1c06      	adds	r6, r0, #0
    d2ee:	1c0d      	adds	r5, r1, #0
    d2f0:	9203      	str	r2, [sp, #12]
  ldir_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    d2f2:	2b00      	cmp	r3, #0
    d2f4:	d12b      	bne.n	d34e <_ZN7FatFile8openNextEPS_h+0x68>
   * the value false, is returned for failure.
   */  
  bool getSFN(char* name);
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_attr & FILE_ATTR_DIR;
    d2f6:	780a      	ldrb	r2, [r1, #0]
    d2f8:	2370      	movs	r3, #112	; 0x70
    d2fa:	421a      	tst	r2, r3
    d2fc:	d027      	beq.n	d34e <_ZN7FatFile8openNextEPS_h+0x68>
    d2fe:	6949      	ldr	r1, [r1, #20]
    d300:	241f      	movs	r4, #31
    d302:	400c      	ands	r4, r1
    d304:	1e27      	subs	r7, r4, #0
    d306:	d122      	bne.n	d34e <_ZN7FatFile8openNextEPS_h+0x68>
fail:
  m_attr = FILE_ATTR_CLOSED;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, uint8_t oflag) {
    d308:	696a      	ldr	r2, [r5, #20]
    goto fail;
  }
  while (1) {
    // read entry into cache
    index = dirFile->curPosition()/32;
    dir_t* dir = dirFile->readDirCache();
    d30a:	1c28      	adds	r0, r5, #0
    d30c:	2100      	movs	r1, #0
fail:
  m_attr = FILE_ATTR_CLOSED;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, uint8_t oflag) {
    d30e:	9202      	str	r2, [sp, #8]
    goto fail;
  }
  while (1) {
    // read entry into cache
    index = dirFile->curPosition()/32;
    dir_t* dir = dirFile->readDirCache();
    d310:	f7ff ff21 	bl	d156 <_ZN7FatFile12readDirCacheEb>
    if (!dir) {
    d314:	2800      	cmp	r0, #0
    d316:	d01a      	beq.n	d34e <_ZN7FatFile8openNextEPS_h+0x68>
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    // done if last entry
    if (dir->name[0] == DIR_NAME_FREE) {
    d318:	7803      	ldrb	r3, [r0, #0]
    d31a:	2b00      	cmp	r3, #0
    d31c:	d017      	beq.n	d34e <_ZN7FatFile8openNextEPS_h+0x68>
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == DIR_NAME_DELETED) {
    d31e:	2b2e      	cmp	r3, #46	; 0x2e
    d320:	d101      	bne.n	d326 <_ZN7FatFile8openNextEPS_h+0x40>
      if (ldir->ord & LDIR_ORD_LAST_LONG_ENTRY) {
        lfnOrd = ldir->ord & 0X1F;
        chksum = ldir->chksum;
      }
    } else {
      lfnOrd = 0;
    d322:	2400      	movs	r4, #0
    d324:	e7f0      	b.n	d308 <_ZN7FatFile8openNextEPS_h+0x22>
    // done if last entry
    if (dir->name[0] == DIR_NAME_FREE) {
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == DIR_NAME_DELETED) {
    d326:	2be5      	cmp	r3, #229	; 0xe5
    d328:	d0fb      	beq.n	d322 <_ZN7FatFile8openNextEPS_h+0x3c>
    goto fail;
  }
  while (1) {
    // read entry into cache
    index = dirFile->curPosition()/32;
    dir_t* dir = dirFile->readDirCache();
    d32a:	7ac2      	ldrb	r2, [r0, #11]
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == DIR_NAME_DELETED) {
      lfnOrd = 0;
    } else if (DIR_IS_FILE_OR_SUBDIR(dir)) {
    d32c:	0711      	lsls	r1, r2, #28
    d32e:	d406      	bmi.n	d33e <_ZN7FatFile8openNextEPS_h+0x58>
      if (lfnOrd && chksum != lfnChecksum(dir->name)) {
    d330:	2c00      	cmp	r4, #0
    d332:	d00e      	beq.n	d352 <_ZN7FatFile8openNextEPS_h+0x6c>
    d334:	f000 fac7 	bl	d8c6 <_ZN7FatFile11lfnChecksumEPh>
    d338:	4287      	cmp	r7, r0
    d33a:	d108      	bne.n	d34e <_ZN7FatFile8openNextEPS_h+0x68>
    d33c:	e009      	b.n	d352 <_ZN7FatFile8openNextEPS_h+0x6c>
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      return true;
    } else if (DIR_IS_LONG_NAME(dir)) {
    d33e:	2a0f      	cmp	r2, #15
    d340:	d1ef      	bne.n	d322 <_ZN7FatFile8openNextEPS_h+0x3c>
      ldir = reinterpret_cast<ldir_t*>(dir);
      if (ldir->ord & LDIR_ORD_LAST_LONG_ENTRY) {
    d342:	065a      	lsls	r2, r3, #25
    d344:	d5e0      	bpl.n	d308 <_ZN7FatFile8openNextEPS_h+0x22>
        lfnOrd = ldir->ord & 0X1F;
    d346:	241f      	movs	r4, #31
    d348:	401c      	ands	r4, r3
        chksum = ldir->chksum;
    d34a:	7b47      	ldrb	r7, [r0, #13]
    d34c:	e7dc      	b.n	d308 <_ZN7FatFile8openNextEPS_h+0x22>
      lfnOrd = 0;
    }
  }

fail:
  return false;
    d34e:	2000      	movs	r0, #0
    d350:	e008      	b.n	d364 <_ZN7FatFile8openNextEPS_h+0x7e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (1) {
    // read entry into cache
    index = dirFile->curPosition()/32;
    d352:	9b02      	ldr	r3, [sp, #8]
    } else if (DIR_IS_FILE_OR_SUBDIR(dir)) {
      if (lfnOrd && chksum != lfnChecksum(dir->name)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
    d354:	9400      	str	r4, [sp, #0]
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (1) {
    // read entry into cache
    index = dirFile->curPosition()/32;
    d356:	095a      	lsrs	r2, r3, #5
    } else if (DIR_IS_FILE_OR_SUBDIR(dir)) {
      if (lfnOrd && chksum != lfnChecksum(dir->name)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
    d358:	b292      	uxth	r2, r2
    d35a:	1c30      	adds	r0, r6, #0
    d35c:	1c29      	adds	r1, r5, #0
    d35e:	9b03      	ldr	r3, [sp, #12]
    d360:	f7ff ff5c 	bl	d21c <_ZN7FatFile15openCachedEntryEPS_thh>
    }
  }

fail:
  return false;
}
    d364:	b005      	add	sp, #20
    d366:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000d368 <_ZN7FatFile4syncEv>:
void FatFile::setpos(FatPos_t* pos) {
  m_curPosition = pos->position;
  m_curCluster = pos->cluster;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    d368:	b538      	push	{r3, r4, r5, lr}
  if (!isOpen()) {
    d36a:	7803      	ldrb	r3, [r0, #0]
void FatFile::setpos(FatPos_t* pos) {
  m_curPosition = pos->position;
  m_curCluster = pos->cluster;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    d36c:	1c05      	adds	r5, r0, #0
  if (!isOpen()) {
    return true;
    d36e:	2101      	movs	r1, #1
  m_curPosition = pos->position;
  m_curCluster = pos->cluster;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  if (!isOpen()) {
    d370:	2b00      	cmp	r3, #0
    d372:	d03d      	beq.n	d3f0 <_ZN7FatFile4syncEv+0x88>
    return true;
  }

  if (m_flags & F_FILE_DIR_DIRTY) {
    d374:	7883      	ldrb	r3, [r0, #2]
    d376:	2b7f      	cmp	r3, #127	; 0x7f
    d378:	d934      	bls.n	d3e4 <_ZN7FatFile4syncEv+0x7c>
    dir_t* dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
    d37a:	f7ff fdc9 	bl	cf10 <_ZN7FatFile13cacheDirEntryEh>
    d37e:	1e04      	subs	r4, r0, #0
    // check for deleted by another open file object
    if (!dir || dir->name[0] == DIR_NAME_DELETED) {
    d380:	d105      	bne.n	d38e <_ZN7FatFile4syncEv+0x26>
    return true;
  }
  DBG_FAIL_MACRO;

fail:
  m_error |= WRITE_ERROR;
    d382:	786b      	ldrb	r3, [r5, #1]
    d384:	2201      	movs	r2, #1
    d386:	4313      	orrs	r3, r2
    d388:	706b      	strb	r3, [r5, #1]
  return false;
    d38a:	2100      	movs	r1, #0
    d38c:	e030      	b.n	d3f0 <_ZN7FatFile4syncEv+0x88>
  }

  if (m_flags & F_FILE_DIR_DIRTY) {
    dir_t* dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
    // check for deleted by another open file object
    if (!dir || dir->name[0] == DIR_NAME_DELETED) {
    d38e:	7803      	ldrb	r3, [r0, #0]
    d390:	2be5      	cmp	r3, #229	; 0xe5
    d392:	d0f6      	beq.n	d382 <_ZN7FatFile4syncEv+0x1a>
  }
  /** \return True if this is a normal file else false. */
  bool isFile() const {
    return m_attr & FILE_ATTR_FILE;
    d394:	782b      	ldrb	r3, [r5, #0]
      DBG_FAIL_MACRO;
      goto fail;
    }
    // do not set filesize for dir files
    if (isFile()) {
    d396:	071a      	lsls	r2, r3, #28
    d398:	d507      	bpl.n	d3aa <_ZN7FatFile4syncEv+0x42>
      dir->fileSize = m_fileSize;
    d39a:	7f2b      	ldrb	r3, [r5, #28]
    d39c:	7703      	strb	r3, [r0, #28]
    d39e:	7f6b      	ldrb	r3, [r5, #29]
    d3a0:	7743      	strb	r3, [r0, #29]
    d3a2:	7fab      	ldrb	r3, [r5, #30]
    d3a4:	7783      	strb	r3, [r0, #30]
    d3a6:	7feb      	ldrb	r3, [r5, #31]
    d3a8:	77c3      	strb	r3, [r0, #31]
    }

    // update first cluster fields
    dir->firstClusterLow = m_firstCluster & 0XFFFF;
    d3aa:	6a2b      	ldr	r3, [r5, #32]
    d3ac:	b29a      	uxth	r2, r3
    dir->firstClusterHigh = m_firstCluster >> 16;
    d3ae:	0c1b      	lsrs	r3, r3, #16
    d3b0:	7523      	strb	r3, [r4, #20]
    d3b2:	0a1b      	lsrs	r3, r3, #8
    d3b4:	7563      	strb	r3, [r4, #21]

    // set modify time if user supplied a callback date/time function
    if (m_dateTime) {
    d3b6:	4b0f      	ldr	r3, [pc, #60]	; (d3f4 <_ZN7FatFile4syncEv+0x8c>)
    if (isFile()) {
      dir->fileSize = m_fileSize;
    }

    // update first cluster fields
    dir->firstClusterLow = m_firstCluster & 0XFFFF;
    d3b8:	76a2      	strb	r2, [r4, #26]
    dir->firstClusterHigh = m_firstCluster >> 16;

    // set modify time if user supplied a callback date/time function
    if (m_dateTime) {
    d3ba:	681b      	ldr	r3, [r3, #0]
    if (isFile()) {
      dir->fileSize = m_fileSize;
    }

    // update first cluster fields
    dir->firstClusterLow = m_firstCluster & 0XFFFF;
    d3bc:	0a12      	lsrs	r2, r2, #8
    d3be:	76e2      	strb	r2, [r4, #27]
    dir->firstClusterHigh = m_firstCluster >> 16;

    // set modify time if user supplied a callback date/time function
    if (m_dateTime) {
    d3c0:	2b00      	cmp	r3, #0
    d3c2:	d00b      	beq.n	d3dc <_ZN7FatFile4syncEv+0x74>
      m_dateTime(&dir->lastWriteDate, &dir->lastWriteTime);
    d3c4:	1c20      	adds	r0, r4, #0
    d3c6:	1c21      	adds	r1, r4, #0
    d3c8:	3018      	adds	r0, #24
    d3ca:	3116      	adds	r1, #22
    d3cc:	4798      	blx	r3
      dir->lastAccessDate = dir->lastWriteDate;
    d3ce:	7e63      	ldrb	r3, [r4, #25]
    d3d0:	7e22      	ldrb	r2, [r4, #24]
    d3d2:	021b      	lsls	r3, r3, #8
    d3d4:	4313      	orrs	r3, r2
    d3d6:	74a3      	strb	r3, [r4, #18]
    d3d8:	0a1b      	lsrs	r3, r3, #8
    d3da:	74e3      	strb	r3, [r4, #19]
    }
    // clear directory dirty
    m_flags &= ~F_FILE_DIR_DIRTY;
    d3dc:	78aa      	ldrb	r2, [r5, #2]
    d3de:	237f      	movs	r3, #127	; 0x7f
    d3e0:	4013      	ands	r3, r2
    d3e2:	70ab      	strb	r3, [r5, #2]
  }
  if (m_vol->cacheSync()) {
    d3e4:	68a8      	ldr	r0, [r5, #8]
    d3e6:	f7ff fd3d 	bl	ce64 <_ZN9FatVolume9cacheSyncEv>
    d3ea:	2800      	cmp	r0, #0
    d3ec:	d0c9      	beq.n	d382 <_ZN7FatFile4syncEv+0x1a>
    return true;
    d3ee:	2101      	movs	r1, #1
  DBG_FAIL_MACRO;

fail:
  m_error |= WRITE_ERROR;
  return false;
}
    d3f0:	1c08      	adds	r0, r1, #0
    d3f2:	bd38      	pop	{r3, r4, r5, pc}
    d3f4:	20000cf0 	.word	0x20000cf0

0000d3f8 <_ZN7FatFile5closeEv>:

fail:
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
    d3f8:	b510      	push	{r4, lr}
    d3fa:	1c04      	adds	r4, r0, #0
  bool rtn = sync();
    d3fc:	f7ff ffb4 	bl	d368 <_ZN7FatFile4syncEv>
  m_attr = FILE_ATTR_CLOSED;
    d400:	2300      	movs	r3, #0
    d402:	7023      	strb	r3, [r4, #0]
  return rtn;
}
    d404:	bd10      	pop	{r4, pc}

0000d406 <_ZN7FatFile4openEPS_PKch>:
//------------------------------------------------------------------------------
bool FatFile::open(FatFileSystem* fs, const char* path, uint8_t oflag) {
  return open(fs->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, uint8_t oflag) {
    d406:	b5f0      	push	{r4, r5, r6, r7, lr}
    d408:	b093      	sub	sp, #76	; 0x4c
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
    d40a:	ad09      	add	r5, sp, #36	; 0x24
    d40c:	1c1e      	adds	r6, r3, #0
    d40e:	2300      	movs	r3, #0
    d410:	702b      	strb	r3, [r5, #0]
    d412:	706b      	strb	r3, [r5, #1]
  FatFile tmpDir;
  fname_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    d414:	7803      	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::open(FatFileSystem* fs, const char* path, uint8_t oflag) {
  return open(fs->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, uint8_t oflag) {
    d416:	1c04      	adds	r4, r0, #0
    d418:	1c0f      	adds	r7, r1, #0
    d41a:	9201      	str	r2, [sp, #4]
  FatFile tmpDir;
  fname_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    d41c:	2b00      	cmp	r3, #0
    d41e:	d001      	beq.n	d424 <_ZN7FatFile4openEPS_PKch+0x1e>
    close();
  }
  return open(dirFile, &fname, oflag);

fail:
  return false;
    d420:	2000      	movs	r0, #0
    d422:	e03d      	b.n	d4a0 <_ZN7FatFile4openEPS_PKch+0x9a>
   * the value false, is returned for failure.
   */  
  bool getSFN(char* name);
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_attr & FILE_ATTR_DIR;
    d424:	780a      	ldrb	r2, [r1, #0]
bool FatFile::open(FatFile* dirFile, const char* path, uint8_t oflag) {
  FatFile tmpDir;
  fname_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    d426:	2370      	movs	r3, #112	; 0x70
    d428:	421a      	tst	r2, r3
    d42a:	d0f9      	beq.n	d420 <_ZN7FatFile4openEPS_PKch+0x1a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    d42c:	9901      	ldr	r1, [sp, #4]
    d42e:	780b      	ldrb	r3, [r1, #0]
    d430:	2b2f      	cmp	r3, #47	; 0x2f
    d432:	d113      	bne.n	d45c <_ZN7FatFile4openEPS_PKch+0x56>
    while (isDirSeparator(*path)) {
    d434:	9a01      	ldr	r2, [sp, #4]
    d436:	7813      	ldrb	r3, [r2, #0]
    d438:	2b2f      	cmp	r3, #47	; 0x2f
    d43a:	d102      	bne.n	d442 <_ZN7FatFile4openEPS_PKch+0x3c>
      path++;
    d43c:	3201      	adds	r2, #1
    d43e:	9201      	str	r2, [sp, #4]
    d440:	e7f8      	b.n	d434 <_ZN7FatFile4openEPS_PKch+0x2e>
    d442:	68b9      	ldr	r1, [r7, #8]
    }
    if (*path == 0) {
    d444:	2b00      	cmp	r3, #0
    d446:	d103      	bne.n	d450 <_ZN7FatFile4openEPS_PKch+0x4a>
      return openRoot(dirFile->m_vol);
    d448:	1c20      	adds	r0, r4, #0
    d44a:	f7ff fd94 	bl	cf76 <_ZN7FatFile8openRootEP9FatVolume>
    d44e:	e027      	b.n	d4a0 <_ZN7FatFile4openEPS_PKch+0x9a>
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    d450:	1c28      	adds	r0, r5, #0
    d452:	f7ff fd90 	bl	cf76 <_ZN7FatFile8openRootEP9FatVolume>
    d456:	2800      	cmp	r0, #0
    d458:	d0e2      	beq.n	d420 <_ZN7FatFile4openEPS_PKch+0x1a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    d45a:	1c2f      	adds	r7, r5, #0
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    d45c:	9801      	ldr	r0, [sp, #4]
    d45e:	a903      	add	r1, sp, #12
    d460:	aa01      	add	r2, sp, #4
    d462:	f000 fac8 	bl	d9f6 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_>
    d466:	2800      	cmp	r0, #0
    d468:	d0da      	beq.n	d420 <_ZN7FatFile4openEPS_PKch+0x1a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    d46a:	9801      	ldr	r0, [sp, #4]
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    close();
  }
  return open(dirFile, &fname, oflag);
    d46c:	1c39      	adds	r1, r7, #0
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    d46e:	7803      	ldrb	r3, [r0, #0]
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    close();
  }
  return open(dirFile, &fname, oflag);
    d470:	aa03      	add	r2, sp, #12
    d472:	1c20      	adds	r0, r4, #0
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    d474:	2b00      	cmp	r3, #0
    d476:	d010      	beq.n	d49a <_ZN7FatFile4openEPS_PKch+0x94>
      break;
    }
    if (!open(dirFile, &fname, O_READ)) {
    d478:	2301      	movs	r3, #1
    d47a:	f000 fc67 	bl	dd4c <_ZN7FatFile4openEPS_P7fname_th>
    d47e:	2800      	cmp	r0, #0
    d480:	d0ce      	beq.n	d420 <_ZN7FatFile4openEPS_PKch+0x1a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    d482:	1c2a      	adds	r2, r5, #0
    d484:	1c23      	adds	r3, r4, #0
    d486:	cb83      	ldmia	r3!, {r0, r1, r7}
    d488:	c283      	stmia	r2!, {r0, r1, r7}
    d48a:	cb83      	ldmia	r3!, {r0, r1, r7}
    d48c:	c283      	stmia	r2!, {r0, r1, r7}
    d48e:	cb83      	ldmia	r3!, {r0, r1, r7}
    d490:	c283      	stmia	r2!, {r0, r1, r7}
    dirFile = &tmpDir;
    close();
    d492:	1c20      	adds	r0, r4, #0
    d494:	f7ff ffb0 	bl	d3f8 <_ZN7FatFile5closeEv>
    d498:	e7df      	b.n	d45a <_ZN7FatFile4openEPS_PKch+0x54>
  }
  return open(dirFile, &fname, oflag);
    d49a:	1c33      	adds	r3, r6, #0
    d49c:	f000 fc56 	bl	dd4c <_ZN7FatFile4openEPS_P7fname_th>

fail:
  return false;
}
    d4a0:	b013      	add	sp, #76	; 0x4c
    d4a2:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000d4a4 <_ZN7FatFile6removeEPS_PKc>:

fail:
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::remove(FatFile* dirFile, const char* path) {
    d4a4:	b530      	push	{r4, r5, lr}
    d4a6:	b08b      	sub	sp, #44	; 0x2c
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
    d4a8:	ac01      	add	r4, sp, #4
    d4aa:	2300      	movs	r3, #0
    d4ac:	1c05      	adds	r5, r0, #0
    d4ae:	1c0a      	adds	r2, r1, #0
    d4b0:	7023      	strb	r3, [r4, #0]
    d4b2:	7063      	strb	r3, [r4, #1]
  FatFile file;
  if (!file.open(dirFile, path, O_WRITE)) {
    d4b4:	1c20      	adds	r0, r4, #0
    d4b6:	1c29      	adds	r1, r5, #0
    d4b8:	2302      	movs	r3, #2
    d4ba:	f7ff ffa4 	bl	d406 <_ZN7FatFile4openEPS_PKch>
    d4be:	2800      	cmp	r0, #0
    d4c0:	d002      	beq.n	d4c8 <_ZN7FatFile6removeEPS_PKc+0x24>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return file.remove();
    d4c2:	1c20      	adds	r0, r4, #0
    d4c4:	f000 fb8d 	bl	dbe2 <_ZN7FatFile6removeEv>

fail:
  return false;
}
    d4c8:	b00b      	add	sp, #44	; 0x2c
    d4ca:	bd30      	pop	{r4, r5, pc}

0000d4cc <_ZN7FatFile5mkdirEPS_P7fname_t>:

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, fname_t* fname) {
    d4cc:	b5f0      	push	{r4, r5, r6, r7, lr}
    d4ce:	1c0e      	adds	r6, r1, #0
   * the value false, is returned for failure.
   */  
  bool getSFN(char* name);
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_attr & FILE_ATTR_DIR;
    d4d0:	7809      	ldrb	r1, [r1, #0]
  uint32_t block;
  dir_t dot;
  dir_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    d4d2:	2370      	movs	r3, #112	; 0x70

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, fname_t* fname) {
    d4d4:	b08b      	sub	sp, #44	; 0x2c
    d4d6:	1c04      	adds	r4, r0, #0
  uint32_t block;
  dir_t dot;
  dir_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    d4d8:	4219      	tst	r1, r3
    d4da:	d01f      	beq.n	d51c <_ZN7FatFile5mkdirEPS_P7fname_t+0x50>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    d4dc:	1c31      	adds	r1, r6, #0
    d4de:	23c3      	movs	r3, #195	; 0xc3
    d4e0:	f000 fc34 	bl	dd4c <_ZN7FatFile4openEPS_P7fname_th>
    d4e4:	2800      	cmp	r0, #0
    d4e6:	d019      	beq.n	d51c <_ZN7FatFile5mkdirEPS_P7fname_t+0x50>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = O_READ;
    d4e8:	2501      	movs	r5, #1
  m_attr = FILE_ATTR_SUBDIR;
    d4ea:	2710      	movs	r7, #16
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = O_READ;
    d4ec:	70a5      	strb	r5, [r4, #2]
  m_attr = FILE_ATTR_SUBDIR;
    d4ee:	7027      	strb	r7, [r4, #0]

  // allocate and zero first cluster
  if (!addDirCluster()) {
    d4f0:	1c20      	adds	r0, r4, #0
    d4f2:	f7ff fcd3 	bl	ce9c <_ZN7FatFile13addDirClusterEv>
    d4f6:	2800      	cmp	r0, #0
    d4f8:	d010      	beq.n	d51c <_ZN7FatFile5mkdirEPS_P7fname_t+0x50>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    d4fa:	6921      	ldr	r1, [r4, #16]
   * the value false is returned for failure.
   */
  static bool remove(FatFile* dirFile, const char* path);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    d4fc:	1c20      	adds	r0, r4, #0
    d4fe:	6221      	str	r1, [r4, #32]
    d500:	2100      	movs	r1, #0
    d502:	f7ff fe45 	bl	d190 <_ZN7FatFile7seekSetEm>
  // Set to start of dir
  rewind();
  // force entry to device
  if (!sync()) {
    d506:	1c20      	adds	r0, r4, #0
    d508:	f7ff ff2e 	bl	d368 <_ZN7FatFile4syncEv>
    d50c:	2800      	cmp	r0, #0
    d50e:	d005      	beq.n	d51c <_ZN7FatFile5mkdirEPS_P7fname_t+0x50>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // cache entry - should already be in cache due to sync() call
  dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
    d510:	1c29      	adds	r1, r5, #0
    d512:	1c20      	adds	r0, r4, #0
    d514:	f7ff fcfc 	bl	cf10 <_ZN7FatFile13cacheDirEntryEh>
    d518:	1e05      	subs	r5, r0, #0
  if (!dir) {
    d51a:	d101      	bne.n	d520 <_ZN7FatFile5mkdirEPS_P7fname_t+0x54>
  memcpy(&pc->dir[1], &dot, sizeof(dot));
  // write first block
  return m_vol->cacheSync();

fail:
  return false;
    d51c:	2000      	movs	r0, #0
    d51e:	e03d      	b.n	d59c <_ZN7FatFile5mkdirEPS_P7fname_t+0xd0>
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // change directory entry  attribute
  dir->attributes = DIR_ATT_DIRECTORY;
    d520:	72c7      	strb	r7, [r0, #11]

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
    d522:	2220      	movs	r2, #32
    d524:	a802      	add	r0, sp, #8
    d526:	1c29      	adds	r1, r5, #0
    d528:	f004 f847 	bl	115ba <memcpy>
    d52c:	7d6f      	ldrb	r7, [r5, #21]
    d52e:	7d2b      	ldrb	r3, [r5, #20]
    d530:	023f      	lsls	r7, r7, #8
    d532:	7eea      	ldrb	r2, [r5, #27]
    d534:	431f      	orrs	r7, r3
    d536:	7eab      	ldrb	r3, [r5, #26]
    d538:	0212      	lsls	r2, r2, #8
    d53a:	431a      	orrs	r2, r3
    d53c:	9201      	str	r2, [sp, #4]
  dot.name[0] = '.';
    d53e:	232e      	movs	r3, #46	; 0x2e
    d540:	466a      	mov	r2, sp
    d542:	7213      	strb	r3, [r2, #8]
    d544:	2300      	movs	r3, #0
    d546:	a902      	add	r1, sp, #8
    d548:	18ca      	adds	r2, r1, r3
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    d54a:	2120      	movs	r1, #32
    d54c:	3301      	adds	r3, #1
    d54e:	7051      	strb	r1, [r2, #1]
  dir->attributes = DIR_ATT_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    d550:	2b0a      	cmp	r3, #10
    d552:	d1f8      	bne.n	d546 <_ZN7FatFile5mkdirEPS_P7fname_t+0x7a>
    dot.name[i] = ' ';
  }

  // cache block for '.'  and '..'
  block = m_vol->clusterStartBlock(m_firstCluster);
    d554:	6a21      	ldr	r1, [r4, #32]
    d556:	68a0      	ldr	r0, [r4, #8]
    d558:	f000 fe26 	bl	e1a8 <_ZNK9FatVolume17clusterStartBlockEm>
    d55c:	1c01      	adds	r1, r0, #0
    d55e:	68a0      	ldr	r0, [r4, #8]
    d560:	2201      	movs	r2, #1
    d562:	3024      	adds	r0, #36	; 0x24
    d564:	f000 fdfb 	bl	e15e <_ZN8FatCache4readEmh>
    d568:	1e05      	subs	r5, r0, #0
  pc = m_vol->cacheFetchData(block, FatCache::CACHE_FOR_WRITE);
  if (!pc) {
    d56a:	d0d7      	beq.n	d51c <_ZN7FatFile5mkdirEPS_P7fname_t+0x50>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy '.' to block
  memcpy(&pc->dir[0], &dot, sizeof(dot));
    d56c:	9b01      	ldr	r3, [sp, #4]
    d56e:	466a      	mov	r2, sp
    d570:	8397      	strh	r7, [r2, #28]
    d572:	8453      	strh	r3, [r2, #34]	; 0x22
    d574:	a902      	add	r1, sp, #8
    d576:	2220      	movs	r2, #32
    d578:	f004 f81f 	bl	115ba <memcpy>
    d57c:	466f      	mov	r7, sp
  // make entry for '..'
  dot.name[1] = '.';
    d57e:	232e      	movs	r3, #46	; 0x2e
    d580:	727b      	strb	r3, [r7, #9]
  dot.firstClusterLow = parent->m_firstCluster & 0XFFFF;
    d582:	6a33      	ldr	r3, [r6, #32]
  dot.firstClusterHigh = parent->m_firstCluster >> 16;
  // copy '..' to block
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    d584:	1c28      	adds	r0, r5, #0
  // copy '.' to block
  memcpy(&pc->dir[0], &dot, sizeof(dot));
  // make entry for '..'
  dot.name[1] = '.';
  dot.firstClusterLow = parent->m_firstCluster & 0XFFFF;
  dot.firstClusterHigh = parent->m_firstCluster >> 16;
    d586:	0c1a      	lsrs	r2, r3, #16
    d588:	83ba      	strh	r2, [r7, #28]
  }
  // copy '.' to block
  memcpy(&pc->dir[0], &dot, sizeof(dot));
  // make entry for '..'
  dot.name[1] = '.';
  dot.firstClusterLow = parent->m_firstCluster & 0XFFFF;
    d58a:	847b      	strh	r3, [r7, #34]	; 0x22
  dot.firstClusterHigh = parent->m_firstCluster >> 16;
  // copy '..' to block
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    d58c:	3020      	adds	r0, #32
    d58e:	a902      	add	r1, sp, #8
    d590:	2220      	movs	r2, #32
    d592:	f004 f812 	bl	115ba <memcpy>
  // write first block
  return m_vol->cacheSync();
    d596:	68a0      	ldr	r0, [r4, #8]
    d598:	f7ff fc64 	bl	ce64 <_ZN9FatVolume9cacheSyncEv>

fail:
  return false;
}
    d59c:	b00b      	add	sp, #44	; 0x2c
    d59e:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000d5a0 <_ZN7FatFile5mkdirEPS_PKcb>:
void FatFile::getpos(FatPos_t* pos) {
  pos->position = m_curPosition;
  pos->cluster = m_curCluster;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    d5a0:	b5f0      	push	{r4, r5, r6, r7, lr}
    d5a2:	b093      	sub	sp, #76	; 0x4c
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
    d5a4:	ad09      	add	r5, sp, #36	; 0x24
    d5a6:	9300      	str	r3, [sp, #0]
    d5a8:	2300      	movs	r3, #0
    d5aa:	702b      	strb	r3, [r5, #0]
    d5ac:	706b      	strb	r3, [r5, #1]
  fname_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    d5ae:	7803      	ldrb	r3, [r0, #0]
void FatFile::getpos(FatPos_t* pos) {
  pos->position = m_curPosition;
  pos->cluster = m_curCluster;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    d5b0:	1c04      	adds	r4, r0, #0
    d5b2:	1c0e      	adds	r6, r1, #0
    d5b4:	9201      	str	r2, [sp, #4]
  fname_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    d5b6:	2b00      	cmp	r3, #0
    d5b8:	d001      	beq.n	d5be <_ZN7FatFile5mkdirEPS_PKcb+0x1e>
    close();
  }
  return mkdir(parent, &fname);

fail:
  return false;
    d5ba:	2700      	movs	r7, #0
    d5bc:	e041      	b.n	d642 <_ZN7FatFile5mkdirEPS_PKcb+0xa2>
   * the value false, is returned for failure.
   */  
  bool getSFN(char* name);
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_attr & FILE_ATTR_DIR;
    d5be:	780a      	ldrb	r2, [r1, #0]
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
  fname_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    d5c0:	2370      	movs	r3, #112	; 0x70
    d5c2:	421a      	tst	r2, r3
    d5c4:	d0f9      	beq.n	d5ba <_ZN7FatFile5mkdirEPS_PKcb+0x1a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    d5c6:	9a01      	ldr	r2, [sp, #4]
    d5c8:	7813      	ldrb	r3, [r2, #0]
    d5ca:	2b2f      	cmp	r3, #47	; 0x2f
    d5cc:	d10d      	bne.n	d5ea <_ZN7FatFile5mkdirEPS_PKcb+0x4a>
    while (isDirSeparator(*path)) {
    d5ce:	9b01      	ldr	r3, [sp, #4]
    d5d0:	781a      	ldrb	r2, [r3, #0]
    d5d2:	2a2f      	cmp	r2, #47	; 0x2f
    d5d4:	d102      	bne.n	d5dc <_ZN7FatFile5mkdirEPS_PKcb+0x3c>
      path++;
    d5d6:	3301      	adds	r3, #1
    d5d8:	9301      	str	r3, [sp, #4]
    d5da:	e7f8      	b.n	d5ce <_ZN7FatFile5mkdirEPS_PKcb+0x2e>
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    d5dc:	68b1      	ldr	r1, [r6, #8]
    d5de:	1c28      	adds	r0, r5, #0
    d5e0:	f7ff fcc9 	bl	cf76 <_ZN7FatFile8openRootEP9FatVolume>
    d5e4:	2800      	cmp	r0, #0
    d5e6:	d0e8      	beq.n	d5ba <_ZN7FatFile5mkdirEPS_PKcb+0x1a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    d5e8:	1c2e      	adds	r6, r5, #0
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    d5ea:	9801      	ldr	r0, [sp, #4]
    d5ec:	a903      	add	r1, sp, #12
    d5ee:	aa01      	add	r2, sp, #4
    d5f0:	f000 fa01 	bl	d9f6 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_>
    d5f4:	2800      	cmp	r0, #0
    d5f6:	d0e0      	beq.n	d5ba <_ZN7FatFile5mkdirEPS_PKcb+0x1a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    d5f8:	9801      	ldr	r0, [sp, #4]
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    d5fa:	1c31      	adds	r1, r6, #0
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    d5fc:	7803      	ldrb	r3, [r0, #0]
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    d5fe:	aa03      	add	r2, sp, #12
    d600:	1c20      	adds	r0, r4, #0
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    d602:	2b00      	cmp	r3, #0
    d604:	d01a      	beq.n	d63c <_ZN7FatFile5mkdirEPS_PKcb+0x9c>
      break;
    }
    if (!open(parent, &fname, O_READ)) {
    d606:	2301      	movs	r3, #1
    d608:	f000 fba0 	bl	dd4c <_ZN7FatFile4openEPS_P7fname_th>
    d60c:	1e07      	subs	r7, r0, #0
    d60e:	d109      	bne.n	d624 <_ZN7FatFile5mkdirEPS_PKcb+0x84>
      if (!pFlag || !mkdir(parent, &fname)) {
    d610:	9900      	ldr	r1, [sp, #0]
    d612:	2900      	cmp	r1, #0
    d614:	d015      	beq.n	d642 <_ZN7FatFile5mkdirEPS_PKcb+0xa2>
    d616:	1c20      	adds	r0, r4, #0
    d618:	1c31      	adds	r1, r6, #0
    d61a:	aa03      	add	r2, sp, #12
    d61c:	f7ff ff56 	bl	d4cc <_ZN7FatFile5mkdirEPS_P7fname_t>
    d620:	2800      	cmp	r0, #0
    d622:	d00e      	beq.n	d642 <_ZN7FatFile5mkdirEPS_PKcb+0xa2>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    d624:	1c2b      	adds	r3, r5, #0
    d626:	1c22      	adds	r2, r4, #0
    d628:	ca43      	ldmia	r2!, {r0, r1, r6}
    d62a:	c343      	stmia	r3!, {r0, r1, r6}
    d62c:	ca43      	ldmia	r2!, {r0, r1, r6}
    d62e:	c343      	stmia	r3!, {r0, r1, r6}
    d630:	ca43      	ldmia	r2!, {r0, r1, r6}
    d632:	c343      	stmia	r3!, {r0, r1, r6}
    parent = &tmpDir;
    close();
    d634:	1c20      	adds	r0, r4, #0
    d636:	f7ff fedf 	bl	d3f8 <_ZN7FatFile5closeEv>
    d63a:	e7d5      	b.n	d5e8 <_ZN7FatFile5mkdirEPS_PKcb+0x48>
  }
  return mkdir(parent, &fname);
    d63c:	f7ff ff46 	bl	d4cc <_ZN7FatFile5mkdirEPS_P7fname_t>
    d640:	1c07      	adds	r7, r0, #0

fail:
  return false;
}
    d642:	1c38      	adds	r0, r7, #0
    d644:	b013      	add	sp, #76	; 0x4c
    d646:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000d648 <_ZN7FatFile8truncateEm>:

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate(uint32_t length) {
    d648:	b573      	push	{r0, r1, r4, r5, r6, lr}
  }
  /** \return True if this is a normal file else false. */
  bool isFile() const {
    return m_attr & FILE_ATTR_FILE;
    d64a:	7803      	ldrb	r3, [r0, #0]
    d64c:	1c04      	adds	r4, r0, #0
    d64e:	1c0d      	adds	r5, r1, #0
  uint32_t newPos;
  // error if not a normal file or read-only
  if (!isFile() || !(m_flags & O_WRITE)) {
    d650:	071a      	lsls	r2, r3, #28
    d652:	d50f      	bpl.n	d674 <_ZN7FatFile8truncateEm+0x2c>
    d654:	7883      	ldrb	r3, [r0, #2]
    d656:	079a      	lsls	r2, r3, #30
    d658:	d50c      	bpl.n	d674 <_ZN7FatFile8truncateEm+0x2c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // error if length is greater than current size
  if (length > m_fileSize) {
    d65a:	69c3      	ldr	r3, [r0, #28]
    d65c:	4299      	cmp	r1, r3
    d65e:	d809      	bhi.n	d674 <_ZN7FatFile8truncateEm+0x2c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // fileSize and length are zero - nothing to do
  if (m_fileSize == 0) {
    return true;
    d660:	2001      	movs	r0, #1
  if (length > m_fileSize) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // fileSize and length are zero - nothing to do
  if (m_fileSize == 0) {
    d662:	2b00      	cmp	r3, #0
    d664:	d038      	beq.n	d6d8 <_ZN7FatFile8truncateEm+0x90>

  // remember position for seek after truncation
  newPos = m_curPosition > length ? length : m_curPosition;

  // position to last cluster in truncated file
  if (!seekSet(length)) {
    d666:	1c20      	adds	r0, r4, #0
    d668:	1c29      	adds	r1, r5, #0
  if (m_fileSize == 0) {
    return true;
  }

  // remember position for seek after truncation
  newPos = m_curPosition > length ? length : m_curPosition;
    d66a:	6966      	ldr	r6, [r4, #20]

  // position to last cluster in truncated file
  if (!seekSet(length)) {
    d66c:	f7ff fd90 	bl	d190 <_ZN7FatFile7seekSetEm>
    d670:	2800      	cmp	r0, #0
    d672:	d101      	bne.n	d678 <_ZN7FatFile8truncateEm+0x30>
  }
  // set file to correct position
  return seekSet(newPos);

fail:
  return false;
    d674:	2000      	movs	r0, #0
    d676:	e02f      	b.n	d6d8 <_ZN7FatFile8truncateEm+0x90>
    d678:	68a0      	ldr	r0, [r4, #8]
  // position to last cluster in truncated file
  if (!seekSet(length)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (length == 0) {
    d67a:	2d00      	cmp	r5, #0
    d67c:	d106      	bne.n	d68c <_ZN7FatFile8truncateEm+0x44>
    // free all clusters
    if (!m_vol->freeChain(m_firstCluster)) {
    d67e:	6a21      	ldr	r1, [r4, #32]
    d680:	f000 fe32 	bl	e2e8 <_ZN9FatVolume9freeChainEm>
    d684:	2800      	cmp	r0, #0
    d686:	d0f5      	beq.n	d674 <_ZN7FatFile8truncateEm+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_firstCluster = 0;
    d688:	6225      	str	r5, [r4, #32]
    d68a:	e013      	b.n	d6b4 <_ZN7FatFile8truncateEm+0x6c>
  } else {
    uint32_t toFree;
    int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    d68c:	6921      	ldr	r1, [r4, #16]
    d68e:	aa01      	add	r2, sp, #4
    d690:	f000 fd90 	bl	e1b4 <_ZN9FatVolume6fatGetEmPm>
    if (fg < 0) {
    d694:	2800      	cmp	r0, #0
    d696:	dbed      	blt.n	d674 <_ZN7FatFile8truncateEm+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg) {
    d698:	d00c      	beq.n	d6b4 <_ZN7FatFile8truncateEm+0x6c>
      // free extra clusters
      if (!m_vol->freeChain(toFree)) {
    d69a:	68a0      	ldr	r0, [r4, #8]
    d69c:	9901      	ldr	r1, [sp, #4]
    d69e:	f000 fe23 	bl	e2e8 <_ZN9FatVolume9freeChainEm>
    d6a2:	2800      	cmp	r0, #0
    d6a4:	d0e6      	beq.n	d674 <_ZN7FatFile8truncateEm+0x2c>
  }
  uint32_t clusterStartBlock(uint32_t cluster) const;
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    d6a6:	68a0      	ldr	r0, [r4, #8]
    d6a8:	6921      	ldr	r1, [r4, #16]
    d6aa:	4a0c      	ldr	r2, [pc, #48]	; (d6dc <_ZN7FatFile8truncateEm+0x94>)
    d6ac:	f000 fdb7 	bl	e21e <_ZN9FatVolume6fatPutEmm>
        DBG_FAIL_MACRO;
        goto fail;
      }
      // current cluster is end of chain
      if (!m_vol->fatPutEOC(m_curCluster)) {
    d6b0:	2800      	cmp	r0, #0
    d6b2:	d0df      	beq.n	d674 <_ZN7FatFile8truncateEm+0x2c>
    }
  }
  m_fileSize = length;

  // need to update directory entry
  m_flags |= F_FILE_DIR_DIRTY;
    d6b4:	78a2      	ldrb	r2, [r4, #2]
    d6b6:	2380      	movs	r3, #128	; 0x80
    d6b8:	425b      	negs	r3, r3
    d6ba:	4313      	orrs	r3, r2
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  }
  m_fileSize = length;
    d6bc:	61e5      	str	r5, [r4, #28]

  // need to update directory entry
  m_flags |= F_FILE_DIR_DIRTY;
    d6be:	70a3      	strb	r3, [r4, #2]

  if (!sync()) {
    d6c0:	1c20      	adds	r0, r4, #0
    d6c2:	f7ff fe51 	bl	d368 <_ZN7FatFile4syncEv>
    d6c6:	2800      	cmp	r0, #0
    d6c8:	d0d4      	beq.n	d674 <_ZN7FatFile8truncateEm+0x2c>
    d6ca:	1e29      	subs	r1, r5, #0
    d6cc:	42b1      	cmp	r1, r6
    d6ce:	d900      	bls.n	d6d2 <_ZN7FatFile8truncateEm+0x8a>
    d6d0:	1c31      	adds	r1, r6, #0
    DBG_FAIL_MACRO;
    goto fail;
  }
  // set file to correct position
  return seekSet(newPos);
    d6d2:	1c20      	adds	r0, r4, #0
    d6d4:	f7ff fd5c 	bl	d190 <_ZN7FatFile7seekSetEm>

fail:
  return false;
}
    d6d8:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    d6da:	46c0      	nop			; (mov r8, r8)
    d6dc:	0fffffff 	.word	0x0fffffff

0000d6e0 <_ZN7FatFile5writeEPKvj>:
//------------------------------------------------------------------------------
int FatFile::write(const void* buf, size_t nbyte) {
    d6e0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    d6e2:	7803      	ldrb	r3, [r0, #0]
    d6e4:	1c04      	adds	r4, r0, #0
    d6e6:	9100      	str	r1, [sp, #0]
    d6e8:	9201      	str	r2, [sp, #4]
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isFile() || !(m_flags & O_WRITE)) {
    d6ea:	071a      	lsls	r2, r3, #28
    d6ec:	d50a      	bpl.n	d704 <_ZN7FatFile5writeEPKvj+0x24>
    d6ee:	7883      	ldrb	r3, [r0, #2]
    d6f0:	079a      	lsls	r2, r3, #30
    d6f2:	d507      	bpl.n	d704 <_ZN7FatFile5writeEPKvj+0x24>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & O_APPEND)) {
    d6f4:	075a      	lsls	r2, r3, #29
    d6f6:	d50b      	bpl.n	d710 <_ZN7FatFile5writeEPKvj+0x30>
    if (!seekSet(m_fileSize)) {
    d6f8:	1c20      	adds	r0, r4, #0
    d6fa:	69e1      	ldr	r1, [r4, #28]
    d6fc:	f7ff fd48 	bl	d190 <_ZN7FatFile7seekSetEm>
    d700:	2800      	cmp	r0, #0
    d702:	d105      	bne.n	d710 <_ZN7FatFile5writeEPKvj+0x30>
  }
  return nbyte;

fail:
  // return for write error
  m_error |= WRITE_ERROR;
    d704:	7863      	ldrb	r3, [r4, #1]
    d706:	2201      	movs	r2, #1
    d708:	4313      	orrs	r3, r2
    d70a:	7063      	strb	r3, [r4, #1]
  return -1;
    d70c:	4250      	negs	r0, r2
    d70e:	e0b8      	b.n	d882 <_ZN7FatFile5writeEPKvj+0x1a2>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    d710:	6962      	ldr	r2, [r4, #20]
    d712:	43d3      	mvns	r3, r2
    d714:	9a01      	ldr	r2, [sp, #4]
    d716:	429a      	cmp	r2, r3
    d718:	d8f4      	bhi.n	d704 <_ZN7FatFile5writeEPKvj+0x24>
    d71a:	1c15      	adds	r5, r2, #0
    d71c:	6967      	ldr	r7, [r4, #20]
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    d71e:	2d00      	cmp	r5, #0
    d720:	d100      	bne.n	d724 <_ZN7FatFile5writeEPKvj+0x44>
    d722:	e08e      	b.n	d842 <_ZN7FatFile5writeEPKvj+0x162>
    uint8_t blockOfCluster = m_vol->blockOfCluster(m_curPosition);
    d724:	68a0      	ldr	r0, [r4, #8]
  }
//------------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t blockOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterBlockMask;
    d726:	0a7b      	lsrs	r3, r7, #9
    d728:	7946      	ldrb	r6, [r0, #5]
    uint16_t blockOffset = m_curPosition & 0X1FF;
    d72a:	05ff      	lsls	r7, r7, #23
    d72c:	401e      	ands	r6, r3
    d72e:	0dff      	lsrs	r7, r7, #23
    if (blockOfCluster == 0 && blockOffset == 0) {
    d730:	2e00      	cmp	r6, #0
    d732:	d11d      	bne.n	d770 <_ZN7FatFile5writeEPKvj+0x90>
    d734:	2f00      	cmp	r7, #0
    d736:	d11b      	bne.n	d770 <_ZN7FatFile5writeEPKvj+0x90>
      // start of new cluster
      if (m_curCluster != 0) {
    d738:	6921      	ldr	r1, [r4, #16]
    d73a:	2900      	cmp	r1, #0
    d73c:	d00c      	beq.n	d758 <_ZN7FatFile5writeEPKvj+0x78>
        int8_t fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    d73e:	1c22      	adds	r2, r4, #0
    d740:	3210      	adds	r2, #16
    d742:	f000 fd37 	bl	e1b4 <_ZN9FatVolume6fatGetEmPm>
        if (fg < 0) {
    d746:	2800      	cmp	r0, #0
    d748:	dbdc      	blt.n	d704 <_ZN7FatFile5writeEPKvj+0x24>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
    d74a:	d111      	bne.n	d770 <_ZN7FatFile5writeEPKvj+0x90>
          // add cluster if at end of chain
          if (!addCluster()) {
    d74c:	1c20      	adds	r0, r4, #0
    d74e:	f7ff fb98 	bl	ce82 <_ZN7FatFile10addClusterEv>
    d752:	2800      	cmp	r0, #0
    d754:	d10c      	bne.n	d770 <_ZN7FatFile5writeEPKvj+0x90>
    d756:	e7d5      	b.n	d704 <_ZN7FatFile5writeEPKvj+0x24>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    d758:	6a23      	ldr	r3, [r4, #32]
    d75a:	2b00      	cmp	r3, #0
    d75c:	d107      	bne.n	d76e <_ZN7FatFile5writeEPKvj+0x8e>
          // allocate first cluster of file
          if (!addCluster()) {
    d75e:	1c20      	adds	r0, r4, #0
    d760:	f7ff fb8f 	bl	ce82 <_ZN7FatFile10addClusterEv>
    d764:	2800      	cmp	r0, #0
    d766:	d0cd      	beq.n	d704 <_ZN7FatFile5writeEPKvj+0x24>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    d768:	6923      	ldr	r3, [r4, #16]
    d76a:	6223      	str	r3, [r4, #32]
    d76c:	e000      	b.n	d770 <_ZN7FatFile5writeEPKvj+0x90>
        } else {
          m_curCluster = m_firstCluster;
    d76e:	6123      	str	r3, [r4, #16]
        }
      }
    }
    // block for data write
    uint32_t block = m_vol->clusterStartBlock(m_curCluster) + blockOfCluster;
    d770:	6921      	ldr	r1, [r4, #16]
    d772:	68a0      	ldr	r0, [r4, #8]
    d774:	f000 fd18 	bl	e1a8 <_ZNK9FatVolume17clusterStartBlockEm>
    d778:	1981      	adds	r1, r0, r6
    d77a:	68a0      	ldr	r0, [r4, #8]

    if (blockOffset != 0 || nToWrite < 512) {
    d77c:	2f00      	cmp	r7, #0
    d77e:	d102      	bne.n	d786 <_ZN7FatFile5writeEPKvj+0xa6>
    d780:	4b40      	ldr	r3, [pc, #256]	; (d884 <_ZN7FatFile5writeEPKvj+0x1a4>)
    d782:	429d      	cmp	r5, r3
    d784:	d827      	bhi.n	d7d6 <_ZN7FatFile5writeEPKvj+0xf6>
      // partial block - must use cache
      // max space in block
      n = 512 - blockOffset;
    d786:	2380      	movs	r3, #128	; 0x80
    d788:	009b      	lsls	r3, r3, #2
    d78a:	1bdb      	subs	r3, r3, r7
    d78c:	1e2e      	subs	r6, r5, #0
    d78e:	429e      	cmp	r6, r3
    d790:	d900      	bls.n	d794 <_ZN7FatFile5writeEPKvj+0xb4>
    d792:	1c1e      	adds	r6, r3, #0
      if (blockOffset == 0 && m_curPosition >= m_fileSize) {
        // start of new block don't need to read into cache
        cacheOption = FatCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of block
        cacheOption = FatCache::CACHE_FOR_WRITE;
    d794:	2201      	movs	r2, #1
    d796:	4694      	mov	ip, r2
      // lesser of space and amount to write
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (blockOffset == 0 && m_curPosition >= m_fileSize) {
    d798:	2f00      	cmp	r7, #0
    d79a:	d107      	bne.n	d7ac <_ZN7FatFile5writeEPKvj+0xcc>
        // start of new block don't need to read into cache
        cacheOption = FatCache::CACHE_RESERVE_FOR_WRITE;
    d79c:	2305      	movs	r3, #5
    d79e:	469c      	mov	ip, r3
      // lesser of space and amount to write
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (blockOffset == 0 && m_curPosition >= m_fileSize) {
    d7a0:	6962      	ldr	r2, [r4, #20]
    d7a2:	69e3      	ldr	r3, [r4, #28]
    d7a4:	429a      	cmp	r2, r3
    d7a6:	d201      	bcs.n	d7ac <_ZN7FatFile5writeEPKvj+0xcc>
        // start of new block don't need to read into cache
        cacheOption = FatCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of block
        cacheOption = FatCache::CACHE_FOR_WRITE;
    d7a8:	2201      	movs	r2, #1
    d7aa:	4694      	mov	ip, r2
  bool cacheSync() {
    return m_cache.sync();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t blockNumber, uint8_t options) {
    return m_cache.read(blockNumber, options);
    d7ac:	3024      	adds	r0, #36	; 0x24
    d7ae:	4662      	mov	r2, ip
    d7b0:	f000 fcd5 	bl	e15e <_ZN8FatCache4readEmh>
      }
      pc = m_vol->cacheFetchData(block, cacheOption);
      if (!pc) {
    d7b4:	2800      	cmp	r0, #0
    d7b6:	d0a5      	beq.n	d704 <_ZN7FatFile5writeEPKvj+0x24>
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + blockOffset;
      memcpy(dst, src, n);
    d7b8:	19c0      	adds	r0, r0, r7
    d7ba:	9900      	ldr	r1, [sp, #0]
    d7bc:	1c32      	adds	r2, r6, #0
    d7be:	f003 fefc 	bl	115ba <memcpy>
      if (512 == (n + blockOffset)) {
    d7c2:	19f7      	adds	r7, r6, r7
    d7c4:	2380      	movs	r3, #128	; 0x80
    d7c6:	009b      	lsls	r3, r3, #2
    d7c8:	429f      	cmp	r7, r3
    d7ca:	d132      	bne.n	d832 <_ZN7FatFile5writeEPKvj+0x152>
  }
  void cacheInvalidate() {
    m_cache.invalidate();
  }
  bool cacheSyncData() {
    return m_cache.sync();
    d7cc:	68a0      	ldr	r0, [r4, #8]
    d7ce:	3024      	adds	r0, #36	; 0x24
    d7d0:	f000 fc9e 	bl	e110 <_ZN8FatCache4syncEv>
    d7d4:	e018      	b.n	d808 <_ZN7FatFile5writeEPKvj+0x128>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_BLOCK_IO
    } else if (nToWrite >= 1024) {
    d7d6:	4b2c      	ldr	r3, [pc, #176]	; (d888 <_ZN7FatFile5writeEPKvj+0x1a8>)
    d7d8:	429d      	cmp	r5, r3
    d7da:	d918      	bls.n	d80e <_ZN7FatFile5writeEPKvj+0x12e>
      // use multiple block write command
      uint8_t maxBlocks = m_vol->blocksPerCluster() - blockOfCluster;
    d7dc:	7903      	ldrb	r3, [r0, #4]
      uint8_t nBlock = nToWrite >> 9;
    d7de:	0a6a      	lsrs	r2, r5, #9
        }
      }
#if USE_MULTI_BLOCK_IO
    } else if (nToWrite >= 1024) {
      // use multiple block write command
      uint8_t maxBlocks = m_vol->blocksPerCluster() - blockOfCluster;
    d7e0:	1b9e      	subs	r6, r3, r6
      uint8_t nBlock = nToWrite >> 9;
    d7e2:	b2d2      	uxtb	r2, r2
        }
      }
#if USE_MULTI_BLOCK_IO
    } else if (nToWrite >= 1024) {
      // use multiple block write command
      uint8_t maxBlocks = m_vol->blocksPerCluster() - blockOfCluster;
    d7e4:	b2f6      	uxtb	r6, r6
    d7e6:	1c13      	adds	r3, r2, #0
    d7e8:	42b2      	cmp	r2, r6
    d7ea:	d900      	bls.n	d7ee <_ZN7FatFile5writeEPKvj+0x10e>
    d7ec:	1c33      	adds	r3, r6, #0
  }
  cache_t *cacheAddress() {
    return m_cache.block();
  }
  uint32_t cacheBlockNumber() {
    return m_cache.lbn();
    d7ee:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    d7f0:	b2db      	uxtb	r3, r3
      uint8_t nBlock = nToWrite >> 9;
      if (nBlock > maxBlocks) {
        nBlock = maxBlocks;
      }
      n = 512*nBlock;
    d7f2:	025e      	lsls	r6, r3, #9
      if (m_vol->cacheBlockNumber() <= block
          && block < (m_vol->cacheBlockNumber() + nBlock)) {
    d7f4:	428a      	cmp	r2, r1
    d7f6:	d802      	bhi.n	d7fe <_ZN7FatFile5writeEPKvj+0x11e>
    d7f8:	189a      	adds	r2, r3, r2
    d7fa:	4291      	cmp	r1, r2
    d7fc:	d33a      	bcc.n	d874 <_ZN7FatFile5writeEPKvj+0x194>
        // invalidate cache if block is in cache
        m_vol->cacheInvalidate();
      }
      if (!m_vol->writeBlocks(block, src, nBlock)) {
    d7fe:	68a0      	ldr	r0, [r4, #8]
    d800:	6802      	ldr	r2, [r0, #0]
    d802:	68d7      	ldr	r7, [r2, #12]
    d804:	9a00      	ldr	r2, [sp, #0]
    d806:	47b8      	blx	r7
    d808:	2800      	cmp	r0, #0
    d80a:	d112      	bne.n	d832 <_ZN7FatFile5writeEPKvj+0x152>
    d80c:	e77a      	b.n	d704 <_ZN7FatFile5writeEPKvj+0x24>
      }
#endif  // USE_MULTI_BLOCK_IO
    } else {
      // use single block write command
      n = 512;
      if (m_vol->cacheBlockNumber() == block) {
    d80e:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    d810:	428b      	cmp	r3, r1
    d812:	d104      	bne.n	d81e <_ZN7FatFile5writeEPKvj+0x13e>
    m_vol = vol;
    invalidate();
  }
  /** Invalidate current cache block. */
  void invalidate() {
    m_status = 0;
    d814:	1d43      	adds	r3, r0, #5
    d816:	77df      	strb	r7, [r3, #31]
    m_lbn = 0XFFFFFFFF;
    d818:	2301      	movs	r3, #1
    d81a:	425b      	negs	r3, r3
    d81c:	62c3      	str	r3, [r0, #44]	; 0x2c
        m_vol->cacheInvalidate();
      }
      if (!m_vol->writeBlock(block, src)) {
    d81e:	68a0      	ldr	r0, [r4, #8]
    d820:	9a00      	ldr	r2, [sp, #0]
    d822:	6803      	ldr	r3, [r0, #0]
    d824:	685b      	ldr	r3, [r3, #4]
    d826:	4798      	blx	r3
    d828:	2800      	cmp	r0, #0
    d82a:	d100      	bne.n	d82e <_ZN7FatFile5writeEPKvj+0x14e>
    d82c:	e76a      	b.n	d704 <_ZN7FatFile5writeEPKvj+0x24>
        goto fail;
      }
#endif  // USE_MULTI_BLOCK_IO
    } else {
      // use single block write command
      n = 512;
    d82e:	2680      	movs	r6, #128	; 0x80
    d830:	00b6      	lsls	r6, r6, #2
      if (!m_vol->writeBlock(block, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    d832:	6962      	ldr	r2, [r4, #20]
    src += n;
    nToWrite -= n;
    d834:	1bad      	subs	r5, r5, r6
      if (!m_vol->writeBlock(block, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    d836:	1993      	adds	r3, r2, r6
    d838:	6163      	str	r3, [r4, #20]
    src += n;
    d83a:	9b00      	ldr	r3, [sp, #0]
    d83c:	199b      	adds	r3, r3, r6
    d83e:	9300      	str	r3, [sp, #0]
    d840:	e76c      	b.n	d71c <_ZN7FatFile5writeEPKvj+0x3c>
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    d842:	69e2      	ldr	r2, [r4, #28]
    d844:	78a3      	ldrb	r3, [r4, #2]
    d846:	4297      	cmp	r7, r2
    d848:	d901      	bls.n	d84e <_ZN7FatFile5writeEPKvj+0x16e>
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    d84a:	61e7      	str	r7, [r4, #28]
    d84c:	e003      	b.n	d856 <_ZN7FatFile5writeEPKvj+0x176>
    m_flags |= F_FILE_DIR_DIRTY;
  } else if (m_dateTime) {
    d84e:	4a0f      	ldr	r2, [pc, #60]	; (d88c <_ZN7FatFile5writeEPKvj+0x1ac>)
    d850:	6812      	ldr	r2, [r2, #0]
    d852:	2a00      	cmp	r2, #0
    d854:	d003      	beq.n	d85e <_ZN7FatFile5writeEPKvj+0x17e>
    // insure sync will update modified date and time
    m_flags |= F_FILE_DIR_DIRTY;
    d856:	2280      	movs	r2, #128	; 0x80
    d858:	4252      	negs	r2, r2
    d85a:	4313      	orrs	r3, r2
    d85c:	70a3      	strb	r3, [r4, #2]
  }

  if (m_flags & O_SYNC) {
    d85e:	78a3      	ldrb	r3, [r4, #2]
    d860:	071a      	lsls	r2, r3, #28
    d862:	d401      	bmi.n	d868 <_ZN7FatFile5writeEPKvj+0x188>
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  return nbyte;
    d864:	9801      	ldr	r0, [sp, #4]
    d866:	e00c      	b.n	d882 <_ZN7FatFile5writeEPKvj+0x1a2>
    // insure sync will update modified date and time
    m_flags |= F_FILE_DIR_DIRTY;
  }

  if (m_flags & O_SYNC) {
    if (!sync()) {
    d868:	1c20      	adds	r0, r4, #0
    d86a:	f7ff fd7d 	bl	d368 <_ZN7FatFile4syncEv>
    d86e:	2800      	cmp	r0, #0
    d870:	d1f8      	bne.n	d864 <_ZN7FatFile5writeEPKvj+0x184>
    d872:	e747      	b.n	d704 <_ZN7FatFile5writeEPKvj+0x24>
    m_vol = vol;
    invalidate();
  }
  /** Invalidate current cache block. */
  void invalidate() {
    m_status = 0;
    d874:	1d42      	adds	r2, r0, #5
    d876:	2700      	movs	r7, #0
    d878:	77d7      	strb	r7, [r2, #31]
    m_lbn = 0XFFFFFFFF;
    d87a:	2201      	movs	r2, #1
    d87c:	4252      	negs	r2, r2
    d87e:	62c2      	str	r2, [r0, #44]	; 0x2c
    d880:	e7bd      	b.n	d7fe <_ZN7FatFile5writeEPKvj+0x11e>

fail:
  // return for write error
  m_error |= WRITE_ERROR;
  return -1;
}
    d882:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    d884:	000001ff 	.word	0x000001ff
    d888:	000003ff 	.word	0x000003ff
    d88c:	20000cf0 	.word	0x20000cf0

0000d890 <_ZL10lfnGetCharP18longDirectoryEntryh>:
 *
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \return The 16-bit character.
 */
static uint16_t lfnGetChar(ldir_t *ldir, uint8_t i) {
    d890:	1c03      	adds	r3, r0, #0
  if (i < LDIR_NAME1_DIM) {
    d892:	2904      	cmp	r1, #4
    d894:	d804      	bhi.n	d8a0 <_ZL10lfnGetCharP18longDirectoryEntryh+0x10>
    return ldir->name1[i];
    d896:	0049      	lsls	r1, r1, #1
    d898:	1843      	adds	r3, r0, r1
    d89a:	785a      	ldrb	r2, [r3, #1]
    d89c:	7898      	ldrb	r0, [r3, #2]
    d89e:	e00f      	b.n	d8c0 <_ZL10lfnGetCharP18longDirectoryEntryh+0x30>
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM)) {
    d8a0:	290a      	cmp	r1, #10
    d8a2:	d805      	bhi.n	d8b0 <_ZL10lfnGetCharP18longDirectoryEntryh+0x20>
    return ldir->name2[i - LDIR_NAME1_DIM];
    d8a4:	3901      	subs	r1, #1
    d8a6:	0049      	lsls	r1, r1, #1
    d8a8:	1843      	adds	r3, r0, r1
    d8aa:	799a      	ldrb	r2, [r3, #6]
    d8ac:	79d8      	ldrb	r0, [r3, #7]
    d8ae:	e007      	b.n	d8c0 <_ZL10lfnGetCharP18longDirectoryEntryh+0x30>
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM + LDIR_NAME2_DIM)) {
    return ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM];
  }
  return 0;
    d8b0:	2000      	movs	r0, #0
static uint16_t lfnGetChar(ldir_t *ldir, uint8_t i) {
  if (i < LDIR_NAME1_DIM) {
    return ldir->name1[i];
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM)) {
    return ldir->name2[i - LDIR_NAME1_DIM];
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM + LDIR_NAME2_DIM)) {
    d8b2:	2910      	cmp	r1, #16
    d8b4:	d806      	bhi.n	d8c4 <_ZL10lfnGetCharP18longDirectoryEntryh+0x34>
    return ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM];
    d8b6:	3101      	adds	r1, #1
    d8b8:	0049      	lsls	r1, r1, #1
    d8ba:	185b      	adds	r3, r3, r1
    d8bc:	791a      	ldrb	r2, [r3, #4]
    d8be:	7958      	ldrb	r0, [r3, #5]
    d8c0:	0200      	lsls	r0, r0, #8
    d8c2:	4310      	orrs	r0, r2
  }
  return 0;
}
    d8c4:	4770      	bx	lr

0000d8c6 <_ZN7FatFile11lfnChecksumEPh>:
 * <http://www.gnu.org/licenses/>.
 */
#include "FatFile.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
    d8c6:	2300      	movs	r3, #0
    d8c8:	b510      	push	{r4, lr}
    d8ca:	1c04      	adds	r4, r0, #0
  uint8_t sum = 0;
    d8cc:	1c18      	adds	r0, r3, #0
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    d8ce:	01c2      	lsls	r2, r0, #7
    d8d0:	5ce1      	ldrb	r1, [r4, r3]
    d8d2:	0840      	lsrs	r0, r0, #1
    d8d4:	4302      	orrs	r2, r0
    d8d6:	1852      	adds	r2, r2, r1
    d8d8:	3301      	adds	r3, #1
    d8da:	b2d0      	uxtb	r0, r2
#include "FatFile.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    d8dc:	2b0b      	cmp	r3, #11
    d8de:	d1f6      	bne.n	d8ce <_ZN7FatFile11lfnChecksumEPh+0x8>
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
  }
  return sum;
}
    d8e0:	bd10      	pop	{r4, pc}

0000d8e2 <_ZN7FatFile11openClusterEPS_>:
fail:
  name[0] = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    d8e2:	b538      	push	{r3, r4, r5, lr}
  if (file->m_dirCluster == 0) {
    d8e4:	68cb      	ldr	r3, [r1, #12]
fail:
  name[0] = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    d8e6:	1c04      	adds	r4, r0, #0
    d8e8:	1c0d      	adds	r5, r1, #0
  if (file->m_dirCluster == 0) {
    d8ea:	2b00      	cmp	r3, #0
    d8ec:	d103      	bne.n	d8f6 <_ZN7FatFile11openClusterEPS_+0x14>
    return openRoot(file->m_vol);
    d8ee:	6889      	ldr	r1, [r1, #8]
    d8f0:	f7ff fb41 	bl	cf76 <_ZN7FatFile8openRootEP9FatVolume>
    d8f4:	e00b      	b.n	d90e <_ZN7FatFile11openClusterEPS_+0x2c>
  }
  memset(this, 0, sizeof(FatFile));
    d8f6:	2100      	movs	r1, #0
    d8f8:	2224      	movs	r2, #36	; 0x24
    d8fa:	f003 fe67 	bl	115cc <memset>
  m_attr = FILE_ATTR_SUBDIR;
    d8fe:	2310      	movs	r3, #16
    d900:	7023      	strb	r3, [r4, #0]
  m_flags = O_READ;
  m_vol = file->m_vol;
    d902:	68ab      	ldr	r3, [r5, #8]
  m_firstCluster = file->m_dirCluster;
    d904:	68ed      	ldr	r5, [r5, #12]
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
  m_attr = FILE_ATTR_SUBDIR;
  m_flags = O_READ;
    d906:	2001      	movs	r0, #1
    d908:	70a0      	strb	r0, [r4, #2]
  m_vol = file->m_vol;
    d90a:	60a3      	str	r3, [r4, #8]
  m_firstCluster = file->m_dirCluster;
    d90c:	6225      	str	r5, [r4, #32]
  return true;
}
    d90e:	bd38      	pop	{r3, r4, r5, pc}

0000d910 <_ZN7FatFile7getNameEPcj>:
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    lfnPutChar(ldir, i, c);
  }
}
//==============================================================================
bool FatFile::getName(char* name, size_t size) {
    d910:	b5f0      	push	{r4, r5, r6, r7, lr}
    d912:	b091      	sub	sp, #68	; 0x44
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
    d914:	2300      	movs	r3, #0
    d916:	1c05      	adds	r5, r0, #0
    d918:	a807      	add	r0, sp, #28
    d91a:	7003      	strb	r3, [r0, #0]
    d91c:	7043      	strb	r3, [r0, #1]
  FatFile dirFile;
  ldir_t* ldir;
  if (!isOpen() || size < 13) {
    d91e:	782b      	ldrb	r3, [r5, #0]
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    lfnPutChar(ldir, i, c);
  }
}
//==============================================================================
bool FatFile::getName(char* name, size_t size) {
    d920:	9101      	str	r1, [sp, #4]
    d922:	9203      	str	r2, [sp, #12]
  FatFile dirFile;
  ldir_t* ldir;
  if (!isOpen() || size < 13) {
    d924:	2b00      	cmp	r3, #0
    d926:	d104      	bne.n	d932 <_ZN7FatFile7getNameEPcj+0x22>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

fail:
  name[0] = 0;
    d928:	9901      	ldr	r1, [sp, #4]
    d92a:	2300      	movs	r3, #0
    d92c:	700b      	strb	r3, [r1, #0]
  return false;
    d92e:	9302      	str	r3, [sp, #8]
    d930:	e05e      	b.n	d9f0 <_ZN7FatFile7getNameEPcj+0xe0>
}
//==============================================================================
bool FatFile::getName(char* name, size_t size) {
  FatFile dirFile;
  ldir_t* ldir;
  if (!isOpen() || size < 13) {
    d932:	9a03      	ldr	r2, [sp, #12]
    d934:	2a0c      	cmp	r2, #12
    d936:	d9f7      	bls.n	d928 <_ZN7FatFile7getNameEPcj+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    d938:	78eb      	ldrb	r3, [r5, #3]
    d93a:	2b00      	cmp	r3, #0
    d93c:	d105      	bne.n	d94a <_ZN7FatFile7getNameEPcj+0x3a>
    return getSFN(name);
    d93e:	1c28      	adds	r0, r5, #0
    d940:	9901      	ldr	r1, [sp, #4]
    d942:	f000 fbcd 	bl	e0e0 <_ZN7FatFile6getSFNEPc>
    d946:	9002      	str	r0, [sp, #8]
    d948:	e052      	b.n	d9f0 <_ZN7FatFile7getNameEPcj+0xe0>
  }
  if (!dirFile.openCluster(this)) {
    d94a:	1c29      	adds	r1, r5, #0
    d94c:	f7ff ffc9 	bl	d8e2 <_ZN7FatFile11openClusterEPS_>
    d950:	2701      	movs	r7, #1
    d952:	2800      	cmp	r0, #0
    d954:	d0e8      	beq.n	d928 <_ZN7FatFile7getNameEPcj+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t ord = 1; ord <= m_lfnOrd; ord++) {
    d956:	78eb      	ldrb	r3, [r5, #3]
    d958:	42bb      	cmp	r3, r7
    d95a:	d3e5      	bcc.n	d928 <_ZN7FatFile7getNameEPcj+0x18>
    if (!dirFile.seekSet(32UL*(m_dirIndex - ord))) {
    d95c:	88a9      	ldrh	r1, [r5, #4]
    d95e:	a807      	add	r0, sp, #28
    d960:	1bc9      	subs	r1, r1, r7
    d962:	0149      	lsls	r1, r1, #5
    d964:	f7ff fc14 	bl	d190 <_ZN7FatFile7seekSetEm>
    d968:	9002      	str	r0, [sp, #8]
    d96a:	2800      	cmp	r0, #0
    d96c:	d0dc      	beq.n	d928 <_ZN7FatFile7getNameEPcj+0x18>
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<ldir_t*>(dirFile.readDirCache());
    d96e:	a807      	add	r0, sp, #28
    d970:	2100      	movs	r1, #0
    d972:	f7ff fbf0 	bl	d156 <_ZN7FatFile12readDirCacheEb>
    d976:	1e06      	subs	r6, r0, #0
    if (!ldir) {
    d978:	d0d6      	beq.n	d928 <_ZN7FatFile7getNameEPcj+0x18>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attr != DIR_ATT_LONG_NAME) {
    d97a:	7ac3      	ldrb	r3, [r0, #11]
    d97c:	2b0f      	cmp	r3, #15
    d97e:	d1d3      	bne.n	d928 <_ZN7FatFile7getNameEPcj+0x18>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ord != (ldir->ord & 0X1F)) {
    d980:	7802      	ldrb	r2, [r0, #0]
    d982:	231f      	movs	r3, #31
    d984:	4013      	ands	r3, r2
    d986:	429f      	cmp	r7, r3
    d988:	d1ce      	bne.n	d928 <_ZN7FatFile7getNameEPcj+0x18>
  return 0;
}
//------------------------------------------------------------------------------
static bool lfnGetName(ldir_t *ldir, char* name, size_t n) {
  uint8_t i;
  size_t k = 13*((ldir->ord & 0X1F) - 1);
    d98a:	1e7b      	subs	r3, r7, #1
    d98c:	220d      	movs	r2, #13
    d98e:	435a      	muls	r2, r3
    d990:	9204      	str	r2, [sp, #16]
    d992:	1c14      	adds	r4, r2, #0
    d994:	320d      	adds	r2, #13
    d996:	9205      	str	r2, [sp, #20]
    d998:	9b04      	ldr	r3, [sp, #16]
  for (i = 0; i < 13; i++) {
    uint16_t c = lfnGetChar(ldir, i);
    d99a:	1c30      	adds	r0, r6, #0
    d99c:	1ae1      	subs	r1, r4, r3
    d99e:	b2c9      	uxtb	r1, r1
    d9a0:	f7ff ff76 	bl	d890 <_ZL10lfnGetCharP18longDirectoryEntryh>
    if (c == 0 || k >= n) {
    d9a4:	2800      	cmp	r0, #0
    d9a6:	d00e      	beq.n	d9c6 <_ZN7FatFile7getNameEPcj+0xb6>
    d9a8:	9903      	ldr	r1, [sp, #12]
    d9aa:	428c      	cmp	r4, r1
    d9ac:	d214      	bcs.n	d9d8 <_ZN7FatFile7getNameEPcj+0xc8>
      break;
    }
    name[k++] = c >= 0X7F ? '?' : c;
    d9ae:	3401      	adds	r4, #1
    d9b0:	233f      	movs	r3, #63	; 0x3f
    d9b2:	287e      	cmp	r0, #126	; 0x7e
    d9b4:	d800      	bhi.n	d9b8 <_ZN7FatFile7getNameEPcj+0xa8>
    d9b6:	b2c3      	uxtb	r3, r0
    d9b8:	9901      	ldr	r1, [sp, #4]
    d9ba:	190a      	adds	r2, r1, r4
    d9bc:	3a01      	subs	r2, #1
    d9be:	7013      	strb	r3, [r2, #0]
}
//------------------------------------------------------------------------------
static bool lfnGetName(ldir_t *ldir, char* name, size_t n) {
  uint8_t i;
  size_t k = 13*((ldir->ord & 0X1F) - 1);
  for (i = 0; i < 13; i++) {
    d9c0:	9a05      	ldr	r2, [sp, #20]
    d9c2:	4294      	cmp	r4, r2
    d9c4:	d1e8      	bne.n	d998 <_ZN7FatFile7getNameEPcj+0x88>
      break;
    }
    name[k++] = c >= 0X7F ? '?' : c;
  }
  // Terminate with zero byte if name fits.
  if (k < n && (ldir->ord & LDIR_ORD_LAST_LONG_ENTRY)) {
    d9c6:	9b03      	ldr	r3, [sp, #12]
    d9c8:	429c      	cmp	r4, r3
    d9ca:	d205      	bcs.n	d9d8 <_ZN7FatFile7getNameEPcj+0xc8>
    d9cc:	7833      	ldrb	r3, [r6, #0]
    d9ce:	0659      	lsls	r1, r3, #25
    d9d0:	d502      	bpl.n	d9d8 <_ZN7FatFile7getNameEPcj+0xc8>
    name[k] = 0;
    d9d2:	9a01      	ldr	r2, [sp, #4]
    d9d4:	2300      	movs	r3, #0
    d9d6:	5513      	strb	r3, [r2, r4]
  }
  // Truncate if name is too long.
  name[n - 1] = 0;
    d9d8:	9a03      	ldr	r2, [sp, #12]
    d9da:	9901      	ldr	r1, [sp, #4]
    d9dc:	188b      	adds	r3, r1, r2
    d9de:	3b01      	subs	r3, #1
    d9e0:	2200      	movs	r2, #0
    d9e2:	701a      	strb	r2, [r3, #0]
    }
    if (!lfnGetName(ldir, name, size)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->ord & LDIR_ORD_LAST_LONG_ENTRY) {
    d9e4:	7833      	ldrb	r3, [r6, #0]
    d9e6:	0659      	lsls	r1, r3, #25
    d9e8:	d402      	bmi.n	d9f0 <_ZN7FatFile7getNameEPcj+0xe0>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t ord = 1; ord <= m_lfnOrd; ord++) {
    d9ea:	1c7b      	adds	r3, r7, #1
    d9ec:	b2df      	uxtb	r7, r3
    d9ee:	e7b2      	b.n	d956 <_ZN7FatFile7getNameEPcj+0x46>
  DBG_FAIL_MACRO;

fail:
  name[0] = 0;
  return false;
}
    d9f0:	9802      	ldr	r0, [sp, #8]
    d9f2:	b011      	add	sp, #68	; 0x44
    d9f4:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000d9f6 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_>:
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            fname_t* fname, const char** ptr) {
    d9f6:	b5f0      	push	{r4, r5, r6, r7, lr}
    d9f8:	b087      	sub	sp, #28
  int len = 0;
  int si;
  int dot;

  // Skip leading spaces.
  while (*path == ' ') {
    d9fa:	7803      	ldrb	r3, [r0, #0]
    d9fc:	2b20      	cmp	r3, #32
    d9fe:	d101      	bne.n	da04 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xe>
    path++;
    da00:	3001      	adds	r0, #1
    da02:	e7fa      	b.n	d9fa <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x4>
  }
  fname->lfn = path;
    da04:	6088      	str	r0, [r1, #8]
    da06:	1c04      	adds	r4, r0, #0
    da08:	1a23      	subs	r3, r4, r0
    da0a:	9300      	str	r3, [sp, #0]

  for (len = 0; ; len++) {
    c = path[len];
    da0c:	7823      	ldrb	r3, [r4, #0]
    if (c == 0 || isDirSeparator(c)) {
    da0e:	2b00      	cmp	r3, #0
    da10:	d102      	bne.n	da18 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x22>
    da12:	9c00      	ldr	r4, [sp, #0]
    da14:	1903      	adds	r3, r0, r4
    da16:	e01b      	b.n	da50 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x5a>
    da18:	2b2f      	cmp	r3, #47	; 0x2f
    da1a:	d0fa      	beq.n	da12 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x1c>
  name[n - 1] = 0;
  return true;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(char c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    da1c:	2b5c      	cmp	r3, #92	; 0x5c
    da1e:	d101      	bne.n	da24 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x2e>
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
      return false;
    da20:	2000      	movs	r0, #0
    da22:	e0dc      	b.n	dbde <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x1e8>
  name[n - 1] = 0;
  return true;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(char c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    da24:	2508      	movs	r5, #8
    da26:	1c1e      	adds	r6, r3, #0
    da28:	43ae      	bics	r6, r5
    da2a:	2e22      	cmp	r6, #34	; 0x22
    da2c:	d0f8      	beq.n	da20 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x2a>
    da2e:	2b3a      	cmp	r3, #58	; 0x3a
    da30:	d0f6      	beq.n	da20 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x2a>
      c == ':' || c == '<' || c == '>' || c == '?' || c == '|') {
    da32:	2540      	movs	r5, #64	; 0x40
    da34:	1c1f      	adds	r7, r3, #0
    da36:	43af      	bics	r7, r5
    da38:	2f3c      	cmp	r7, #60	; 0x3c
    da3a:	d0f1      	beq.n	da20 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x2a>
    da3c:	1c1d      	adds	r5, r3, #0
    da3e:	3d3e      	subs	r5, #62	; 0x3e
    da40:	2d01      	cmp	r5, #1
    da42:	d9ed      	bls.n	da20 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x2a>
  for (len = 0; ; len++) {
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
    da44:	3b20      	subs	r3, #32
    da46:	3401      	adds	r4, #1
    da48:	2b5e      	cmp	r3, #94	; 0x5e
    da4a:	d9dd      	bls.n	da08 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x12>
    da4c:	e7e8      	b.n	da20 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x2a>
    da4e:	3301      	adds	r3, #1
      return false;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
    da50:	781c      	ldrb	r4, [r3, #0]
    da52:	2c20      	cmp	r4, #32
    da54:	d0fb      	beq.n	da4e <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x58>
    da56:	2c2f      	cmp	r4, #47	; 0x2f
    da58:	d0f9      	beq.n	da4e <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x58>
  *ptr = &path[end];
    da5a:	6013      	str	r3, [r2, #0]

  // Back over spaces and dots.
  while (len) {
    da5c:	9c00      	ldr	r4, [sp, #0]
    da5e:	2c00      	cmp	r4, #0
    da60:	d00e      	beq.n	da80 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x8a>
    da62:	9a00      	ldr	r2, [sp, #0]
    da64:	1883      	adds	r3, r0, r2
    da66:	3b01      	subs	r3, #1
    c = path[len - 1];
    da68:	781b      	ldrb	r3, [r3, #0]
    if (c != '.' && c != ' ') {
    da6a:	2b2e      	cmp	r3, #46	; 0x2e
    da6c:	d001      	beq.n	da72 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x7c>
    da6e:	2b20      	cmp	r3, #32
    da70:	d103      	bne.n	da7a <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x84>
      break;
    }
    len--;
    da72:	9b00      	ldr	r3, [sp, #0]
    da74:	3b01      	subs	r3, #1
    da76:	9300      	str	r3, [sp, #0]
    da78:	e7f0      	b.n	da5c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x66>
  }
  // Max length of LFN is 255.
  if (len > 255) {
    da7a:	9e00      	ldr	r6, [sp, #0]
    da7c:	2eff      	cmp	r6, #255	; 0xff
    da7e:	dccf      	bgt.n	da20 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x2a>
    return false;
  }
  fname->len = len;
    da80:	9f00      	ldr	r7, [sp, #0]
    da82:	2300      	movs	r3, #0
    da84:	604f      	str	r7, [r1, #4]
    da86:	18ca      	adds	r2, r1, r3
  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    fname->sfn[k] = ' ';
    da88:	2420      	movs	r4, #32
    da8a:	3301      	adds	r3, #1
    da8c:	7354      	strb	r4, [r2, #13]
  if (len > 255) {
    return false;
  }
  fname->len = len;
  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    da8e:	2b0b      	cmp	r3, #11
    da90:	d1f9      	bne.n	da86 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x90>
    da92:	1c03      	adds	r3, r0, #0
    fname->sfn[k] = ' ';
  }
  // skip leading spaces and dots.
  for (si = 0; path[si] == '.' || path[si] == ' '; si++) {}
    da94:	781c      	ldrb	r4, [r3, #0]
    da96:	1a1a      	subs	r2, r3, r0
    da98:	2c2e      	cmp	r4, #46	; 0x2e
    da9a:	d101      	bne.n	daa0 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xaa>
    da9c:	3301      	adds	r3, #1
    da9e:	e7f9      	b.n	da94 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x9e>
    daa0:	2c20      	cmp	r4, #32
    daa2:	d0fb      	beq.n	da9c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xa6>
  // Not 8.3 if leading dot or space.
  is83 = !si;
    daa4:	4257      	negs	r7, r2
    daa6:	4157      	adcs	r7, r2
    daa8:	b2ff      	uxtb	r7, r7

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
    daaa:	9c00      	ldr	r4, [sp, #0]
    fname->sfn[k] = ' ';
  }
  // skip leading spaces and dots.
  for (si = 0; path[si] == '.' || path[si] == ' '; si++) {}
  // Not 8.3 if leading dot or space.
  is83 = !si;
    daac:	9701      	str	r7, [sp, #4]

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
    daae:	3c01      	subs	r4, #1
    dab0:	1c63      	adds	r3, r4, #1
    dab2:	d107      	bne.n	dac4 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xce>
        // Done - extension longer than three characters.
        is83 = false;
        break;
      }
      if (si != dot) {
        is83 = false;
    dab4:	2500      	movs	r5, #0
    dab6:	2607      	movs	r6, #7
    dab8:	2708      	movs	r7, #8
    daba:	9602      	str	r6, [sp, #8]
    dabc:	9505      	str	r5, [sp, #20]
    dabe:	9504      	str	r5, [sp, #16]
    dac0:	9703      	str	r7, [sp, #12]
    dac2:	e036      	b.n	db32 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x13c>
  for (si = 0; path[si] == '.' || path[si] == ' '; si++) {}
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
    dac4:	5d03      	ldrb	r3, [r0, r4]
    dac6:	2b2e      	cmp	r3, #46	; 0x2e
    dac8:	d1f1      	bne.n	daae <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xb8>
    daca:	e7f3      	b.n	dab4 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xbe>
  for (; si < len; si++) {
    c = path[si];
    dacc:	5c83      	ldrb	r3, [r0, r2]
    if (c == ' ' || (c == '.' && dot != si)) {
    dace:	2b20      	cmp	r3, #32
    dad0:	d04a      	beq.n	db68 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x172>
    dad2:	2b2e      	cmp	r3, #46	; 0x2e
    dad4:	d131      	bne.n	db3a <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x144>
    dad6:	4294      	cmp	r4, r2
    dad8:	d154      	bne.n	db84 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x18e>
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
    dada:	262a      	movs	r6, #42	; 0x2a
    dadc:	4276      	negs	r6, r6
    dade:	18f6      	adds	r6, r6, r3
    dae0:	2e05      	cmp	r6, #5
    dae2:	d92f      	bls.n	db44 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x14e>
      return false;
    }
    // :;<=>?
    if (0X3A <= c && c <= 0X3F) {
    dae4:	273a      	movs	r7, #58	; 0x3a
    dae6:	427f      	negs	r7, r7
    dae8:	18ff      	adds	r7, r7, r3
    daea:	2f05      	cmp	r7, #5
    daec:	d92c      	bls.n	db48 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x152>
      return false;
    }
    // [\]
    if (0X5B <= c && c <= 0X5D) {
    daee:	265b      	movs	r6, #91	; 0x5b
    daf0:	4276      	negs	r6, r6
    daf2:	18f6      	adds	r6, r6, r3
    daf4:	2e02      	cmp	r6, #2
    daf6:	d927      	bls.n	db48 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x152>
      is83 = false;
      continue;
    }
    if (!legal83Char(c) && si != dot) {
    daf8:	2721      	movs	r7, #33	; 0x21
    dafa:	427f      	negs	r7, r7
    dafc:	18ff      	adds	r7, r7, r3
    dafe:	2f5d      	cmp	r7, #93	; 0x5d
    db00:	d822      	bhi.n	db48 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x152>
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
    db02:	42a2      	cmp	r2, r4
    db04:	d05b      	beq.n	dbbe <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x1c8>
    db06:	9e02      	ldr	r6, [sp, #8]
    db08:	42b5      	cmp	r5, r6
    db0a:	d830      	bhi.n	db6e <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x178>
      si = dot;
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = DIR_NT_LC_EXT;  // bit for extension.
    } else {
      if ('a' <= c && c <= 'z') {
    db0c:	2761      	movs	r7, #97	; 0x61
    db0e:	427f      	negs	r7, r7
    db10:	18ff      	adds	r7, r7, r3
    db12:	2f19      	cmp	r7, #25
    db14:	d81e      	bhi.n	db54 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x15e>
        c += 'A' - 'a';
        lc |= bit;
    db16:	9e04      	ldr	r6, [sp, #16]
    db18:	9f03      	ldr	r7, [sp, #12]
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = DIR_NT_LC_EXT;  // bit for extension.
    } else {
      if ('a' <= c && c <= 'z') {
        c += 'A' - 'a';
    db1a:	3b20      	subs	r3, #32
        lc |= bit;
    db1c:	433e      	orrs	r6, r7
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = DIR_NT_LC_EXT;  // bit for extension.
    } else {
      if ('a' <= c && c <= 'z') {
        c += 'A' - 'a';
    db1e:	b2db      	uxtb	r3, r3
        lc |= bit;
    db20:	9604      	str	r6, [sp, #16]
      } else if ('A' <= c && c <= 'Z') {
        uc |= bit;
      }
      fname->sfn[i++] = c;
    db22:	1c6f      	adds	r7, r5, #1
    db24:	194d      	adds	r5, r1, r5
    db26:	736b      	strb	r3, [r5, #13]
    db28:	b2fd      	uxtb	r5, r7
      if (i < 7) {
    db2a:	2d06      	cmp	r5, #6
    db2c:	d800      	bhi.n	db30 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x13a>
        fname->seqPos = i;
    db2e:	730d      	strb	r5, [r1, #12]
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    db30:	3201      	adds	r2, #1
    db32:	9f00      	ldr	r7, [sp, #0]
    db34:	42ba      	cmp	r2, r7
    db36:	dbc9      	blt.n	dacc <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xd6>
    db38:	e029      	b.n	db8e <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x198>
  /** Check for a legal 8.3 character.
   * \param[in] c Character to be checked.
   * \return true for a legal 8.3 character else false.
   */
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
    db3a:	2b22      	cmp	r3, #34	; 0x22
    db3c:	d004      	beq.n	db48 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x152>
    db3e:	2b7c      	cmp	r3, #124	; 0x7c
    db40:	d1cb      	bne.n	dada <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xe4>
    db42:	e001      	b.n	db48 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x152>
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
    db44:	2b2d      	cmp	r3, #45	; 0x2d
    db46:	d0cd      	beq.n	dae4 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xee>
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
      is83 = false;
      continue;
    }
    if (!legal83Char(c) && si != dot) {
    db48:	42a2      	cmp	r2, r4
    db4a:	d038      	beq.n	dbbe <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x1c8>
      is83 = false;
    db4c:	2300      	movs	r3, #0
    db4e:	9301      	str	r3, [sp, #4]
      c = '_';
    db50:	235f      	movs	r3, #95	; 0x5f
    db52:	e7d8      	b.n	db06 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x110>
      bit = DIR_NT_LC_EXT;  // bit for extension.
    } else {
      if ('a' <= c && c <= 'z') {
        c += 'A' - 'a';
        lc |= bit;
      } else if ('A' <= c && c <= 'Z') {
    db54:	2641      	movs	r6, #65	; 0x41
    db56:	4276      	negs	r6, r6
    db58:	18f6      	adds	r6, r6, r3
    db5a:	2e19      	cmp	r6, #25
    db5c:	d8e1      	bhi.n	db22 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x12c>
        uc |= bit;
    db5e:	9f05      	ldr	r7, [sp, #20]
    db60:	9e03      	ldr	r6, [sp, #12]
    db62:	4337      	orrs	r7, r6
    db64:	9705      	str	r7, [sp, #20]
    db66:	e7dc      	b.n	db22 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x12c>
  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
      is83 = false;
    db68:	2300      	movs	r3, #0
    db6a:	9301      	str	r3, [sp, #4]
    db6c:	e7e0      	b.n	db30 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x13a>
    if (!legal83Char(c) && si != dot) {
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
      if (in == 10) {
    db6e:	9f02      	ldr	r7, [sp, #8]
    db70:	2f0a      	cmp	r7, #10
    db72:	d031      	beq.n	dbd8 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x1e2>
      }
      if (si != dot) {
        is83 = false;
      }
      // Break if no dot and base-name is longer than eight characters.
      if (si > dot) {
    db74:	42a2      	cmp	r2, r4
    db76:	dc08      	bgt.n	db8a <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x194>
        break;
      }
      si = dot;
      in = 10;  // Max index for full 8.3 name.
    db78:	270a      	movs	r7, #10
      i = 8;    // Place for extension.
      bit = DIR_NT_LC_EXT;  // bit for extension.
    db7a:	2310      	movs	r3, #16
    db7c:	1c22      	adds	r2, r4, #0
      // Break if no dot and base-name is longer than eight characters.
      if (si > dot) {
        break;
      }
      si = dot;
      in = 10;  // Max index for full 8.3 name.
    db7e:	9702      	str	r7, [sp, #8]
      i = 8;    // Place for extension.
    db80:	2508      	movs	r5, #8
      bit = DIR_NT_LC_EXT;  // bit for extension.
    db82:	9303      	str	r3, [sp, #12]
  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
      is83 = false;
    db84:	2600      	movs	r6, #0
    db86:	9601      	str	r6, [sp, #4]
    db88:	e7d2      	b.n	db30 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x13a>
        // Done - extension longer than three characters.
        is83 = false;
        break;
      }
      if (si != dot) {
        is83 = false;
    db8a:	2200      	movs	r2, #0
    db8c:	9201      	str	r2, [sp, #4]
      if (i < 7) {
        fname->seqPos = i;
      }
    }
  }
  if (fname->sfn[0] == ' ') {
    db8e:	7b4b      	ldrb	r3, [r1, #13]
    db90:	2b20      	cmp	r3, #32
    db92:	d100      	bne.n	db96 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x1a0>
    db94:	e744      	b.n	da20 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x2a>
    return false;
  }

  if (is83) {
    db96:	9e01      	ldr	r6, [sp, #4]
    db98:	2e00      	cmp	r6, #0
    db9a:	d007      	beq.n	dbac <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x1b6>
    db9c:	9b04      	ldr	r3, [sp, #16]
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
    db9e:	9f05      	ldr	r7, [sp, #20]
    dba0:	421f      	tst	r7, r3
    dba2:	d000      	beq.n	dba6 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x1b0>
    dba4:	2302      	movs	r3, #2
    dba6:	700b      	strb	r3, [r1, #0]
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
    dba8:	2001      	movs	r0, #1
    dbaa:	e018      	b.n	dbde <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x1e8>

  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    dbac:	7b0b      	ldrb	r3, [r1, #12]
  }

  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    dbae:	2001      	movs	r0, #1
    dbb0:	7008      	strb	r0, [r1, #0]
    fname->sfn[fname->seqPos] = '~';
    dbb2:	18c9      	adds	r1, r1, r3
    dbb4:	237e      	movs	r3, #126	; 0x7e
    dbb6:	734b      	strb	r3, [r1, #13]
    fname->sfn[fname->seqPos + 1] = '1';
    dbb8:	2331      	movs	r3, #49	; 0x31
    dbba:	738b      	strb	r3, [r1, #14]
    dbbc:	e00f      	b.n	dbde <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x1e8>
    if (!legal83Char(c) && si != dot) {
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
      if (in == 10) {
    dbbe:	9a02      	ldr	r2, [sp, #8]
    dbc0:	2a0a      	cmp	r2, #10
    dbc2:	d102      	bne.n	dbca <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x1d4>
        // Done - extension longer than three characters.
        is83 = false;
        break;
      }
      if (si != dot) {
        is83 = false;
    dbc4:	2300      	movs	r3, #0
    dbc6:	9301      	str	r3, [sp, #4]
    dbc8:	e7e1      	b.n	db8e <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x198>
      // Break if no dot and base-name is longer than eight characters.
      if (si > dot) {
        break;
      }
      si = dot;
      in = 10;  // Max index for full 8.3 name.
    dbca:	230a      	movs	r3, #10
      i = 8;    // Place for extension.
      bit = DIR_NT_LC_EXT;  // bit for extension.
    dbcc:	2610      	movs	r6, #16
    if (!legal83Char(c) && si != dot) {
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
      if (in == 10) {
    dbce:	1c22      	adds	r2, r4, #0
      // Break if no dot and base-name is longer than eight characters.
      if (si > dot) {
        break;
      }
      si = dot;
      in = 10;  // Max index for full 8.3 name.
    dbd0:	9302      	str	r3, [sp, #8]
      i = 8;    // Place for extension.
    dbd2:	2508      	movs	r5, #8
      bit = DIR_NT_LC_EXT;  // bit for extension.
    dbd4:	9603      	str	r6, [sp, #12]
    dbd6:	e7ab      	b.n	db30 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x13a>
        // Done - extension longer than three characters.
        is83 = false;
        break;
      }
      if (si != dot) {
        is83 = false;
    dbd8:	2400      	movs	r4, #0
    dbda:	9401      	str	r4, [sp, #4]
    dbdc:	e7d7      	b.n	db8e <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x198>
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
}
    dbde:	b007      	add	sp, #28
    dbe0:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000dbe2 <_ZN7FatFile6removeEv>:

fail:
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::remove() {
    dbe2:	b5f0      	push	{r4, r5, r6, r7, lr}
    dbe4:	b08b      	sub	sp, #44	; 0x2c
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
    dbe6:	2300      	movs	r3, #0
    dbe8:	ad01      	add	r5, sp, #4
    dbea:	702b      	strb	r3, [r5, #0]
    dbec:	706b      	strb	r3, [r5, #1]
  bool isDir() const {
    return m_attr & FILE_ATTR_DIR;
  }
  /** \return True if this is a normal file else false. */
  bool isFile() const {
    return m_attr & FILE_ATTR_FILE;
    dbee:	7803      	ldrb	r3, [r0, #0]
    dbf0:	1c04      	adds	r4, r0, #0
  FatFile dirFile;
  dir_t* dir;
  ldir_t* ldir;

  // Cant' remove not open for write.
  if (!isFile() || !(m_flags & O_WRITE)) {
    dbf2:	071a      	lsls	r2, r3, #28
    dbf4:	d401      	bmi.n	dbfa <_ZN7FatFile6removeEv+0x18>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

fail:
  return false;
    dbf6:	2000      	movs	r0, #0
    dbf8:	e053      	b.n	dca2 <_ZN7FatFile6removeEv+0xc0>
  FatFile dirFile;
  dir_t* dir;
  ldir_t* ldir;

  // Cant' remove not open for write.
  if (!isFile() || !(m_flags & O_WRITE)) {
    dbfa:	7883      	ldrb	r3, [r0, #2]
    dbfc:	079a      	lsls	r2, r3, #30
    dbfe:	d5fa      	bpl.n	dbf6 <_ZN7FatFile6removeEv+0x14>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
    dc00:	6a01      	ldr	r1, [r0, #32]
    dc02:	2900      	cmp	r1, #0
    dc04:	d004      	beq.n	dc10 <_ZN7FatFile6removeEv+0x2e>
    dc06:	68a0      	ldr	r0, [r4, #8]
    dc08:	f000 fb6e 	bl	e2e8 <_ZN9FatVolume9freeChainEm>
    dc0c:	2800      	cmp	r0, #0
    dc0e:	d0f2      	beq.n	dbf6 <_ZN7FatFile6removeEv+0x14>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Cache directory entry.
  dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
    dc10:	1c20      	adds	r0, r4, #0
    dc12:	2101      	movs	r1, #1
    dc14:	f7ff f97c 	bl	cf10 <_ZN7FatFile13cacheDirEntryEh>
    dc18:	1e06      	subs	r6, r0, #0
  if (!dir) {
    dc1a:	d0ec      	beq.n	dbf6 <_ZN7FatFile6removeEv+0x14>
    DBG_FAIL_MACRO;
    goto fail;
  }
  chksum = lfnChecksum(dir->name);
    dc1c:	f7ff fe53 	bl	d8c6 <_ZN7FatFile11lfnChecksumEPh>

  // Mark entry deleted.
  dir->name[0] = DIR_NAME_DELETED;
    dc20:	23e5      	movs	r3, #229	; 0xe5
    dc22:	7033      	strb	r3, [r6, #0]

  // Set this file closed.
  m_attr = FILE_ATTR_CLOSED;
    dc24:	2300      	movs	r3, #0
  dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  chksum = lfnChecksum(dir->name);
    dc26:	1c07      	adds	r7, r0, #0

  // Mark entry deleted.
  dir->name[0] = DIR_NAME_DELETED;

  // Set this file closed.
  m_attr = FILE_ATTR_CLOSED;
    dc28:	7023      	strb	r3, [r4, #0]

  // Write entry to device.
  if (!m_vol->cacheSync()) {
    dc2a:	68a0      	ldr	r0, [r4, #8]
    dc2c:	f7ff f91a 	bl	ce64 <_ZN9FatVolume9cacheSyncEv>
    dc30:	2800      	cmp	r0, #0
    dc32:	d0e0      	beq.n	dbf6 <_ZN7FatFile6removeEv+0x14>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    dc34:	78e3      	ldrb	r3, [r4, #3]
    dc36:	2b00      	cmp	r3, #0
    dc38:	d033      	beq.n	dca2 <_ZN7FatFile6removeEv+0xc0>
    // Done, no LFN entries.
    return true;
  }
  if (!dirFile.openCluster(this)) {
    dc3a:	1c28      	adds	r0, r5, #0
    dc3c:	1c21      	adds	r1, r4, #0
    dc3e:	f7ff fe50 	bl	d8e2 <_ZN7FatFile11openClusterEPS_>
    dc42:	2601      	movs	r6, #1
    dc44:	2800      	cmp	r0, #0
    dc46:	d0d6      	beq.n	dbf6 <_ZN7FatFile6removeEv+0x14>
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (ord = 1; ord <= m_lfnOrd; ord++) {
    dc48:	78e3      	ldrb	r3, [r4, #3]
    dc4a:	42b3      	cmp	r3, r6
    dc4c:	d3d3      	bcc.n	dbf6 <_ZN7FatFile6removeEv+0x14>
    if (!dirFile.seekSet(32UL*(m_dirIndex - ord))) {
    dc4e:	88a1      	ldrh	r1, [r4, #4]
    dc50:	1c28      	adds	r0, r5, #0
    dc52:	1b89      	subs	r1, r1, r6
    dc54:	0149      	lsls	r1, r1, #5
    dc56:	f7ff fa9b 	bl	d190 <_ZN7FatFile7seekSetEm>
    dc5a:	2800      	cmp	r0, #0
    dc5c:	d0cb      	beq.n	dbf6 <_ZN7FatFile6removeEv+0x14>
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<ldir_t*>(dirFile.readDirCache());
    dc5e:	1c28      	adds	r0, r5, #0
    dc60:	2100      	movs	r1, #0
    dc62:	f7ff fa78 	bl	d156 <_ZN7FatFile12readDirCacheEb>
    if (!ldir) {
    dc66:	2800      	cmp	r0, #0
    dc68:	d0c5      	beq.n	dbf6 <_ZN7FatFile6removeEv+0x14>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attr != DIR_ATT_LONG_NAME ||
    dc6a:	7ac3      	ldrb	r3, [r0, #11]
    dc6c:	2b0f      	cmp	r3, #15
    dc6e:	d1c2      	bne.n	dbf6 <_ZN7FatFile6removeEv+0x14>
        ord != (ldir->ord & 0X1F) ||
    dc70:	7803      	ldrb	r3, [r0, #0]
    dc72:	221f      	movs	r2, #31
    dc74:	401a      	ands	r2, r3
    ldir = reinterpret_cast<ldir_t*>(dirFile.readDirCache());
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attr != DIR_ATT_LONG_NAME ||
    dc76:	4296      	cmp	r6, r2
    dc78:	d1bd      	bne.n	dbf6 <_ZN7FatFile6removeEv+0x14>
        ord != (ldir->ord & 0X1F) ||
    dc7a:	7b42      	ldrb	r2, [r0, #13]
    dc7c:	42ba      	cmp	r2, r7
    dc7e:	d1ba      	bne.n	dbf6 <_ZN7FatFile6removeEv+0x14>
        chksum != ldir->chksum) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    last = ldir->ord & LDIR_ORD_LAST_LONG_ENTRY;
    ldir->ord = DIR_NAME_DELETED;
    dc80:	22e5      	movs	r2, #229	; 0xe5
    dc82:	7002      	strb	r2, [r0, #0]
  cache_t* block() {
    return &m_block;
  }
  /** Set current block dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    dc84:	68a2      	ldr	r2, [r4, #8]
    dc86:	2001      	movs	r0, #1
    dc88:	3205      	adds	r2, #5
    dc8a:	7fd1      	ldrb	r1, [r2, #31]
    dc8c:	4301      	orrs	r1, r0
    dc8e:	77d1      	strb	r1, [r2, #31]
    m_vol->cacheDirty();
    if (last) {
    dc90:	065a      	lsls	r2, r3, #25
    dc92:	d503      	bpl.n	dc9c <_ZN7FatFile6removeEv+0xba>
      if (!m_vol->cacheSync()) {
    dc94:	68a0      	ldr	r0, [r4, #8]
    dc96:	f7ff f8e5 	bl	ce64 <_ZN9FatVolume9cacheSyncEv>
    dc9a:	e002      	b.n	dca2 <_ZN7FatFile6removeEv+0xc0>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (ord = 1; ord <= m_lfnOrd; ord++) {
    dc9c:	3601      	adds	r6, #1
    dc9e:	b2f6      	uxtb	r6, r6
    dca0:	e7d2      	b.n	dc48 <_ZN7FatFile6removeEv+0x66>
  // Fall into fail.
  DBG_FAIL_MACRO;

fail:
  return false;
}
    dca2:	b00b      	add	sp, #44	; 0x2c
    dca4:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000dca6 <_ZN7FatFile12lfnUniqueSfnEP7fname_t>:
//------------------------------------------------------------------------------
bool FatFile::lfnUniqueSfn(fname_t* fname) {
    dca6:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;;
    dca8:	7b0c      	ldrb	r4, [r1, #12]

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::lfnUniqueSfn(fname_t* fname) {
    dcaa:	1c07      	adds	r7, r0, #0
    dcac:	1c0d      	adds	r5, r1, #0
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;;
    dcae:	2602      	movs	r6, #2
  for (uint8_t seq = 2; seq < 100; seq++) {
    if (seq < FIRST_HASH_SEQ) {
      fname->sfn[pos + 1] = '0' + seq;
    } else {
      DBG_PRINT_IF(seq > FIRST_HASH_SEQ);
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
    dcb0:	6869      	ldr	r1, [r5, #4]
    dcb2:	68aa      	ldr	r2, [r5, #8]
    dcb4:	1873      	adds	r3, r6, r1
    dcb6:	1851      	adds	r1, r2, r1
    dcb8:	b29b      	uxth	r3, r3
    dcba:	9101      	str	r1, [sp, #4]
}
//------------------------------------------------------------------------------
// Daniel Bernstein University of Illinois at Chicago.
// Original had + instead of ^
static uint16_t Bernstein(uint16_t hash, const char *str, size_t len) {
  for (size_t i = 0; i < len; i++) {
    dcbc:	9901      	ldr	r1, [sp, #4]
    dcbe:	428a      	cmp	r2, r1
    dcc0:	d007      	beq.n	dcd2 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x2c>
    // hash = hash * 33 ^ str[i];
    hash = ((hash << 5) + hash) ^ str[i];
    dcc2:	0159      	lsls	r1, r3, #5
    dcc4:	7810      	ldrb	r0, [r2, #0]
    dcc6:	468c      	mov	ip, r1
    dcc8:	4463      	add	r3, ip
    dcca:	4043      	eors	r3, r0
    dccc:	b29b      	uxth	r3, r3
    dcce:	3201      	adds	r2, #1
    dcd0:	e7f4      	b.n	dcbc <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x16>
    dcd2:	1c22      	adds	r2, r4, #0
    dcd4:	2c03      	cmp	r4, #3
    dcd6:	d900      	bls.n	dcda <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x34>
    dcd8:	2203      	movs	r2, #3
    dcda:	b2d4      	uxtb	r4, r2
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    dcdc:	1d22      	adds	r2, r4, #4
    dcde:	b2d2      	uxtb	r2, r2
        uint8_t h = hex & 0XF;
    dce0:	210f      	movs	r1, #15
    dce2:	4019      	ands	r1, r3
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    dce4:	1c08      	adds	r0, r1, #0
    dce6:	3037      	adds	r0, #55	; 0x37
    dce8:	2909      	cmp	r1, #9
    dcea:	d800      	bhi.n	dcee <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x48>
    dcec:	3807      	subs	r0, #7
    dcee:	18a9      	adds	r1, r5, r2
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    dcf0:	3a01      	subs	r2, #1
    dcf2:	b2d2      	uxtb	r2, r2
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    dcf4:	7348      	strb	r0, [r1, #13]
        hex >>= 4;
    dcf6:	091b      	lsrs	r3, r3, #4
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    dcf8:	42a2      	cmp	r2, r4
    dcfa:	d8f1      	bhi.n	dce0 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x3a>
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
        hex >>= 4;
      }
    }
    fname->sfn[pos] = '~';
    dcfc:	192b      	adds	r3, r5, r4
    dcfe:	227e      	movs	r2, #126	; 0x7e
    dd00:	735a      	strb	r2, [r3, #13]
   * the value false is returned for failure.
   */
  static bool remove(FatFile* dirFile, const char* path);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    dd02:	1c38      	adds	r0, r7, #0
    dd04:	2100      	movs	r1, #0
    dd06:	f7ff fa43 	bl	d190 <_ZN7FatFile7seekSetEm>
    rewind();
    while (1) {
      dir = readDirCache(true);
    dd0a:	2101      	movs	r1, #1
    dd0c:	1c38      	adds	r0, r7, #0
    dd0e:	f7ff fa22 	bl	d156 <_ZN7FatFile12readDirCacheEb>
    dd12:	1e01      	subs	r1, r0, #0
      if (!dir) {
    dd14:	d104      	bne.n	dd20 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x7a>
        if (!getError()) {
    dd16:	7878      	ldrb	r0, [r7, #1]
    dd18:	4243      	negs	r3, r0
    dd1a:	4158      	adcs	r0, r3
    dd1c:	b2c0      	uxtb	r0, r0
    dd1e:	e013      	b.n	dd48 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0xa2>
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (dir->name[0] == DIR_NAME_FREE) {
    dd20:	7803      	ldrb	r3, [r0, #0]
    dd22:	2b00      	cmp	r3, #0
    dd24:	d00a      	beq.n	dd3c <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x96>
 * \param[in] dir Pointer to a directory entry.
 *
 * \return true if the entry is for a normal file or subdirectory else false.
 */
static inline uint8_t DIR_IS_FILE_OR_SUBDIR(const dir_t* dir) {
  return (dir->attributes & DIR_ATT_VOLUME_ID) == 0;
    dd26:	7ac3      	ldrb	r3, [r0, #11]
        goto done;
      }
      if (DIR_IS_FILE_OR_SUBDIR(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    dd28:	071a      	lsls	r2, r3, #28
    dd2a:	d4ee      	bmi.n	dd0a <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x64>
    dd2c:	1c28      	adds	r0, r5, #0
    dd2e:	300d      	adds	r0, #13
    dd30:	220b      	movs	r2, #11
    dd32:	f003 fc33 	bl	1159c <memcmp>
    dd36:	2800      	cmp	r0, #0
    dd38:	d1e7      	bne.n	dd0a <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x64>
    dd3a:	e001      	b.n	dd40 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x9a>

fail:
  return false;

done:
  return true;
    dd3c:	2001      	movs	r0, #1
    dd3e:	e003      	b.n	dd48 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0xa2>
    dd40:	3601      	adds	r6, #1
    dd42:	b2b6      	uxth	r6, r6
  uint16_t hex;

  DBG_HALT_IF(!(fname->flags & FNAME_FLAG_LOST_CHARS));
  DBG_HALT_IF(fname->sfn[pos] != '~' && fname->sfn[pos + 1] != '1');

  for (uint8_t seq = 2; seq < 100; seq++) {
    dd44:	2e64      	cmp	r6, #100	; 0x64
    dd46:	d1b3      	bne.n	dcb0 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0xa>
fail:
  return false;

done:
  return true;
}
    dd48:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

0000dd4c <_ZN7FatFile4openEPS_P7fname_th>:
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, uint8_t oflag) {
    dd4c:	b5f0      	push	{r4, r5, r6, r7, lr}
    dd4e:	1c0c      	adds	r4, r1, #0
    dd50:	b091      	sub	sp, #68	; 0x44
  uint8_t chksum = 0;
  uint16_t freeIndex = 0;
  uint16_t curIndex;
  dir_t* dir;
  ldir_t* ldir;
  size_t len = fname->len;
    dd52:	6851      	ldr	r1, [r2, #4]
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, uint8_t oflag) {
    dd54:	9206      	str	r2, [sp, #24]
   * the value false, is returned for failure.
   */  
  bool getSFN(char* name);
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_attr & FILE_ATTR_DIR;
    dd56:	7822      	ldrb	r2, [r4, #0]
    dd58:	930c      	str	r3, [sp, #48]	; 0x30
  uint16_t curIndex;
  dir_t* dir;
  ldir_t* ldir;
  size_t len = fname->len;

  if (!dirFile->isDir() || isOpen()) {
    dd5a:	2370      	movs	r3, #112	; 0x70
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, uint8_t oflag) {
    dd5c:	900e      	str	r0, [sp, #56]	; 0x38
  uint8_t chksum = 0;
  uint16_t freeIndex = 0;
  uint16_t curIndex;
  dir_t* dir;
  ldir_t* ldir;
  size_t len = fname->len;
    dd5e:	910a      	str	r1, [sp, #40]	; 0x28

  if (!dirFile->isDir() || isOpen()) {
    dd60:	421a      	tst	r2, r3
    dd62:	d101      	bne.n	dd68 <_ZN7FatFile4openEPS_P7fname_th+0x1c>
    goto fail;
  }
  return true;

fail:
  return false;
    dd64:	2000      	movs	r0, #0
    dd66:	e1a9      	b.n	e0bc <_ZN7FatFile4openEPS_P7fname_th+0x370>
  uint16_t curIndex;
  dir_t* dir;
  ldir_t* ldir;
  size_t len = fname->len;

  if (!dirFile->isDir() || isOpen()) {
    dd68:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    dd6a:	7813      	ldrb	r3, [r2, #0]
    dd6c:	2b00      	cmp	r3, #0
    dd6e:	d1f9      	bne.n	dd64 <_ZN7FatFile4openEPS_P7fname_th+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
    dd70:	9906      	ldr	r1, [sp, #24]
    dd72:	780b      	ldrb	r3, [r1, #0]
    dd74:	079a      	lsls	r2, r3, #30
    dd76:	d100      	bne.n	dd7a <_ZN7FatFile4openEPS_P7fname_th+0x2e>
    dd78:	e197      	b.n	e0aa <_ZN7FatFile4openEPS_P7fname_th+0x35e>
    dd7a:	980a      	ldr	r0, [sp, #40]	; 0x28
    dd7c:	210d      	movs	r1, #13
    dd7e:	300c      	adds	r0, #12
    dd80:	f003 fb0a 	bl	11398 <__aeabi_uidiv>
    dd84:	3001      	adds	r0, #1
    dd86:	b2c0      	uxtb	r0, r0
    dd88:	9009      	str	r0, [sp, #36]	; 0x24
   * the value false is returned for failure.
   */
  static bool remove(FatFile* dirFile, const char* path);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    dd8a:	1c20      	adds	r0, r4, #0
    dd8c:	2100      	movs	r1, #0
    dd8e:	f7ff f9ff 	bl	d190 <_ZN7FatFile7seekSetEm>
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t ord = 0;
  uint8_t chksum = 0;
  uint16_t freeIndex = 0;
    dd92:	2300      	movs	r3, #0
    dd94:	9305      	str	r3, [sp, #20]
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t ord = 0;
  uint8_t chksum = 0;
    dd96:	930b      	str	r3, [sp, #44]	; 0x2c
bool FatFile::open(FatFile* dirFile, fname_t* fname, uint8_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t ord = 0;
    dd98:	9307      	str	r3, [sp, #28]
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, uint8_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
    dd9a:	1c1f      	adds	r7, r3, #0
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, uint8_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
    dd9c:	9304      	str	r3, [sp, #16]
  }
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, uint8_t oflag) {
  bool fnameFound = false;
    dd9e:	930d      	str	r3, [sp, #52]	; 0x34
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    dda0:	6963      	ldr	r3, [r4, #20]
    dir = dirFile->readDirCache(true);
    dda2:	1c20      	adds	r0, r4, #0
    dda4:	2101      	movs	r1, #1
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    dda6:	095e      	lsrs	r6, r3, #5
    dir = dirFile->readDirCache(true);
    dda8:	f7ff f9d5 	bl	d156 <_ZN7FatFile12readDirCacheEb>
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    ddac:	b2b6      	uxth	r6, r6
    dir = dirFile->readDirCache(true);
    ddae:	1e05      	subs	r5, r0, #0
    if (!dir) {
    ddb0:	d104      	bne.n	ddbc <_ZN7FatFile4openEPS_P7fname_th+0x70>
      if (dirFile->getError()) {
    ddb2:	7863      	ldrb	r3, [r4, #1]
    ddb4:	2b00      	cmp	r3, #0
    ddb6:	d100      	bne.n	ddba <_ZN7FatFile4openEPS_P7fname_th+0x6e>
    ddb8:	e095      	b.n	dee6 <_ZN7FatFile4openEPS_P7fname_th+0x19a>
    ddba:	e7d3      	b.n	dd64 <_ZN7FatFile4openEPS_P7fname_th+0x18>
        goto fail;
      }
      // At EOF
      goto create;
    }
    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == DIR_NAME_FREE) {
    ddbc:	7803      	ldrb	r3, [r0, #0]
    ddbe:	2be5      	cmp	r3, #229	; 0xe5
    ddc0:	d001      	beq.n	ddc6 <_ZN7FatFile4openEPS_P7fname_th+0x7a>
    ddc2:	2b00      	cmp	r3, #0
    ddc4:	d10a      	bne.n	dddc <_ZN7FatFile4openEPS_P7fname_th+0x90>
      if (freeFound == 0) {
    ddc6:	2f00      	cmp	r7, #0
    ddc8:	d100      	bne.n	ddcc <_ZN7FatFile4openEPS_P7fname_th+0x80>
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    ddca:	9605      	str	r6, [sp, #20]
    }
    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == DIR_NAME_FREE) {
      if (freeFound == 0) {
        freeIndex = curIndex;
      }
      if (freeFound < freeNeed) {
    ddcc:	9909      	ldr	r1, [sp, #36]	; 0x24
    ddce:	428f      	cmp	r7, r1
    ddd0:	d201      	bcs.n	ddd6 <_ZN7FatFile4openEPS_P7fname_th+0x8a>
        freeFound++;
    ddd2:	1c7a      	adds	r2, r7, #1
    ddd4:	b2d7      	uxtb	r7, r2
      }
      if (dir->name[0] == DIR_NAME_FREE) {
    ddd6:	2b00      	cmp	r3, #0
    ddd8:	d107      	bne.n	ddea <_ZN7FatFile4openEPS_P7fname_th+0x9e>
    ddda:	e084      	b.n	dee6 <_ZN7FatFile4openEPS_P7fname_th+0x19a>
        goto create;
      }
    } else {
      if (freeFound < freeNeed) {
        freeFound = 0;
    dddc:	9909      	ldr	r1, [sp, #36]	; 0x24
    ddde:	2200      	movs	r2, #0
    dde0:	428f      	cmp	r7, r1
    dde2:	4152      	adcs	r2, r2
    dde4:	4252      	negs	r2, r2
    dde6:	4017      	ands	r7, r2
    dde8:	e003      	b.n	ddf2 <_ZN7FatFile4openEPS_P7fname_th+0xa6>
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == '.') {
    ddea:	2be5      	cmp	r3, #229	; 0xe5
    ddec:	d101      	bne.n	ddf2 <_ZN7FatFile4openEPS_P7fname_th+0xa6>
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
          // Not found.
          lfnOrd = 0;
    ddee:	2100      	movs	r1, #0
    ddf0:	e039      	b.n	de66 <_ZN7FatFile4openEPS_P7fname_th+0x11a>
      if (freeFound < freeNeed) {
        freeFound = 0;
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == '.') {
    ddf2:	2b2e      	cmp	r3, #46	; 0x2e
    ddf4:	d102      	bne.n	ddfc <_ZN7FatFile4openEPS_P7fname_th+0xb0>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    ddf6:	2200      	movs	r2, #0
    ddf8:	9204      	str	r2, [sp, #16]
    ddfa:	e7d1      	b.n	dda0 <_ZN7FatFile4openEPS_P7fname_th+0x54>
  uint8_t freeFound = 0;
  uint8_t ord = 0;
  uint8_t chksum = 0;
  uint16_t freeIndex = 0;
  uint16_t curIndex;
  dir_t* dir;
    ddfc:	7aea      	ldrb	r2, [r5, #11]
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == '.') {
      lfnOrd = 0;
    } else if (DIR_IS_LONG_NAME(dir)) {
    ddfe:	2a0f      	cmp	r2, #15
    de00:	d14a      	bne.n	de98 <_ZN7FatFile4openEPS_P7fname_th+0x14c>
      ldir_t *ldir = reinterpret_cast<ldir_t*>(dir);
      if (!lfnOrd) {
    de02:	9a04      	ldr	r2, [sp, #16]
    de04:	2a00      	cmp	r2, #0
    de06:	d108      	bne.n	de1a <_ZN7FatFile4openEPS_P7fname_th+0xce>
        if ((ldir->ord & LDIR_ORD_LAST_LONG_ENTRY) == 0) {
    de08:	0659      	lsls	r1, r3, #25
    de0a:	d5c9      	bpl.n	dda0 <_ZN7FatFile4openEPS_P7fname_th+0x54>
          continue;
        }
        lfnOrd = ord = ldir->ord & 0X1F;
    de0c:	221f      	movs	r2, #31
    de0e:	4013      	ands	r3, r2
    de10:	9304      	str	r3, [sp, #16]
        chksum = ldir->chksum;
    de12:	7b6a      	ldrb	r2, [r5, #13]
      ldir_t *ldir = reinterpret_cast<ldir_t*>(dir);
      if (!lfnOrd) {
        if ((ldir->ord & LDIR_ORD_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = ord = ldir->ord & 0X1F;
    de14:	9307      	str	r3, [sp, #28]
        chksum = ldir->chksum;
    de16:	920b      	str	r2, [sp, #44]	; 0x2c
    de18:	e00c      	b.n	de34 <_ZN7FatFile4openEPS_P7fname_th+0xe8>
      } else if (ldir->ord != --ord || chksum != ldir->chksum) {
    de1a:	9a07      	ldr	r2, [sp, #28]
    de1c:	3a01      	subs	r2, #1
    de1e:	b2d2      	uxtb	r2, r2
    de20:	9207      	str	r2, [sp, #28]
    de22:	4293      	cmp	r3, r2
    de24:	d002      	beq.n	de2c <_ZN7FatFile4openEPS_P7fname_th+0xe0>
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
          // Not found.
          lfnOrd = 0;
    de26:	2300      	movs	r3, #0
    de28:	9304      	str	r3, [sp, #16]
    de2a:	e7b9      	b.n	dda0 <_ZN7FatFile4openEPS_P7fname_th+0x54>
        if ((ldir->ord & LDIR_ORD_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = ord = ldir->ord & 0X1F;
        chksum = ldir->chksum;
      } else if (ldir->ord != --ord || chksum != ldir->chksum) {
    de2c:	7b6b      	ldrb	r3, [r5, #13]
    de2e:	990b      	ldr	r1, [sp, #44]	; 0x2c
    de30:	428b      	cmp	r3, r1
    de32:	d1dc      	bne.n	ddee <_ZN7FatFile4openEPS_P7fname_th+0xa2>
        lfnOrd = 0;
        continue;
      }
      size_t k = 13*(ord - 1);
    de34:	9b07      	ldr	r3, [sp, #28]
    de36:	220d      	movs	r2, #13
    de38:	3b01      	subs	r3, #1
    de3a:	435a      	muls	r2, r3
      if (k >= len) {
    de3c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        chksum = ldir->chksum;
      } else if (ldir->ord != --ord || chksum != ldir->chksum) {
        lfnOrd = 0;
        continue;
      }
      size_t k = 13*(ord - 1);
    de3e:	9208      	str	r2, [sp, #32]
    de40:	1e16      	subs	r6, r2, #0
      if (k >= len) {
    de42:	429e      	cmp	r6, r3
    de44:	d2d7      	bcs.n	ddf6 <_ZN7FatFile4openEPS_P7fname_th+0xaa>
    de46:	320d      	adds	r2, #13
    de48:	920f      	str	r2, [sp, #60]	; 0x3c
    de4a:	9a08      	ldr	r2, [sp, #32]
        // Not found.
        lfnOrd = 0;
        continue;
      }
      for (uint8_t i = 0; i < 13; i++) {
        uint16_t u = lfnGetChar(ldir, i);
    de4c:	1c28      	adds	r0, r5, #0
    de4e:	1ab1      	subs	r1, r6, r2
    de50:	b2c9      	uxtb	r1, r1
    de52:	f7ff fd1d 	bl	d890 <_ZL10lfnGetCharP18longDirectoryEntryh>
        if (k == len) {
    de56:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    de58:	429e      	cmp	r6, r3
    de5a:	d106      	bne.n	de6a <_ZN7FatFile4openEPS_P7fname_th+0x11e>
          if (u != 0) {
            // Not found.
            lfnOrd = 0;
    de5c:	4243      	negs	r3, r0
    de5e:	4158      	adcs	r0, r3
    de60:	9904      	ldr	r1, [sp, #16]
    de62:	4240      	negs	r0, r0
    de64:	4001      	ands	r1, r0
    de66:	9104      	str	r1, [sp, #16]
    de68:	e79a      	b.n	dda0 <_ZN7FatFile4openEPS_P7fname_th+0x54>
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    de6a:	28ff      	cmp	r0, #255	; 0xff
    de6c:	d8db      	bhi.n	de26 <_ZN7FatFile4openEPS_P7fname_th+0xda>
    de6e:	b2c0      	uxtb	r0, r0
}
#if USE_LONG_FILE_NAMES
//------------------------------------------------------------------------------
// Saves about 90 bytes of flash on 328 over tolower().
inline char lfnToLower(char c) {
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
    de70:	1c03      	adds	r3, r0, #0
    de72:	3b41      	subs	r3, #65	; 0x41
    de74:	2b19      	cmp	r3, #25
    de76:	d801      	bhi.n	de7c <_ZN7FatFile4openEPS_P7fname_th+0x130>
    de78:	3020      	adds	r0, #32
    de7a:	b2c0      	uxtb	r0, r0
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    de7c:	9b06      	ldr	r3, [sp, #24]
    de7e:	1c72      	adds	r2, r6, #1
    de80:	689b      	ldr	r3, [r3, #8]
    de82:	9303      	str	r3, [sp, #12]
    de84:	5d9b      	ldrb	r3, [r3, r6]
}
#if USE_LONG_FILE_NAMES
//------------------------------------------------------------------------------
// Saves about 90 bytes of flash on 328 over tolower().
inline char lfnToLower(char c) {
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
    de86:	1c19      	adds	r1, r3, #0
    de88:	3941      	subs	r1, #65	; 0x41
    de8a:	2919      	cmp	r1, #25
    de8c:	d801      	bhi.n	de92 <_ZN7FatFile4openEPS_P7fname_th+0x146>
    de8e:	3320      	adds	r3, #32
    de90:	b2db      	uxtb	r3, r3
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    de92:	4298      	cmp	r0, r3
    de94:	d1ab      	bne.n	ddee <_ZN7FatFile4openEPS_P7fname_th+0xa2>
    de96:	e10b      	b.n	e0b0 <_ZN7FatFile4openEPS_P7fname_th+0x364>
          // Not found.
          lfnOrd = 0;
          break;
        }
      }
    } else if (DIR_IS_FILE_OR_SUBDIR(dir)) {
    de98:	0711      	lsls	r1, r2, #28
    de9a:	d4ac      	bmi.n	ddf6 <_ZN7FatFile4openEPS_P7fname_th+0xaa>
      if (lfnOrd) {
    de9c:	9a04      	ldr	r2, [sp, #16]
    de9e:	2a00      	cmp	r2, #0
    dea0:	d00b      	beq.n	deba <_ZN7FatFile4openEPS_P7fname_th+0x16e>
        if (1 == ord && lfnChecksum(dir->name) == chksum) {
    dea2:	9b07      	ldr	r3, [sp, #28]
    dea4:	2b01      	cmp	r3, #1
    dea6:	d000      	beq.n	deaa <_ZN7FatFile4openEPS_P7fname_th+0x15e>
    dea8:	e75c      	b.n	dd64 <_ZN7FatFile4openEPS_P7fname_th+0x18>
    deaa:	1c28      	adds	r0, r5, #0
    deac:	f7ff fd0b 	bl	d8c6 <_ZN7FatFile11lfnChecksumEPh>
    deb0:	990b      	ldr	r1, [sp, #44]	; 0x2c
    deb2:	4288      	cmp	r0, r1
    deb4:	d000      	beq.n	deb8 <_ZN7FatFile4openEPS_P7fname_th+0x16c>
    deb6:	e755      	b.n	dd64 <_ZN7FatFile4openEPS_P7fname_th+0x18>
    deb8:	e00f      	b.n	deda <_ZN7FatFile4openEPS_P7fname_th+0x18e>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    deba:	9906      	ldr	r1, [sp, #24]
    debc:	1c28      	adds	r0, r5, #0
    debe:	310d      	adds	r1, #13
    dec0:	220b      	movs	r2, #11
    dec2:	f003 fb6b 	bl	1159c <memcmp>
    dec6:	2800      	cmp	r0, #0
    dec8:	d000      	beq.n	decc <_ZN7FatFile4openEPS_P7fname_th+0x180>
    deca:	e769      	b.n	dda0 <_ZN7FatFile4openEPS_P7fname_th+0x54>
        if (!(fname->flags & FNAME_FLAG_LOST_CHARS)) {
    decc:	9b06      	ldr	r3, [sp, #24]
    dece:	781a      	ldrb	r2, [r3, #0]
    ded0:	2301      	movs	r3, #1
    ded2:	421a      	tst	r2, r3
    ded4:	d001      	beq.n	deda <_ZN7FatFile4openEPS_P7fname_th+0x18e>
          goto found;
        }
        fnameFound = true;
    ded6:	930d      	str	r3, [sp, #52]	; 0x34
    ded8:	e762      	b.n	dda0 <_ZN7FatFile4openEPS_P7fname_th+0x54>
    }
  }

found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    deda:	990c      	ldr	r1, [sp, #48]	; 0x30
    dedc:	b24b      	sxtb	r3, r1
    dede:	2b00      	cmp	r3, #0
    dee0:	db00      	blt.n	dee4 <_ZN7FatFile4openEPS_P7fname_th+0x198>
    dee2:	e0d9      	b.n	e098 <_ZN7FatFile4openEPS_P7fname_th+0x34c>
    dee4:	e73e      	b.n	dd64 <_ZN7FatFile4openEPS_P7fname_th+0x18>
  }
  goto open;

create:
  // don't create unless O_CREAT and O_WRITE
  if (!(oflag & O_CREAT) || !(oflag & O_WRITE)) {
    dee6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    dee8:	2342      	movs	r3, #66	; 0x42
    deea:	4013      	ands	r3, r2
    deec:	2b42      	cmp	r3, #66	; 0x42
    deee:	d000      	beq.n	def2 <_ZN7FatFile4openEPS_P7fname_th+0x1a6>
    def0:	e738      	b.n	dd64 <_ZN7FatFile4openEPS_P7fname_th+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // If at EOF start in next cluster.
  if (freeFound == 0) {
    def2:	2f00      	cmp	r7, #0
    def4:	d009      	beq.n	df0a <_ZN7FatFile4openEPS_P7fname_th+0x1be>
    def6:	9e05      	ldr	r6, [sp, #20]
    def8:	e007      	b.n	df0a <_ZN7FatFile4openEPS_P7fname_th+0x1be>
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    dir = dirFile->readDirCache();
    defa:	1c20      	adds	r0, r4, #0
    defc:	2100      	movs	r1, #0
    defe:	f7ff f92a 	bl	d156 <_ZN7FatFile12readDirCacheEb>
    if (!dir) {
    df02:	2800      	cmp	r0, #0
    df04:	d005      	beq.n	df12 <_ZN7FatFile4openEPS_P7fname_th+0x1c6>
        goto fail;
      }
      // EOF if no error.
      break;
    }
    freeFound++;
    df06:	1c7b      	adds	r3, r7, #1
    df08:	b2df      	uxtb	r7, r3
  // If at EOF start in next cluster.
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    df0a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    df0c:	429f      	cmp	r7, r3
    df0e:	d3f4      	bcc.n	defa <_ZN7FatFile4openEPS_P7fname_th+0x1ae>
    df10:	e010      	b.n	df34 <_ZN7FatFile4openEPS_P7fname_th+0x1e8>
    dir = dirFile->readDirCache();
    if (!dir) {
      if (dirFile->getError()) {
    df12:	7863      	ldrb	r3, [r4, #1]
    df14:	2b00      	cmp	r3, #0
    df16:	d00d      	beq.n	df34 <_ZN7FatFile4openEPS_P7fname_th+0x1e8>
    df18:	e724      	b.n	dd64 <_ZN7FatFile4openEPS_P7fname_th+0x18>
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
    df1a:	1c20      	adds	r0, r4, #0
    df1c:	f7fe ffbe 	bl	ce9c <_ZN7FatFile13addDirClusterEv>
    df20:	2800      	cmp	r0, #0
    df22:	d100      	bne.n	df26 <_ZN7FatFile4openEPS_P7fname_th+0x1da>
    df24:	e71e      	b.n	dd64 <_ZN7FatFile4openEPS_P7fname_th+0x18>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Done if more than one block per cluster.  Max freeNeed is 21.
    if (dirFile->m_vol->blocksPerCluster() > 1) {
    df26:	68a1      	ldr	r1, [r4, #8]
    df28:	790b      	ldrb	r3, [r1, #4]
    df2a:	2b01      	cmp	r3, #1
    df2c:	d805      	bhi.n	df3a <_ZN7FatFile4openEPS_P7fname_th+0x1ee>
      break;
    }
    freeFound += 16;
    df2e:	1c3b      	adds	r3, r7, #0
    df30:	3310      	adds	r3, #16
    df32:	b2df      	uxtb	r7, r3
      // EOF if no error.
      break;
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
    df34:	9b09      	ldr	r3, [sp, #36]	; 0x24
    df36:	429f      	cmp	r7, r3
    df38:	d3ef      	bcc.n	df1a <_ZN7FatFile4openEPS_P7fname_th+0x1ce>
    if (dirFile->m_vol->blocksPerCluster() > 1) {
      break;
    }
    freeFound += 16;
  }
  if (fnameFound) {
    df3a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    df3c:	2a00      	cmp	r2, #0
    df3e:	d006      	beq.n	df4e <_ZN7FatFile4openEPS_P7fname_th+0x202>
    if (!dirFile->lfnUniqueSfn(fname)) {
    df40:	1c20      	adds	r0, r4, #0
    df42:	9906      	ldr	r1, [sp, #24]
    df44:	f7ff feaf 	bl	dca6 <_ZN7FatFile12lfnUniqueSfnEP7fname_t>
    df48:	2800      	cmp	r0, #0
    df4a:	d100      	bne.n	df4e <_ZN7FatFile4openEPS_P7fname_th+0x202>
    df4c:	e70a      	b.n	dd64 <_ZN7FatFile4openEPS_P7fname_th+0x18>
      goto fail;
    }
  }
  if (!dirFile->seekSet(32UL*freeIndex)) {
    df4e:	0171      	lsls	r1, r6, #5
    df50:	1c20      	adds	r0, r4, #0
    df52:	f7ff f91d 	bl	d190 <_ZN7FatFile7seekSetEm>
    df56:	2800      	cmp	r0, #0
    df58:	d100      	bne.n	df5c <_ZN7FatFile4openEPS_P7fname_th+0x210>
    df5a:	e703      	b.n	dd64 <_ZN7FatFile4openEPS_P7fname_th+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
    df5c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    df5e:	3b01      	subs	r3, #1
    df60:	b2db      	uxtb	r3, r3
    df62:	9304      	str	r3, [sp, #16]
    df64:	e039      	b.n	dfda <_ZN7FatFile4openEPS_P7fname_th+0x28e>
  for (uint8_t ord = lfnOrd ; ord ; ord--) {
    ldir = reinterpret_cast<ldir_t*>(dirFile->readDirCache());
    df66:	1c20      	adds	r0, r4, #0
    df68:	2100      	movs	r1, #0
    df6a:	f7ff f8f4 	bl	d156 <_ZN7FatFile12readDirCacheEb>
    df6e:	1e05      	subs	r5, r0, #0
    if (!ldir) {
    df70:	d100      	bne.n	df74 <_ZN7FatFile4openEPS_P7fname_th+0x228>
    df72:	e6f7      	b.n	dd64 <_ZN7FatFile4openEPS_P7fname_th+0x18>
    df74:	68a3      	ldr	r3, [r4, #8]
    df76:	2101      	movs	r1, #1
    df78:	3305      	adds	r3, #5
    df7a:	7fda      	ldrb	r2, [r3, #31]
    df7c:	9f05      	ldr	r7, [sp, #20]
    df7e:	430a      	orrs	r2, r1
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    ldir->ord = ord == lfnOrd ? LDIR_ORD_LAST_LONG_ENTRY | ord : ord;
    df80:	9904      	ldr	r1, [sp, #16]
    df82:	77da      	strb	r2, [r3, #31]
    df84:	428f      	cmp	r7, r1
    df86:	d102      	bne.n	df8e <_ZN7FatFile4openEPS_P7fname_th+0x242>
    df88:	9a05      	ldr	r2, [sp, #20]
    df8a:	2740      	movs	r7, #64	; 0x40
    df8c:	4317      	orrs	r7, r2
    ldir->attr = DIR_ATT_LONG_NAME;
    ldir->type = 0;
    ldir->chksum = lfnChecksum(fname->sfn);
    df8e:	9806      	ldr	r0, [sp, #24]
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    ldir->ord = ord == lfnOrd ? LDIR_ORD_LAST_LONG_ENTRY | ord : ord;
    ldir->attr = DIR_ATT_LONG_NAME;
    df90:	230f      	movs	r3, #15
    ldir->type = 0;
    df92:	2600      	movs	r6, #0
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    ldir->ord = ord == lfnOrd ? LDIR_ORD_LAST_LONG_ENTRY | ord : ord;
    df94:	702f      	strb	r7, [r5, #0]
    ldir->attr = DIR_ATT_LONG_NAME;
    df96:	72eb      	strb	r3, [r5, #11]
    ldir->type = 0;
    df98:	732e      	strb	r6, [r5, #12]
    ldir->chksum = lfnChecksum(fname->sfn);
    df9a:	300d      	adds	r0, #13
    df9c:	f7ff fc93 	bl	d8c6 <_ZN7FatFile11lfnChecksumEPh>
    ldir->mustBeZero = 0;
    lfnPutName(ldir, fname->lfn, len);
    dfa0:	9b06      	ldr	r3, [sp, #24]
    }
    dirFile->m_vol->cacheDirty();
    ldir->ord = ord == lfnOrd ? LDIR_ORD_LAST_LONG_ENTRY | ord : ord;
    ldir->attr = DIR_ATT_LONG_NAME;
    ldir->type = 0;
    ldir->chksum = lfnChecksum(fname->sfn);
    dfa2:	7368      	strb	r0, [r5, #13]
    ldir->mustBeZero = 0;
    lfnPutName(ldir, fname->lfn, len);
    dfa4:	6899      	ldr	r1, [r3, #8]
    ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM] = c;
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(ldir_t *ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->ord & 0X1F) - 1);
    dfa6:	231f      	movs	r3, #31
    dfa8:	401f      	ands	r7, r3
    dfaa:	3f01      	subs	r7, #1
    dfac:	230d      	movs	r3, #13
    dfae:	435f      	muls	r7, r3
    dirFile->m_vol->cacheDirty();
    ldir->ord = ord == lfnOrd ? LDIR_ORD_LAST_LONG_ENTRY | ord : ord;
    ldir->attr = DIR_ATT_LONG_NAME;
    ldir->type = 0;
    ldir->chksum = lfnChecksum(fname->sfn);
    ldir->mustBeZero = 0;
    dfb0:	76ae      	strb	r6, [r5, #26]
    dfb2:	76ee      	strb	r6, [r5, #27]
}
//------------------------------------------------------------------------------
static void lfnPutName(ldir_t *ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->ord & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    dfb4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    dfb6:	4297      	cmp	r7, r2
    dfb8:	d214      	bcs.n	dfe4 <_ZN7FatFile4openEPS_P7fname_th+0x298>
    dfba:	5dcb      	ldrb	r3, [r1, r7]
    dfbc:	b2f2      	uxtb	r2, r6
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(ldir_t *ldir, uint8_t i, uint16_t c) {
  if (i < LDIR_NAME1_DIM) {
    dfbe:	2a04      	cmp	r2, #4
    dfc0:	d817      	bhi.n	dff2 <_ZN7FatFile4openEPS_P7fname_th+0x2a6>
    ldir->name1[i] = c;
    dfc2:	0072      	lsls	r2, r6, #1
    dfc4:	18aa      	adds	r2, r5, r2
    dfc6:	7053      	strb	r3, [r2, #1]
    dfc8:	0a1b      	lsrs	r3, r3, #8
    dfca:	7093      	strb	r3, [r2, #2]
    dfcc:	3601      	adds	r6, #1
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(ldir_t *ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->ord & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
    dfce:	3701      	adds	r7, #1
    dfd0:	2e0d      	cmp	r6, #13
    dfd2:	d1ef      	bne.n	dfb4 <_ZN7FatFile4openEPS_P7fname_th+0x268>
  if (!dirFile->seekSet(32UL*freeIndex)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
  for (uint8_t ord = lfnOrd ; ord ; ord--) {
    dfd4:	9b05      	ldr	r3, [sp, #20]
    dfd6:	3b01      	subs	r3, #1
    dfd8:	b2db      	uxtb	r3, r3
    dfda:	9305      	str	r3, [sp, #20]
    dfdc:	9b05      	ldr	r3, [sp, #20]
    dfde:	2b00      	cmp	r3, #0
    dfe0:	d1c1      	bne.n	df66 <_ZN7FatFile4openEPS_P7fname_th+0x21a>
    dfe2:	e016      	b.n	e012 <_ZN7FatFile4openEPS_P7fname_th+0x2c6>
}
//------------------------------------------------------------------------------
static void lfnPutName(ldir_t *ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->ord & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    dfe4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    dfe6:	1abb      	subs	r3, r7, r2
    dfe8:	1e5a      	subs	r2, r3, #1
    dfea:	4193      	sbcs	r3, r2
    dfec:	425b      	negs	r3, r3
    dfee:	b29b      	uxth	r3, r3
    dff0:	e7e4      	b.n	dfbc <_ZN7FatFile4openEPS_P7fname_th+0x270>
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(ldir_t *ldir, uint8_t i, uint16_t c) {
  if (i < LDIR_NAME1_DIM) {
    ldir->name1[i] = c;
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM)) {
    dff2:	2a0a      	cmp	r2, #10
    dff4:	d806      	bhi.n	e004 <_ZN7FatFile4openEPS_P7fname_th+0x2b8>
    ldir->name2[i - LDIR_NAME1_DIM] = c;
    dff6:	1e72      	subs	r2, r6, #1
    dff8:	0052      	lsls	r2, r2, #1
    dffa:	18aa      	adds	r2, r5, r2
    dffc:	7193      	strb	r3, [r2, #6]
    dffe:	0a1b      	lsrs	r3, r3, #8
    e000:	71d3      	strb	r3, [r2, #7]
    e002:	e7e3      	b.n	dfcc <_ZN7FatFile4openEPS_P7fname_th+0x280>
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM + LDIR_NAME2_DIM)) {
    ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM] = c;
    e004:	1c72      	adds	r2, r6, #1
    e006:	0052      	lsls	r2, r2, #1
    e008:	18aa      	adds	r2, r5, r2
    e00a:	7113      	strb	r3, [r2, #4]
    e00c:	0a1b      	lsrs	r3, r3, #8
    e00e:	7153      	strb	r3, [r2, #5]
    e010:	e7dc      	b.n	dfcc <_ZN7FatFile4openEPS_P7fname_th+0x280>
    ldir->type = 0;
    ldir->chksum = lfnChecksum(fname->sfn);
    ldir->mustBeZero = 0;
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
    e012:	6961      	ldr	r1, [r4, #20]
  dir = dirFile->readDirCache();
    e014:	1c20      	adds	r0, r4, #0
    ldir->type = 0;
    ldir->chksum = lfnChecksum(fname->sfn);
    ldir->mustBeZero = 0;
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
    e016:	094e      	lsrs	r6, r1, #5
  dir = dirFile->readDirCache();
    e018:	1c19      	adds	r1, r3, #0
    e01a:	f7ff f89c 	bl	d156 <_ZN7FatFile12readDirCacheEb>
    ldir->type = 0;
    ldir->chksum = lfnChecksum(fname->sfn);
    ldir->mustBeZero = 0;
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
    e01e:	b2b6      	uxth	r6, r6
  dir = dirFile->readDirCache();
    e020:	1e05      	subs	r5, r0, #0
  if (!dir) {
    e022:	d100      	bne.n	e026 <_ZN7FatFile4openEPS_P7fname_th+0x2da>
    e024:	e69e      	b.n	dd64 <_ZN7FatFile4openEPS_P7fname_th+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // initialize as empty file
  memset(dir, 0, sizeof(dir_t));
    e026:	9905      	ldr	r1, [sp, #20]
    e028:	2220      	movs	r2, #32
    e02a:	f003 facf 	bl	115cc <memset>
  memcpy(dir->name, fname->sfn, 11);
    e02e:	9906      	ldr	r1, [sp, #24]
    e030:	220b      	movs	r2, #11
    e032:	310d      	adds	r1, #13
    e034:	1c28      	adds	r0, r5, #0
    e036:	f003 fac0 	bl	115ba <memcpy>

  // Set base-name and extension lower case bits.
  dir->reservedNT =  (DIR_NT_LC_BASE | DIR_NT_LC_EXT) & fname->flags;
    e03a:	9b06      	ldr	r3, [sp, #24]
    e03c:	781a      	ldrb	r2, [r3, #0]
    e03e:	2318      	movs	r3, #24
    e040:	4013      	ands	r3, r2
    e042:	732b      	strb	r3, [r5, #12]

  // set timestamps
  if (m_dateTime) {
    e044:	4b1e      	ldr	r3, [pc, #120]	; (e0c0 <_ZN7FatFile4openEPS_P7fname_th+0x374>)
    e046:	681b      	ldr	r3, [r3, #0]
    e048:	2b00      	cmp	r3, #0
    e04a:	d005      	beq.n	e058 <_ZN7FatFile4openEPS_P7fname_th+0x30c>
    // call user date/time function
    m_dateTime(&dir->creationDate, &dir->creationTime);
    e04c:	1c28      	adds	r0, r5, #0
    e04e:	1c29      	adds	r1, r5, #0
    e050:	3010      	adds	r0, #16
    e052:	310e      	adds	r1, #14
    e054:	4798      	blx	r3
    e056:	e007      	b.n	e068 <_ZN7FatFile4openEPS_P7fname_th+0x31c>
  } else {
    // use default date/time
    dir->creationDate = FAT_DEFAULT_DATE;
    e058:	2321      	movs	r3, #33	; 0x21
    e05a:	742b      	strb	r3, [r5, #16]
    dir->creationTime = FAT_DEFAULT_TIME;
    e05c:	9905      	ldr	r1, [sp, #20]
  if (m_dateTime) {
    // call user date/time function
    m_dateTime(&dir->creationDate, &dir->creationTime);
  } else {
    // use default date/time
    dir->creationDate = FAT_DEFAULT_DATE;
    e05e:	2328      	movs	r3, #40	; 0x28
    e060:	746b      	strb	r3, [r5, #17]
    dir->creationTime = FAT_DEFAULT_TIME;
    e062:	2308      	movs	r3, #8
    e064:	73a9      	strb	r1, [r5, #14]
    e066:	73eb      	strb	r3, [r5, #15]
  }
  dir->lastAccessDate = dir->creationDate;
    e068:	7c6b      	ldrb	r3, [r5, #17]
    e06a:	7c2a      	ldrb	r2, [r5, #16]
    e06c:	021b      	lsls	r3, r3, #8
    e06e:	4313      	orrs	r3, r2
    e070:	22ff      	movs	r2, #255	; 0xff
    e072:	401a      	ands	r2, r3
    e074:	0a1b      	lsrs	r3, r3, #8
    e076:	74eb      	strb	r3, [r5, #19]
  dir->lastWriteDate = dir->creationDate;
    e078:	766b      	strb	r3, [r5, #25]
  dir->lastWriteTime = dir->creationTime;
    e07a:	7beb      	ldrb	r3, [r5, #15]
  } else {
    // use default date/time
    dir->creationDate = FAT_DEFAULT_DATE;
    dir->creationTime = FAT_DEFAULT_TIME;
  }
  dir->lastAccessDate = dir->creationDate;
    e07c:	74aa      	strb	r2, [r5, #18]
  dir->lastWriteDate = dir->creationDate;
    e07e:	762a      	strb	r2, [r5, #24]
  dir->lastWriteTime = dir->creationTime;
    e080:	7baa      	ldrb	r2, [r5, #14]
    e082:	021b      	lsls	r3, r3, #8
    e084:	4313      	orrs	r3, r2
    e086:	75ab      	strb	r3, [r5, #22]
    e088:	0a1b      	lsrs	r3, r3, #8
    e08a:	75eb      	strb	r3, [r5, #23]
    e08c:	68a3      	ldr	r3, [r4, #8]
    e08e:	2101      	movs	r1, #1
    e090:	3305      	adds	r3, #5
    e092:	7fda      	ldrb	r2, [r3, #31]
    e094:	430a      	orrs	r2, r1
    e096:	77da      	strb	r2, [r3, #31]
  // Force write of entry to device.
  dirFile->m_vol->cacheDirty();

open:
  // open entry in cache.
  if (!openCachedEntry(dirFile, curIndex, oflag, lfnOrd)) {
    e098:	9a04      	ldr	r2, [sp, #16]
    e09a:	980e      	ldr	r0, [sp, #56]	; 0x38
    e09c:	9200      	str	r2, [sp, #0]
    e09e:	1c21      	adds	r1, r4, #0
    e0a0:	1c32      	adds	r2, r6, #0
    e0a2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    e0a4:	f7ff f8ba 	bl	d21c <_ZN7FatFile15openCachedEntryEPS_thh>
    e0a8:	e008      	b.n	e0bc <_ZN7FatFile4openEPS_P7fname_th+0x370>
  if (!dirFile->isDir() || isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
    e0aa:	2301      	movs	r3, #1
    e0ac:	9309      	str	r3, [sp, #36]	; 0x24
    e0ae:	e66c      	b.n	dd8a <_ZN7FatFile4openEPS_P7fname_th+0x3e>
      if (k >= len) {
        // Not found.
        lfnOrd = 0;
        continue;
      }
      for (uint8_t i = 0; i < 13; i++) {
    e0b0:	990f      	ldr	r1, [sp, #60]	; 0x3c
    e0b2:	428a      	cmp	r2, r1
    e0b4:	d100      	bne.n	e0b8 <_ZN7FatFile4openEPS_P7fname_th+0x36c>
    e0b6:	e673      	b.n	dda0 <_ZN7FatFile4openEPS_P7fname_th+0x54>
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    e0b8:	1c16      	adds	r6, r2, #0
    e0ba:	e6c6      	b.n	de4a <_ZN7FatFile4openEPS_P7fname_th+0xfe>
  }
  return true;

fail:
  return false;
}
    e0bc:	b011      	add	sp, #68	; 0x44
    e0be:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e0c0:	20000cf0 	.word	0x20000cf0

0000e0c4 <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
    e0c4:	b538      	push	{r3, r4, r5, lr}
    e0c6:	1c05      	adds	r5, r0, #0
    e0c8:	1c0c      	adds	r4, r1, #0
      if (str == NULL) return 0;
    e0ca:	1e08      	subs	r0, r1, #0
    e0cc:	d007      	beq.n	e0de <_ZN5Print5writeEPKc+0x1a>
      return write((const uint8_t *)str, strlen(str));
    e0ce:	f003 fba5 	bl	1181c <strlen>
    e0d2:	682b      	ldr	r3, [r5, #0]
    e0d4:	1c02      	adds	r2, r0, #0
    e0d6:	685b      	ldr	r3, [r3, #4]
    e0d8:	1c28      	adds	r0, r5, #0
    e0da:	1c21      	adds	r1, r4, #0
    e0dc:	4798      	blx	r3
    }
    e0de:	bd38      	pop	{r3, r4, r5, pc}

0000e0e0 <_ZN7FatFile6getSFNEPc>:
 * <http://www.gnu.org/licenses/>.
 */
#include "FatFile.h"
#include "FatFileSystem.h"
//------------------------------------------------------------------------------
bool FatFile::getSFN(char* name) {
    e0e0:	b510      	push	{r4, lr}
    e0e2:	7803      	ldrb	r3, [r0, #0]
    e0e4:	1c0c      	adds	r4, r1, #0
  dir_t* dir;
  if (!isOpen()) {
    e0e6:	2b00      	cmp	r3, #0
    e0e8:	d101      	bne.n	e0ee <_ZN7FatFile6getSFNEPc+0xe>
  // format name
  dirName(dir, name);
  return true;

fail:
  return false;
    e0ea:	2000      	movs	r0, #0
    e0ec:	e00f      	b.n	e10e <_ZN7FatFile6getSFNEPc+0x2e>
  dir_t* dir;
  if (!isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isRoot()) {
    e0ee:	2160      	movs	r1, #96	; 0x60
    e0f0:	4019      	ands	r1, r3
    e0f2:	d004      	beq.n	e0fe <_ZN7FatFile6getSFNEPc+0x1e>
    name[0] = '/';
    e0f4:	232f      	movs	r3, #47	; 0x2f
    e0f6:	7023      	strb	r3, [r4, #0]
    name[1] = '\0';
    e0f8:	2300      	movs	r3, #0
    e0fa:	7063      	strb	r3, [r4, #1]
    e0fc:	e006      	b.n	e10c <_ZN7FatFile6getSFNEPc+0x2c>
    return true;
  }
  // cache entry
  dir = cacheDirEntry(FatCache::CACHE_FOR_READ);
    e0fe:	f7fe ff07 	bl	cf10 <_ZN7FatFile13cacheDirEntryEh>
  if (!dir) {
    e102:	2800      	cmp	r0, #0
    e104:	d0f1      	beq.n	e0ea <_ZN7FatFile6getSFNEPc+0xa>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // format name
  dirName(dir, name);
    e106:	1c21      	adds	r1, r4, #0
    e108:	f7fe ff12 	bl	cf30 <_ZN7FatFile7dirNameEPK14directoryEntryPc>
  return true;
    e10c:	2001      	movs	r0, #1

fail:
  return false;
}
    e10e:	bd10      	pop	{r4, pc}

0000e110 <_ZN8FatCache4syncEv>:

fail:
  return 0;
}
//------------------------------------------------------------------------------
bool FatCache::sync() {
    e110:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (m_status & CACHE_STATUS_DIRTY) {
    e112:	7803      	ldrb	r3, [r0, #0]
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;
    e114:	2501      	movs	r5, #1

fail:
  return 0;
}
//------------------------------------------------------------------------------
bool FatCache::sync() {
    e116:	1c04      	adds	r4, r0, #0
  if (m_status & CACHE_STATUS_DIRTY) {
    e118:	422b      	tst	r3, r5
    e11a:	d01e      	beq.n	e15a <_ZN8FatCache4syncEv+0x4a>
    if (!m_vol->writeBlock(m_lbn, m_block.data)) {
    e11c:	6840      	ldr	r0, [r0, #4]
    e11e:	1c26      	adds	r6, r4, #0
    e120:	6803      	ldr	r3, [r0, #0]
    e122:	360c      	adds	r6, #12
    e124:	685b      	ldr	r3, [r3, #4]
    e126:	68a1      	ldr	r1, [r4, #8]
    e128:	1c32      	adds	r2, r6, #0
    e12a:	4798      	blx	r3
    e12c:	1e05      	subs	r5, r0, #0
    e12e:	d101      	bne.n	e134 <_ZN8FatCache4syncEv+0x24>
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;

fail:
  return false;
    e130:	2500      	movs	r5, #0
    e132:	e012      	b.n	e15a <_ZN8FatCache4syncEv+0x4a>
    if (!m_vol->writeBlock(m_lbn, m_block.data)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
    e134:	7823      	ldrb	r3, [r4, #0]
    e136:	079a      	lsls	r2, r3, #30
    e138:	d404      	bmi.n	e144 <_ZN8FatCache4syncEv+0x34>
      if (!m_vol->writeBlock(lbn, m_block.data)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
    e13a:	7823      	ldrb	r3, [r4, #0]
    e13c:	2201      	movs	r2, #1
    e13e:	4393      	bics	r3, r2
    e140:	7023      	strb	r3, [r4, #0]
    e142:	e00a      	b.n	e15a <_ZN8FatCache4syncEv+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
      uint32_t lbn = m_lbn + m_vol->blocksPerFat();
    e144:	6860      	ldr	r0, [r4, #4]
    e146:	68a2      	ldr	r2, [r4, #8]
      if (!m_vol->writeBlock(lbn, m_block.data)) {
    e148:	6803      	ldr	r3, [r0, #0]
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
      uint32_t lbn = m_lbn + m_vol->blocksPerFat();
    e14a:	6907      	ldr	r7, [r0, #16]
      if (!m_vol->writeBlock(lbn, m_block.data)) {
    e14c:	685b      	ldr	r3, [r3, #4]
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
      uint32_t lbn = m_lbn + m_vol->blocksPerFat();
    e14e:	18b9      	adds	r1, r7, r2
      if (!m_vol->writeBlock(lbn, m_block.data)) {
    e150:	1c32      	adds	r2, r6, #0
    e152:	4798      	blx	r3
    e154:	2800      	cmp	r0, #0
    e156:	d1f0      	bne.n	e13a <_ZN8FatCache4syncEv+0x2a>
    e158:	e7ea      	b.n	e130 <_ZN8FatCache4syncEv+0x20>
  }
  return true;

fail:
  return false;
}
    e15a:	1c28      	adds	r0, r5, #0
    e15c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000e15e <_ZN8FatCache4readEmh>:
 */
#include <string.h>
#include "FatVolume.h"
//------------------------------------------------------------------------------
cache_t* FatCache::read(uint32_t lbn, uint8_t option) {
  if (m_lbn != lbn) {
    e15e:	6883      	ldr	r3, [r0, #8]
 * <http://www.gnu.org/licenses/>.
 */
#include <string.h>
#include "FatVolume.h"
//------------------------------------------------------------------------------
cache_t* FatCache::read(uint32_t lbn, uint8_t option) {
    e160:	b570      	push	{r4, r5, r6, lr}
    e162:	1c04      	adds	r4, r0, #0
    e164:	1c0d      	adds	r5, r1, #0
    e166:	1c16      	adds	r6, r2, #0
  if (m_lbn != lbn) {
    e168:	428b      	cmp	r3, r1
    e16a:	d015      	beq.n	e198 <_ZN8FatCache4readEmh+0x3a>
    if (!sync()) {
    e16c:	f7ff ffd0 	bl	e110 <_ZN8FatCache4syncEv>
    e170:	2800      	cmp	r0, #0
    e172:	d101      	bne.n	e178 <_ZN8FatCache4readEmh+0x1a>
  }
  m_status |= option & CACHE_STATUS_MASK;
  return &m_block;

fail:
  return 0;
    e174:	2000      	movs	r0, #0
    e176:	e016      	b.n	e1a6 <_ZN8FatCache4readEmh+0x48>
  if (m_lbn != lbn) {
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
    e178:	0773      	lsls	r3, r6, #29
    e17a:	d503      	bpl.n	e184 <_ZN8FatCache4readEmh+0x26>
      if (!m_vol->readBlock(lbn, m_block.data)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status = 0;
    e17c:	2300      	movs	r3, #0
    e17e:	7023      	strb	r3, [r4, #0]
    m_lbn = lbn;
    e180:	60a5      	str	r5, [r4, #8]
    e182:	e009      	b.n	e198 <_ZN8FatCache4readEmh+0x3a>
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
      if (!m_vol->readBlock(lbn, m_block.data)) {
    e184:	6860      	ldr	r0, [r4, #4]
    e186:	1c22      	adds	r2, r4, #0
    e188:	6803      	ldr	r3, [r0, #0]
    e18a:	1c29      	adds	r1, r5, #0
    e18c:	681b      	ldr	r3, [r3, #0]
    e18e:	320c      	adds	r2, #12
    e190:	4798      	blx	r3
    e192:	2800      	cmp	r0, #0
    e194:	d1f2      	bne.n	e17c <_ZN8FatCache4readEmh+0x1e>
    e196:	e7ed      	b.n	e174 <_ZN8FatCache4readEmh+0x16>
      }
    }
    m_status = 0;
    m_lbn = lbn;
  }
  m_status |= option & CACHE_STATUS_MASK;
    e198:	2303      	movs	r3, #3
    e19a:	401e      	ands	r6, r3
    e19c:	7823      	ldrb	r3, [r4, #0]
  return &m_block;
    e19e:	1c20      	adds	r0, r4, #0
      }
    }
    m_status = 0;
    m_lbn = lbn;
  }
  m_status |= option & CACHE_STATUS_MASK;
    e1a0:	431e      	orrs	r6, r3
    e1a2:	7026      	strb	r6, [r4, #0]
  return &m_block;
    e1a4:	300c      	adds	r0, #12

fail:
  return 0;
}
    e1a6:	bd70      	pop	{r4, r5, r6, pc}

0000e1a8 <_ZNK9FatVolume17clusterStartBlockEm>:
fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t FatVolume::clusterStartBlock(uint32_t cluster) const {
  return m_dataStartBlock + ((cluster - 2) << m_clusterSizeShift);
    e1a8:	7983      	ldrb	r3, [r0, #6]
    e1aa:	3902      	subs	r1, #2
    e1ac:	4099      	lsls	r1, r3
    e1ae:	6943      	ldr	r3, [r0, #20]
    e1b0:	18c8      	adds	r0, r1, r3
}
    e1b2:	4770      	bx	lr

0000e1b4 <_ZN9FatVolume6fatGetEmPm>:
//------------------------------------------------------------------------------
// Fetch a FAT entry - return -1 error, 0 EOC, else 1.
int8_t FatVolume::fatGet(uint32_t cluster, uint32_t* value) {
    e1b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  DBG_HALT_IF(cluster < 2 || cluster > m_lastCluster);

  if (m_fatType == 32) {
    e1b6:	79c3      	ldrb	r3, [r0, #7]
uint32_t FatVolume::clusterStartBlock(uint32_t cluster) const {
  return m_dataStartBlock + ((cluster - 2) << m_clusterSizeShift);
}
//------------------------------------------------------------------------------
// Fetch a FAT entry - return -1 error, 0 EOC, else 1.
int8_t FatVolume::fatGet(uint32_t cluster, uint32_t* value) {
    e1b8:	1c04      	adds	r4, r0, #0
    e1ba:	1c0d      	adds	r5, r1, #0
    e1bc:	1c16      	adds	r6, r2, #0
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  DBG_HALT_IF(cluster < 2 || cluster > m_lastCluster);

  if (m_fatType == 32) {
    e1be:	2b20      	cmp	r3, #32
    e1c0:	d113      	bne.n	e1ea <_ZN9FatVolume6fatGetEmPm+0x36>
    lba = m_fatStartBlock + (cluster >> 7);
    e1c2:	6983      	ldr	r3, [r0, #24]
    e1c4:	09c9      	lsrs	r1, r1, #7
    e1c6:	18c9      	adds	r1, r1, r3
  FatCache m_cache;
#if USE_SEPARATE_FAT_CACHE
  FatCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t blockNumber, uint8_t options) {
    return m_fatCache.read(blockNumber,
                           options | FatCache::CACHE_STATUS_MIRROR_FAT);
    e1c8:	238c      	movs	r3, #140	; 0x8c
    e1ca:	009b      	lsls	r3, r3, #2
    e1cc:	18c0      	adds	r0, r0, r3
    e1ce:	2202      	movs	r2, #2
    e1d0:	f7ff ffc5 	bl	e15e <_ZN8FatCache4readEmh>
    pc = cacheFetchFat(lba, FatCache::CACHE_FOR_READ);
    if (!pc) {
    e1d4:	2800      	cmp	r0, #0
    e1d6:	d101      	bne.n	e1dc <_ZN9FatVolume6fatGetEmPm+0x28>
  }
  *value = next;
  return 1;

fail:
  return -1;
    e1d8:	20ff      	movs	r0, #255	; 0xff
    e1da:	e01e      	b.n	e21a <_ZN9FatVolume6fatGetEmPm+0x66>
    pc = cacheFetchFat(lba, FatCache::CACHE_FOR_READ);
    if (!pc) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = pc->fat32[cluster & 0X7F] & FAT32MASK;
    e1dc:	237f      	movs	r3, #127	; 0x7f
    e1de:	401d      	ands	r5, r3
    e1e0:	00ad      	lsls	r5, r5, #2
    e1e2:	582b      	ldr	r3, [r5, r0]
    e1e4:	011b      	lsls	r3, r3, #4
    e1e6:	091b      	lsrs	r3, r3, #4
    goto done;
    e1e8:	e011      	b.n	e20e <_ZN9FatVolume6fatGetEmPm+0x5a>
  }

  if (m_fatType == 16) {
    e1ea:	2b10      	cmp	r3, #16
    e1ec:	d1f4      	bne.n	e1d8 <_ZN9FatVolume6fatGetEmPm+0x24>
    lba = m_fatStartBlock + ((cluster >> 8) & 0XFF);
    e1ee:	6983      	ldr	r3, [r0, #24]
    e1f0:	0a09      	lsrs	r1, r1, #8
    e1f2:	27ff      	movs	r7, #255	; 0xff
    e1f4:	4039      	ands	r1, r7
    e1f6:	18c9      	adds	r1, r1, r3
    e1f8:	238c      	movs	r3, #140	; 0x8c
    e1fa:	009b      	lsls	r3, r3, #2
    e1fc:	18c0      	adds	r0, r0, r3
    e1fe:	2202      	movs	r2, #2
    e200:	f7ff ffad 	bl	e15e <_ZN8FatCache4readEmh>
    pc = cacheFetchFat(lba, FatCache::CACHE_FOR_READ);
    if (!pc) {
    e204:	2800      	cmp	r0, #0
    e206:	d0e7      	beq.n	e1d8 <_ZN9FatVolume6fatGetEmPm+0x24>
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = pc->fat16[cluster & 0XFF];
    e208:	403d      	ands	r5, r7
    e20a:	006d      	lsls	r5, r5, #1
    e20c:	5a2b      	ldrh	r3, [r5, r0]
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
done:
  if (isEOC(next)) {
    e20e:	69e2      	ldr	r2, [r4, #28]
    return 0;
    e210:	2000      	movs	r0, #0
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
done:
  if (isEOC(next)) {
    e212:	4293      	cmp	r3, r2
    e214:	d801      	bhi.n	e21a <_ZN9FatVolume6fatGetEmPm+0x66>
    return 0;
  }
  *value = next;
    e216:	6033      	str	r3, [r6, #0]
  return 1;
    e218:	2001      	movs	r0, #1
    e21a:	b240      	sxtb	r0, r0

fail:
  return -1;
}
    e21c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000e21e <_ZN9FatVolume6fatPutEmm>:
//------------------------------------------------------------------------------
// Store a FAT entry
bool FatVolume::fatPut(uint32_t cluster, uint32_t value) {
    e21e:	b570      	push	{r4, r5, r6, lr}
    e220:	1c15      	adds	r5, r2, #0
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  DBG_HALT_IF(cluster < 2 || cluster > m_lastCluster);

  if (m_fatType == 32) {
    e222:	79c2      	ldrb	r2, [r0, #7]
fail:
  return -1;
}
//------------------------------------------------------------------------------
// Store a FAT entry
bool FatVolume::fatPut(uint32_t cluster, uint32_t value) {
    e224:	1c03      	adds	r3, r0, #0
    e226:	1c0c      	adds	r4, r1, #0
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  DBG_HALT_IF(cluster < 2 || cluster > m_lastCluster);

  if (m_fatType == 32) {
    e228:	2a20      	cmp	r2, #32
    e22a:	d10f      	bne.n	e24c <_ZN9FatVolume6fatPutEmm+0x2e>
    e22c:	228c      	movs	r2, #140	; 0x8c
    lba = m_fatStartBlock + (cluster >> 7);
    e22e:	699b      	ldr	r3, [r3, #24]
    e230:	0092      	lsls	r2, r2, #2
    e232:	09c9      	lsrs	r1, r1, #7
    e234:	1880      	adds	r0, r0, r2
    e236:	18c9      	adds	r1, r1, r3
    e238:	2203      	movs	r2, #3
    e23a:	f7ff ff90 	bl	e15e <_ZN8FatCache4readEmh>
    pc = cacheFetchFat(lba, FatCache::CACHE_FOR_WRITE);
    if (!pc) {
    e23e:	2800      	cmp	r0, #0
    e240:	d019      	beq.n	e276 <_ZN9FatVolume6fatPutEmm+0x58>
      DBG_FAIL_MACRO;
      goto fail;
    }
    pc->fat32[cluster & 0X7F] = value;
    e242:	237f      	movs	r3, #127	; 0x7f
    e244:	401c      	ands	r4, r3
    e246:	00a4      	lsls	r4, r4, #2
    e248:	5025      	str	r5, [r4, r0]
    e24a:	e013      	b.n	e274 <_ZN9FatVolume6fatPutEmm+0x56>
    return true;
  }

  if (m_fatType == 16) {
    e24c:	2a10      	cmp	r2, #16
    e24e:	d001      	beq.n	e254 <_ZN9FatVolume6fatPutEmm+0x36>
    DBG_FAIL_MACRO;
    goto fail;
  }

fail:
  return false;
    e250:	2000      	movs	r0, #0
    e252:	e010      	b.n	e276 <_ZN9FatVolume6fatPutEmm+0x58>
    e254:	228c      	movs	r2, #140	; 0x8c
    pc->fat32[cluster & 0X7F] = value;
    return true;
  }

  if (m_fatType == 16) {
    lba = m_fatStartBlock + ((cluster >> 8) & 0XFF);
    e256:	0a09      	lsrs	r1, r1, #8
    e258:	26ff      	movs	r6, #255	; 0xff
    e25a:	699b      	ldr	r3, [r3, #24]
    e25c:	0092      	lsls	r2, r2, #2
    e25e:	4031      	ands	r1, r6
    e260:	1880      	adds	r0, r0, r2
    e262:	18c9      	adds	r1, r1, r3
    e264:	2203      	movs	r2, #3
    e266:	f7ff ff7a 	bl	e15e <_ZN8FatCache4readEmh>
    pc = cacheFetchFat(lba, FatCache::CACHE_FOR_WRITE);
    if (!pc) {
    e26a:	2800      	cmp	r0, #0
    e26c:	d0f0      	beq.n	e250 <_ZN9FatVolume6fatPutEmm+0x32>
      DBG_FAIL_MACRO;
      goto fail;
    }
    pc->fat16[cluster & 0XFF] = value;
    e26e:	4034      	ands	r4, r6
    e270:	0064      	lsls	r4, r4, #1
    e272:	5225      	strh	r5, [r4, r0]
    return true;
    e274:	2001      	movs	r0, #1
    goto fail;
  }

fail:
  return false;
}
    e276:	bd70      	pop	{r4, r5, r6, pc}

0000e278 <_ZN9FatVolume15allocateClusterEmPm>:

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatVolume::allocateCluster(uint32_t current, uint32_t* next) {
    e278:	b5f0      	push	{r4, r5, r6, r7, lr}
    e27a:	b085      	sub	sp, #20
    e27c:	1c05      	adds	r5, r0, #0
    e27e:	1c0f      	adds	r7, r1, #0
    e280:	9201      	str	r2, [sp, #4]
    e282:	1e0e      	subs	r6, r1, #0
  uint32_t find = current ? current : m_allocSearchStart;
    e284:	d100      	bne.n	e288 <_ZN9FatVolume15allocateClusterEmPm+0x10>
    e286:	68c6      	ldr	r6, [r0, #12]
    e288:	1c34      	adds	r4, r6, #0
  uint32_t start = find;
  while (1) {
    find++;
    // If at end of FAT go to beginning of FAT.
    if (find > m_lastCluster) {
    e28a:	69eb      	ldr	r3, [r5, #28]
//------------------------------------------------------------------------------
bool FatVolume::allocateCluster(uint32_t current, uint32_t* next) {
  uint32_t find = current ? current : m_allocSearchStart;
  uint32_t start = find;
  while (1) {
    find++;
    e28c:	3401      	adds	r4, #1
    // If at end of FAT go to beginning of FAT.
    if (find > m_lastCluster) {
    e28e:	429c      	cmp	r4, r3
    e290:	d900      	bls.n	e294 <_ZN9FatVolume15allocateClusterEmPm+0x1c>
      find = 2;
    e292:	2402      	movs	r4, #2
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    e294:	1c28      	adds	r0, r5, #0
    e296:	1c21      	adds	r1, r4, #0
    e298:	aa03      	add	r2, sp, #12
    e29a:	f7ff ff8b 	bl	e1b4 <_ZN9FatVolume6fatGetEmPm>
    if (fg < 0) {
    e29e:	2800      	cmp	r0, #0
    e2a0:	db0d      	blt.n	e2be <_ZN9FatVolume15allocateClusterEmPm+0x46>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg && f == 0) {
    e2a2:	d002      	beq.n	e2aa <_ZN9FatVolume15allocateClusterEmPm+0x32>
    e2a4:	9b03      	ldr	r3, [sp, #12]
    e2a6:	2b00      	cmp	r3, #0
    e2a8:	d002      	beq.n	e2b0 <_ZN9FatVolume15allocateClusterEmPm+0x38>
      break;
    }
    if (find == start) {
    e2aa:	42b4      	cmp	r4, r6
    e2ac:	d1ed      	bne.n	e28a <_ZN9FatVolume15allocateClusterEmPm+0x12>
    e2ae:	e006      	b.n	e2be <_ZN9FatVolume15allocateClusterEmPm+0x46>
  }
  uint32_t clusterStartBlock(uint32_t cluster) const;
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    e2b0:	1c28      	adds	r0, r5, #0
    e2b2:	1c21      	adds	r1, r4, #0
    e2b4:	4a0b      	ldr	r2, [pc, #44]	; (e2e4 <_ZN9FatVolume15allocateClusterEmPm+0x6c>)
    e2b6:	f7ff ffb2 	bl	e21e <_ZN9FatVolume6fatPutEmm>
    e2ba:	1e06      	subs	r6, r0, #0
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // mark end of chain
  if (!fatPutEOC(find)) {
    e2bc:	d101      	bne.n	e2c2 <_ZN9FatVolume15allocateClusterEmPm+0x4a>
  updateFreeClusterCount(-1);
  *next = find;
  return true;

fail:
  return false;
    e2be:	2600      	movs	r6, #0
    e2c0:	e00c      	b.n	e2dc <_ZN9FatVolume15allocateClusterEmPm+0x64>
  // mark end of chain
  if (!fatPutEOC(find)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
    e2c2:	2f00      	cmp	r7, #0
    e2c4:	d007      	beq.n	e2d6 <_ZN9FatVolume15allocateClusterEmPm+0x5e>
    // link clusters
    if (!fatPut(current, find)) {
    e2c6:	1c28      	adds	r0, r5, #0
    e2c8:	1c39      	adds	r1, r7, #0
    e2ca:	1c22      	adds	r2, r4, #0
    e2cc:	f7ff ffa7 	bl	e21e <_ZN9FatVolume6fatPutEmm>
    e2d0:	2800      	cmp	r0, #0
    e2d2:	d101      	bne.n	e2d8 <_ZN9FatVolume15allocateClusterEmPm+0x60>
    e2d4:	e7f3      	b.n	e2be <_ZN9FatVolume15allocateClusterEmPm+0x46>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // Remember place for search start.
    m_allocSearchStart = find;
    e2d6:	60ec      	str	r4, [r5, #12]
  }
  updateFreeClusterCount(-1);
  *next = find;
    e2d8:	9b01      	ldr	r3, [sp, #4]
    e2da:	601c      	str	r4, [r3, #0]
  return true;

fail:
  return false;
}
    e2dc:	1c30      	adds	r0, r6, #0
    e2de:	b005      	add	sp, #20
    e2e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e2e2:	46c0      	nop			; (mov r8, r8)
    e2e4:	0fffffff 	.word	0x0fffffff

0000e2e8 <_ZN9FatVolume9freeChainEm>:
fail:
  return false;
}
//------------------------------------------------------------------------------
// free a cluster chain
bool FatVolume::freeChain(uint32_t cluster) {
    e2e8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    e2ea:	1c05      	adds	r5, r0, #0
    e2ec:	1c0c      	adds	r4, r1, #0
  uint32_t next;
  int8_t fg;
  do {
    fg = fatGet(cluster, &next);
    e2ee:	1c28      	adds	r0, r5, #0
    e2f0:	1c21      	adds	r1, r4, #0
    e2f2:	aa01      	add	r2, sp, #4
    e2f4:	f7ff ff5e 	bl	e1b4 <_ZN9FatVolume6fatGetEmPm>
    e2f8:	1e06      	subs	r6, r0, #0
    if (fg < 0) {
    e2fa:	da01      	bge.n	e300 <_ZN9FatVolume9freeChainEm+0x18>
  } while (fg);

  return true;

fail:
  return false;
    e2fc:	2000      	movs	r0, #0
    e2fe:	e00d      	b.n	e31c <_ZN9FatVolume9freeChainEm+0x34>
    if (fg < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
    e300:	1c28      	adds	r0, r5, #0
    e302:	1c21      	adds	r1, r4, #0
    e304:	2200      	movs	r2, #0
    e306:	f7ff ff8a 	bl	e21e <_ZN9FatVolume6fatPutEmm>
    e30a:	2800      	cmp	r0, #0
    e30c:	d0f6      	beq.n	e2fc <_ZN9FatVolume9freeChainEm+0x14>
      goto fail;
    }
    // Add one to count of free clusters.
    updateFreeClusterCount(1);

    if (cluster < m_allocSearchStart) {
    e30e:	68eb      	ldr	r3, [r5, #12]
    e310:	429c      	cmp	r4, r3
    e312:	d200      	bcs.n	e316 <_ZN9FatVolume9freeChainEm+0x2e>
      m_allocSearchStart = cluster;
    e314:	60ec      	str	r4, [r5, #12]
    }
    cluster = next;
    e316:	9c01      	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
// free a cluster chain
bool FatVolume::freeChain(uint32_t cluster) {
  uint32_t next;
  int8_t fg;
  do {
    e318:	2e00      	cmp	r6, #0
    e31a:	d1e8      	bne.n	e2ee <_ZN9FatVolume9freeChainEm+0x6>

  return true;

fail:
  return false;
}
    e31c:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
	...

0000e320 <_ZN9FatVolume4initEh>:

fail:
  return -1;
}
//------------------------------------------------------------------------------
bool FatVolume::init(uint8_t part) {
    e320:	b570      	push	{r4, r5, r6, lr}
  uint32_t volumeStartBlock = 0;
  fat32_boot_t* fbs;
  cache_t* pc;
  uint8_t tmp;
  m_fatType = 0;
  m_allocSearchStart = 1;
    e322:	2301      	movs	r3, #1

fail:
  return -1;
}
//------------------------------------------------------------------------------
bool FatVolume::init(uint8_t part) {
    e324:	1c0d      	adds	r5, r1, #0
    invalidate();
  }
  /** Invalidate current cache block. */
  void invalidate() {
    m_status = 0;
    m_lbn = 0XFFFFFFFF;
    e326:	2101      	movs	r1, #1
  uint32_t volumeStartBlock = 0;
  fat32_boot_t* fbs;
  cache_t* pc;
  uint8_t tmp;
  m_fatType = 0;
  m_allocSearchStart = 1;
    e328:	60c3      	str	r3, [r0, #12]

fail:
  return -1;
}
//------------------------------------------------------------------------------
bool FatVolume::init(uint8_t part) {
    e32a:	1c04      	adds	r4, r0, #0
  uint32_t totalBlocks;
  uint32_t volumeStartBlock = 0;
  fat32_boot_t* fbs;
  cache_t* pc;
  uint8_t tmp;
  m_fatType = 0;
    e32c:	2200      	movs	r2, #0
    m_vol = vol;
    invalidate();
  }
  /** Invalidate current cache block. */
  void invalidate() {
    m_status = 0;
    e32e:	1d43      	adds	r3, r0, #5
    m_lbn = 0XFFFFFFFF;
    e330:	4249      	negs	r1, r1
    e332:	71c2      	strb	r2, [r0, #7]
  }
  /** Initialize the cache.
   * \param[in] vol FatVolume that owns this FatCache.
   */
  void init(FatVolume *vol) {
    m_vol = vol;
    e334:	62a0      	str	r0, [r4, #40]	; 0x28
    invalidate();
  }
  /** Invalidate current cache block. */
  void invalidate() {
    m_status = 0;
    e336:	77da      	strb	r2, [r3, #31]
    m_lbn = 0XFFFFFFFF;
    e338:	62c1      	str	r1, [r0, #44]	; 0x2c
  }
  /** Initialize the cache.
   * \param[in] vol FatVolume that owns this FatCache.
   */
  void init(FatVolume *vol) {
    m_vol = vol;
    e33a:	208c      	movs	r0, #140	; 0x8c
    e33c:	0080      	lsls	r0, r0, #2
    e33e:	1823      	adds	r3, r4, r0
    invalidate();
  }
  /** Invalidate current cache block. */
  void invalidate() {
    m_status = 0;
    e340:	208c      	movs	r0, #140	; 0x8c
    e342:	0080      	lsls	r0, r0, #2
  }
  /** Initialize the cache.
   * \param[in] vol FatVolume that owns this FatCache.
   */
  void init(FatVolume *vol) {
    m_vol = vol;
    e344:	605c      	str	r4, [r3, #4]
    invalidate();
  }
  /** Invalidate current cache block. */
  void invalidate() {
    m_status = 0;
    e346:	5422      	strb	r2, [r4, r0]
    m_lbn = 0XFFFFFFFF;
    e348:	6099      	str	r1, [r3, #8]
  m_fatCache.init(this);
#endif  // USE_SEPARATE_FAT_CACHE

  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
    e34a:	4295      	cmp	r5, r2
    e34c:	d01d      	beq.n	e38a <_ZN9FatVolume4initEh+0x6a>
    if (part > 4) {
    e34e:	2d04      	cmp	r5, #4
    e350:	d900      	bls.n	e354 <_ZN9FatVolume4initEh+0x34>
    e352:	e08c      	b.n	e46e <_ZN9FatVolume4initEh+0x14e>
  bool cacheSync() {
    return m_cache.sync();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t blockNumber, uint8_t options) {
    return m_cache.read(blockNumber, options);
    e354:	1c20      	adds	r0, r4, #0
    e356:	3024      	adds	r0, #36	; 0x24
    e358:	1c11      	adds	r1, r2, #0
    e35a:	f7ff ff00 	bl	e15e <_ZN8FatCache4readEmh>
      DBG_FAIL_MACRO;
      goto fail;
    }
    pc = cacheFetchData(0, FatCache::CACHE_FOR_READ);
    if (!pc) {
    e35e:	2800      	cmp	r0, #0
    e360:	d100      	bne.n	e364 <_ZN9FatVolume4initEh+0x44>
    e362:	e084      	b.n	e46e <_ZN9FatVolume4initEh+0x14e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    part_t* p = &pc->mbr.part[part - 1];
    e364:	012d      	lsls	r5, r5, #4
    e366:	35a9      	adds	r5, #169	; 0xa9
    e368:	35ff      	adds	r5, #255	; 0xff
    e36a:	1940      	adds	r0, r0, r5
    if ((p->boot & 0X7F) != 0 || p->firstSector == 0) {
    e36c:	7982      	ldrb	r2, [r0, #6]
    e36e:	0651      	lsls	r1, r2, #25
    e370:	d000      	beq.n	e374 <_ZN9FatVolume4initEh+0x54>
    e372:	e07c      	b.n	e46e <_ZN9FatVolume4initEh+0x14e>
    e374:	7bc5      	ldrb	r5, [r0, #15]
    e376:	7b82      	ldrb	r2, [r0, #14]
    e378:	022d      	lsls	r5, r5, #8
    e37a:	4315      	orrs	r5, r2
    e37c:	7c02      	ldrb	r2, [r0, #16]
    e37e:	7c43      	ldrb	r3, [r0, #17]
    e380:	0412      	lsls	r2, r2, #16
    e382:	4315      	orrs	r5, r2
    e384:	061b      	lsls	r3, r3, #24
    e386:	431d      	orrs	r5, r3
    e388:	d071      	beq.n	e46e <_ZN9FatVolume4initEh+0x14e>
    e38a:	1c20      	adds	r0, r4, #0
    e38c:	3024      	adds	r0, #36	; 0x24
    e38e:	1c29      	adds	r1, r5, #0
    e390:	2200      	movs	r2, #0
    e392:	f7ff fee4 	bl	e15e <_ZN8FatCache4readEmh>
      goto fail;
    }
    volumeStartBlock = p->firstSector;
  }
  pc = cacheFetchData(volumeStartBlock, FatCache::CACHE_FOR_READ);
  if (!pc) {
    e396:	2800      	cmp	r0, #0
    e398:	d069      	beq.n	e46e <_ZN9FatVolume4initEh+0x14e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  fbs = &(pc->fbs32);
  if (fbs->bytesPerSector != 512 ||
    e39a:	7b02      	ldrb	r2, [r0, #12]
    e39c:	7ac3      	ldrb	r3, [r0, #11]
    e39e:	0212      	lsls	r2, r2, #8
    e3a0:	431a      	orrs	r2, r3
    e3a2:	2380      	movs	r3, #128	; 0x80
    e3a4:	009b      	lsls	r3, r3, #2
    e3a6:	429a      	cmp	r2, r3
    e3a8:	d161      	bne.n	e46e <_ZN9FatVolume4initEh+0x14e>
    e3aa:	7c03      	ldrb	r3, [r0, #16]
    e3ac:	2b02      	cmp	r3, #2
    e3ae:	d15e      	bne.n	e46e <_ZN9FatVolume4initEh+0x14e>
      fbs->fatCount != 2 ||
      fbs->reservedSectorCount == 0) {
    e3b0:	7bc3      	ldrb	r3, [r0, #15]
    e3b2:	7b82      	ldrb	r2, [r0, #14]
    e3b4:	021b      	lsls	r3, r3, #8
    DBG_FAIL_MACRO;
    goto fail;
  }
  fbs = &(pc->fbs32);
  if (fbs->bytesPerSector != 512 ||
      fbs->fatCount != 2 ||
    e3b6:	4313      	orrs	r3, r2
    e3b8:	d059      	beq.n	e46e <_ZN9FatVolume4initEh+0x14e>
      fbs->reservedSectorCount == 0) {
    // not valid FAT volume
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_blocksPerCluster = fbs->sectorsPerCluster;
    e3ba:	7b42      	ldrb	r2, [r0, #13]
  m_clusterBlockMask = m_blocksPerCluster - 1;

  // determine shift that is same as multiply by m_blocksPerCluster
  m_clusterSizeShift = 0;
  for (tmp = 1; m_blocksPerCluster != tmp; tmp <<= 1, m_clusterSizeShift++) {
    e3bc:	2109      	movs	r1, #9
    // not valid FAT volume
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_blocksPerCluster = fbs->sectorsPerCluster;
  m_clusterBlockMask = m_blocksPerCluster - 1;
    e3be:	1e53      	subs	r3, r2, #1
    e3c0:	7163      	strb	r3, [r4, #5]

  // determine shift that is same as multiply by m_blocksPerCluster
  m_clusterSizeShift = 0;
    e3c2:	2300      	movs	r3, #0
    e3c4:	71a3      	strb	r3, [r4, #6]
      fbs->reservedSectorCount == 0) {
    // not valid FAT volume
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_blocksPerCluster = fbs->sectorsPerCluster;
    e3c6:	7122      	strb	r2, [r4, #4]
  m_clusterBlockMask = m_blocksPerCluster - 1;

  // determine shift that is same as multiply by m_blocksPerCluster
  m_clusterSizeShift = 0;
  for (tmp = 1; m_blocksPerCluster != tmp; tmp <<= 1, m_clusterSizeShift++) {
    e3c8:	2301      	movs	r3, #1
    e3ca:	429a      	cmp	r2, r3
    e3cc:	d008      	beq.n	e3e0 <_ZN9FatVolume4initEh+0xc0>
    e3ce:	3901      	subs	r1, #1
    if (tmp == 0) {
    e3d0:	2900      	cmp	r1, #0
    e3d2:	d04c      	beq.n	e46e <_ZN9FatVolume4initEh+0x14e>
  m_blocksPerCluster = fbs->sectorsPerCluster;
  m_clusterBlockMask = m_blocksPerCluster - 1;

  // determine shift that is same as multiply by m_blocksPerCluster
  m_clusterSizeShift = 0;
  for (tmp = 1; m_blocksPerCluster != tmp; tmp <<= 1, m_clusterSizeShift++) {
    e3d4:	79a6      	ldrb	r6, [r4, #6]
    e3d6:	005b      	lsls	r3, r3, #1
    e3d8:	3601      	adds	r6, #1
    e3da:	b2db      	uxtb	r3, r3
    e3dc:	71a6      	strb	r6, [r4, #6]
    e3de:	e7f4      	b.n	e3ca <_ZN9FatVolume4initEh+0xaa>
      goto fail;
    }
  }

  m_blocksPerFat = fbs->sectorsPerFat16 ?
                   fbs->sectorsPerFat16 : fbs->sectorsPerFat32;
    e3e0:	7dc3      	ldrb	r3, [r0, #23]
    e3e2:	7d82      	ldrb	r2, [r0, #22]
    e3e4:	021b      	lsls	r3, r3, #8
    e3e6:	4313      	orrs	r3, r2
    e3e8:	d10e      	bne.n	e408 <_ZN9FatVolume4initEh+0xe8>
    e3ea:	1d43      	adds	r3, r0, #5
    e3ec:	7fda      	ldrb	r2, [r3, #31]
    e3ee:	1d83      	adds	r3, r0, #6
    e3f0:	7fdb      	ldrb	r3, [r3, #31]
    e3f2:	021b      	lsls	r3, r3, #8
    e3f4:	4313      	orrs	r3, r2
    e3f6:	1dc2      	adds	r2, r0, #7
    e3f8:	7fd2      	ldrb	r2, [r2, #31]
    e3fa:	0412      	lsls	r2, r2, #16
    e3fc:	4313      	orrs	r3, r2
    e3fe:	1c02      	adds	r2, r0, #0
    e400:	3208      	adds	r2, #8
    e402:	7fd2      	ldrb	r2, [r2, #31]
    e404:	0612      	lsls	r2, r2, #24
    e406:	4313      	orrs	r3, r2
    e408:	6123      	str	r3, [r4, #16]

  m_fatStartBlock = volumeStartBlock + fbs->reservedSectorCount;
    e40a:	7bc1      	ldrb	r1, [r0, #15]
    e40c:	7b82      	ldrb	r2, [r0, #14]
    e40e:	0209      	lsls	r1, r1, #8
    e410:	4311      	orrs	r1, r2
    e412:	1869      	adds	r1, r5, r1
    e414:	61a1      	str	r1, [r4, #24]

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = fbs->rootDirEntryCount;
    e416:	7c86      	ldrb	r6, [r0, #18]
    e418:	7c42      	ldrb	r2, [r0, #17]
    e41a:	0236      	lsls	r6, r6, #8
    e41c:	4316      	orrs	r6, r2

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartBlock + 2 * m_blocksPerFat;
    e41e:	005b      	lsls	r3, r3, #1
  // data start for FAT16 and FAT32
  m_dataStartBlock = m_rootDirStart + ((32 * fbs->rootDirEntryCount + 511)/512);
    e420:	4a21      	ldr	r2, [pc, #132]	; (e4a8 <_ZN9FatVolume4initEh+0x188>)

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = fbs->rootDirEntryCount;

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartBlock + 2 * m_blocksPerFat;
    e422:	1859      	adds	r1, r3, r1
  // data start for FAT16 and FAT32
  m_dataStartBlock = m_rootDirStart + ((32 * fbs->rootDirEntryCount + 511)/512);
    e424:	0173      	lsls	r3, r6, #5
    e426:	189b      	adds	r3, r3, r2
    e428:	125b      	asrs	r3, r3, #9
    e42a:	18cb      	adds	r3, r1, r3
                   fbs->sectorsPerFat16 : fbs->sectorsPerFat32;

  m_fatStartBlock = volumeStartBlock + fbs->reservedSectorCount;

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = fbs->rootDirEntryCount;
    e42c:	8126      	strh	r6, [r4, #8]

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartBlock + 2 * m_blocksPerFat;
    e42e:	6221      	str	r1, [r4, #32]
  // data start for FAT16 and FAT32
  m_dataStartBlock = m_rootDirStart + ((32 * fbs->rootDirEntryCount + 511)/512);
    e430:	6163      	str	r3, [r4, #20]

  // total blocks for FAT16 or FAT32
  totalBlocks = fbs->totalSectors16 ?
                fbs->totalSectors16 : fbs->totalSectors32;
    e432:	7d02      	ldrb	r2, [r0, #20]
    e434:	7cc1      	ldrb	r1, [r0, #19]
    e436:	0212      	lsls	r2, r2, #8
    e438:	430a      	orrs	r2, r1
    e43a:	d10d      	bne.n	e458 <_ZN9FatVolume4initEh+0x138>
    e43c:	1c42      	adds	r2, r0, #1
    e43e:	7fd1      	ldrb	r1, [r2, #31]
    e440:	1c82      	adds	r2, r0, #2
    e442:	7fd2      	ldrb	r2, [r2, #31]
    e444:	0212      	lsls	r2, r2, #8
    e446:	430a      	orrs	r2, r1
    e448:	1cc1      	adds	r1, r0, #3
    e44a:	7fc9      	ldrb	r1, [r1, #31]
    e44c:	0409      	lsls	r1, r1, #16
    e44e:	430a      	orrs	r2, r1
    e450:	1d01      	adds	r1, r0, #4
    e452:	7fc9      	ldrb	r1, [r1, #31]
    e454:	0609      	lsls	r1, r1, #24
    e456:	430a      	orrs	r2, r1
  // total data blocks
  clusterCount = totalBlocks - (m_dataStartBlock - volumeStartBlock);
    e458:	1aed      	subs	r5, r5, r3

  // divide by cluster size to get cluster count
  clusterCount >>= m_clusterSizeShift;
    e45a:	79a1      	ldrb	r1, [r4, #6]

  // total blocks for FAT16 or FAT32
  totalBlocks = fbs->totalSectors16 ?
                fbs->totalSectors16 : fbs->totalSectors32;
  // total data blocks
  clusterCount = totalBlocks - (m_dataStartBlock - volumeStartBlock);
    e45c:	18ad      	adds	r5, r5, r2

  // divide by cluster size to get cluster count
  clusterCount >>= m_clusterSizeShift;
    e45e:	40cd      	lsrs	r5, r1
  m_lastCluster = clusterCount + 1;
    e460:	1c6b      	adds	r3, r5, #1
    e462:	61e3      	str	r3, [r4, #28]

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);

  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    e464:	4b11      	ldr	r3, [pc, #68]	; (e4ac <_ZN9FatVolume4initEh+0x18c>)
    e466:	429d      	cmp	r5, r3
    e468:	d803      	bhi.n	e472 <_ZN9FatVolume4initEh+0x152>
    m_fatType = 12;
    e46a:	230c      	movs	r3, #12
    e46c:	71e3      	strb	r3, [r4, #7]
    m_fatType = 32;
  }
  return true;

fail:
  return false;
    e46e:	2000      	movs	r0, #0
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    e470:	e018      	b.n	e4a4 <_ZN9FatVolume4initEh+0x184>
    }
  } else if (clusterCount < 65525) {
    e472:	4b0f      	ldr	r3, [pc, #60]	; (e4b0 <_ZN9FatVolume4initEh+0x190>)
    e474:	429d      	cmp	r5, r3
    e476:	d801      	bhi.n	e47c <_ZN9FatVolume4initEh+0x15c>
    m_fatType = 16;
    e478:	2310      	movs	r3, #16
    e47a:	e011      	b.n	e4a0 <_ZN9FatVolume4initEh+0x180>
  } else {
    m_rootDirStart = fbs->fat32RootCluster;
    e47c:	1c03      	adds	r3, r0, #0
    e47e:	332c      	adds	r3, #44	; 0x2c
    e480:	781a      	ldrb	r2, [r3, #0]
    e482:	3301      	adds	r3, #1
    e484:	781b      	ldrb	r3, [r3, #0]
    e486:	021b      	lsls	r3, r3, #8
    e488:	4313      	orrs	r3, r2
    e48a:	1c02      	adds	r2, r0, #0
    e48c:	322e      	adds	r2, #46	; 0x2e
    e48e:	7812      	ldrb	r2, [r2, #0]
    e490:	302f      	adds	r0, #47	; 0x2f
    e492:	0412      	lsls	r2, r2, #16
    e494:	4313      	orrs	r3, r2
    e496:	7802      	ldrb	r2, [r0, #0]
    e498:	0612      	lsls	r2, r2, #24
    e49a:	4313      	orrs	r3, r2
    e49c:	6223      	str	r3, [r4, #32]
    m_fatType = 32;
    e49e:	2320      	movs	r3, #32
    e4a0:	71e3      	strb	r3, [r4, #7]
  }
  return true;
    e4a2:	2001      	movs	r0, #1

fail:
  return false;
}
    e4a4:	bd70      	pop	{r4, r5, r6, pc}
    e4a6:	46c0      	nop			; (mov r8, r8)
    e4a8:	000001ff 	.word	0x000001ff
    e4ac:	00000ff4 	.word	0x00000ff4
    e4b0:	0000fff4 	.word	0x0000fff4

0000e4b4 <_ZN9SdSpiCard14chipSelectHighEv>:
    error(SD_CARD_ERROR_BAD_CSD);
    return 0;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::chipSelectHigh() {
    e4b4:	b510      	push	{r4, lr}
  if (!m_selected) {
    e4b6:	7903      	ldrb	r3, [r0, #4]
    error(SD_CARD_ERROR_BAD_CSD);
    return 0;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::chipSelectHigh() {
    e4b8:	1c04      	adds	r4, r0, #0
  if (!m_selected) {
    e4ba:	2b00      	cmp	r3, #0
    e4bc:	d00c      	beq.n	e4d8 <_ZN9SdSpiCard14chipSelectHighEv+0x24>
    SD_CS_DBG("chipSelectHigh error");
    return;
  }
  digitalWrite(m_chipSelectPin, HIGH);
    e4be:	7940      	ldrb	r0, [r0, #5]
    e4c0:	2101      	movs	r1, #1
    e4c2:	f001 faab 	bl	fa1c <digitalWrite>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spi->receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spi->send(data);
    e4c6:	6820      	ldr	r0, [r4, #0]
    e4c8:	21ff      	movs	r1, #255	; 0xff
    e4ca:	f000 fb17 	bl	eafc <_ZN5SdSpi4sendEh>
  }
  void spiBeginTransaction(uint8_t spiDivisor) {
    m_spi->beginTransaction(spiDivisor);
  }
  void spiEndTransaction() {
    m_spi->endTransaction();
    e4ce:	6820      	ldr	r0, [r4, #0]
    e4d0:	f000 fa96 	bl	ea00 <_ZN5SdSpi14endTransactionEv>
  // insure MISO goes high impedance
  spiSend(0XFF);
  spiEndTransaction();
  m_selected = false;
    e4d4:	2300      	movs	r3, #0
    e4d6:	7123      	strb	r3, [r4, #4]
}
    e4d8:	bd10      	pop	{r4, pc}

0000e4da <_ZN9SdSpiCard13chipSelectLowEv>:
//------------------------------------------------------------------------------
void SdSpiCard::chipSelectLow() {
    e4da:	b538      	push	{r3, r4, r5, lr}
  if ((micros() - last) > WDT_YIELD_TIME_MICROS) {
    SysCall::yield();
    last = micros();
  }
#endif  // WDT_YIELD_TIME_MICROS
  if (m_selected) {
    e4dc:	7905      	ldrb	r5, [r0, #4]
  spiSend(0XFF);
  spiEndTransaction();
  m_selected = false;
}
//------------------------------------------------------------------------------
void SdSpiCard::chipSelectLow() {
    e4de:	1c04      	adds	r4, r0, #0
  if ((micros() - last) > WDT_YIELD_TIME_MICROS) {
    SysCall::yield();
    last = micros();
  }
#endif  // WDT_YIELD_TIME_MICROS
  if (m_selected) {
    e4e0:	2d00      	cmp	r5, #0
    e4e2:	d109      	bne.n	e4f8 <_ZN9SdSpiCard13chipSelectLowEv+0x1e>
  bool writeData(uint8_t token, const uint8_t* src);
  void spiBegin(uint8_t chipSelectPin) {
    m_spi->begin(chipSelectPin);
  }
  void spiBeginTransaction(uint8_t spiDivisor) {
    m_spi->beginTransaction(spiDivisor);
    e4e4:	79c1      	ldrb	r1, [r0, #7]
    e4e6:	6800      	ldr	r0, [r0, #0]
    e4e8:	f000 fa6e 	bl	e9c8 <_ZN5SdSpi16beginTransactionEh>
    SD_CS_DBG("chipSelectLow error");
    return;
  }
  spiBeginTransaction(m_sckDivisor);
  digitalWrite(m_chipSelectPin, LOW);
    e4ec:	7960      	ldrb	r0, [r4, #5]
    e4ee:	1c29      	adds	r1, r5, #0
    e4f0:	f001 fa94 	bl	fa1c <digitalWrite>
  m_selected = true;
    e4f4:	2301      	movs	r3, #1
    e4f6:	7123      	strb	r3, [r4, #4]
}
    e4f8:	bd38      	pop	{r3, r4, r5, pc}

0000e4fa <_ZN9SdSpiCard8readDataEPhj>:
    return false;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst, size_t count) {
    e4fa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e4fc:	1c04      	adds	r4, r0, #0
    e4fe:	1c0e      	adds	r6, r1, #0
    e500:	1c15      	adds	r5, r2, #0
#if USE_SD_CRC
  uint16_t crc;
#endif  // USE_SD_CRC
  // wait for start block token
  unsigned t0 = millis();
    e502:	f000 ff0d 	bl	f320 <millis>
    e506:	1c07      	adds	r7, r0, #0
  }
  void spiEndTransaction() {
    m_spi->endTransaction();
  }
  uint8_t spiReceive() {
    return m_spi->receive();
    e508:	6820      	ldr	r0, [r4, #0]
    e50a:	f000 fa7b 	bl	ea04 <_ZN5SdSpi7receiveEv>
  while ((m_status = spiReceive()) == 0XFF) {
    e50e:	7220      	strb	r0, [r4, #8]
    e510:	28ff      	cmp	r0, #255	; 0xff
    e512:	d108      	bne.n	e526 <_ZN9SdSpiCard8readDataEPhj+0x2c>
    if (((unsigned)millis() - t0) > SD_READ_TIMEOUT) {
    e514:	f000 ff04 	bl	f320 <millis>
    e518:	2396      	movs	r3, #150	; 0x96
    e51a:	1bc0      	subs	r0, r0, r7
    e51c:	005b      	lsls	r3, r3, #1
    e51e:	4298      	cmp	r0, r3
    e520:	d9f2      	bls.n	e508 <_ZN9SdSpiCard8readDataEPhj+0xe>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    e522:	2311      	movs	r3, #17
    e524:	e00c      	b.n	e540 <_ZN9SdSpiCard8readDataEPhj+0x46>
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
    }
  }
  if (m_status != DATA_START_BLOCK) {
    e526:	28fe      	cmp	r0, #254	; 0xfe
    e528:	d001      	beq.n	e52e <_ZN9SdSpiCard8readDataEPhj+0x34>
    e52a:	230f      	movs	r3, #15
    e52c:	e008      	b.n	e540 <_ZN9SdSpiCard8readDataEPhj+0x46>
  }
  uint8_t spiReceive() {
    return m_spi->receive();
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spi->receive(buf, n);
    e52e:	6820      	ldr	r0, [r4, #0]
    e530:	1c31      	adds	r1, r6, #0
    e532:	1c2a      	adds	r2, r5, #0
    e534:	f000 fa6e 	bl	ea14 <_ZN5SdSpi7receiveEPhj>
    error(SD_CARD_ERROR_READ);
    goto fail;
  }
  // transfer data
  if ((m_status = spiReceive(dst, count))) {
    e538:	7220      	strb	r0, [r4, #8]
    e53a:	2800      	cmp	r0, #0
    e53c:	d006      	beq.n	e54c <_ZN9SdSpiCard8readDataEPhj+0x52>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    e53e:	231c      	movs	r3, #28
  spiReceive();
#endif  // USE_SD_CRC
  return true;

fail:
  chipSelectHigh();
    e540:	1c20      	adds	r0, r4, #0
    e542:	71a3      	strb	r3, [r4, #6]
    e544:	f7ff ffb6 	bl	e4b4 <_ZN9SdSpiCard14chipSelectHighEv>
  return false;
    e548:	2000      	movs	r0, #0
    e54a:	e006      	b.n	e55a <_ZN9SdSpiCard8readDataEPhj+0x60>
  }
  void spiEndTransaction() {
    m_spi->endTransaction();
  }
  uint8_t spiReceive() {
    return m_spi->receive();
    e54c:	6820      	ldr	r0, [r4, #0]
    e54e:	f000 fa59 	bl	ea04 <_ZN5SdSpi7receiveEv>
    e552:	6820      	ldr	r0, [r4, #0]
    e554:	f000 fa56 	bl	ea04 <_ZN5SdSpi7receiveEv>
    e558:	2001      	movs	r0, #1
}
    e55a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000e55c <_ZN9SdSpiCard11waitNotBusyEt>:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
// wait for card to go not busy
bool SdSpiCard::waitNotBusy(uint16_t timeoutMillis) {
    e55c:	b570      	push	{r4, r5, r6, lr}
    e55e:	1c04      	adds	r4, r0, #0
    e560:	1c0e      	adds	r6, r1, #0
  unsigned t0 = millis();
    e562:	f000 fedd 	bl	f320 <millis>
    e566:	1c05      	adds	r5, r0, #0
    e568:	6820      	ldr	r0, [r4, #0]
    e56a:	f000 fa4b 	bl	ea04 <_ZN5SdSpi7receiveEv>
  while (spiReceive() != 0XFF) {
    e56e:	28ff      	cmp	r0, #255	; 0xff
    e570:	d006      	beq.n	e580 <_ZN9SdSpiCard11waitNotBusyEt+0x24>
    if (((unsigned)millis() - t0) >= timeoutMillis) {
    e572:	f000 fed5 	bl	f320 <millis>
    e576:	1b40      	subs	r0, r0, r5
    e578:	42b0      	cmp	r0, r6
    e57a:	d3f5      	bcc.n	e568 <_ZN9SdSpiCard11waitNotBusyEt+0xc>
    }
  }
  return true;

fail:
  return false;
    e57c:	2000      	movs	r0, #0
    e57e:	e000      	b.n	e582 <_ZN9SdSpiCard11waitNotBusyEt+0x26>
  while (spiReceive() != 0XFF) {
    if (((unsigned)millis() - t0) >= timeoutMillis) {
      goto fail;
    }
  }
  return true;
    e580:	2001      	movs	r0, #1

fail:
  return false;
}
    e582:	bd70      	pop	{r4, r5, r6, pc}

0000e584 <_ZN9SdSpiCard11cardCommandEhm>:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    e584:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    e586:	9201      	str	r2, [sp, #4]
  // select card
  if (!m_selected) {
    e588:	7903      	ldrb	r3, [r0, #4]
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    e58a:	1c04      	adds	r4, r0, #0
    e58c:	1c0e      	adds	r6, r1, #0
  // select card
  if (!m_selected) {
    e58e:	2b00      	cmp	r3, #0
    e590:	d101      	bne.n	e596 <_ZN9SdSpiCard11cardCommandEhm+0x12>
    chipSelectLow();
    e592:	f7ff ffa2 	bl	e4da <_ZN9SdSpiCard13chipSelectLowEv>
  }
  // wait if busy
  waitNotBusy(SD_WRITE_TIMEOUT);
    e596:	2196      	movs	r1, #150	; 0x96
    e598:	0089      	lsls	r1, r1, #2
    e59a:	1c20      	adds	r0, r4, #0
    e59c:	f7ff ffde 	bl	e55c <_ZN9SdSpiCard11waitNotBusyEt>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spi->receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spi->send(data);
    e5a0:	2140      	movs	r1, #64	; 0x40
    e5a2:	4331      	orrs	r1, r6
    e5a4:	6820      	ldr	r0, [r4, #0]
    e5a6:	f000 faa9 	bl	eafc <_ZN5SdSpi4sendEh>
    e5aa:	466d      	mov	r5, sp
    e5ac:	466f      	mov	r7, sp
    e5ae:	3507      	adds	r5, #7
    e5b0:	3703      	adds	r7, #3
    e5b2:	7829      	ldrb	r1, [r5, #0]
    e5b4:	6820      	ldr	r0, [r4, #0]
    e5b6:	3d01      	subs	r5, #1
    e5b8:	f000 faa0 	bl	eafc <_ZN5SdSpi4sendEh>
  // send command
  spiSend(cmd | 0x40);

  // send argument
  uint8_t *pa = reinterpret_cast<uint8_t *>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    e5bc:	42bd      	cmp	r5, r7
    e5be:	d1f8      	bne.n	e5b2 <_ZN9SdSpiCard11cardCommandEhm+0x2e>
    spiSend(pa[i]);
  }

  // send CRC - correct for CMD0 with arg zero or CMD8 with arg 0X1AA
  spiSend(cmd == CMD0 ? 0X95 : 0X87);
    e5c0:	2187      	movs	r1, #135	; 0x87
    e5c2:	2e00      	cmp	r6, #0
    e5c4:	d100      	bne.n	e5c8 <_ZN9SdSpiCard11cardCommandEhm+0x44>
    e5c6:	2195      	movs	r1, #149	; 0x95
    e5c8:	6820      	ldr	r0, [r4, #0]
    e5ca:	f000 fa97 	bl	eafc <_ZN5SdSpi4sendEh>
#endif  // USE_SD_CRC

  // skip stuff byte for stop read
  if (cmd == CMD12) {
    e5ce:	2e0c      	cmp	r6, #12
    e5d0:	d102      	bne.n	e5d8 <_ZN9SdSpiCard11cardCommandEhm+0x54>
  }
  void spiEndTransaction() {
    m_spi->endTransaction();
  }
  uint8_t spiReceive() {
    return m_spi->receive();
    e5d2:	6820      	ldr	r0, [r4, #0]
    e5d4:	f000 fa16 	bl	ea04 <_ZN5SdSpi7receiveEv>
  for (int8_t i = 3; i >= 0; i--) {
    spiSend(pa[i]);
  }

  // send CRC - correct for CMD0 with arg zero or CMD8 with arg 0X1AA
  spiSend(cmd == CMD0 ? 0X95 : 0X87);
    e5d8:	2500      	movs	r5, #0
    e5da:	6820      	ldr	r0, [r4, #0]
    e5dc:	f000 fa12 	bl	ea04 <_ZN5SdSpi7receiveEv>
  if (cmd == CMD12) {
    spiReceive();
  }

  // wait for response
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i != 0XFF; i++) {
    e5e0:	b243      	sxtb	r3, r0
    e5e2:	7220      	strb	r0, [r4, #8]
    e5e4:	2b00      	cmp	r3, #0
    e5e6:	da04      	bge.n	e5f2 <_ZN9SdSpiCard11cardCommandEhm+0x6e>
    e5e8:	2dff      	cmp	r5, #255	; 0xff
    e5ea:	d002      	beq.n	e5f2 <_ZN9SdSpiCard11cardCommandEhm+0x6e>
    e5ec:	3501      	adds	r5, #1
    e5ee:	b2ed      	uxtb	r5, r5
    e5f0:	e7f3      	b.n	e5da <_ZN9SdSpiCard11cardCommandEhm+0x56>
  }
  return m_status;
}
    e5f2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0000e5f4 <_ZN9SdSpiCard5beginEP5SdSpihh>:
#endif  // CRC_CCITT
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(m_spi_t* spi, uint8_t chipSelectPin, uint8_t sckDivisor) {
    e5f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e5f6:	1c1f      	adds	r7, r3, #0
  m_errorCode = m_type = 0;
    e5f8:	2300      	movs	r3, #0
  m_spi = spi;
  m_chipSelectPin = chipSelectPin;
    e5fa:	7142      	strb	r2, [r0, #5]
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(m_spi_t* spi, uint8_t chipSelectPin, uint8_t sckDivisor) {
  m_errorCode = m_type = 0;
    e5fc:	7243      	strb	r3, [r0, #9]
    e5fe:	7183      	strb	r3, [r0, #6]
  m_spi = spi;
    e600:	6001      	str	r1, [r0, #0]
#endif  // CRC_CCITT
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(m_spi_t* spi, uint8_t chipSelectPin, uint8_t sckDivisor) {
    e602:	1c04      	adds	r4, r0, #0
  m_errorCode = m_type = 0;
  m_spi = spi;
  m_chipSelectPin = chipSelectPin;
  // 16-bit init start time allows over a minute
  unsigned t0 = (unsigned)millis();
    e604:	f000 fe8c 	bl	f320 <millis>
    m_type = value;
  }
  bool waitNotBusy(uint16_t timeoutMillis);
  bool writeData(uint8_t token, const uint8_t* src);
  void spiBegin(uint8_t chipSelectPin) {
    m_spi->begin(chipSelectPin);
    e608:	7961      	ldrb	r1, [r4, #5]
    e60a:	1c05      	adds	r5, r0, #0
    e60c:	6820      	ldr	r0, [r4, #0]
    e60e:	f000 f9bd 	bl	e98c <_ZN5SdSpi5beginEh>

  // initialize SPI bus and chip select pin.
  spiBegin(m_chipSelectPin);

  // set SCK rate for initialization commands.
  m_sckDivisor = SPI_SCK_INIT_DIVISOR;
    e612:	2380      	movs	r3, #128	; 0x80
    e614:	71e3      	strb	r3, [r4, #7]

  // toggle chip select and set slow SPI clock.
  chipSelectLow();
    e616:	1c20      	adds	r0, r4, #0
    e618:	f7ff ff5f 	bl	e4da <_ZN9SdSpiCard13chipSelectLowEv>
  chipSelectHigh();
    e61c:	1c20      	adds	r0, r4, #0
    e61e:	f7ff ff49 	bl	e4b4 <_ZN9SdSpiCard14chipSelectHighEv>
    e622:	260a      	movs	r6, #10
    e624:	3e01      	subs	r6, #1
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spi->receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spi->send(data);
    e626:	6820      	ldr	r0, [r4, #0]
    e628:	21ff      	movs	r1, #255	; 0xff
    e62a:	b2f6      	uxtb	r6, r6
    e62c:	f000 fa66 	bl	eafc <_ZN5SdSpi4sendEh>

  // must supply min of 74 clock cycles with CS high.
  for (uint8_t i = 0; i < 10; i++) {
    e630:	2e00      	cmp	r6, #0
    e632:	d1f7      	bne.n	e624 <_ZN9SdSpiCard5beginEP5SdSpihh+0x30>
    spiSend(0XFF);
  }
  // command to go idle in SPI mode
  while (cardCommand(CMD0, 0) != R1_IDLE_STATE) {
    e634:	2100      	movs	r1, #0
    e636:	1c20      	adds	r0, r4, #0
    e638:	1c0a      	adds	r2, r1, #0
    e63a:	f7ff ffa3 	bl	e584 <_ZN9SdSpiCard11cardCommandEhm>
    e63e:	2801      	cmp	r0, #1
    e640:	d008      	beq.n	e654 <_ZN9SdSpiCard5beginEP5SdSpihh+0x60>
    if (((unsigned)millis() - t0) > SD_INIT_TIMEOUT) {
    e642:	f000 fe6d 	bl	f320 <millis>
    e646:	23fa      	movs	r3, #250	; 0xfa
    e648:	1b40      	subs	r0, r0, r5
    e64a:	00db      	lsls	r3, r3, #3
    e64c:	4298      	cmp	r0, r3
    e64e:	d9f1      	bls.n	e634 <_ZN9SdSpiCard5beginEP5SdSpihh+0x40>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    e650:	2301      	movs	r3, #1
    e652:	e04a      	b.n	e6ea <_ZN9SdSpiCard5beginEP5SdSpihh+0xf6>
    goto fail;
  }
#endif  // USE_SD_CRC
  // check SD version
  while (1) {
    if (cardCommand(CMD8, 0x1AA) == (R1_ILLEGAL_COMMAND | R1_IDLE_STATE)) {
    e654:	22d5      	movs	r2, #213	; 0xd5
    e656:	1c20      	adds	r0, r4, #0
    e658:	2108      	movs	r1, #8
    e65a:	0052      	lsls	r2, r2, #1
    e65c:	f7ff ff92 	bl	e584 <_ZN9SdSpiCard11cardCommandEhm>
    e660:	2805      	cmp	r0, #5
    e662:	d101      	bne.n	e668 <_ZN9SdSpiCard5beginEP5SdSpihh+0x74>
  }
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void type(uint8_t value) {
    m_type = value;
    e664:	2301      	movs	r3, #1
    e666:	e00b      	b.n	e680 <_ZN9SdSpiCard5beginEP5SdSpihh+0x8c>
    e668:	2604      	movs	r6, #4
  }
  void spiEndTransaction() {
    m_spi->endTransaction();
  }
  uint8_t spiReceive() {
    return m_spi->receive();
    e66a:	6820      	ldr	r0, [r4, #0]
    e66c:	f000 f9ca 	bl	ea04 <_ZN5SdSpi7receiveEv>
    e670:	3e01      	subs	r6, #1
    e672:	b2f6      	uxtb	r6, r6
      type(SD_CARD_TYPE_SD1);
      break;
    }
    for (uint8_t i = 0; i < 4; i++) {
      m_status = spiReceive();
    e674:	7220      	strb	r0, [r4, #8]
  while (1) {
    if (cardCommand(CMD8, 0x1AA) == (R1_ILLEGAL_COMMAND | R1_IDLE_STATE)) {
      type(SD_CARD_TYPE_SD1);
      break;
    }
    for (uint8_t i = 0; i < 4; i++) {
    e676:	2e00      	cmp	r6, #0
    e678:	d1f7      	bne.n	e66a <_ZN9SdSpiCard5beginEP5SdSpihh+0x76>
      m_status = spiReceive();
    }
    if (m_status == 0XAA) {
    e67a:	28aa      	cmp	r0, #170	; 0xaa
    e67c:	d107      	bne.n	e68e <_ZN9SdSpiCard5beginEP5SdSpihh+0x9a>
  }
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void type(uint8_t value) {
    m_type = value;
    e67e:	2302      	movs	r3, #2
    e680:	7263      	strb	r3, [r4, #9]
      error(SD_CARD_ERROR_CMD8);
      goto fail;
    }
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
    e682:	7a66      	ldrb	r6, [r4, #9]
    e684:	3e02      	subs	r6, #2
    e686:	4273      	negs	r3, r6
    e688:	415e      	adcs	r6, r3
    e68a:	07b6      	lsls	r6, r6, #30

  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    e68c:	e008      	b.n	e6a0 <_ZN9SdSpiCard5beginEP5SdSpihh+0xac>
    }
    if (m_status == 0XAA) {
      type(SD_CARD_TYPE_SD2);
      break;
    }
    if (((unsigned)millis() - t0) > SD_INIT_TIMEOUT) {
    e68e:	f000 fe47 	bl	f320 <millis>
    e692:	23fa      	movs	r3, #250	; 0xfa
    e694:	1b40      	subs	r0, r0, r5
    e696:	00db      	lsls	r3, r3, #3
    e698:	4298      	cmp	r0, r3
    e69a:	d9db      	bls.n	e654 <_ZN9SdSpiCard5beginEP5SdSpihh+0x60>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    e69c:	2302      	movs	r3, #2
    e69e:	e024      	b.n	e6ea <_ZN9SdSpiCard5beginEP5SdSpihh+0xf6>
  bool writeStop();

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    cardCommand(CMD55, 0);
    e6a0:	2137      	movs	r1, #55	; 0x37
    e6a2:	2200      	movs	r2, #0
    e6a4:	1c20      	adds	r0, r4, #0
    e6a6:	f7ff ff6d 	bl	e584 <_ZN9SdSpiCard11cardCommandEhm>
    return cardCommand(cmd, arg);
    e6aa:	1c32      	adds	r2, r6, #0
    e6ac:	1c20      	adds	r0, r4, #0
    e6ae:	2129      	movs	r1, #41	; 0x29
    e6b0:	f7ff ff68 	bl	e584 <_ZN9SdSpiCard11cardCommandEhm>
    e6b4:	1e02      	subs	r2, r0, #0
    }
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;

  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    e6b6:	d008      	beq.n	e6ca <_ZN9SdSpiCard5beginEP5SdSpihh+0xd6>
    // check for timeout
    if (((unsigned)millis() - t0) > SD_INIT_TIMEOUT) {
    e6b8:	f000 fe32 	bl	f320 <millis>
    e6bc:	23fa      	movs	r3, #250	; 0xfa
    e6be:	1b40      	subs	r0, r0, r5
    e6c0:	00db      	lsls	r3, r3, #3
    e6c2:	4298      	cmp	r0, r3
    e6c4:	d9ec      	bls.n	e6a0 <_ZN9SdSpiCard5beginEP5SdSpihh+0xac>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    e6c6:	230a      	movs	r3, #10
    e6c8:	e00f      	b.n	e6ea <_ZN9SdSpiCard5beginEP5SdSpihh+0xf6>
      error(SD_CARD_ERROR_ACMD41);
      goto fail;
    }
  }
  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    e6ca:	7a63      	ldrb	r3, [r4, #9]
    e6cc:	2b02      	cmp	r3, #2
    e6ce:	d005      	beq.n	e6dc <_ZN9SdSpiCard5beginEP5SdSpihh+0xe8>
    // Discard rest of ocr - contains allowed voltage range.
    for (uint8_t i = 0; i < 3; i++) {
      spiReceive();
    }
  }
  chipSelectHigh();
    e6d0:	1c20      	adds	r0, r4, #0
    e6d2:	f7ff feef 	bl	e4b4 <_ZN9SdSpiCard14chipSelectHighEv>
  m_sckDivisor = sckDivisor;
    e6d6:	71e7      	strb	r7, [r4, #7]
  return true;
    e6d8:	2001      	movs	r0, #1
    e6da:	e01f      	b.n	e71c <_ZN9SdSpiCard5beginEP5SdSpihh+0x128>
      goto fail;
    }
  }
  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
    e6dc:	1c20      	adds	r0, r4, #0
    e6de:	213a      	movs	r1, #58	; 0x3a
    e6e0:	f7ff ff50 	bl	e584 <_ZN9SdSpiCard11cardCommandEhm>
    e6e4:	2800      	cmp	r0, #0
    e6e6:	d006      	beq.n	e6f6 <_ZN9SdSpiCard5beginEP5SdSpihh+0x102>
    e6e8:	2308      	movs	r3, #8
  chipSelectHigh();
  m_sckDivisor = sckDivisor;
  return true;

fail:
  chipSelectHigh();
    e6ea:	1c20      	adds	r0, r4, #0
    e6ec:	71a3      	strb	r3, [r4, #6]
    e6ee:	f7ff fee1 	bl	e4b4 <_ZN9SdSpiCard14chipSelectHighEv>
  return false;
    e6f2:	2000      	movs	r0, #0
    e6f4:	e012      	b.n	e71c <_ZN9SdSpiCard5beginEP5SdSpihh+0x128>
  }
  void spiEndTransaction() {
    m_spi->endTransaction();
  }
  uint8_t spiReceive() {
    return m_spi->receive();
    e6f6:	6820      	ldr	r0, [r4, #0]
    e6f8:	f000 f984 	bl	ea04 <_ZN5SdSpi7receiveEv>
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
      error(SD_CARD_ERROR_CMD58);
      goto fail;
    }
    if ((spiReceive() & 0XC0) == 0XC0) {
    e6fc:	23c0      	movs	r3, #192	; 0xc0
    e6fe:	4018      	ands	r0, r3
    e700:	4298      	cmp	r0, r3
    e702:	d101      	bne.n	e708 <_ZN9SdSpiCard5beginEP5SdSpihh+0x114>
  }
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void type(uint8_t value) {
    m_type = value;
    e704:	2303      	movs	r3, #3
    e706:	7263      	strb	r3, [r4, #9]
  }
  void spiEndTransaction() {
    m_spi->endTransaction();
  }
  uint8_t spiReceive() {
    return m_spi->receive();
    e708:	6820      	ldr	r0, [r4, #0]
    e70a:	f000 f97b 	bl	ea04 <_ZN5SdSpi7receiveEv>
    e70e:	6820      	ldr	r0, [r4, #0]
    e710:	f000 f978 	bl	ea04 <_ZN5SdSpi7receiveEv>
    e714:	6820      	ldr	r0, [r4, #0]
    e716:	f000 f975 	bl	ea04 <_ZN5SdSpi7receiveEv>
    e71a:	e7d9      	b.n	e6d0 <_ZN9SdSpiCard5beginEP5SdSpihh+0xdc>
  return true;

fail:
  chipSelectHigh();
  return false;
}
    e71c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000e71e <_ZN9SdSpiCard9readBlockEmPh>:
    chipSelectHigh();
  }
  return rtn;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readBlock(uint32_t blockNumber, uint8_t* dst) {
    e71e:	b538      	push	{r3, r4, r5, lr}
    e720:	1c15      	adds	r5, r2, #0
  SD_TRACE("RB", blockNumber);
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    e722:	7a42      	ldrb	r2, [r0, #9]
    chipSelectHigh();
  }
  return rtn;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readBlock(uint32_t blockNumber, uint8_t* dst) {
    e724:	1c04      	adds	r4, r0, #0
    e726:	1c0b      	adds	r3, r1, #0
  SD_TRACE("RB", blockNumber);
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    e728:	2a03      	cmp	r2, #3
    e72a:	d000      	beq.n	e72e <_ZN9SdSpiCard9readBlockEmPh+0x10>
    blockNumber <<= 9;
    e72c:	024b      	lsls	r3, r1, #9
  }
  if (cardCommand(CMD17, blockNumber)) {
    e72e:	1c20      	adds	r0, r4, #0
    e730:	2111      	movs	r1, #17
    e732:	1c1a      	adds	r2, r3, #0
    e734:	f7ff ff26 	bl	e584 <_ZN9SdSpiCard11cardCommandEhm>
    e738:	2800      	cmp	r0, #0
    e73a:	d002      	beq.n	e742 <_ZN9SdSpiCard9readBlockEmPh+0x24>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    e73c:	2304      	movs	r3, #4
    e73e:	71a3      	strb	r3, [r4, #6]
    e740:	e00b      	b.n	e75a <_ZN9SdSpiCard9readBlockEmPh+0x3c>
    error(SD_CARD_ERROR_CMD17);
    goto fail;
  }
  if (!readData(dst, 512)) {
    e742:	2280      	movs	r2, #128	; 0x80
    e744:	1c29      	adds	r1, r5, #0
    e746:	1c20      	adds	r0, r4, #0
    e748:	0092      	lsls	r2, r2, #2
    e74a:	f7ff fed6 	bl	e4fa <_ZN9SdSpiCard8readDataEPhj>
    e74e:	1e05      	subs	r5, r0, #0
    e750:	d003      	beq.n	e75a <_ZN9SdSpiCard9readBlockEmPh+0x3c>
    goto fail;
  }
  chipSelectHigh();
    e752:	1c20      	adds	r0, r4, #0
    e754:	f7ff feae 	bl	e4b4 <_ZN9SdSpiCard14chipSelectHighEv>
  return true;
    e758:	e003      	b.n	e762 <_ZN9SdSpiCard9readBlockEmPh+0x44>

fail:
  chipSelectHigh();
    e75a:	1c20      	adds	r0, r4, #0
    e75c:	f7ff feaa 	bl	e4b4 <_ZN9SdSpiCard14chipSelectHighEv>
  return false;
    e760:	2500      	movs	r5, #0
}
    e762:	1c28      	adds	r0, r5, #0
    e764:	bd38      	pop	{r3, r4, r5, pc}

0000e766 <_ZN9SdSpiCard9readStartEm>:
fail:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t blockNumber) {
    e766:	b510      	push	{r4, lr}
  SD_TRACE("RS", blockNumber);
  if (type() != SD_CARD_TYPE_SDHC) {
    e768:	7a43      	ldrb	r3, [r0, #9]
fail:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t blockNumber) {
    e76a:	1c04      	adds	r4, r0, #0
    e76c:	1c0a      	adds	r2, r1, #0
  SD_TRACE("RS", blockNumber);
  if (type() != SD_CARD_TYPE_SDHC) {
    e76e:	2b03      	cmp	r3, #3
    e770:	d000      	beq.n	e774 <_ZN9SdSpiCard9readStartEm+0xe>
    blockNumber <<= 9;
    e772:	024a      	lsls	r2, r1, #9
  }
  if (cardCommand(CMD18, blockNumber)) {
    e774:	1c20      	adds	r0, r4, #0
    e776:	2112      	movs	r1, #18
    e778:	f7ff ff04 	bl	e584 <_ZN9SdSpiCard11cardCommandEhm>
    error(SD_CARD_ERROR_CMD18);
    goto fail;
  }
  return true;
    e77c:	2301      	movs	r3, #1
bool SdSpiCard::readStart(uint32_t blockNumber) {
  SD_TRACE("RS", blockNumber);
  if (type() != SD_CARD_TYPE_SDHC) {
    blockNumber <<= 9;
  }
  if (cardCommand(CMD18, blockNumber)) {
    e77e:	2800      	cmp	r0, #0
    e780:	d005      	beq.n	e78e <_ZN9SdSpiCard9readStartEm+0x28>
    e782:	2305      	movs	r3, #5
    e784:	71a3      	strb	r3, [r4, #6]
    goto fail;
  }
  return true;

fail:
  chipSelectHigh();
    e786:	1c20      	adds	r0, r4, #0
    e788:	f7ff fe94 	bl	e4b4 <_ZN9SdSpiCard14chipSelectHighEv>
  return false;
    e78c:	2300      	movs	r3, #0
}
    e78e:	1c18      	adds	r0, r3, #0
    e790:	bd10      	pop	{r4, pc}

0000e792 <_ZN9SdSpiCard8readStopEv>:
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    e792:	b510      	push	{r4, lr}
  if (cardCommand(CMD12, 0)) {
    e794:	210c      	movs	r1, #12
    e796:	2200      	movs	r2, #0
fail:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    e798:	1c04      	adds	r4, r0, #0
  if (cardCommand(CMD12, 0)) {
    e79a:	f7ff fef3 	bl	e584 <_ZN9SdSpiCard11cardCommandEhm>
    e79e:	2800      	cmp	r0, #0
    e7a0:	d006      	beq.n	e7b0 <_ZN9SdSpiCard8readStopEv+0x1e>
    e7a2:	2303      	movs	r3, #3
  }
  chipSelectHigh();
  return true;

fail:
  chipSelectHigh();
    e7a4:	1c20      	adds	r0, r4, #0
    e7a6:	71a3      	strb	r3, [r4, #6]
    e7a8:	f7ff fe84 	bl	e4b4 <_ZN9SdSpiCard14chipSelectHighEv>
  return false;
    e7ac:	2000      	movs	r0, #0
    e7ae:	e003      	b.n	e7b8 <_ZN9SdSpiCard8readStopEv+0x26>
bool SdSpiCard::readStop() {
  if (cardCommand(CMD12, 0)) {
    error(SD_CARD_ERROR_CMD12);
    goto fail;
  }
  chipSelectHigh();
    e7b0:	1c20      	adds	r0, r4, #0
    e7b2:	f7ff fe7f 	bl	e4b4 <_ZN9SdSpiCard14chipSelectHighEv>
  return true;
    e7b6:	2001      	movs	r0, #1

fail:
  chipSelectHigh();
  return false;
}
    e7b8:	bd10      	pop	{r4, pc}

0000e7ba <_ZN9SdSpiCard10readBlocksEmPhj>:
fail:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readBlocks(uint32_t block, uint8_t* dst, size_t count) {
    e7ba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e7bc:	1c04      	adds	r4, r0, #0
    e7be:	1c16      	adds	r6, r2, #0
    e7c0:	1c1f      	adds	r7, r3, #0
  if (!readStart(block)) {
    e7c2:	f7ff ffd0 	bl	e766 <_ZN9SdSpiCard9readStartEm>
    e7c6:	2500      	movs	r5, #0
    e7c8:	2800      	cmp	r0, #0
    e7ca:	d10d      	bne.n	e7e8 <_ZN9SdSpiCard10readBlocksEmPhj+0x2e>
    return false;
    e7cc:	2000      	movs	r0, #0
    e7ce:	e010      	b.n	e7f2 <_ZN9SdSpiCard10readBlocksEmPhj+0x38>
  }
  for (uint16_t b = 0; b < count; b++, dst += 512) {
    if (!readData(dst, 512)) {
    e7d0:	2280      	movs	r2, #128	; 0x80
    e7d2:	1c31      	adds	r1, r6, #0
    e7d4:	0092      	lsls	r2, r2, #2
    e7d6:	f7ff fe90 	bl	e4fa <_ZN9SdSpiCard8readDataEPhj>
    e7da:	2800      	cmp	r0, #0
    e7dc:	d0f6      	beq.n	e7cc <_ZN9SdSpiCard10readBlocksEmPhj+0x12>
//------------------------------------------------------------------------------
bool SdSpiCard::readBlocks(uint32_t block, uint8_t* dst, size_t count) {
  if (!readStart(block)) {
    return false;
  }
  for (uint16_t b = 0; b < count; b++, dst += 512) {
    e7de:	2380      	movs	r3, #128	; 0x80
    e7e0:	3501      	adds	r5, #1
    e7e2:	009b      	lsls	r3, r3, #2
    e7e4:	b2ad      	uxth	r5, r5
    e7e6:	18f6      	adds	r6, r6, r3
    if (!readData(dst, 512)) {
    e7e8:	1c20      	adds	r0, r4, #0
//------------------------------------------------------------------------------
bool SdSpiCard::readBlocks(uint32_t block, uint8_t* dst, size_t count) {
  if (!readStart(block)) {
    return false;
  }
  for (uint16_t b = 0; b < count; b++, dst += 512) {
    e7ea:	42bd      	cmp	r5, r7
    e7ec:	d3f0      	bcc.n	e7d0 <_ZN9SdSpiCard10readBlocksEmPhj+0x16>
    if (!readData(dst, 512)) {
      return false;
    }
  }
  return readStop();
    e7ee:	f7ff ffd0 	bl	e792 <_ZN9SdSpiCard8readStopEv>
}
    e7f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000e7f4 <_ZN9SdSpiCard9writeDataEhPKh>:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
// send one block of data for write block or write multiple blocks
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    e7f4:	b538      	push	{r3, r4, r5, lr}
    e7f6:	1c04      	adds	r4, r0, #0
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spi->receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spi->send(data);
    e7f8:	6800      	ldr	r0, [r0, #0]
    e7fa:	1c15      	adds	r5, r2, #0
    e7fc:	f000 f97e 	bl	eafc <_ZN5SdSpi4sendEh>
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spi->send(buf, n);
    e800:	2280      	movs	r2, #128	; 0x80
    e802:	0092      	lsls	r2, r2, #2
    e804:	6820      	ldr	r0, [r4, #0]
    e806:	1c29      	adds	r1, r5, #0
    e808:	f000 f980 	bl	eb0c <_ZN5SdSpi4sendEPKhj>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spi->receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spi->send(data);
    e80c:	6820      	ldr	r0, [r4, #0]
    e80e:	21ff      	movs	r1, #255	; 0xff
    e810:	f000 f974 	bl	eafc <_ZN5SdSpi4sendEh>
    e814:	6820      	ldr	r0, [r4, #0]
    e816:	21ff      	movs	r1, #255	; 0xff
    e818:	f000 f970 	bl	eafc <_ZN5SdSpi4sendEh>
  }
  void spiEndTransaction() {
    m_spi->endTransaction();
  }
  uint8_t spiReceive() {
    return m_spi->receive();
    e81c:	6820      	ldr	r0, [r4, #0]
    e81e:	f000 f8f1 	bl	ea04 <_ZN5SdSpi7receiveEv>
  spiSend(src, 512);
  spiSend(crc >> 8);
  spiSend(crc & 0XFF);

  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    e822:	231f      	movs	r3, #31
  spiSend(token);
  spiSend(src, 512);
  spiSend(crc >> 8);
  spiSend(crc & 0XFF);

  m_status = spiReceive();
    e824:	7220      	strb	r0, [r4, #8]
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    e826:	4003      	ands	r3, r0
    error(SD_CARD_ERROR_WRITE);
    goto fail;
  }
  return true;
    e828:	2001      	movs	r0, #1
  spiSend(src, 512);
  spiSend(crc >> 8);
  spiSend(crc & 0XFF);

  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    e82a:	2b05      	cmp	r3, #5
    e82c:	d005      	beq.n	e83a <_ZN9SdSpiCard9writeDataEhPKh+0x46>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    e82e:	2313      	movs	r3, #19
    goto fail;
  }
  return true;

fail:
  chipSelectHigh();
    e830:	1c20      	adds	r0, r4, #0
    e832:	71a3      	strb	r3, [r4, #6]
    e834:	f7ff fe3e 	bl	e4b4 <_ZN9SdSpiCard14chipSelectHighEv>
  return false;
    e838:	2000      	movs	r0, #0
}
    e83a:	bd38      	pop	{r3, r4, r5, pc}

0000e83c <_ZN9SdSpiCard10writeBlockEmPKh>:

fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeBlock(uint32_t blockNumber, const uint8_t* src) {
    e83c:	b538      	push	{r3, r4, r5, lr}
    e83e:	1c15      	adds	r5, r2, #0
  SD_TRACE("WB", blockNumber);
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    e840:	7a42      	ldrb	r2, [r0, #9]

fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeBlock(uint32_t blockNumber, const uint8_t* src) {
    e842:	1c04      	adds	r4, r0, #0
    e844:	1c0b      	adds	r3, r1, #0
  SD_TRACE("WB", blockNumber);
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    e846:	2a03      	cmp	r2, #3
    e848:	d000      	beq.n	e84c <_ZN9SdSpiCard10writeBlockEmPKh+0x10>
    blockNumber <<= 9;
    e84a:	024b      	lsls	r3, r1, #9
  }
  if (cardCommand(CMD24, blockNumber)) {
    e84c:	1c20      	adds	r0, r4, #0
    e84e:	2118      	movs	r1, #24
    e850:	1c1a      	adds	r2, r3, #0
    e852:	f7ff fe97 	bl	e584 <_ZN9SdSpiCard11cardCommandEhm>
    e856:	2800      	cmp	r0, #0
    e858:	d002      	beq.n	e860 <_ZN9SdSpiCard10writeBlockEmPKh+0x24>
    e85a:	2306      	movs	r3, #6
    e85c:	71a3      	strb	r3, [r4, #6]
    e85e:	e00a      	b.n	e876 <_ZN9SdSpiCard10writeBlockEmPKh+0x3a>
    error(SD_CARD_ERROR_CMD24);
    goto fail;
  }
  if (!writeData(DATA_START_BLOCK, src)) {
    e860:	1c2a      	adds	r2, r5, #0
    e862:	1c20      	adds	r0, r4, #0
    e864:	21fe      	movs	r1, #254	; 0xfe
    e866:	f7ff ffc5 	bl	e7f4 <_ZN9SdSpiCard9writeDataEhPKh>
    e86a:	1e05      	subs	r5, r0, #0
    e86c:	d003      	beq.n	e876 <_ZN9SdSpiCard10writeBlockEmPKh+0x3a>
    error(SD_CARD_ERROR_WRITE_PROGRAMMING);
    goto fail;
  }
#endif  // CHECK_PROGRAMMING

  chipSelectHigh();
    e86e:	1c20      	adds	r0, r4, #0
    e870:	f7ff fe20 	bl	e4b4 <_ZN9SdSpiCard14chipSelectHighEv>
  return true;
    e874:	e003      	b.n	e87e <_ZN9SdSpiCard10writeBlockEmPKh+0x42>

fail:
  chipSelectHigh();
    e876:	1c20      	adds	r0, r4, #0
    e878:	f7ff fe1c 	bl	e4b4 <_ZN9SdSpiCard14chipSelectHighEv>
  return false;
    e87c:	2500      	movs	r5, #0
}
    e87e:	1c28      	adds	r0, r5, #0
    e880:	bd38      	pop	{r3, r4, r5, pc}

0000e882 <_ZN9SdSpiCard9writeDataEPKh>:
 fail:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    e882:	b538      	push	{r3, r4, r5, lr}
    e884:	1c0d      	adds	r5, r1, #0
  // wait for previous write to finish
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    e886:	2196      	movs	r1, #150	; 0x96
    e888:	0089      	lsls	r1, r1, #2
 fail:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    e88a:	1c04      	adds	r4, r0, #0
  // wait for previous write to finish
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    e88c:	f7ff fe66 	bl	e55c <_ZN9SdSpiCard11waitNotBusyEt>
    e890:	2800      	cmp	r0, #0
    e892:	d102      	bne.n	e89a <_ZN9SdSpiCard9writeDataEPKh+0x18>
    e894:	2317      	movs	r3, #23
    e896:	71a3      	strb	r3, [r4, #6]
    e898:	e006      	b.n	e8a8 <_ZN9SdSpiCard9writeDataEPKh+0x26>
    error(SD_CARD_ERROR_WRITE_TIMEOUT);
    goto fail;
  }
  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) {
    e89a:	1c20      	adds	r0, r4, #0
    e89c:	21fc      	movs	r1, #252	; 0xfc
    e89e:	1c2a      	adds	r2, r5, #0
    e8a0:	f7ff ffa8 	bl	e7f4 <_ZN9SdSpiCard9writeDataEhPKh>
    e8a4:	2800      	cmp	r0, #0
    e8a6:	d103      	bne.n	e8b0 <_ZN9SdSpiCard9writeDataEPKh+0x2e>
    goto fail;
  }
  return true;

fail:
  chipSelectHigh();
    e8a8:	1c20      	adds	r0, r4, #0
    e8aa:	f7ff fe03 	bl	e4b4 <_ZN9SdSpiCard14chipSelectHighEv>
  return false;
    e8ae:	2000      	movs	r0, #0
}
    e8b0:	bd38      	pop	{r3, r4, r5, pc}

0000e8b2 <_ZN9SdSpiCard10writeStartEmm>:
fail:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t blockNumber, uint32_t eraseCount) {
    e8b2:	b570      	push	{r4, r5, r6, lr}
    e8b4:	1c04      	adds	r4, r0, #0
    e8b6:	1c16      	adds	r6, r2, #0
    e8b8:	1c0d      	adds	r5, r1, #0
  bool writeStop();

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    cardCommand(CMD55, 0);
    e8ba:	2200      	movs	r2, #0
    e8bc:	2137      	movs	r1, #55	; 0x37
    e8be:	f7ff fe61 	bl	e584 <_ZN9SdSpiCard11cardCommandEhm>
    return cardCommand(cmd, arg);
    e8c2:	1c20      	adds	r0, r4, #0
    e8c4:	2117      	movs	r1, #23
    e8c6:	1c32      	adds	r2, r6, #0
    e8c8:	f7ff fe5c 	bl	e584 <_ZN9SdSpiCard11cardCommandEhm>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    e8cc:	2309      	movs	r3, #9
  SD_TRACE("WS", blockNumber);
  // send pre-erase count
  if (cardAcmd(ACMD23, eraseCount)) {
    e8ce:	2800      	cmp	r0, #0
    e8d0:	d10c      	bne.n	e8ec <_ZN9SdSpiCard10writeStartEmm+0x3a>
    error(SD_CARD_ERROR_ACMD23);
    goto fail;
  }
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    e8d2:	7a63      	ldrb	r3, [r4, #9]
    e8d4:	2b03      	cmp	r3, #3
    e8d6:	d000      	beq.n	e8da <_ZN9SdSpiCard10writeStartEmm+0x28>
    blockNumber <<= 9;
    e8d8:	026d      	lsls	r5, r5, #9
  }
  if (cardCommand(CMD25, blockNumber)) {
    e8da:	1c20      	adds	r0, r4, #0
    e8dc:	2119      	movs	r1, #25
    e8de:	1c2a      	adds	r2, r5, #0
    e8e0:	f7ff fe50 	bl	e584 <_ZN9SdSpiCard11cardCommandEhm>
    error(SD_CARD_ERROR_CMD25);
    goto fail;
  }
  return true;
    e8e4:	2301      	movs	r3, #1
  }
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    blockNumber <<= 9;
  }
  if (cardCommand(CMD25, blockNumber)) {
    e8e6:	2800      	cmp	r0, #0
    e8e8:	d005      	beq.n	e8f6 <_ZN9SdSpiCard10writeStartEmm+0x44>
    e8ea:	2307      	movs	r3, #7
    e8ec:	71a3      	strb	r3, [r4, #6]
    goto fail;
  }
  return true;

fail:
  chipSelectHigh();
    e8ee:	1c20      	adds	r0, r4, #0
    e8f0:	f7ff fde0 	bl	e4b4 <_ZN9SdSpiCard14chipSelectHighEv>
  return false;
    e8f4:	2300      	movs	r3, #0
}
    e8f6:	1c18      	adds	r0, r3, #0
    e8f8:	bd70      	pop	{r4, r5, r6, pc}

0000e8fa <_ZN9SdSpiCard9writeStopEv>:
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    e8fa:	2196      	movs	r1, #150	; 0x96
fail:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    e8fc:	b538      	push	{r3, r4, r5, lr}
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    e8fe:	0089      	lsls	r1, r1, #2
fail:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    e900:	1c04      	adds	r4, r0, #0
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    e902:	f7ff fe2b 	bl	e55c <_ZN9SdSpiCard11waitNotBusyEt>
    e906:	2800      	cmp	r0, #0
    e908:	d00e      	beq.n	e928 <_ZN9SdSpiCard9writeStopEv+0x2e>
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spi->receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spi->send(data);
    e90a:	6820      	ldr	r0, [r4, #0]
    e90c:	21fd      	movs	r1, #253	; 0xfd
    e90e:	f000 f8f5 	bl	eafc <_ZN5SdSpi4sendEh>
    goto fail;
  }
  spiSend(STOP_TRAN_TOKEN);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    e912:	2196      	movs	r1, #150	; 0x96
    e914:	1c20      	adds	r0, r4, #0
    e916:	0089      	lsls	r1, r1, #2
    e918:	f7ff fe20 	bl	e55c <_ZN9SdSpiCard11waitNotBusyEt>
    e91c:	1e05      	subs	r5, r0, #0
    e91e:	d003      	beq.n	e928 <_ZN9SdSpiCard9writeStopEv+0x2e>
    goto fail;
  }
  chipSelectHigh();
    e920:	1c20      	adds	r0, r4, #0
    e922:	f7ff fdc7 	bl	e4b4 <_ZN9SdSpiCard14chipSelectHighEv>
  return true;
    e926:	e005      	b.n	e934 <_ZN9SdSpiCard9writeStopEv+0x3a>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    e928:	2312      	movs	r3, #18
    e92a:	71a3      	strb	r3, [r4, #6]

fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
    e92c:	1c20      	adds	r0, r4, #0
    e92e:	f7ff fdc1 	bl	e4b4 <_ZN9SdSpiCard14chipSelectHighEv>
  return false;
    e932:	2500      	movs	r5, #0
}
    e934:	1c28      	adds	r0, r5, #0
    e936:	bd38      	pop	{r3, r4, r5, pc}

0000e938 <_ZN9SdSpiCard11writeBlocksEmPKhj>:
fail:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeBlocks(uint32_t block, const uint8_t* src, size_t count) {
    e938:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e93a:	1c17      	adds	r7, r2, #0
  if (!writeStart(block, count)) {
    e93c:	1c1a      	adds	r2, r3, #0
fail:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeBlocks(uint32_t block, const uint8_t* src, size_t count) {
    e93e:	1c04      	adds	r4, r0, #0
    e940:	1c1e      	adds	r6, r3, #0
  if (!writeStart(block, count)) {
    e942:	f7ff ffb6 	bl	e8b2 <_ZN9SdSpiCard10writeStartEmm>
    e946:	2800      	cmp	r0, #0
    e948:	d00e      	beq.n	e968 <_ZN9SdSpiCard11writeBlocksEmPKhj+0x30>
    e94a:	2500      	movs	r5, #0
    e94c:	0269      	lsls	r1, r5, #9
    e94e:	1879      	adds	r1, r7, r1
    goto fail;
  }
  for (size_t b = 0; b < count; b++, src += 512) {
    if (!writeData(src)) {
    e950:	1c20      	adds	r0, r4, #0
//------------------------------------------------------------------------------
bool SdSpiCard::writeBlocks(uint32_t block, const uint8_t* src, size_t count) {
  if (!writeStart(block, count)) {
    goto fail;
  }
  for (size_t b = 0; b < count; b++, src += 512) {
    e952:	42b5      	cmp	r5, r6
    e954:	d005      	beq.n	e962 <_ZN9SdSpiCard11writeBlocksEmPKhj+0x2a>
    if (!writeData(src)) {
    e956:	f7ff ff94 	bl	e882 <_ZN9SdSpiCard9writeDataEPKh>
    e95a:	2800      	cmp	r0, #0
    e95c:	d004      	beq.n	e968 <_ZN9SdSpiCard11writeBlocksEmPKhj+0x30>
//------------------------------------------------------------------------------
bool SdSpiCard::writeBlocks(uint32_t block, const uint8_t* src, size_t count) {
  if (!writeStart(block, count)) {
    goto fail;
  }
  for (size_t b = 0; b < count; b++, src += 512) {
    e95e:	3501      	adds	r5, #1
    e960:	e7f4      	b.n	e94c <_ZN9SdSpiCard11writeBlocksEmPKhj+0x14>
    if (!writeData(src)) {
      goto fail;
    }
  }
  return writeStop();
    e962:	f7ff ffca 	bl	e8fa <_ZN9SdSpiCard9writeStopEv>
    e966:	e003      	b.n	e970 <_ZN9SdSpiCard11writeBlocksEmPKhj+0x38>

 fail:
  chipSelectHigh();
    e968:	1c20      	adds	r0, r4, #0
    e96a:	f7ff fda3 	bl	e4b4 <_ZN9SdSpiCard14chipSelectHighEv>
  return false;
    e96e:	2000      	movs	r0, #0
}
    e970:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0000e974 <_Z15dma_callback_rxP12dma_resource>:
// are we done yet?
volatile bool transfer_rx_done = false;
volatile bool transfer_tx_done = false;
// If you like, a callback can be used
void dma_callback_rx(struct dma_resource* const resource) {
	transfer_rx_done = true;
    e974:	4b01      	ldr	r3, [pc, #4]	; (e97c <_Z15dma_callback_rxP12dma_resource+0x8>)
    e976:	2201      	movs	r2, #1
    e978:	701a      	strb	r2, [r3, #0]
}
    e97a:	4770      	bx	lr
    e97c:	20000d52 	.word	0x20000d52

0000e980 <_Z15dma_callback_txP12dma_resource>:
void dma_callback_tx(struct dma_resource* const resource) {
	transfer_tx_done = true;
    e980:	4b01      	ldr	r3, [pc, #4]	; (e988 <_Z15dma_callback_txP12dma_resource+0x8>)
    e982:	2201      	movs	r2, #1
    e984:	701a      	strb	r2, [r3, #0]
}
    e986:	4770      	bx	lr
    e988:	20000d50 	.word	0x20000d50

0000e98c <_ZN5SdSpi5beginEh>:

static SPISettings mySPISettings;

uint8_t chipSelectPin;

void SdSpi::begin(uint8_t _chipSelectPin) {
    e98c:	b510      	push	{r4, lr}
	chipSelectPin = _chipSelectPin;
    e98e:	4c0a      	ldr	r4, [pc, #40]	; (e9b8 <_ZN5SdSpi5beginEh+0x2c>)
	pinMode(chipSelectPin, OUTPUT);
    e990:	1c08      	adds	r0, r1, #0
static SPISettings mySPISettings;

uint8_t chipSelectPin;

void SdSpi::begin(uint8_t _chipSelectPin) {
	chipSelectPin = _chipSelectPin;
    e992:	7021      	strb	r1, [r4, #0]
	pinMode(chipSelectPin, OUTPUT);
    e994:	2101      	movs	r1, #1
    e996:	f000 ffe7 	bl	f968 <pinMode>
	digitalWrite(chipSelectPin, HIGH);
    e99a:	7820      	ldrb	r0, [r4, #0]
    e99c:	2101      	movs	r1, #1
    e99e:	f001 f83d 	bl	fa1c <digitalWrite>
	SPI.begin();
    e9a2:	4806      	ldr	r0, [pc, #24]	; (e9bc <_ZN5SdSpi5beginEh+0x30>)
    e9a4:	f000 fb9e 	bl	f0e4 <_ZN8SPIClass5beginEv>
	mySPISettings = SPISettings(12000000, MSBFIRST, SPI_MODE0);
    e9a8:	4b05      	ldr	r3, [pc, #20]	; (e9c0 <_ZN5SdSpi5beginEh+0x34>)
    e9aa:	4a06      	ldr	r2, [pc, #24]	; (e9c4 <_ZN5SdSpi5beginEh+0x38>)
    e9ac:	601a      	str	r2, [r3, #0]
    e9ae:	2200      	movs	r2, #0
    e9b0:	711a      	strb	r2, [r3, #4]
    e9b2:	715a      	strb	r2, [r3, #5]
}
    e9b4:	bd10      	pop	{r4, pc}
    e9b6:	46c0      	nop			; (mov r8, r8)
    e9b8:	20000d51 	.word	0x20000d51
    e9bc:	20000e40 	.word	0x20000e40
    e9c0:	20000cf4 	.word	0x20000cf4
    e9c4:	00b71b00 	.word	0x00b71b00

0000e9c8 <_ZN5SdSpi16beginTransactionEh>:

void SdSpi::beginTransaction(uint8_t divisor) {
    e9c8:	b508      	push	{r3, lr}
#ifndef SPI_CLOCK_DIV128
	SPI.setClockDivider(divisor);
#else  // SPI_CLOCK_DIV128
	int v;
	if (divisor <= 2) {
		v = SPI_CLOCK_DIV2;
    e9ca:	2306      	movs	r3, #6
#endif  // ENABLE_SPI_TRANSACTIONS
#ifndef SPI_CLOCK_DIV128
	SPI.setClockDivider(divisor);
#else  // SPI_CLOCK_DIV128
	int v;
	if (divisor <= 2) {
    e9cc:	2902      	cmp	r1, #2
    e9ce:	d90f      	bls.n	e9f0 <_ZN5SdSpi16beginTransactionEh+0x28>
		v = SPI_CLOCK_DIV2;
	} else  if (divisor <= 4) {
		v = SPI_CLOCK_DIV4;
    e9d0:	230c      	movs	r3, #12
	SPI.setClockDivider(divisor);
#else  // SPI_CLOCK_DIV128
	int v;
	if (divisor <= 2) {
		v = SPI_CLOCK_DIV2;
	} else  if (divisor <= 4) {
    e9d2:	2904      	cmp	r1, #4
    e9d4:	d90c      	bls.n	e9f0 <_ZN5SdSpi16beginTransactionEh+0x28>
		v = SPI_CLOCK_DIV4;
	} else  if (divisor <= 8) {
		v = SPI_CLOCK_DIV8;
    e9d6:	2318      	movs	r3, #24
	int v;
	if (divisor <= 2) {
		v = SPI_CLOCK_DIV2;
	} else  if (divisor <= 4) {
		v = SPI_CLOCK_DIV4;
	} else  if (divisor <= 8) {
    e9d8:	2908      	cmp	r1, #8
    e9da:	d909      	bls.n	e9f0 <_ZN5SdSpi16beginTransactionEh+0x28>
		v = SPI_CLOCK_DIV8;
	} else  if (divisor <= 16) {
		v = SPI_CLOCK_DIV16;
    e9dc:	2330      	movs	r3, #48	; 0x30
		v = SPI_CLOCK_DIV2;
	} else  if (divisor <= 4) {
		v = SPI_CLOCK_DIV4;
	} else  if (divisor <= 8) {
		v = SPI_CLOCK_DIV8;
	} else  if (divisor <= 16) {
    e9de:	2910      	cmp	r1, #16
    e9e0:	d906      	bls.n	e9f0 <_ZN5SdSpi16beginTransactionEh+0x28>
		v = SPI_CLOCK_DIV16;
	} else  if (divisor <= 32) {
		v = SPI_CLOCK_DIV32;
    e9e2:	2360      	movs	r3, #96	; 0x60
		v = SPI_CLOCK_DIV4;
	} else  if (divisor <= 8) {
		v = SPI_CLOCK_DIV8;
	} else  if (divisor <= 16) {
		v = SPI_CLOCK_DIV16;
	} else  if (divisor <= 32) {
    e9e4:	2920      	cmp	r1, #32
    e9e6:	d903      	bls.n	e9f0 <_ZN5SdSpi16beginTransactionEh+0x28>
		v = SPI_CLOCK_DIV32;
	} else  if (divisor <= 64) {
		v = SPI_CLOCK_DIV64;
	} else {
		v = SPI_CLOCK_DIV128;
    e9e8:	23ff      	movs	r3, #255	; 0xff
		v = SPI_CLOCK_DIV8;
	} else  if (divisor <= 16) {
		v = SPI_CLOCK_DIV16;
	} else  if (divisor <= 32) {
		v = SPI_CLOCK_DIV32;
	} else  if (divisor <= 64) {
    e9ea:	2940      	cmp	r1, #64	; 0x40
    e9ec:	d800      	bhi.n	e9f0 <_ZN5SdSpi16beginTransactionEh+0x28>
		v = SPI_CLOCK_DIV64;
    e9ee:	23c0      	movs	r3, #192	; 0xc0
	} else {
		v = SPI_CLOCK_DIV128;
	}
	SPI.setClockDivider(v);
    e9f0:	b2d9      	uxtb	r1, r3
    e9f2:	4802      	ldr	r0, [pc, #8]	; (e9fc <_ZN5SdSpi16beginTransactionEh+0x34>)
    e9f4:	f000 fbcc 	bl	f190 <_ZN8SPIClass15setClockDividerEh>
#endif  // SPI_CLOCK_DIV128
}
    e9f8:	bd08      	pop	{r3, pc}
    e9fa:	46c0      	nop			; (mov r8, r8)
    e9fc:	20000e40 	.word	0x20000e40

0000ea00 <_ZN5SdSpi14endTransactionEv>:

void SdSpi::endTransaction() {
#if ENABLE_SPI_TRANSACTIONS
	SPI.endTransaction();
#endif  // ENABLE_SPI_TRANSACTIONS
}
    ea00:	4770      	bx	lr
	...

0000ea04 <_ZN5SdSpi7receiveEv>:

// no DMA needed here
uint8_t SdSpi::receive() {
    ea04:	b508      	push	{r3, lr}
	return SPI.transfer(0XFF);
    ea06:	4802      	ldr	r0, [pc, #8]	; (ea10 <_ZN5SdSpi7receiveEv+0xc>)
    ea08:	21ff      	movs	r1, #255	; 0xff
    ea0a:	f000 fbc9 	bl	f1a0 <_ZN8SPIClass8transferEh>
}
    ea0e:	bd08      	pop	{r3, pc}
    ea10:	20000e40 	.word	0x20000e40

0000ea14 <_ZN5SdSpi7receiveEPhj>:

uint8_t SdSpi::receive(uint8_t* buf, size_t n) {
    ea14:	b5f0      	push	{r4, r5, r6, r7, lr}
	myDMA.configure_peripheraltrigger(SERCOM4_DMAC_ID_TX);
    ea16:	4d32      	ldr	r5, [pc, #200]	; (eae0 <_ZN5SdSpi7receiveEPhj+0xcc>)
// no DMA needed here
uint8_t SdSpi::receive() {
	return SPI.transfer(0XFF);
}

uint8_t SdSpi::receive(uint8_t* buf, size_t n) {
    ea18:	b089      	sub	sp, #36	; 0x24
    ea1a:	9105      	str	r1, [sp, #20]
	myDMA.configure_peripheraltrigger(SERCOM4_DMAC_ID_TX);
    ea1c:	1c28      	adds	r0, r5, #0
    ea1e:	210a      	movs	r1, #10
// no DMA needed here
uint8_t SdSpi::receive() {
	return SPI.transfer(0XFF);
}

uint8_t SdSpi::receive(uint8_t* buf, size_t n) {
    ea20:	9204      	str	r2, [sp, #16]
	myDMA.configure_peripheraltrigger(SERCOM4_DMAC_ID_TX);
    ea22:	f7f8 fe8a 	bl	773a <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA27configure_peripheraltriggerEm>
	myDMA.configure_triggeraction(DMA_TRIGGER_ACTON_BEAT);
    ea26:	2102      	movs	r1, #2
    ea28:	1c28      	adds	r0, r5, #0
    ea2a:	f7f8 fe88 	bl	773e <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA23configure_triggeractionE27dma_transfer_trigger_action>
	myDMA.allocate();
    ea2e:	1c28      	adds	r0, r5, #0
    ea30:	f7f8 fe87 	bl	7742 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA8allocateEv>
	uint8_t b = 0xFF;
    ea34:	4669      	mov	r1, sp
		(void *)(&SERCOM4->SPI.DATA.reg), // to here
		n, // this many
		DMA_BEAT_SIZE_BYTE, // 8 bits
		false, // increment source addr?
		false // increment dest addr?
	);
    ea36:	2600      	movs	r6, #0

uint8_t SdSpi::receive(uint8_t* buf, size_t n) {
	myDMA.configure_peripheraltrigger(SERCOM4_DMAC_ID_TX);
	myDMA.configure_triggeraction(DMA_TRIGGER_ACTON_BEAT);
	myDMA.allocate();
	uint8_t b = 0xFF;
    ea38:	311f      	adds	r1, #31
    ea3a:	23ff      	movs	r3, #255	; 0xff
    ea3c:	700b      	strb	r3, [r1, #0]
		(void *)(&SERCOM4->SPI.DATA.reg), // to here
		n, // this many
		DMA_BEAT_SIZE_BYTE, // 8 bits
		false, // increment source addr?
		false // increment dest addr?
	);
    ea3e:	4a29      	ldr	r2, [pc, #164]	; (eae4 <_ZN5SdSpi7receiveEPhj+0xd0>)
    ea40:	9b04      	ldr	r3, [sp, #16]
    ea42:	1c28      	adds	r0, r5, #0
    ea44:	9600      	str	r6, [sp, #0]
    ea46:	9601      	str	r6, [sp, #4]
    ea48:	9602      	str	r6, [sp, #8]
    ea4a:	f7f8 fe80 	bl	774e <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA25setup_transfer_descriptorEPvS1_m13dma_beat_sizebb>
	myDMA.add_descriptor();
    ea4e:	1c28      	adds	r0, r5, #0
    ea50:	f7f8 feb3 	bl	77ba <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA14add_descriptorEv>
	myDMA.register_callback(dma_callback_tx);
    ea54:	2201      	movs	r2, #1
    ea56:	1c28      	adds	r0, r5, #0
    ea58:	4923      	ldr	r1, [pc, #140]	; (eae8 <_ZN5SdSpi7receiveEPhj+0xd4>)
    ea5a:	f7f8 febf 	bl	77dc <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA17register_callbackEPFvP12dma_resourceE17dma_callback_type>
	myDMA.enable_callback();
    ea5e:	1c28      	adds	r0, r5, #0
    ea60:	2101      	movs	r1, #1
    ea62:	f7f8 febf 	bl	77e4 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA15enable_callbackE17dma_callback_type>
	
	myDMA2.configure_peripheraltrigger(SERCOM4_DMAC_ID_RX);
    ea66:	4c21      	ldr	r4, [pc, #132]	; (eaec <_ZN5SdSpi7receiveEPhj+0xd8>)
    ea68:	2109      	movs	r1, #9
    ea6a:	1c20      	adds	r0, r4, #0
    ea6c:	f7f8 fe65 	bl	773a <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA27configure_peripheraltriggerEm>
	myDMA2.configure_triggeraction(DMA_TRIGGER_ACTON_BEAT);
    ea70:	2102      	movs	r1, #2
    ea72:	1c20      	adds	r0, r4, #0
    ea74:	f7f8 fe63 	bl	773e <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA23configure_triggeractionE27dma_transfer_trigger_action>
		buf, // to here
		n, // this many
		DMA_BEAT_SIZE_BYTE, // 8 bits
		false, // increment source addr?
		true // increment dest addr?
	);
    ea78:	2701      	movs	r7, #1
	myDMA.register_callback(dma_callback_tx);
	myDMA.enable_callback();
	
	myDMA2.configure_peripheraltrigger(SERCOM4_DMAC_ID_RX);
	myDMA2.configure_triggeraction(DMA_TRIGGER_ACTON_BEAT);
	myDMA2.allocate();
    ea7a:	1c20      	adds	r0, r4, #0
    ea7c:	f7f8 fe61 	bl	7742 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA8allocateEv>
		buf, // to here
		n, // this many
		DMA_BEAT_SIZE_BYTE, // 8 bits
		false, // increment source addr?
		true // increment dest addr?
	);
    ea80:	9b04      	ldr	r3, [sp, #16]
    ea82:	4918      	ldr	r1, [pc, #96]	; (eae4 <_ZN5SdSpi7receiveEPhj+0xd0>)
    ea84:	9a05      	ldr	r2, [sp, #20]
    ea86:	9702      	str	r7, [sp, #8]
    ea88:	1c20      	adds	r0, r4, #0
    ea8a:	9600      	str	r6, [sp, #0]
    ea8c:	9601      	str	r6, [sp, #4]
    ea8e:	f7f8 fe5e 	bl	774e <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA25setup_transfer_descriptorEPvS1_m13dma_beat_sizebb>
	myDMA2.add_descriptor();
    ea92:	1c20      	adds	r0, r4, #0
    ea94:	f7f8 fe91 	bl	77ba <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA14add_descriptorEv>
	myDMA2.register_callback(dma_callback_rx);
    ea98:	1c3a      	adds	r2, r7, #0
    ea9a:	1c20      	adds	r0, r4, #0
    ea9c:	4914      	ldr	r1, [pc, #80]	; (eaf0 <_ZN5SdSpi7receiveEPhj+0xdc>)
    ea9e:	f7f8 fe9d 	bl	77dc <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA17register_callbackEPFvP12dma_resourceE17dma_callback_type>
	myDMA2.enable_callback();
    eaa2:	1c39      	adds	r1, r7, #0
    eaa4:	1c20      	adds	r0, r4, #0
    eaa6:	f7f8 fe9d 	bl	77e4 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA15enable_callbackE17dma_callback_type>
	
	
	transfer_tx_done = transfer_rx_done = false;
    eaaa:	4b12      	ldr	r3, [pc, #72]	; (eaf4 <_ZN5SdSpi7receiveEPhj+0xe0>)
    eaac:	4f12      	ldr	r7, [pc, #72]	; (eaf8 <_ZN5SdSpi7receiveEPhj+0xe4>)
	myDMA2.start_transfer_job();
    eaae:	1c20      	adds	r0, r4, #0
	myDMA2.add_descriptor();
	myDMA2.register_callback(dma_callback_rx);
	myDMA2.enable_callback();
	
	
	transfer_tx_done = transfer_rx_done = false;
    eab0:	703e      	strb	r6, [r7, #0]
    eab2:	701e      	strb	r6, [r3, #0]
	myDMA2.start_transfer_job();
    eab4:	f7f8 fe8d 	bl	77d2 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA18start_transfer_jobEv>
	myDMA.start_transfer_job();
    eab8:	1c28      	adds	r0, r5, #0
    eaba:	f7f8 fe8a 	bl	77d2 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA18start_transfer_jobEv>
    eabe:	4a0d      	ldr	r2, [pc, #52]	; (eaf4 <_ZN5SdSpi7receiveEPhj+0xe0>)
    eac0:	1c28      	adds	r0, r5, #0
	while (!(transfer_tx_done && transfer_rx_done)); // chill
    eac2:	7813      	ldrb	r3, [r2, #0]
    eac4:	2b00      	cmp	r3, #0
    eac6:	d0fc      	beq.n	eac2 <_ZN5SdSpi7receiveEPhj+0xae>
    eac8:	783b      	ldrb	r3, [r7, #0]
    eaca:	2b00      	cmp	r3, #0
    eacc:	d0f9      	beq.n	eac2 <_ZN5SdSpi7receiveEPhj+0xae>
	myDMA.free();
    eace:	f7f8 fe7b 	bl	77c8 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA4freeEv>
	myDMA2.free();
    ead2:	1c20      	adds	r0, r4, #0
    ead4:	f7f8 fe78 	bl	77c8 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA4freeEv>
	return 0; // we just assume this worked.... (probably not too good an idea)
	// TODO: check for stuff
}
    ead8:	2000      	movs	r0, #0
    eada:	b009      	add	sp, #36	; 0x24
    eadc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    eade:	46c0      	nop			; (mov r8, r8)
    eae0:	20000d60 	.word	0x20000d60
    eae4:	42001828 	.word	0x42001828
    eae8:	0000e981 	.word	0x0000e981
    eaec:	20000d00 	.word	0x20000d00
    eaf0:	0000e975 	.word	0x0000e975
    eaf4:	20000d50 	.word	0x20000d50
    eaf8:	20000d52 	.word	0x20000d52

0000eafc <_ZN5SdSpi4sendEh>:

void SdSpi::send(uint8_t b) {
    eafc:	b508      	push	{r3, lr}
	SPI.transfer(b);
    eafe:	4802      	ldr	r0, [pc, #8]	; (eb08 <_ZN5SdSpi4sendEh+0xc>)
    eb00:	f000 fb4e 	bl	f1a0 <_ZN8SPIClass8transferEh>
}
    eb04:	bd08      	pop	{r3, pc}
    eb06:	46c0      	nop			; (mov r8, r8)
    eb08:	20000e40 	.word	0x20000e40

0000eb0c <_ZN5SdSpi4sendEPKhj>:

void SdSpi::send(const uint8_t* buf, size_t n) {
    eb0c:	b5f0      	push	{r4, r5, r6, r7, lr}
	myDMA.configure_peripheraltrigger(SERCOM4_DMAC_ID_TX);
    eb0e:	4c19      	ldr	r4, [pc, #100]	; (eb74 <_ZN5SdSpi4sendEPKhj+0x68>)

void SdSpi::send(uint8_t b) {
	SPI.transfer(b);
}

void SdSpi::send(const uint8_t* buf, size_t n) {
    eb10:	b087      	sub	sp, #28
    eb12:	1c0f      	adds	r7, r1, #0
	myDMA.configure_peripheraltrigger(SERCOM4_DMAC_ID_TX);
    eb14:	1c20      	adds	r0, r4, #0
    eb16:	210a      	movs	r1, #10

void SdSpi::send(uint8_t b) {
	SPI.transfer(b);
}

void SdSpi::send(const uint8_t* buf, size_t n) {
    eb18:	9205      	str	r2, [sp, #20]
	myDMA.configure_peripheraltrigger(SERCOM4_DMAC_ID_TX);
    eb1a:	f7f8 fe0e 	bl	773a <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA27configure_peripheraltriggerEm>
	myDMA.configure_triggeraction(DMA_TRIGGER_ACTON_BEAT);
    eb1e:	2102      	movs	r1, #2
    eb20:	1c20      	adds	r0, r4, #0
    eb22:	f7f8 fe0c 	bl	773e <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA23configure_triggeractionE27dma_transfer_trigger_action>
		(void *)(&SERCOM4->SPI.DATA.reg), // to here
		n, // this many
		DMA_BEAT_SIZE_BYTE, // 8 bits
		true, // increment source addr?
		false // increment dest addr?
	);
    eb26:	2600      	movs	r6, #0
    eb28:	2501      	movs	r5, #1
}

void SdSpi::send(const uint8_t* buf, size_t n) {
	myDMA.configure_peripheraltrigger(SERCOM4_DMAC_ID_TX);
	myDMA.configure_triggeraction(DMA_TRIGGER_ACTON_BEAT);
	myDMA.allocate();
    eb2a:	1c20      	adds	r0, r4, #0
    eb2c:	f7f8 fe09 	bl	7742 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA8allocateEv>
		(void *)(&SERCOM4->SPI.DATA.reg), // to here
		n, // this many
		DMA_BEAT_SIZE_BYTE, // 8 bits
		true, // increment source addr?
		false // increment dest addr?
	);
    eb30:	9b05      	ldr	r3, [sp, #20]
    eb32:	1c39      	adds	r1, r7, #0
    eb34:	4a10      	ldr	r2, [pc, #64]	; (eb78 <_ZN5SdSpi4sendEPKhj+0x6c>)
    eb36:	1c20      	adds	r0, r4, #0
    eb38:	9600      	str	r6, [sp, #0]
    eb3a:	9501      	str	r5, [sp, #4]
    eb3c:	9602      	str	r6, [sp, #8]
    eb3e:	f7f8 fe06 	bl	774e <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA25setup_transfer_descriptorEPvS1_m13dma_beat_sizebb>
	myDMA.add_descriptor();
    eb42:	1c20      	adds	r0, r4, #0
    eb44:	f7f8 fe39 	bl	77ba <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA14add_descriptorEv>
	transfer_tx_done = false;
    eb48:	4f0c      	ldr	r7, [pc, #48]	; (eb7c <_ZN5SdSpi4sendEPKhj+0x70>)
	myDMA.register_callback(dma_callback_tx);
    eb4a:	1c2a      	adds	r2, r5, #0
    eb4c:	1c20      	adds	r0, r4, #0
    eb4e:	490c      	ldr	r1, [pc, #48]	; (eb80 <_ZN5SdSpi4sendEPKhj+0x74>)
		DMA_BEAT_SIZE_BYTE, // 8 bits
		true, // increment source addr?
		false // increment dest addr?
	);
	myDMA.add_descriptor();
	transfer_tx_done = false;
    eb50:	703e      	strb	r6, [r7, #0]
	myDMA.register_callback(dma_callback_tx);
    eb52:	f7f8 fe43 	bl	77dc <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA17register_callbackEPFvP12dma_resourceE17dma_callback_type>
	myDMA.enable_callback();
    eb56:	1c20      	adds	r0, r4, #0
    eb58:	1c29      	adds	r1, r5, #0
    eb5a:	f7f8 fe43 	bl	77e4 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA15enable_callbackE17dma_callback_type>
	myDMA.start_transfer_job();
    eb5e:	1c20      	adds	r0, r4, #0
    eb60:	f7f8 fe37 	bl	77d2 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA18start_transfer_jobEv>
    eb64:	1c20      	adds	r0, r4, #0
	while (!transfer_tx_done); // chill
    eb66:	783b      	ldrb	r3, [r7, #0]
    eb68:	2b00      	cmp	r3, #0
    eb6a:	d0fc      	beq.n	eb66 <_ZN5SdSpi4sendEPKhj+0x5a>
	myDMA.free();
    eb6c:	f7f8 fe2c 	bl	77c8 <_ZN14Gamebuino_Meta16Adafruit_ZeroDMA4freeEv>
}
    eb70:	b007      	add	sp, #28
    eb72:	bdf0      	pop	{r4, r5, r6, r7, pc}
    eb74:	20000d60 	.word	0x20000d60
    eb78:	42001828 	.word	0x42001828
    eb7c:	20000d50 	.word	0x20000d50
    eb80:	0000e981 	.word	0x0000e981

0000eb84 <_GLOBAL__sub_I_myDMA>:
    eb84:	b508      	push	{r3, lr}

#include "../../../Adafruit_ZeroDMA.h"
#include "../../../Adafruit_ZeroDMA/utility/dmac.h"
#include "../../../Adafruit_ZeroDMA/utility/dma.h"

Gamebuino_Meta::Adafruit_ZeroDMA myDMA;
    eb86:	4806      	ldr	r0, [pc, #24]	; (eba0 <_GLOBAL__sub_I_myDMA+0x1c>)
    eb88:	f7f8 fdd1 	bl	772e <_ZN14Gamebuino_Meta16Adafruit_ZeroDMAC1Ev>
Gamebuino_Meta::Adafruit_ZeroDMA myDMA2;
    eb8c:	4805      	ldr	r0, [pc, #20]	; (eba4 <_GLOBAL__sub_I_myDMA+0x20>)
    eb8e:	f7f8 fdce 	bl	772e <_ZN14Gamebuino_Meta16Adafruit_ZeroDMAC1Ev>
  void init_MightInline(uint32_t clock, BitOrder bitOrder, uint8_t dataMode) {
    init_AlwaysInline(clock, bitOrder, dataMode);
  }

  void init_AlwaysInline(uint32_t clock, BitOrder bitOrder, uint8_t dataMode) __attribute__((__always_inline__)) {
    this->clockFreq = (clock >= (F_CPU / SPI_MIN_CLOCK_DIVIDER) ? F_CPU / SPI_MIN_CLOCK_DIVIDER : clock);
    eb92:	4b05      	ldr	r3, [pc, #20]	; (eba8 <_GLOBAL__sub_I_myDMA+0x24>)
    eb94:	4a05      	ldr	r2, [pc, #20]	; (ebac <_GLOBAL__sub_I_myDMA+0x28>)
    eb96:	601a      	str	r2, [r3, #0]

    this->bitOrder = (bitOrder == MSBFIRST ? MSB_FIRST : LSB_FIRST);
    eb98:	2200      	movs	r2, #0
    eb9a:	715a      	strb	r2, [r3, #5]

    switch (dataMode)
    {
      case SPI_MODE0:
        this->dataMode = SERCOM_SPI_MODE_0; break;
    eb9c:	711a      	strb	r2, [r3, #4]
	myDMA.register_callback(dma_callback_tx);
	myDMA.enable_callback();
	myDMA.start_transfer_job();
	while (!transfer_tx_done); // chill
	myDMA.free();
}
    eb9e:	bd08      	pop	{r3, pc}
    eba0:	20000d60 	.word	0x20000d60
    eba4:	20000d00 	.word	0x20000d00
    eba8:	20000cf4 	.word	0x20000cf4
    ebac:	003d0900 	.word	0x003d0900

0000ebb0 <_ZN14Gamebuino_Meta21Sound_Handler_Pattern6rewindEv>:
	rewind();
	channel->use = true;
}

void Sound_Handler_Pattern::rewind() {
	note_duration = 0;
    ebb0:	2300      	movs	r3, #0
    ebb2:	7243      	strb	r3, [r0, #9]
	patternCursor = 0;
    ebb4:	7203      	strb	r3, [r0, #8]
}
    ebb6:	4770      	bx	lr

0000ebb8 <_ZN14Gamebuino_Meta21Sound_Handler_Pattern6getPosEv>:

uint32_t Sound_Handler_Pattern::getPos() {
	return patternCursor;
    ebb8:	7a00      	ldrb	r0, [r0, #8]
}
    ebba:	4770      	bx	lr

0000ebbc <_ZN14Gamebuino_Meta21Sound_Handler_PatternD1Ev>:

#include "Sound.h"

namespace Gamebuino_Meta {

class Sound_Handler_Pattern : public Sound_Handler {
    ebbc:	b510      	push	{r4, lr}
    ebbe:	4b04      	ldr	r3, [pc, #16]	; (ebd0 <_ZN14Gamebuino_Meta21Sound_Handler_PatternD1Ev+0x14>)
    ebc0:	1c04      	adds	r4, r0, #0
    ebc2:	3308      	adds	r3, #8
    ebc4:	6003      	str	r3, [r0, #0]
    ebc6:	f000 f85f 	bl	ec88 <_ZN14Gamebuino_Meta13Sound_HandlerD1Ev>
    ebca:	1c20      	adds	r0, r4, #0
    ebcc:	bd10      	pop	{r4, pc}
    ebce:	46c0      	nop			; (mov r8, r8)
    ebd0:	00015650 	.word	0x00015650

0000ebd4 <_ZN14Gamebuino_Meta21Sound_Handler_PatternD0Ev>:
    ebd4:	b510      	push	{r4, lr}
    ebd6:	1c04      	adds	r4, r0, #0
    ebd8:	f7ff fff0 	bl	ebbc <_ZN14Gamebuino_Meta21Sound_Handler_PatternD1Ev>
    ebdc:	1c20      	adds	r0, r4, #0
    ebde:	f001 fb2f 	bl	10240 <_ZdlPv>
    ebe2:	1c20      	adds	r0, r4, #0
    ebe4:	bd10      	pop	{r4, pc}
	...

0000ebe8 <_ZN14Gamebuino_Meta21Sound_Handler_Pattern6updateEv>:

void Sound_Handler_Pattern::update() {
	if (note_duration--) {
    ebe8:	7a43      	ldrb	r3, [r0, #9]

uint32_t Sound_Handler_Pattern::getPos() {
	return patternCursor;
}

void Sound_Handler_Pattern::update() {
    ebea:	b510      	push	{r4, lr}
	if (note_duration--) {
    ebec:	1e5a      	subs	r2, r3, #1
    ebee:	7242      	strb	r2, [r0, #9]
    ebf0:	2b00      	cmp	r3, #0
    ebf2:	d12d      	bne.n	ec50 <_ZN14Gamebuino_Meta21Sound_Handler_Pattern6updateEv+0x68>
		return;
	}
	uint16_t data = ((uint16_t*)channel->buffer)[patternCursor++];
    ebf4:	7a02      	ldrb	r2, [r0, #8]
    ebf6:	6843      	ldr	r3, [r0, #4]
    ebf8:	1c54      	adds	r4, r2, #1
    ebfa:	6859      	ldr	r1, [r3, #4]
    ebfc:	0052      	lsls	r2, r2, #1
    ebfe:	7204      	strb	r4, [r0, #8]
    ec00:	5a52      	ldrh	r2, [r2, r1]
	if (!data) { // end of pattern - what to do?
    ec02:	2a00      	cmp	r2, #0
    ec04:	d108      	bne.n	ec18 <_ZN14Gamebuino_Meta21Sound_Handler_Pattern6updateEv+0x30>
		if (channel->loop) {
    ec06:	7a5a      	ldrb	r2, [r3, #9]
    ec08:	2a00      	cmp	r2, #0
    ec0a:	d003      	beq.n	ec14 <_ZN14Gamebuino_Meta21Sound_Handler_Pattern6updateEv+0x2c>
			rewind(); 
    ec0c:	6803      	ldr	r3, [r0, #0]
    ec0e:	68db      	ldr	r3, [r3, #12]
    ec10:	4798      	blx	r3
    ec12:	e01d      	b.n	ec50 <_ZN14Gamebuino_Meta21Sound_Handler_Pattern6updateEv+0x68>
		} else {
			channel->use = false;
    ec14:	72da      	strb	r2, [r3, #11]
    ec16:	e01b      	b.n	ec50 <_ZN14Gamebuino_Meta21Sound_Handler_Pattern6updateEv+0x68>
		}
		return;
	}
	while (data & 0x0001) { // read all the commands
    ec18:	2401      	movs	r4, #1
    ec1a:	4014      	ands	r4, r2
    ec1c:	d006      	beq.n	ec2c <_ZN14Gamebuino_Meta21Sound_Handler_Pattern6updateEv+0x44>
		data >>= 5;
		int8_t Y = data - 16;
		*/
		// trash for now
		
		data = ((uint16_t*)channel->buffer)[patternCursor++];
    ec1e:	7a02      	ldrb	r2, [r0, #8]
    ec20:	6859      	ldr	r1, [r3, #4]
    ec22:	1c54      	adds	r4, r2, #1
    ec24:	7204      	strb	r4, [r0, #8]
    ec26:	0052      	lsls	r2, r2, #1
    ec28:	5a52      	ldrh	r2, [r2, r1]
    ec2a:	e7f5      	b.n	ec18 <_ZN14Gamebuino_Meta21Sound_Handler_Pattern6updateEv+0x30>
	}
	data >>= 2;
    ec2c:	1092      	asrs	r2, r2, #2
	
	uint8_t id = data & 0x003F;
    ec2e:	213f      	movs	r1, #63	; 0x3f
    ec30:	4011      	ands	r1, r2
	if (id == 63) {
    ec32:	293f      	cmp	r1, #63	; 0x3f
    ec34:	d101      	bne.n	ec3a <_ZN14Gamebuino_Meta21Sound_Handler_Pattern6updateEv+0x52>
		channel->amplitude = 0;
    ec36:	721c      	strb	r4, [r3, #8]
    ec38:	e005      	b.n	ec46 <_ZN14Gamebuino_Meta21Sound_Handler_Pattern6updateEv+0x5e>
	} else {
		channel->total = _halfPeriods[id] * 2;
    ec3a:	4c06      	ldr	r4, [pc, #24]	; (ec54 <_ZN14Gamebuino_Meta21Sound_Handler_Pattern6updateEv+0x6c>)
    ec3c:	5c61      	ldrb	r1, [r4, r1]
    ec3e:	0049      	lsls	r1, r1, #1
    ec40:	8059      	strh	r1, [r3, #2]
		channel->amplitude = 0x30;
    ec42:	2130      	movs	r1, #48	; 0x30
    ec44:	7219      	strb	r1, [r3, #8]
	}
	channel->index = 0;
    ec46:	6841      	ldr	r1, [r0, #4]
    ec48:	2300      	movs	r3, #0
	data >>= 6;
    ec4a:	1192      	asrs	r2, r2, #6
		channel->amplitude = 0;
	} else {
		channel->total = _halfPeriods[id] * 2;
		channel->amplitude = 0x30;
	}
	channel->index = 0;
    ec4c:	800b      	strh	r3, [r1, #0]
	data >>= 6;
	note_duration = data;
    ec4e:	7242      	strb	r2, [r0, #9]
}
    ec50:	bd10      	pop	{r4, pc}
    ec52:	46c0      	nop			; (mov r8, r8)
    ec54:	0001560c 	.word	0x0001560c

0000ec58 <_ZN14Gamebuino_Meta21Sound_Handler_PatternC1EPNS_13Sound_ChannelEPh>:
	2*SOUND_FREQ/44100,
	2*SOUND_FREQ/44100,
	2*SOUND_FREQ/44100,
};

Sound_Handler_Pattern::Sound_Handler_Pattern(Sound_Channel* chan, uint8_t* _buffer) : Sound_Handler(chan) {
    ec58:	b538      	push	{r3, r4, r5, lr}
    ec5a:	1c04      	adds	r4, r0, #0
    ec5c:	1c15      	adds	r5, r2, #0
    ec5e:	f000 f8b5 	bl	edcc <_ZN14Gamebuino_Meta13Sound_HandlerC1EPNS_13Sound_ChannelE>
    ec62:	4b08      	ldr	r3, [pc, #32]	; (ec84 <_ZN14Gamebuino_Meta21Sound_Handler_PatternC1EPNS_13Sound_ChannelEPh+0x2c>)
	channel->buffer = _buffer;
	channel->type = Sound_Channel_Type::square;
    ec64:	2201      	movs	r2, #1
	2*SOUND_FREQ/44100,
	2*SOUND_FREQ/44100,
	2*SOUND_FREQ/44100,
};

Sound_Handler_Pattern::Sound_Handler_Pattern(Sound_Channel* chan, uint8_t* _buffer) : Sound_Handler(chan) {
    ec66:	3308      	adds	r3, #8
    ec68:	6023      	str	r3, [r4, #0]
	channel->buffer = _buffer;
    ec6a:	6863      	ldr	r3, [r4, #4]
	channel->type = Sound_Channel_Type::square;
	channel->amplitude = 0x30;
    ec6c:	2130      	movs	r1, #48	; 0x30
	2*SOUND_FREQ/44100,
	2*SOUND_FREQ/44100,
};

Sound_Handler_Pattern::Sound_Handler_Pattern(Sound_Channel* chan, uint8_t* _buffer) : Sound_Handler(chan) {
	channel->buffer = _buffer;
    ec6e:	605d      	str	r5, [r3, #4]
	channel->type = Sound_Channel_Type::square;
	channel->amplitude = 0x30;
    ec70:	7219      	strb	r1, [r3, #8]
	2*SOUND_FREQ/44100,
};

Sound_Handler_Pattern::Sound_Handler_Pattern(Sound_Channel* chan, uint8_t* _buffer) : Sound_Handler(chan) {
	channel->buffer = _buffer;
	channel->type = Sound_Channel_Type::square;
    ec72:	741a      	strb	r2, [r3, #16]
	rewind();
	channel->use = true;
}

void Sound_Handler_Pattern::rewind() {
	note_duration = 0;
    ec74:	2300      	movs	r3, #0
    ec76:	7263      	strb	r3, [r4, #9]
	patternCursor = 0;
    ec78:	7223      	strb	r3, [r4, #8]
Sound_Handler_Pattern::Sound_Handler_Pattern(Sound_Channel* chan, uint8_t* _buffer) : Sound_Handler(chan) {
	channel->buffer = _buffer;
	channel->type = Sound_Channel_Type::square;
	channel->amplitude = 0x30;
	rewind();
	channel->use = true;
    ec7a:	6863      	ldr	r3, [r4, #4]
}
    ec7c:	1c20      	adds	r0, r4, #0
Sound_Handler_Pattern::Sound_Handler_Pattern(Sound_Channel* chan, uint8_t* _buffer) : Sound_Handler(chan) {
	channel->buffer = _buffer;
	channel->type = Sound_Channel_Type::square;
	channel->amplitude = 0x30;
	rewind();
	channel->use = true;
    ec7e:	72da      	strb	r2, [r3, #11]
}
    ec80:	bd38      	pop	{r3, r4, r5, pc}
    ec82:	46c0      	nop			; (mov r8, r8)
    ec84:	00015650 	.word	0x00015650

0000ec88 <_ZN14Gamebuino_Meta13Sound_HandlerD1Ev>:

Sound_Handler::Sound_Handler(Sound_Channel* _channel) {
	channel = _channel;
}

Sound_Handler::~Sound_Handler() {
    ec88:	4b01      	ldr	r3, [pc, #4]	; (ec90 <_ZN14Gamebuino_Meta13Sound_HandlerD1Ev+0x8>)
    ec8a:	3308      	adds	r3, #8
    ec8c:	6003      	str	r3, [r0, #0]
	
}
    ec8e:	4770      	bx	lr
    ec90:	00015680 	.word	0x00015680

0000ec94 <_ZN14Gamebuino_Meta13Sound_Handler6getPosEv>:

uint32_t Sound_Handler::getPos() {
	return 0xFFFFFFFF;
    ec94:	2001      	movs	r0, #1
}
    ec96:	4240      	negs	r0, r0
    ec98:	4770      	bx	lr
	...

0000ec9c <_ZN14Gamebuino_Meta13Sound_HandlerD0Ev>:

Sound_Handler::Sound_Handler(Sound_Channel* _channel) {
	channel = _channel;
}

Sound_Handler::~Sound_Handler() {
    ec9c:	b510      	push	{r4, lr}
    ec9e:	4b04      	ldr	r3, [pc, #16]	; (ecb0 <_ZN14Gamebuino_Meta13Sound_HandlerD0Ev+0x14>)
    eca0:	1c04      	adds	r4, r0, #0
    eca2:	3308      	adds	r3, #8
    eca4:	6003      	str	r3, [r0, #0]
	
}
    eca6:	f001 facb 	bl	10240 <_ZdlPv>
    ecaa:	1c20      	adds	r0, r4, #0
    ecac:	bd10      	pop	{r4, pc}
    ecae:	46c0      	nop			; (mov r8, r8)
    ecb0:	00015680 	.word	0x00015680

0000ecb4 <_ZN14Gamebuino_Meta7tcStartEv>:
}

void tcStart() {
	// Enable TC

	TC5->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
    ecb4:	4b04      	ldr	r3, [pc, #16]	; (ecc8 <_ZN14Gamebuino_Meta7tcStartEv+0x14>)
    ecb6:	2102      	movs	r1, #2
    ecb8:	881a      	ldrh	r2, [r3, #0]
    ecba:	430a      	orrs	r2, r1
    ecbc:	801a      	strh	r2, [r3, #0]
#if SOUND_CHANNELS > 0
Sound_Channel channels[SOUND_CHANNELS];
Sound_Handler* handlers[SOUND_CHANNELS];

bool tcIsSyncing() {
	return TC5->COUNT16.STATUS.reg & TC_STATUS_SYNCBUSY;
    ecbe:	7bda      	ldrb	r2, [r3, #15]

void tcStart() {
	// Enable TC

	TC5->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
	while (tcIsSyncing());
    ecc0:	b252      	sxtb	r2, r2
    ecc2:	2a00      	cmp	r2, #0
    ecc4:	dbfb      	blt.n	ecbe <_ZN14Gamebuino_Meta7tcStartEv+0xa>
}
    ecc6:	4770      	bx	lr
    ecc8:	42003400 	.word	0x42003400

0000eccc <_ZN14Gamebuino_Meta7tcResetEv>:

void tcReset() {
	// Reset TCx
	TC5->COUNT16.CTRLA.reg = TC_CTRLA_SWRST;
    eccc:	4b05      	ldr	r3, [pc, #20]	; (ece4 <_ZN14Gamebuino_Meta7tcResetEv+0x18>)
    ecce:	2201      	movs	r2, #1
    ecd0:	801a      	strh	r2, [r3, #0]
#if SOUND_CHANNELS > 0
Sound_Channel channels[SOUND_CHANNELS];
Sound_Handler* handlers[SOUND_CHANNELS];

bool tcIsSyncing() {
	return TC5->COUNT16.STATUS.reg & TC_STATUS_SYNCBUSY;
    ecd2:	7bda      	ldrb	r2, [r3, #15]
}

void tcReset() {
	// Reset TCx
	TC5->COUNT16.CTRLA.reg = TC_CTRLA_SWRST;
	while (tcIsSyncing());
    ecd4:	b252      	sxtb	r2, r2
    ecd6:	2a00      	cmp	r2, #0
    ecd8:	dbfb      	blt.n	ecd2 <_ZN14Gamebuino_Meta7tcResetEv+0x6>
	while (TC5->COUNT16.CTRLA.bit.SWRST);
    ecda:	881a      	ldrh	r2, [r3, #0]
    ecdc:	07d1      	lsls	r1, r2, #31
    ecde:	d4fc      	bmi.n	ecda <_ZN14Gamebuino_Meta7tcResetEv+0xe>
}
    ece0:	4770      	bx	lr
    ece2:	46c0      	nop			; (mov r8, r8)
    ece4:	42003400 	.word	0x42003400

0000ece8 <_ZN14Gamebuino_Meta11tcConfigureEm>:
	while (tcIsSyncing());
}

void tcConfigure(uint32_t sampleRate) {
	// Enable GCLK for TCC2 and TC5 (timer counter input clock)
	GCLK->CLKCTRL.reg = (uint16_t) (GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN_GCLK0 | GCLK_CLKCTRL_ID(GCM_TC4_TC5)) ;
    ece8:	4b1d      	ldr	r3, [pc, #116]	; (ed60 <_ZN14Gamebuino_Meta11tcConfigureEm+0x78>)
    ecea:	4a1e      	ldr	r2, [pc, #120]	; (ed64 <_ZN14Gamebuino_Meta11tcConfigureEm+0x7c>)
	// Disable TC5
	TC5->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
	while (tcIsSyncing());
}

void tcConfigure(uint32_t sampleRate) {
    ecec:	b570      	push	{r4, r5, r6, lr}
    ecee:	1c05      	adds	r5, r0, #0
	// Enable GCLK for TCC2 and TC5 (timer counter input clock)
	GCLK->CLKCTRL.reg = (uint16_t) (GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN_GCLK0 | GCLK_CLKCTRL_ID(GCM_TC4_TC5)) ;
    ecf0:	805a      	strh	r2, [r3, #2]
	while (GCLK->STATUS.bit.SYNCBUSY);
    ecf2:	785a      	ldrb	r2, [r3, #1]
    ecf4:	09d2      	lsrs	r2, r2, #7
    ecf6:	d1fc      	bne.n	ecf2 <_ZN14Gamebuino_Meta11tcConfigureEm+0xa>

	tcReset();

	// Set Timer counter Mode to 16 bits
	TC5->COUNT16.CTRLA.reg |= TC_CTRLA_MODE_COUNT16;
    ecf8:	4c1b      	ldr	r4, [pc, #108]	; (ed68 <_ZN14Gamebuino_Meta11tcConfigureEm+0x80>)
void tcConfigure(uint32_t sampleRate) {
	// Enable GCLK for TCC2 and TC5 (timer counter input clock)
	GCLK->CLKCTRL.reg = (uint16_t) (GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN_GCLK0 | GCLK_CLKCTRL_ID(GCM_TC4_TC5)) ;
	while (GCLK->STATUS.bit.SYNCBUSY);

	tcReset();
    ecfa:	f7ff ffe7 	bl	eccc <_ZN14Gamebuino_Meta7tcResetEv>

	// Set Timer counter Mode to 16 bits
	TC5->COUNT16.CTRLA.reg |= TC_CTRLA_MODE_COUNT16;
    ecfe:	8823      	ldrh	r3, [r4, #0]

	// Set TC5 mode as match frequency
	TC5->COUNT16.CTRLA.reg |= TC_CTRLA_WAVEGEN_MFRQ;
    ed00:	2220      	movs	r2, #32
	while (GCLK->STATUS.bit.SYNCBUSY);

	tcReset();

	// Set Timer counter Mode to 16 bits
	TC5->COUNT16.CTRLA.reg |= TC_CTRLA_MODE_COUNT16;
    ed02:	b29b      	uxth	r3, r3
    ed04:	8023      	strh	r3, [r4, #0]

	// Set TC5 mode as match frequency
	TC5->COUNT16.CTRLA.reg |= TC_CTRLA_WAVEGEN_MFRQ;
    ed06:	8823      	ldrh	r3, [r4, #0]

	TC5->COUNT16.CTRLA.reg |= TC_CTRLA_PRESCALER_DIV1 | TC_CTRLA_ENABLE;

	TC5->COUNT16.CC[0].reg = (uint16_t) (SystemCoreClock / sampleRate - 1);
    ed08:	1c29      	adds	r1, r5, #0

	// Set Timer counter Mode to 16 bits
	TC5->COUNT16.CTRLA.reg |= TC_CTRLA_MODE_COUNT16;

	// Set TC5 mode as match frequency
	TC5->COUNT16.CTRLA.reg |= TC_CTRLA_WAVEGEN_MFRQ;
    ed0a:	4313      	orrs	r3, r2
    ed0c:	8023      	strh	r3, [r4, #0]

	TC5->COUNT16.CTRLA.reg |= TC_CTRLA_PRESCALER_DIV1 | TC_CTRLA_ENABLE;
    ed0e:	8823      	ldrh	r3, [r4, #0]
    ed10:	2202      	movs	r2, #2
    ed12:	4313      	orrs	r3, r2
    ed14:	8023      	strh	r3, [r4, #0]

	TC5->COUNT16.CC[0].reg = (uint16_t) (SystemCoreClock / sampleRate - 1);
    ed16:	4b15      	ldr	r3, [pc, #84]	; (ed6c <_ZN14Gamebuino_Meta11tcConfigureEm+0x84>)
    ed18:	6818      	ldr	r0, [r3, #0]
    ed1a:	f002 fb3d 	bl	11398 <__aeabi_uidiv>
    ed1e:	3801      	subs	r0, #1
    ed20:	b280      	uxth	r0, r0
    ed22:	8320      	strh	r0, [r4, #24]
#if SOUND_CHANNELS > 0
Sound_Channel channels[SOUND_CHANNELS];
Sound_Handler* handlers[SOUND_CHANNELS];

bool tcIsSyncing() {
	return TC5->COUNT16.STATUS.reg & TC_STATUS_SYNCBUSY;
    ed24:	7be3      	ldrb	r3, [r4, #15]
    ed26:	4910      	ldr	r1, [pc, #64]	; (ed68 <_ZN14Gamebuino_Meta11tcConfigureEm+0x80>)
	TC5->COUNT16.CTRLA.reg |= TC_CTRLA_WAVEGEN_MFRQ;

	TC5->COUNT16.CTRLA.reg |= TC_CTRLA_PRESCALER_DIV1 | TC_CTRLA_ENABLE;

	TC5->COUNT16.CC[0].reg = (uint16_t) (SystemCoreClock / sampleRate - 1);
	while (tcIsSyncing());
    ed28:	b25b      	sxtb	r3, r3
    ed2a:	2b00      	cmp	r3, #0
    ed2c:	dbfa      	blt.n	ed24 <_ZN14Gamebuino_Meta11tcConfigureEm+0x3c>
  \details Disables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    ed2e:	4810      	ldr	r0, [pc, #64]	; (ed70 <_ZN14Gamebuino_Meta11tcConfigureEm+0x88>)
    ed30:	2280      	movs	r2, #128	; 0x80
    ed32:	0352      	lsls	r2, r2, #13
    ed34:	67c2      	str	r2, [r0, #124]	; 0x7c
    ed36:	4b0f      	ldr	r3, [pc, #60]	; (ed74 <_ZN14Gamebuino_Meta11tcConfigureEm+0x8c>)
  \details Clears the pending bit of an external interrupt.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    ed38:	20c0      	movs	r0, #192	; 0xc0
    ed3a:	0040      	lsls	r0, r0, #1
    ed3c:	501a      	str	r2, [r3, r0]
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    ed3e:	20c5      	movs	r0, #197	; 0xc5
    ed40:	0080      	lsls	r0, r0, #2
    ed42:	581d      	ldr	r5, [r3, r0]
    ed44:	26ff      	movs	r6, #255	; 0xff
    ed46:	43b5      	bics	r5, r6
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
    ed48:	501d      	str	r5, [r3, r0]
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    ed4a:	601a      	str	r2, [r3, #0]
	NVIC_ClearPendingIRQ(TC5_IRQn);
	NVIC_SetPriority(TC5_IRQn, 0);
	NVIC_EnableIRQ(TC5_IRQn);

	// Enable the TC5 interrupt request
	TC5->COUNT16.INTENSET.bit.MC0 = 1;
    ed4c:	7b4b      	ldrb	r3, [r1, #13]
    ed4e:	2210      	movs	r2, #16
    ed50:	4313      	orrs	r3, r2
    ed52:	734b      	strb	r3, [r1, #13]
#if SOUND_CHANNELS > 0
Sound_Channel channels[SOUND_CHANNELS];
Sound_Handler* handlers[SOUND_CHANNELS];

bool tcIsSyncing() {
	return TC5->COUNT16.STATUS.reg & TC_STATUS_SYNCBUSY;
    ed54:	7be3      	ldrb	r3, [r4, #15]
	NVIC_SetPriority(TC5_IRQn, 0);
	NVIC_EnableIRQ(TC5_IRQn);

	// Enable the TC5 interrupt request
	TC5->COUNT16.INTENSET.bit.MC0 = 1;
	while (tcIsSyncing());
    ed56:	b25b      	sxtb	r3, r3
    ed58:	2b00      	cmp	r3, #0
    ed5a:	dbfb      	blt.n	ed54 <_ZN14Gamebuino_Meta11tcConfigureEm+0x6c>
}
    ed5c:	bd70      	pop	{r4, r5, r6, pc}
    ed5e:	46c0      	nop			; (mov r8, r8)
    ed60:	40000c00 	.word	0x40000c00
    ed64:	0000401c 	.word	0x0000401c
    ed68:	42003400 	.word	0x42003400
    ed6c:	20000098 	.word	0x20000098
    ed70:	e000e104 	.word	0xe000e104
    ed74:	e000e100 	.word	0xe000e100

0000ed78 <_ZN14Gamebuino_Meta12dacConfigureEv>:

void dacConfigure(void) {
    ed78:	b508      	push	{r3, lr}
	analogWriteResolution(10);
    ed7a:	200a      	movs	r0, #10
    ed7c:	f000 fc5c 	bl	f638 <analogWriteResolution>
	analogWrite(A0, 0);
    ed80:	200e      	movs	r0, #14
    ed82:	2100      	movs	r1, #0
    ed84:	f000 fcf6 	bl	f774 <analogWrite>
}
    ed88:	bd08      	pop	{r3, pc}
	...

0000ed8c <_ZN14Gamebuino_Meta16findEmptyChannelEv>:

int8_t findEmptyChannel() {
    ed8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ed8e:	2300      	movs	r3, #0
    ed90:	2214      	movs	r2, #20
    ed92:	435a      	muls	r2, r3
    ed94:	490b      	ldr	r1, [pc, #44]	; (edc4 <_ZN14Gamebuino_Meta16findEmptyChannelEv+0x38>)
    ed96:	b2de      	uxtb	r6, r3
    ed98:	188a      	adds	r2, r1, r2
	for (uint8_t i = 0; i < SOUND_CHANNELS; i++) {
		if (!channels[i].use) {
    ed9a:	7ad5      	ldrb	r5, [r2, #11]
    ed9c:	2d00      	cmp	r5, #0
    ed9e:	d10a      	bne.n	edb6 <_ZN14Gamebuino_Meta16findEmptyChannelEv+0x2a>
			if (handlers[i]) {
    eda0:	4c09      	ldr	r4, [pc, #36]	; (edc8 <_ZN14Gamebuino_Meta16findEmptyChannelEv+0x3c>)
    eda2:	009f      	lsls	r7, r3, #2
    eda4:	5938      	ldr	r0, [r7, r4]
    eda6:	2800      	cmp	r0, #0
    eda8:	d003      	beq.n	edb2 <_ZN14Gamebuino_Meta16findEmptyChannelEv+0x26>
				delete handlers[i];
    edaa:	6803      	ldr	r3, [r0, #0]
    edac:	685b      	ldr	r3, [r3, #4]
    edae:	4798      	blx	r3
				handlers[i] = 0;
    edb0:	513d      	str	r5, [r7, r4]
			}
			return i;
    edb2:	b2f6      	uxtb	r6, r6
    edb4:	e003      	b.n	edbe <_ZN14Gamebuino_Meta16findEmptyChannelEv+0x32>
    edb6:	3301      	adds	r3, #1
	analogWriteResolution(10);
	analogWrite(A0, 0);
}

int8_t findEmptyChannel() {
	for (uint8_t i = 0; i < SOUND_CHANNELS; i++) {
    edb8:	2b04      	cmp	r3, #4
    edba:	d1e9      	bne.n	ed90 <_ZN14Gamebuino_Meta16findEmptyChannelEv+0x4>
				handlers[i] = 0;
			}
			return i;
		}
	}
	return -1;
    edbc:	26ff      	movs	r6, #255	; 0xff
    edbe:	b270      	sxtb	r0, r6
}
    edc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    edc2:	46c0      	nop			; (mov r8, r8)
    edc4:	20000db4 	.word	0x20000db4
    edc8:	20000e08 	.word	0x20000e08

0000edcc <_ZN14Gamebuino_Meta13Sound_HandlerC1EPNS_13Sound_ChannelE>:
#endif

Sound_Handler::Sound_Handler(Sound_Channel* _channel) {
    edcc:	4b02      	ldr	r3, [pc, #8]	; (edd8 <_ZN14Gamebuino_Meta13Sound_HandlerC1EPNS_13Sound_ChannelE+0xc>)
	channel = _channel;
    edce:	6041      	str	r1, [r0, #4]
	}
	return -1;
}
#endif

Sound_Handler::Sound_Handler(Sound_Channel* _channel) {
    edd0:	3308      	adds	r3, #8
    edd2:	6003      	str	r3, [r0, #0]
	channel = _channel;
}
    edd4:	4770      	bx	lr
    edd6:	46c0      	nop			; (mov r8, r8)
    edd8:	00015680 	.word	0x00015680

0000eddc <_ZN14Gamebuino_Meta5Sound5beginEv>:

void Sound_Handler::setChannel(Sound_Channel* _channel) {
	channel = _channel;
}

void Sound::begin() {
    eddc:	b508      	push	{r3, lr}
#if SOUND_CHANNELS > 0
	dacConfigure();
    edde:	f7ff ffcb 	bl	ed78 <_ZN14Gamebuino_Meta12dacConfigureEv>
	tcConfigure(SOUND_FREQ);
    ede2:	4803      	ldr	r0, [pc, #12]	; (edf0 <_ZN14Gamebuino_Meta5Sound5beginEv+0x14>)
    ede4:	f7ff ff80 	bl	ece8 <_ZN14Gamebuino_Meta11tcConfigureEm>
	tcStart();
    ede8:	f7ff ff64 	bl	ecb4 <_ZN14Gamebuino_Meta7tcStartEv>
#endif
}
    edec:	bd08      	pop	{r3, pc}
    edee:	46c0      	nop			; (mov r8, r8)
    edf0:	0000ac44 	.word	0x0000ac44

0000edf4 <_ZN14Gamebuino_Meta5Sound4playEPKtb>:

int8_t Sound::play(char* filename, bool loop) {
	return play((const char*)filename, loop);
}

int8_t Sound::play(const uint16_t* buffer, bool loop) {
    edf4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    edf6:	1c0f      	adds	r7, r1, #0
    edf8:	1c15      	adds	r5, r2, #0
#if SOUND_CHANNELS > 0
	int8_t i = findEmptyChannel();
    edfa:	f7ff ffc7 	bl	ed8c <_ZN14Gamebuino_Meta16findEmptyChannelEv>
	if (i < 0 || i >= SOUND_CHANNELS) {
    edfe:	b2c3      	uxtb	r3, r0
	return play((const char*)filename, loop);
}

int8_t Sound::play(const uint16_t* buffer, bool loop) {
#if SOUND_CHANNELS > 0
	int8_t i = findEmptyChannel();
    ee00:	1c04      	adds	r4, r0, #0
	if (i < 0 || i >= SOUND_CHANNELS) {
    ee02:	2b03      	cmp	r3, #3
    ee04:	d810      	bhi.n	ee28 <_ZN14Gamebuino_Meta5Sound4playEPKtb+0x34>
		return -1; // no free channels atm
	}
	channels[i].loop = loop;
    ee06:	2614      	movs	r6, #20
    ee08:	4346      	muls	r6, r0
    ee0a:	4b09      	ldr	r3, [pc, #36]	; (ee30 <_ZN14Gamebuino_Meta5Sound4playEPKtb+0x3c>)
	handlers[i] = new Sound_Handler_Pattern(&(channels[i]), (uint8_t*)buffer);
    ee0c:	200c      	movs	r0, #12
#if SOUND_CHANNELS > 0
	int8_t i = findEmptyChannel();
	if (i < 0 || i >= SOUND_CHANNELS) {
		return -1; // no free channels atm
	}
	channels[i].loop = loop;
    ee0e:	199e      	adds	r6, r3, r6
    ee10:	7275      	strb	r5, [r6, #9]
	handlers[i] = new Sound_Handler_Pattern(&(channels[i]), (uint8_t*)buffer);
    ee12:	f001 fa0d 	bl	10230 <_Znwj>
    ee16:	1c3a      	adds	r2, r7, #0
    ee18:	1c31      	adds	r1, r6, #0
    ee1a:	1c05      	adds	r5, r0, #0
    ee1c:	f7ff ff1c 	bl	ec58 <_ZN14Gamebuino_Meta21Sound_Handler_PatternC1EPNS_13Sound_ChannelEPh>
    ee20:	4b04      	ldr	r3, [pc, #16]	; (ee34 <_ZN14Gamebuino_Meta5Sound4playEPKtb+0x40>)
    ee22:	00a2      	lsls	r2, r4, #2
    ee24:	50d5      	str	r5, [r2, r3]
	return i;
    ee26:	e000      	b.n	ee2a <_ZN14Gamebuino_Meta5Sound4playEPKtb+0x36>

int8_t Sound::play(const uint16_t* buffer, bool loop) {
#if SOUND_CHANNELS > 0
	int8_t i = findEmptyChannel();
	if (i < 0 || i >= SOUND_CHANNELS) {
		return -1; // no free channels atm
    ee28:	24ff      	movs	r4, #255	; 0xff
    ee2a:	b260      	sxtb	r0, r4
	handlers[i] = new Sound_Handler_Pattern(&(channels[i]), (uint8_t*)buffer);
	return i;
#else // SOUND_CHANNELS
	return -1;
#endif // SOUND_CHANNELS
}
    ee2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ee2e:	46c0      	nop			; (mov r8, r8)
    ee30:	20000db4 	.word	0x20000db4
    ee34:	20000e08 	.word	0x20000e08

0000ee38 <_ZN14Gamebuino_Meta5Sound6playOKEv>:
		delete handlers[i];
		handlers[i] = 0;
	}
}

int8_t Sound::playOK() {
    ee38:	b508      	push	{r3, lr}
	return play(playOKPattern);
    ee3a:	4902      	ldr	r1, [pc, #8]	; (ee44 <_ZN14Gamebuino_Meta5Sound6playOKEv+0xc>)
    ee3c:	2200      	movs	r2, #0
    ee3e:	f7ff ffd9 	bl	edf4 <_ZN14Gamebuino_Meta5Sound4playEPKtb>
}
    ee42:	bd08      	pop	{r3, pc}
    ee44:	000156a0 	.word	0x000156a0

0000ee48 <_ZN14Gamebuino_Meta5Sound10playCancelEv>:

int8_t Sound::playCancel() {
    ee48:	b508      	push	{r3, lr}
	return play(playCancelPattern);
    ee4a:	4902      	ldr	r1, [pc, #8]	; (ee54 <_ZN14Gamebuino_Meta5Sound10playCancelEv+0xc>)
    ee4c:	2200      	movs	r2, #0
    ee4e:	f7ff ffd1 	bl	edf4 <_ZN14Gamebuino_Meta5Sound4playEPKtb>
}
    ee52:	bd08      	pop	{r3, pc}
    ee54:	00015676 	.word	0x00015676

0000ee58 <_ZN14Gamebuino_Meta5Sound8playTickEv>:

int8_t Sound::playTick() {
    ee58:	b508      	push	{r3, lr}
	return play(playTickP);
    ee5a:	4902      	ldr	r1, [pc, #8]	; (ee64 <_ZN14Gamebuino_Meta5Sound8playTickEv+0xc>)
    ee5c:	2200      	movs	r2, #0
    ee5e:	f7ff ffc9 	bl	edf4 <_ZN14Gamebuino_Meta5Sound4playEPKtb>
}
    ee62:	bd08      	pop	{r3, pc}
    ee64:	00015670 	.word	0x00015670

0000ee68 <_ZN14Gamebuino_Meta5Sound6updateEv>:

bool efx_only = false;

void Sound::update() {
    ee68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ee6a:	4d12      	ldr	r5, [pc, #72]	; (eeb4 <_ZN14Gamebuino_Meta5Sound6updateEv+0x4c>)
    ee6c:	2400      	movs	r4, #0
    ee6e:	350b      	adds	r5, #11
#if SOUND_CHANNELS > 0
	for (uint8_t i = 0; i < SOUND_CHANNELS; i++) {
		if (channels[i].use) {
    ee70:	782f      	ldrb	r7, [r5, #0]
    ee72:	2f00      	cmp	r7, #0
    ee74:	d010      	beq.n	ee98 <_ZN14Gamebuino_Meta5Sound6updateEv+0x30>
			if (!efx_only || (!channels[i].loop && channels[i].type == Sound_Channel_Type::square)) {
    ee76:	4b10      	ldr	r3, [pc, #64]	; (eeb8 <_ZN14Gamebuino_Meta5Sound6updateEv+0x50>)
    ee78:	781b      	ldrb	r3, [r3, #0]
    ee7a:	2b00      	cmp	r3, #0
    ee7c:	d006      	beq.n	ee8c <_ZN14Gamebuino_Meta5Sound6updateEv+0x24>
    ee7e:	1eab      	subs	r3, r5, #2
    ee80:	781b      	ldrb	r3, [r3, #0]
    ee82:	2b00      	cmp	r3, #0
    ee84:	d110      	bne.n	eea8 <_ZN14Gamebuino_Meta5Sound6updateEv+0x40>
    ee86:	796b      	ldrb	r3, [r5, #5]
    ee88:	2b01      	cmp	r3, #1
    ee8a:	d10d      	bne.n	eea8 <_ZN14Gamebuino_Meta5Sound6updateEv+0x40>
				handlers[i]->update();
    ee8c:	4b0b      	ldr	r3, [pc, #44]	; (eebc <_ZN14Gamebuino_Meta5Sound6updateEv+0x54>)
    ee8e:	58e0      	ldr	r0, [r4, r3]
    ee90:	6803      	ldr	r3, [r0, #0]
    ee92:	689b      	ldr	r3, [r3, #8]
    ee94:	4798      	blx	r3
    ee96:	e007      	b.n	eea8 <_ZN14Gamebuino_Meta5Sound6updateEv+0x40>
			}
		} else if (handlers[i]) {
    ee98:	4e08      	ldr	r6, [pc, #32]	; (eebc <_ZN14Gamebuino_Meta5Sound6updateEv+0x54>)
    ee9a:	59a0      	ldr	r0, [r4, r6]
    ee9c:	2800      	cmp	r0, #0
    ee9e:	d003      	beq.n	eea8 <_ZN14Gamebuino_Meta5Sound6updateEv+0x40>
			delete handlers[i];
    eea0:	6803      	ldr	r3, [r0, #0]
    eea2:	685b      	ldr	r3, [r3, #4]
    eea4:	4798      	blx	r3
			handlers[i] = 0;
    eea6:	51a7      	str	r7, [r4, r6]
    eea8:	3404      	adds	r4, #4
    eeaa:	3514      	adds	r5, #20

bool efx_only = false;

void Sound::update() {
#if SOUND_CHANNELS > 0
	for (uint8_t i = 0; i < SOUND_CHANNELS; i++) {
    eeac:	2c10      	cmp	r4, #16
    eeae:	d1df      	bne.n	ee70 <_ZN14Gamebuino_Meta5Sound6updateEv+0x8>
			delete handlers[i];
			handlers[i] = 0;
		}
	}
#endif // SOUND_CHANNELS
}
    eeb0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    eeb2:	46c0      	nop			; (mov r8, r8)
    eeb4:	20000db4 	.word	0x20000db4
    eeb8:	20000db2 	.word	0x20000db2
    eebc:	20000e08 	.word	0x20000e08

0000eec0 <_ZN14Gamebuino_Meta5Sound4muteEv>:

void Sound::mute() {
	muted = true;
    eec0:	4b01      	ldr	r3, [pc, #4]	; (eec8 <_ZN14Gamebuino_Meta5Sound4muteEv+0x8>)
    eec2:	2201      	movs	r2, #1
    eec4:	701a      	strb	r2, [r3, #0]
}
    eec6:	4770      	bx	lr
    eec8:	20000e04 	.word	0x20000e04

0000eecc <_ZN14Gamebuino_Meta5Sound6unmuteEv>:

void Sound::unmute() {
	muted = false;
    eecc:	4b01      	ldr	r3, [pc, #4]	; (eed4 <_ZN14Gamebuino_Meta5Sound6unmuteEv+0x8>)
    eece:	2200      	movs	r2, #0
    eed0:	701a      	strb	r2, [r3, #0]
}
    eed2:	4770      	bx	lr
    eed4:	20000e04 	.word	0x20000e04

0000eed8 <_ZN14Gamebuino_Meta5Sound6isMuteEv>:

bool Sound::isMute() {
	return muted;
    eed8:	4b01      	ldr	r3, [pc, #4]	; (eee0 <_ZN14Gamebuino_Meta5Sound6isMuteEv+0x8>)
    eeda:	7818      	ldrb	r0, [r3, #0]
}
    eedc:	4770      	bx	lr
    eede:	46c0      	nop			; (mov r8, r8)
    eee0:	20000e04 	.word	0x20000e04

0000eee4 <_ZN14Gamebuino_Meta5Sound12startEfxOnlyEv>:

void Sound::startEfxOnly() {
	efx_only = true;
    eee4:	4b01      	ldr	r3, [pc, #4]	; (eeec <_ZN14Gamebuino_Meta5Sound12startEfxOnlyEv+0x8>)
    eee6:	2201      	movs	r2, #1
    eee8:	701a      	strb	r2, [r3, #0]
}
    eeea:	4770      	bx	lr
    eeec:	20000db2 	.word	0x20000db2

0000eef0 <_ZN14Gamebuino_Meta5Sound11stopEfxOnlyEv>:

void Sound::stopEfxOnly() {
	efx_only = false;
    eef0:	4b01      	ldr	r3, [pc, #4]	; (eef8 <_ZN14Gamebuino_Meta5Sound11stopEfxOnlyEv+0x8>)
    eef2:	2200      	movs	r2, #0
    eef4:	701a      	strb	r2, [r3, #0]
}
    eef6:	4770      	bx	lr
    eef8:	20000db2 	.word	0x20000db2

0000eefc <_ZN14Gamebuino_Meta5Sound9setVolumeEh>:
	}
	return channels[i].use;
}

void Sound::setVolume(uint8_t volume) {
	globalVolume = constrain(volume, 0, 8);
    eefc:	1c0b      	adds	r3, r1, #0
    eefe:	2908      	cmp	r1, #8
    ef00:	d900      	bls.n	ef04 <_ZN14Gamebuino_Meta5Sound9setVolumeEh+0x8>
    ef02:	2308      	movs	r3, #8
    ef04:	4a01      	ldr	r2, [pc, #4]	; (ef0c <_ZN14Gamebuino_Meta5Sound9setVolumeEh+0x10>)
    ef06:	7013      	strb	r3, [r2, #0]
}
    ef08:	4770      	bx	lr
    ef0a:	46c0      	nop			; (mov r8, r8)
    ef0c:	2000007c 	.word	0x2000007c

0000ef10 <_ZN14Gamebuino_Meta5Sound9getVolumeEv>:

uint8_t Sound::getVolume() {
	return globalVolume;
    ef10:	4b01      	ldr	r3, [pc, #4]	; (ef18 <_ZN14Gamebuino_Meta5Sound9getVolumeEv+0x8>)
    ef12:	7818      	ldrb	r0, [r3, #0]
}
    ef14:	4770      	bx	lr
    ef16:	46c0      	nop			; (mov r8, r8)
    ef18:	2000007c 	.word	0x2000007c

0000ef1c <Audio_Handler>:
#endif
void Audio_Handler (void) __attribute__((optimize("-O3")));

uint16_t flowdown = 0;

void Audio_Handler (void) {
    ef1c:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (!globalVolume || muted) {
    ef1e:	4e48      	ldr	r6, [pc, #288]	; (f040 <Audio_Handler+0x124>)
#endif
void Audio_Handler (void) __attribute__((optimize("-O3")));

uint16_t flowdown = 0;

void Audio_Handler (void) {
    ef20:	b083      	sub	sp, #12
	if (!globalVolume || muted) {
    ef22:	7833      	ldrb	r3, [r6, #0]
    ef24:	2b00      	cmp	r3, #0
    ef26:	d049      	beq.n	efbc <Audio_Handler+0xa0>
    ef28:	4b46      	ldr	r3, [pc, #280]	; (f044 <Audio_Handler+0x128>)
    ef2a:	781b      	ldrb	r3, [r3, #0]
    ef2c:	2b00      	cmp	r3, #0
    ef2e:	d145      	bne.n	efbc <Audio_Handler+0xa0>
    ef30:	4c45      	ldr	r4, [pc, #276]	; (f048 <Audio_Handler+0x12c>)
    ef32:	2200      	movs	r2, #0
    ef34:	1c27      	adds	r7, r4, #0
    ef36:	4d45      	ldr	r5, [pc, #276]	; (f04c <Audio_Handler+0x130>)
    ef38:	3750      	adds	r7, #80	; 0x50
    ef3a:	9201      	str	r2, [sp, #4]
		TC5->COUNT16.INTFLAG.bit.MC0 = 1;
		return;
	}
	int16_t output = 0;
	for (uint8_t i = 0; i < SOUND_CHANNELS; i++) {
		if (channels[i].use) {
    ef3c:	7ae3      	ldrb	r3, [r4, #11]
    ef3e:	2b00      	cmp	r3, #0
    ef40:	d01c      	beq.n	ef7c <Audio_Handler+0x60>
			switch (channels[i].type) {
    ef42:	7c23      	ldrb	r3, [r4, #16]
    ef44:	2b00      	cmp	r3, #0
    ef46:	d040      	beq.n	efca <Audio_Handler+0xae>
    ef48:	2b01      	cmp	r3, #1
    ef4a:	d117      	bne.n	ef7c <Audio_Handler+0x60>
				} else {
					channels[i].use = false;
				}
				break;
			case Sound_Channel_Type::square:
				if (efx_only && channels[i].loop) {
    ef4c:	4b40      	ldr	r3, [pc, #256]	; (f050 <Audio_Handler+0x134>)
    ef4e:	781b      	ldrb	r3, [r3, #0]
    ef50:	2b00      	cmp	r3, #0
    ef52:	d14d      	bne.n	eff0 <Audio_Handler+0xd4>
					break;
				}
				if (channels[i].index++ >= channels[i].total) {
    ef54:	8823      	ldrh	r3, [r4, #0]
    ef56:	8862      	ldrh	r2, [r4, #2]
    ef58:	1c59      	adds	r1, r3, #1
    ef5a:	8021      	strh	r1, [r4, #0]
    ef5c:	429a      	cmp	r2, r3
    ef5e:	d805      	bhi.n	ef6c <Audio_Handler+0x50>
					channels[i].last = !channels[i].last;
    ef60:	7aa2      	ldrb	r2, [r4, #10]
    ef62:	2301      	movs	r3, #1
    ef64:	405a      	eors	r2, r3
					channels[i].index = 0;
    ef66:	2300      	movs	r3, #0
			case Sound_Channel_Type::square:
				if (efx_only && channels[i].loop) {
					break;
				}
				if (channels[i].index++ >= channels[i].total) {
					channels[i].last = !channels[i].last;
    ef68:	72a2      	strb	r2, [r4, #10]
					channels[i].index = 0;
    ef6a:	8023      	strh	r3, [r4, #0]
				}
				if (channels[i].last) {
    ef6c:	7aa3      	ldrb	r3, [r4, #10]
    ef6e:	2b00      	cmp	r3, #0
    ef70:	d04d      	beq.n	f00e <Audio_Handler+0xf2>
					output -= channels[i].amplitude;
    ef72:	9a01      	ldr	r2, [sp, #4]
    ef74:	7a23      	ldrb	r3, [r4, #8]
    ef76:	1ad3      	subs	r3, r2, r3
    ef78:	b29b      	uxth	r3, r3
    ef7a:	9301      	str	r3, [sp, #4]
    ef7c:	3414      	adds	r4, #20
    ef7e:	3504      	adds	r5, #4
	if (!globalVolume || muted) {
		TC5->COUNT16.INTFLAG.bit.MC0 = 1;
		return;
	}
	int16_t output = 0;
	for (uint8_t i = 0; i < SOUND_CHANNELS; i++) {
    ef80:	42bc      	cmp	r4, r7
    ef82:	d1db      	bne.n	ef3c <Audio_Handler+0x20>
				}
				break;
			}
		}
	}
	if (output) {
    ef84:	9b01      	ldr	r3, [sp, #4]
    ef86:	2b00      	cmp	r3, #0
    ef88:	d036      	beq.n	eff8 <Audio_Handler+0xdc>
		output = (output * 4) >> (8 - globalVolume);
		//offset the signed value to be centered around 512
		//as the 10-bit DAC output is between 0 and 1024
		
		// we need to slowly fade up our zero-level to not have any plop when starting to play sound
		if (flowdown < 512) {
    ef8a:	4a32      	ldr	r2, [pc, #200]	; (f054 <Audio_Handler+0x138>)
											//might cause clipping if several sounds are played simultaneously
		//255			7			512
		//255			6			255		//keep sound as original
		//255			5			127		//reduced volume
		
		output = (output * 4) >> (8 - globalVolume);
    ef8c:	7835      	ldrb	r5, [r6, #0]
    ef8e:	b21c      	sxth	r4, r3
    ef90:	2108      	movs	r1, #8
    ef92:	1b49      	subs	r1, r1, r5
    ef94:	00a4      	lsls	r4, r4, #2
    ef96:	8813      	ldrh	r3, [r2, #0]
		//offset the signed value to be centered around 512
		//as the 10-bit DAC output is between 0 and 1024
		
		// we need to slowly fade up our zero-level to not have any plop when starting to play sound
		if (flowdown < 512) {
    ef98:	482f      	ldr	r0, [pc, #188]	; (f058 <Audio_Handler+0x13c>)
											//might cause clipping if several sounds are played simultaneously
		//255			7			512
		//255			6			255		//keep sound as original
		//255			5			127		//reduced volume
		
		output = (output * 4) >> (8 - globalVolume);
    ef9a:	410c      	asrs	r4, r1
    ef9c:	1c21      	adds	r1, r4, #0
		//offset the signed value to be centered around 512
		//as the 10-bit DAC output is between 0 and 1024
		
		// we need to slowly fade up our zero-level to not have any plop when starting to play sound
		if (flowdown < 512) {
    ef9e:	4283      	cmp	r3, r0
    efa0:	d802      	bhi.n	efa8 <Audio_Handler+0x8c>
			flowdown++;
    efa2:	3301      	adds	r3, #1
    efa4:	b29b      	uxth	r3, r3
    efa6:	8013      	strh	r3, [r2, #0]
		}
		output += flowdown;
    efa8:	185b      	adds	r3, r3, r1
    efaa:	b29b      	uxth	r3, r3
    efac:	b219      	sxth	r1, r3
    efae:	43c9      	mvns	r1, r1
    efb0:	17c9      	asrs	r1, r1, #31
    efb2:	400b      	ands	r3, r1
		if (output < 0) {
			output = 0;
		}
		analogWrite(A0, output);
    efb4:	b219      	sxth	r1, r3
    efb6:	200e      	movs	r0, #14
    efb8:	f000 fbdc 	bl	f774 <analogWrite>
		analogWrite(A0, flowdown); // zero-position
		if (flowdown > 0) {
			flowdown--;
		}
	}
	TC5->COUNT16.INTFLAG.bit.MC0 = 1;
    efbc:	4b27      	ldr	r3, [pc, #156]	; (f05c <Audio_Handler+0x140>)
    efbe:	2210      	movs	r2, #16
    efc0:	7b99      	ldrb	r1, [r3, #14]
    efc2:	430a      	orrs	r2, r1
    efc4:	739a      	strb	r2, [r3, #14]
}
    efc6:	b003      	add	sp, #12
    efc8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	int16_t output = 0;
	for (uint8_t i = 0; i < SOUND_CHANNELS; i++) {
		if (channels[i].use) {
			switch (channels[i].type) {
			case Sound_Channel_Type::raw:
				if (efx_only) {
    efca:	4b21      	ldr	r3, [pc, #132]	; (f050 <Audio_Handler+0x134>)
    efcc:	781b      	ldrb	r3, [r3, #0]
    efce:	2b00      	cmp	r3, #0
    efd0:	d1d4      	bne.n	ef7c <Audio_Handler+0x60>
					break;
				}
				if (channels[i].index < channels[i].total - 1) {
    efd2:	8862      	ldrh	r2, [r4, #2]
    efd4:	8823      	ldrh	r3, [r4, #0]
    efd6:	3a01      	subs	r2, #1
    efd8:	4293      	cmp	r3, r2
    efda:	da1e      	bge.n	f01a <Audio_Handler+0xfe>
					output += (channels[i].buffer[channels[i].index++] - 0x80);
    efdc:	1c59      	adds	r1, r3, #1
    efde:	6862      	ldr	r2, [r4, #4]
    efe0:	8021      	strh	r1, [r4, #0]
    efe2:	5cd3      	ldrb	r3, [r2, r3]
				} else if (!channels[i].last) {
					channels[i].index = 0;
					output += (channels[i].buffer[channels[i].index++] - 0x80);
    efe4:	9a01      	ldr	r2, [sp, #4]
    efe6:	3b80      	subs	r3, #128	; 0x80
    efe8:	18d3      	adds	r3, r2, r3
    efea:	b29b      	uxth	r3, r3
    efec:	9301      	str	r3, [sp, #4]
    efee:	e7c5      	b.n	ef7c <Audio_Handler+0x60>
				} else {
					channels[i].use = false;
				}
				break;
			case Sound_Channel_Type::square:
				if (efx_only && channels[i].loop) {
    eff0:	7a63      	ldrb	r3, [r4, #9]
    eff2:	2b00      	cmp	r3, #0
    eff4:	d1c2      	bne.n	ef7c <Audio_Handler+0x60>
    eff6:	e7ad      	b.n	ef54 <Audio_Handler+0x38>
		analogWrite(A0, output);
	} else {
		// we need to output 0 when not in use to not have weird sound effects with the neoLeds as the interrupt isn't 100% constant there.
		// however, jumping down from 512 (zero-positin) to 0 would give a plop
		// so instead we gradually decrease instead
		analogWrite(A0, flowdown); // zero-position
    eff8:	4c16      	ldr	r4, [pc, #88]	; (f054 <Audio_Handler+0x138>)
    effa:	200e      	movs	r0, #14
    effc:	8821      	ldrh	r1, [r4, #0]
    effe:	f000 fbb9 	bl	f774 <analogWrite>
		if (flowdown > 0) {
    f002:	8823      	ldrh	r3, [r4, #0]
    f004:	2b00      	cmp	r3, #0
    f006:	d0d9      	beq.n	efbc <Audio_Handler+0xa0>
			flowdown--;
    f008:	3b01      	subs	r3, #1
    f00a:	8023      	strh	r3, [r4, #0]
    f00c:	e7d6      	b.n	efbc <Audio_Handler+0xa0>
					channels[i].index = 0;
				}
				if (channels[i].last) {
					output -= channels[i].amplitude;
				} else {
					output += channels[i].amplitude;
    f00e:	9a01      	ldr	r2, [sp, #4]
    f010:	7a23      	ldrb	r3, [r4, #8]
    f012:	189b      	adds	r3, r3, r2
    f014:	b29b      	uxth	r3, r3
    f016:	9301      	str	r3, [sp, #4]
    f018:	e7b0      	b.n	ef7c <Audio_Handler+0x60>
				if (efx_only) {
					break;
				}
				if (channels[i].index < channels[i].total - 1) {
					output += (channels[i].buffer[channels[i].index++] - 0x80);
				} else if (!channels[i].last) {
    f01a:	7aa3      	ldrb	r3, [r4, #10]
    f01c:	2b00      	cmp	r3, #0
    f01e:	d004      	beq.n	f02a <Audio_Handler+0x10e>
					channels[i].index = 0;
					output += (channels[i].buffer[channels[i].index++] - 0x80);
				} else if (channels[i].loop) {
    f020:	7a63      	ldrb	r3, [r4, #9]
    f022:	2b00      	cmp	r3, #0
    f024:	d106      	bne.n	f034 <Audio_Handler+0x118>
					handlers[i]->rewind();
				} else {
					channels[i].use = false;
    f026:	72e3      	strb	r3, [r4, #11]
    f028:	e7a8      	b.n	ef7c <Audio_Handler+0x60>
				}
				if (channels[i].index < channels[i].total - 1) {
					output += (channels[i].buffer[channels[i].index++] - 0x80);
				} else if (!channels[i].last) {
					channels[i].index = 0;
					output += (channels[i].buffer[channels[i].index++] - 0x80);
    f02a:	2201      	movs	r2, #1
    f02c:	6863      	ldr	r3, [r4, #4]
    f02e:	8022      	strh	r2, [r4, #0]
    f030:	781b      	ldrb	r3, [r3, #0]
    f032:	e7d7      	b.n	efe4 <Audio_Handler+0xc8>
				} else if (channels[i].loop) {
					handlers[i]->rewind();
    f034:	6828      	ldr	r0, [r5, #0]
    f036:	6803      	ldr	r3, [r0, #0]
    f038:	68db      	ldr	r3, [r3, #12]
    f03a:	4798      	blx	r3
    f03c:	e79e      	b.n	ef7c <Audio_Handler+0x60>
    f03e:	46c0      	nop			; (mov r8, r8)
    f040:	2000007c 	.word	0x2000007c
    f044:	20000e04 	.word	0x20000e04
    f048:	20000db4 	.word	0x20000db4
    f04c:	20000e08 	.word	0x20000e08
    f050:	20000db2 	.word	0x20000db2
    f054:	20000db0 	.word	0x20000db0
    f058:	000001ff 	.word	0x000001ff
    f05c:	42003400 	.word	0x42003400

0000f060 <_GLOBAL__sub_I__ZN14Gamebuino_Meta12globalVolumeE>:
}
#endif

#endif // SOUND_CHANNELS

} // Gamebuino_Meta
    f060:	4a07      	ldr	r2, [pc, #28]	; (f080 <_GLOBAL__sub_I__ZN14Gamebuino_Meta12globalVolumeE+0x20>)
    f062:	1c13      	adds	r3, r2, #0
    f064:	1c11      	adds	r1, r2, #0
    f066:	3314      	adds	r3, #20
    f068:	3164      	adds	r1, #100	; 0x64
    f06a:	1c18      	adds	r0, r3, #0
    f06c:	3809      	subs	r0, #9
	raw,
	square,
};

class Sound_Handler;
struct Sound_Channel {
    f06e:	2200      	movs	r2, #0
    f070:	7002      	strb	r2, [r0, #0]
    f072:	3314      	adds	r3, #20
    f074:	3001      	adds	r0, #1
    f076:	6002      	str	r2, [r0, #0]

uint8_t globalVolume = 6;
bool muted = false;

#if SOUND_CHANNELS > 0
Sound_Channel channels[SOUND_CHANNELS];
    f078:	428b      	cmp	r3, r1
    f07a:	d1f6      	bne.n	f06a <_GLOBAL__sub_I__ZN14Gamebuino_Meta12globalVolumeE+0xa>
}
#endif

#endif // SOUND_CHANNELS

} // Gamebuino_Meta
    f07c:	4770      	bx	lr
    f07e:	46c0      	nop			; (mov r8, r8)
    f080:	20000db4 	.word	0x20000db4

0000f084 <_GLOBAL__sub_I__ZN14Gamebuino_Meta7buffersE>:
		file.read(channel->buffer, current__SampleIndex);
	}
	head_index = current__SampleIndex;
}

} // namespace Gamebuino_Meta
    f084:	2300      	movs	r3, #0
#include "../../config/config.h"
extern SdFat SD;

namespace Gamebuino_Meta {

struct Buffers {
    f086:	4904      	ldr	r1, [pc, #16]	; (f098 <_GLOBAL__sub_I__ZN14Gamebuino_Meta7buffersE+0x14>)
    f088:	2200      	movs	r2, #0
    f08a:	505a      	str	r2, [r3, r1]
    f08c:	18c9      	adds	r1, r1, r3
    f08e:	3308      	adds	r3, #8
    f090:	710a      	strb	r2, [r1, #4]
	uint8_t* buf = 0;
	bool use = false;
};
Buffers buffers[SOUND_CHANNELS];
    f092:	2b20      	cmp	r3, #32
    f094:	d1f7      	bne.n	f086 <_GLOBAL__sub_I__ZN14Gamebuino_Meta7buffersE+0x2>
		file.read(channel->buffer, current__SampleIndex);
	}
	head_index = current__SampleIndex;
}

} // namespace Gamebuino_Meta
    f096:	4770      	bx	lr
    f098:	20000e18 	.word	0x20000e18

0000f09c <_ZN8SPIClass4initEv>:
  config(DEFAULT_SPI_SETTINGS);
}

void SPIClass::init()
{
  if (initialized)
    f09c:	7a43      	ldrb	r3, [r0, #9]
    f09e:	2b00      	cmp	r3, #0
    f0a0:	d104      	bne.n	f0ac <_ZN8SPIClass4initEv+0x10>
    return;
  interruptMode = SPI_IMODE_NONE;
    f0a2:	7283      	strb	r3, [r0, #10]
  interruptSave = 0;
    f0a4:	72c3      	strb	r3, [r0, #11]
  interruptMask = 0;
    f0a6:	60c3      	str	r3, [r0, #12]
  initialized = true;
    f0a8:	2301      	movs	r3, #1
    f0aa:	7243      	strb	r3, [r0, #9]
}
    f0ac:	4770      	bx	lr

0000f0ae <_ZN8SPIClass6configE11SPISettings>:

void SPIClass::config(SPISettings settings)
{
    f0ae:	b530      	push	{r4, r5, lr}
    f0b0:	b085      	sub	sp, #20
    f0b2:	1c04      	adds	r4, r0, #0
    f0b4:	ad02      	add	r5, sp, #8
  _p_sercom->disableSPI();
    f0b6:	6800      	ldr	r0, [r0, #0]
  interruptMask = 0;
  initialized = true;
}

void SPIClass::config(SPISettings settings)
{
    f0b8:	9102      	str	r1, [sp, #8]
    f0ba:	9203      	str	r2, [sp, #12]
  _p_sercom->disableSPI();
    f0bc:	f000 fec0 	bl	fe40 <_ZN6SERCOM10disableSPIEv>

  _p_sercom->initSPI(_padTx, _padRx, SPI_CHAR_SIZE_8_BITS, settings.bitOrder);
    f0c0:	796b      	ldrb	r3, [r5, #5]
    f0c2:	79e1      	ldrb	r1, [r4, #7]
    f0c4:	7a22      	ldrb	r2, [r4, #8]
    f0c6:	9300      	str	r3, [sp, #0]
    f0c8:	6820      	ldr	r0, [r4, #0]
    f0ca:	2300      	movs	r3, #0
    f0cc:	f000 ff74 	bl	ffb8 <_ZN6SERCOM7initSPIE14SercomSpiTXPad11SercomRXPad17SercomSpiCharSize15SercomDataOrder>
  _p_sercom->initSPIClock(settings.dataMode, settings.clockFreq);
    f0d0:	7929      	ldrb	r1, [r5, #4]
    f0d2:	6820      	ldr	r0, [r4, #0]
    f0d4:	9a02      	ldr	r2, [sp, #8]
    f0d6:	f000 fe83 	bl	fde0 <_ZN6SERCOM12initSPIClockE18SercomSpiClockModem>

  _p_sercom->enableSPI();
    f0da:	6820      	ldr	r0, [r4, #0]
    f0dc:	f000 fea6 	bl	fe2c <_ZN6SERCOM9enableSPIEv>
}
    f0e0:	b005      	add	sp, #20
    f0e2:	bd30      	pop	{r4, r5, pc}

0000f0e4 <_ZN8SPIClass5beginEv>:
  _padTx=PadTx;
  _padRx=PadRx;
}

void SPIClass::begin()
{
    f0e4:	b570      	push	{r4, r5, r6, lr}
    f0e6:	1c04      	adds	r4, r0, #0
  init();

  // PIO init
  pinPeripheral(_uc_pinMiso, g_APinDescription[_uc_pinMiso].ulPinType);
    f0e8:	2618      	movs	r6, #24
  _padRx=PadRx;
}

void SPIClass::begin()
{
  init();
    f0ea:	f7ff ffd7 	bl	f09c <_ZN8SPIClass4initEv>

  // PIO init
  pinPeripheral(_uc_pinMiso, g_APinDescription[_uc_pinMiso].ulPinType);
    f0ee:	7920      	ldrb	r0, [r4, #4]
    f0f0:	1c33      	adds	r3, r6, #0
    f0f2:	4343      	muls	r3, r0
    f0f4:	4d0d      	ldr	r5, [pc, #52]	; (f12c <_ZN8SPIClass5beginEv+0x48>)
    f0f6:	2108      	movs	r1, #8
    f0f8:	18eb      	adds	r3, r5, r3
    f0fa:	5659      	ldrsb	r1, [r3, r1]
    f0fc:	f000 fcbe 	bl	fa7c <pinPeripheral>
  pinPeripheral(_uc_pinSCK, g_APinDescription[_uc_pinSCK].ulPinType);
    f100:	79a0      	ldrb	r0, [r4, #6]
    f102:	1c33      	adds	r3, r6, #0
    f104:	4343      	muls	r3, r0
    f106:	2108      	movs	r1, #8
    f108:	18eb      	adds	r3, r5, r3
    f10a:	5659      	ldrsb	r1, [r3, r1]
    f10c:	f000 fcb6 	bl	fa7c <pinPeripheral>
  pinPeripheral(_uc_pinMosi, g_APinDescription[_uc_pinMosi].ulPinType);
    f110:	7960      	ldrb	r0, [r4, #5]
    f112:	2108      	movs	r1, #8
    f114:	4346      	muls	r6, r0
    f116:	19ad      	adds	r5, r5, r6
    f118:	5669      	ldrsb	r1, [r5, r1]
    f11a:	f000 fcaf 	bl	fa7c <pinPeripheral>

  config(DEFAULT_SPI_SETTINGS);
    f11e:	4b04      	ldr	r3, [pc, #16]	; (f130 <_ZN8SPIClass5beginEv+0x4c>)
    f120:	1c20      	adds	r0, r4, #0
    f122:	cb06      	ldmia	r3!, {r1, r2}
    f124:	f7ff ffc3 	bl	f0ae <_ZN8SPIClass6configE11SPISettings>
}
    f128:	bd70      	pop	{r4, r5, r6, pc}
    f12a:	46c0      	nop			; (mov r8, r8)
    f12c:	000156a8 	.word	0x000156a8
    f130:	20000e38 	.word	0x20000e38

0000f134 <_ZN8SPIClass16beginTransactionE11SPISettings>:
  if (irestore)
    interrupts();
}

void SPIClass::beginTransaction(SPISettings settings)
{
    f134:	b507      	push	{r0, r1, r2, lr}
  if (interruptMode != SPI_IMODE_NONE)
    f136:	7a83      	ldrb	r3, [r0, #10]
  if (irestore)
    interrupts();
}

void SPIClass::beginTransaction(SPISettings settings)
{
    f138:	9100      	str	r1, [sp, #0]
    f13a:	9201      	str	r2, [sp, #4]
  if (interruptMode != SPI_IMODE_NONE)
    f13c:	2b00      	cmp	r3, #0
    f13e:	d00d      	beq.n	f15c <_ZN8SPIClass16beginTransactionE11SPISettings+0x28>
  {
    if (interruptMode & SPI_IMODE_GLOBAL)
    f140:	079a      	lsls	r2, r3, #30
    f142:	d506      	bpl.n	f152 <_ZN8SPIClass16beginTransactionE11SPISettings+0x1e>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    f144:	f3ef 8310 	mrs	r3, PRIMASK
#define interruptsStatus() __interruptsStatus()
static inline unsigned char __interruptsStatus(void) __attribute__((always_inline, unused));
static inline unsigned char __interruptsStatus(void)
{
  // See http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0497a/CHDBIBGJ.html
  return (__get_PRIMASK() ? 0 : 1);
    f148:	425a      	negs	r2, r3
    f14a:	4153      	adcs	r3, r2
{
  if (interruptMode != SPI_IMODE_NONE)
  {
    if (interruptMode & SPI_IMODE_GLOBAL)
    {
      interruptSave = interruptsStatus();
    f14c:	72c3      	strb	r3, [r0, #11]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    f14e:	b672      	cpsid	i
    f150:	e004      	b.n	f15c <_ZN8SPIClass16beginTransactionE11SPISettings+0x28>
      noInterrupts();
    }
    else if (interruptMode & SPI_IMODE_EXTINT)
    f152:	07da      	lsls	r2, r3, #31
    f154:	d502      	bpl.n	f15c <_ZN8SPIClass16beginTransactionE11SPISettings+0x28>
      EIC->INTENCLR.reg = EIC_INTENCLR_EXTINT(interruptMask);
    f156:	8982      	ldrh	r2, [r0, #12]
    f158:	4b03      	ldr	r3, [pc, #12]	; (f168 <_ZN8SPIClass16beginTransactionE11SPISettings+0x34>)
    f15a:	609a      	str	r2, [r3, #8]
  }

  config(settings);
    f15c:	9900      	ldr	r1, [sp, #0]
    f15e:	9a01      	ldr	r2, [sp, #4]
    f160:	f7ff ffa5 	bl	f0ae <_ZN8SPIClass6configE11SPISettings>
}
    f164:	bd07      	pop	{r0, r1, r2, pc}
    f166:	46c0      	nop			; (mov r8, r8)
    f168:	40001800 	.word	0x40001800

0000f16c <_ZN8SPIClass14endTransactionEv>:

void SPIClass::endTransaction(void)
{
  if (interruptMode != SPI_IMODE_NONE)
    f16c:	7a83      	ldrb	r3, [r0, #10]
    f16e:	2b00      	cmp	r3, #0
    f170:	d00b      	beq.n	f18a <_ZN8SPIClass14endTransactionEv+0x1e>
  {
    if (interruptMode & SPI_IMODE_GLOBAL)
    f172:	079a      	lsls	r2, r3, #30
    f174:	d504      	bpl.n	f180 <_ZN8SPIClass14endTransactionEv+0x14>
    {
      if (interruptSave)
    f176:	7ac3      	ldrb	r3, [r0, #11]
    f178:	2b00      	cmp	r3, #0
    f17a:	d006      	beq.n	f18a <_ZN8SPIClass14endTransactionEv+0x1e>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    f17c:	b662      	cpsie	i
    f17e:	e004      	b.n	f18a <_ZN8SPIClass14endTransactionEv+0x1e>
        interrupts();
    }
    else if (interruptMode & SPI_IMODE_EXTINT)
    f180:	07da      	lsls	r2, r3, #31
    f182:	d502      	bpl.n	f18a <_ZN8SPIClass14endTransactionEv+0x1e>
      EIC->INTENSET.reg = EIC_INTENSET_EXTINT(interruptMask);
    f184:	8982      	ldrh	r2, [r0, #12]
    f186:	4b01      	ldr	r3, [pc, #4]	; (f18c <_ZN8SPIClass14endTransactionEv+0x20>)
    f188:	60da      	str	r2, [r3, #12]
  }
}
    f18a:	4770      	bx	lr
    f18c:	40001800 	.word	0x40001800

0000f190 <_ZN8SPIClass15setClockDividerEh>:
      break;
  }
}

void SPIClass::setClockDivider(uint8_t div)
{
    f190:	b508      	push	{r3, lr}
    f192:	6800      	ldr	r0, [r0, #0]
  if (div < SPI_MIN_CLOCK_DIVIDER) {
    f194:	2901      	cmp	r1, #1
    f196:	d800      	bhi.n	f19a <_ZN8SPIClass15setClockDividerEh+0xa>
    _p_sercom->setBaudrateSPI(SPI_MIN_CLOCK_DIVIDER);
    f198:	2102      	movs	r1, #2
  } else {
    _p_sercom->setBaudrateSPI(div);
    f19a:	f000 fe5b 	bl	fe54 <_ZN6SERCOM14setBaudrateSPIEh>
  }
}
    f19e:	bd08      	pop	{r3, pc}

0000f1a0 <_ZN8SPIClass8transferEh>:

byte SPIClass::transfer(uint8_t data)
{
    f1a0:	b508      	push	{r3, lr}
  return _p_sercom->transferDataSPI(data);
    f1a2:	6800      	ldr	r0, [r0, #0]
    f1a4:	f000 fe6e 	bl	fe84 <_ZN6SERCOM15transferDataSPIEh>
}
    f1a8:	bd08      	pop	{r3, pc}
	...

0000f1ac <_GLOBAL__sub_I__ZN8SPIClassC2EP6SERCOMhhh14SercomSpiTXPad11SercomRXPad>:
  void init_MightInline(uint32_t clock, BitOrder bitOrder, uint8_t dataMode) {
    init_AlwaysInline(clock, bitOrder, dataMode);
  }

  void init_AlwaysInline(uint32_t clock, BitOrder bitOrder, uint8_t dataMode) __attribute__((__always_inline__)) {
    this->clockFreq = (clock >= (F_CPU / SPI_MIN_CLOCK_DIVIDER) ? F_CPU / SPI_MIN_CLOCK_DIVIDER : clock);
    f1ac:	4b09      	ldr	r3, [pc, #36]	; (f1d4 <_GLOBAL__sub_I__ZN8SPIClassC2EP6SERCOMhhh14SercomSpiTXPad11SercomRXPad+0x28>)
    f1ae:	4a0a      	ldr	r2, [pc, #40]	; (f1d8 <_GLOBAL__sub_I__ZN8SPIClassC2EP6SERCOMhhh14SercomSpiTXPad11SercomRXPad+0x2c>)

SPIClass::SPIClass(SERCOM *p_sercom, uint8_t uc_pinMISO, uint8_t uc_pinSCK, uint8_t uc_pinMOSI, SercomSpiTXPad PadTx, SercomRXPad PadRx)
{
  initialized = false;
  assert(p_sercom != NULL);
  _p_sercom = p_sercom;
    f1b0:	490a      	ldr	r1, [pc, #40]	; (f1dc <_GLOBAL__sub_I__ZN8SPIClassC2EP6SERCOMhhh14SercomSpiTXPad11SercomRXPad+0x30>)
    f1b2:	601a      	str	r2, [r3, #0]

    this->bitOrder = (bitOrder == MSBFIRST ? MSB_FIRST : LSB_FIRST);
    f1b4:	2200      	movs	r2, #0
    f1b6:	715a      	strb	r2, [r3, #5]

    switch (dataMode)
    {
      case SPI_MODE0:
        this->dataMode = SERCOM_SPI_MODE_0; break;
    f1b8:	711a      	strb	r2, [r3, #4]

const SPISettings DEFAULT_SPI_SETTINGS = SPISettings();

SPIClass::SPIClass(SERCOM *p_sercom, uint8_t uc_pinMISO, uint8_t uc_pinSCK, uint8_t uc_pinMOSI, SercomSpiTXPad PadTx, SercomRXPad PadRx)
{
  initialized = false;
    f1ba:	4b09      	ldr	r3, [pc, #36]	; (f1e0 <_GLOBAL__sub_I__ZN8SPIClassC2EP6SERCOMhhh14SercomSpiTXPad11SercomRXPad+0x34>)
  assert(p_sercom != NULL);
  _p_sercom = p_sercom;
    f1bc:	6019      	str	r1, [r3, #0]

  // pins
  _uc_pinMiso = uc_pinMISO;
    f1be:	2116      	movs	r1, #22
    f1c0:	7119      	strb	r1, [r3, #4]
  _uc_pinSCK = uc_pinSCK;
    f1c2:	2118      	movs	r1, #24
    f1c4:	7199      	strb	r1, [r3, #6]
  _uc_pinMosi = uc_pinMOSI;
    f1c6:	2117      	movs	r1, #23
    f1c8:	7159      	strb	r1, [r3, #5]

  // SERCOM pads
  _padTx=PadTx;
    f1ca:	2101      	movs	r1, #1

const SPISettings DEFAULT_SPI_SETTINGS = SPISettings();

SPIClass::SPIClass(SERCOM *p_sercom, uint8_t uc_pinMISO, uint8_t uc_pinSCK, uint8_t uc_pinMOSI, SercomSpiTXPad PadTx, SercomRXPad PadRx)
{
  initialized = false;
    f1cc:	725a      	strb	r2, [r3, #9]
  _uc_pinMiso = uc_pinMISO;
  _uc_pinSCK = uc_pinSCK;
  _uc_pinMosi = uc_pinMOSI;

  // SERCOM pads
  _padTx=PadTx;
    f1ce:	71d9      	strb	r1, [r3, #7]
  _padRx=PadRx;
    f1d0:	721a      	strb	r2, [r3, #8]
  #ifndef PERIPH_SPI
    #define PERIPH_SPI           sercom4
    #define PAD_SPI_TX           SPI_PAD_2_SCK_3
    #define PAD_SPI_RX           SERCOM_RX_PAD_0
  #endif // PERIPH_SPI
  SPIClass SPI (&PERIPH_SPI,  PIN_SPI_MISO,  PIN_SPI_SCK,  PIN_SPI_MOSI,  PAD_SPI_TX,  PAD_SPI_RX);
    f1d2:	4770      	bx	lr
    f1d4:	20000e38 	.word	0x20000e38
    f1d8:	003d0900 	.word	0x003d0900
    f1dc:	20000f20 	.word	0x20000f20
    f1e0:	20000e40 	.word	0x20000e40

0000f1e4 <SERCOM0_Handler>:
SERCOM sercom5( SERCOM5 ) ;

Uart Serial1( &sercom0, PIN_SERIAL1_RX, PIN_SERIAL1_TX, PAD_SERIAL1_RX, PAD_SERIAL1_TX ) ;
Uart Serial( &sercom5, PIN_SERIAL_RX, PIN_SERIAL_TX, PAD_SERIAL_RX, PAD_SERIAL_TX ) ;
void SERCOM0_Handler()
{
    f1e4:	b508      	push	{r3, lr}
  Serial1.IrqHandler();
    f1e6:	4802      	ldr	r0, [pc, #8]	; (f1f0 <SERCOM0_Handler+0xc>)
    f1e8:	f000 ff5c 	bl	100a4 <_ZN4Uart10IrqHandlerEv>
}
    f1ec:	bd08      	pop	{r3, pc}
    f1ee:	46c0      	nop			; (mov r8, r8)
    f1f0:	20000eb0 	.word	0x20000eb0

0000f1f4 <SERCOM5_Handler>:

void SERCOM5_Handler()
{
    f1f4:	b508      	push	{r3, lr}
  Serial.IrqHandler();
    f1f6:	4802      	ldr	r0, [pc, #8]	; (f200 <SERCOM5_Handler+0xc>)
    f1f8:	f000 ff54 	bl	100a4 <_ZN4Uart10IrqHandlerEv>
}
    f1fc:	bd08      	pop	{r3, pc}
    f1fe:	46c0      	nop			; (mov r8, r8)
    f200:	20000e50 	.word	0x20000e50

0000f204 <_GLOBAL__sub_I_g_APinDescription>:
    f204:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
} ;

const void* g_apTCInstances[TCC_INST_NUM+TC_INST_NUM]={ TCC0, TCC1, TCC2, TC3, TC4, TC5 } ;

// Multi-serial objects instantiation
SERCOM sercom0( SERCOM0 ) ;
    f206:	4f16      	ldr	r7, [pc, #88]	; (f260 <_GLOBAL__sub_I_g_APinDescription+0x5c>)
    f208:	4916      	ldr	r1, [pc, #88]	; (f264 <_GLOBAL__sub_I_g_APinDescription+0x60>)
    f20a:	1c38      	adds	r0, r7, #0
    f20c:	f000 fd78 	bl	fd00 <_ZN6SERCOMC1EP6Sercom>
SERCOM sercom1( SERCOM1 ) ;
    f210:	4915      	ldr	r1, [pc, #84]	; (f268 <_GLOBAL__sub_I_g_APinDescription+0x64>)
    f212:	4816      	ldr	r0, [pc, #88]	; (f26c <_GLOBAL__sub_I_g_APinDescription+0x68>)
    f214:	f000 fd74 	bl	fd00 <_ZN6SERCOMC1EP6Sercom>
SERCOM sercom2( SERCOM2 ) ;
    f218:	4915      	ldr	r1, [pc, #84]	; (f270 <_GLOBAL__sub_I_g_APinDescription+0x6c>)
    f21a:	4816      	ldr	r0, [pc, #88]	; (f274 <_GLOBAL__sub_I_g_APinDescription+0x70>)
    f21c:	f000 fd70 	bl	fd00 <_ZN6SERCOMC1EP6Sercom>
SERCOM sercom3( SERCOM3 ) ;
    f220:	4915      	ldr	r1, [pc, #84]	; (f278 <_GLOBAL__sub_I_g_APinDescription+0x74>)
    f222:	4816      	ldr	r0, [pc, #88]	; (f27c <_GLOBAL__sub_I_g_APinDescription+0x78>)
    f224:	f000 fd6c 	bl	fd00 <_ZN6SERCOMC1EP6Sercom>
SERCOM sercom4( SERCOM4 ) ;
    f228:	4915      	ldr	r1, [pc, #84]	; (f280 <_GLOBAL__sub_I_g_APinDescription+0x7c>)
    f22a:	4816      	ldr	r0, [pc, #88]	; (f284 <_GLOBAL__sub_I_g_APinDescription+0x80>)
    f22c:	f000 fd68 	bl	fd00 <_ZN6SERCOMC1EP6Sercom>
SERCOM sercom5( SERCOM5 ) ;
    f230:	4d15      	ldr	r5, [pc, #84]	; (f288 <_GLOBAL__sub_I_g_APinDescription+0x84>)

Uart Serial1( &sercom0, PIN_SERIAL1_RX, PIN_SERIAL1_TX, PAD_SERIAL1_RX, PAD_SERIAL1_TX ) ;
    f232:	2603      	movs	r6, #3
    f234:	2401      	movs	r4, #1
SERCOM sercom0( SERCOM0 ) ;
SERCOM sercom1( SERCOM1 ) ;
SERCOM sercom2( SERCOM2 ) ;
SERCOM sercom3( SERCOM3 ) ;
SERCOM sercom4( SERCOM4 ) ;
SERCOM sercom5( SERCOM5 ) ;
    f236:	1c28      	adds	r0, r5, #0
    f238:	4914      	ldr	r1, [pc, #80]	; (f28c <_GLOBAL__sub_I_g_APinDescription+0x88>)
    f23a:	f000 fd61 	bl	fd00 <_ZN6SERCOMC1EP6Sercom>

Uart Serial1( &sercom0, PIN_SERIAL1_RX, PIN_SERIAL1_TX, PAD_SERIAL1_RX, PAD_SERIAL1_TX ) ;
    f23e:	1c39      	adds	r1, r7, #0
    f240:	9600      	str	r6, [sp, #0]
    f242:	1c23      	adds	r3, r4, #0
    f244:	9401      	str	r4, [sp, #4]
    f246:	2200      	movs	r2, #0
    f248:	4811      	ldr	r0, [pc, #68]	; (f290 <_GLOBAL__sub_I_g_APinDescription+0x8c>)
    f24a:	f000 ff07 	bl	1005c <_ZN4UartC1EP6SERCOMhh11SercomRXPad15SercomUartTXPad>
Uart Serial( &sercom5, PIN_SERIAL_RX, PIN_SERIAL_TX, PAD_SERIAL_RX, PAD_SERIAL_TX ) ;
    f24e:	9600      	str	r6, [sp, #0]
    f250:	1c29      	adds	r1, r5, #0
    f252:	9401      	str	r4, [sp, #4]
    f254:	221f      	movs	r2, #31
    f256:	231e      	movs	r3, #30
    f258:	480e      	ldr	r0, [pc, #56]	; (f294 <_GLOBAL__sub_I_g_APinDescription+0x90>)
    f25a:	f000 feff 	bl	1005c <_ZN4UartC1EP6SERCOMhh11SercomRXPad15SercomUartTXPad>
}

void SERCOM5_Handler()
{
  Serial.IrqHandler();
}
    f25e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    f260:	20000f14 	.word	0x20000f14
    f264:	42000800 	.word	0x42000800
    f268:	42000c00 	.word	0x42000c00
    f26c:	20000f18 	.word	0x20000f18
    f270:	42001000 	.word	0x42001000
    f274:	20000f1c 	.word	0x20000f1c
    f278:	42001400 	.word	0x42001400
    f27c:	20000f10 	.word	0x20000f10
    f280:	42001800 	.word	0x42001800
    f284:	20000f20 	.word	0x20000f20
    f288:	20000f24 	.word	0x20000f24
    f28c:	42001c00 	.word	0x42001c00
    f290:	20000eb0 	.word	0x20000eb0
    f294:	20000e50 	.word	0x20000e50

0000f298 <Dummy_Handler>:
extern void pendSVHook(void);
extern int sysTickHook(void);

/* Default empty handler */
void Dummy_Handler(void)
{
    f298:	e7fe      	b.n	f298 <Dummy_Handler>
	...

0000f29c <USB_Handler>:
}

static void (*usb_isr)(void) = NULL;

void USB_Handler(void)
{
    f29c:	b508      	push	{r3, lr}
  if (usb_isr)
    f29e:	4b03      	ldr	r3, [pc, #12]	; (f2ac <USB_Handler+0x10>)
    f2a0:	681b      	ldr	r3, [r3, #0]
    f2a2:	2b00      	cmp	r3, #0
    f2a4:	d000      	beq.n	f2a8 <USB_Handler+0xc>
    usb_isr();
    f2a6:	4798      	blx	r3
}
    f2a8:	bd08      	pop	{r3, pc}
    f2aa:	46c0      	nop			; (mov r8, r8)
    f2ac:	20000f28 	.word	0x20000f28

0000f2b0 <Reset_Handler>:

extern int main(void);

/* This is called on processor reset to initialize the device and call main() */
void Reset_Handler(void)
{
    f2b0:	b538      	push	{r3, r4, r5, lr}
    f2b2:	490f      	ldr	r1, [pc, #60]	; (f2f0 <Reset_Handler+0x40>)
    f2b4:	4c0f      	ldr	r4, [pc, #60]	; (f2f4 <Reset_Handler+0x44>)

  /* Initialize the initialized data section */
  pSrc = &__etext;
  pDest = &__data_start__;

  if ((&__data_start__ != &__data_end__) && (pSrc != pDest)) {
    f2b6:	42a1      	cmp	r1, r4
    f2b8:	d104      	bne.n	f2c4 <Reset_Handler+0x14>
  if ((&__data_start__ != &__data_end__) && (pSrc != pDest)) {
    for (pDest = &__bss_start__; pDest < &__bss_end__; pDest++)
      *pDest = 0;
  }

  SystemInit();
    f2ba:	f000 f885 	bl	f3c8 <SystemInit>

  main();
    f2be:	f000 ff97 	bl	101f0 <main>
    f2c2:	e00b      	b.n	f2dc <Reset_Handler+0x2c>

  /* Initialize the initialized data section */
  pSrc = &__etext;
  pDest = &__data_start__;

  if ((&__data_start__ != &__data_end__) && (pSrc != pDest)) {
    f2c4:	4d0c      	ldr	r5, [pc, #48]	; (f2f8 <Reset_Handler+0x48>)
    f2c6:	428d      	cmp	r5, r1
    f2c8:	d0f7      	beq.n	f2ba <Reset_Handler+0xa>
    f2ca:	2300      	movs	r3, #0
    f2cc:	18ca      	adds	r2, r1, r3
    f2ce:	18e8      	adds	r0, r5, r3
    for (; pDest < &__data_end__; pDest++, pSrc++)
    f2d0:	42a2      	cmp	r2, r4
    f2d2:	d204      	bcs.n	f2de <Reset_Handler+0x2e>
      *pDest = *pSrc;
    f2d4:	6800      	ldr	r0, [r0, #0]
    f2d6:	3304      	adds	r3, #4
    f2d8:	6010      	str	r0, [r2, #0]
    f2da:	e7f7      	b.n	f2cc <Reset_Handler+0x1c>
    f2dc:	e7fe      	b.n	f2dc <Reset_Handler+0x2c>
  }

  /* Clear the zero section */
  if ((&__data_start__ != &__data_end__) && (pSrc != pDest)) {
    f2de:	4290      	cmp	r0, r2
    f2e0:	d0eb      	beq.n	f2ba <Reset_Handler+0xa>
    f2e2:	4b06      	ldr	r3, [pc, #24]	; (f2fc <Reset_Handler+0x4c>)
    for (pDest = &__bss_start__; pDest < &__bss_end__; pDest++)
    f2e4:	4a06      	ldr	r2, [pc, #24]	; (f300 <Reset_Handler+0x50>)
    f2e6:	4293      	cmp	r3, r2
    f2e8:	d2e7      	bcs.n	f2ba <Reset_Handler+0xa>
      *pDest = 0;
    f2ea:	2200      	movs	r2, #0
    f2ec:	c304      	stmia	r3!, {r2}
    f2ee:	e7f9      	b.n	f2e4 <Reset_Handler+0x34>
    f2f0:	20000000 	.word	0x20000000
    f2f4:	200001d0 	.word	0x200001d0
    f2f8:	00015bec 	.word	0x00015bec
    f2fc:	200001d0 	.word	0x200001d0
    f300:	20001584 	.word	0x20001584

0000f304 <SysTick_Handler>:

/* Default Arduino systick handler */
extern void SysTick_DefaultHandler(void);

void SysTick_Handler(void)
{
    f304:	b508      	push	{r3, lr}
  if (sysTickHook())
    f306:	f000 f85d 	bl	f3c4 <sysTickHook>
    f30a:	2800      	cmp	r0, #0
    f30c:	d101      	bne.n	f312 <SysTick_Handler+0xe>
    return;
  SysTick_DefaultHandler();
    f30e:	f000 f84f 	bl	f3b0 <SysTick_DefaultHandler>
}
    f312:	bd08      	pop	{r3, pc}

0000f314 <USB_SetHandler>:
    usb_isr();
}

void USB_SetHandler(void (*new_usb_isr)(void))
{
  usb_isr = new_usb_isr;
    f314:	4b01      	ldr	r3, [pc, #4]	; (f31c <USB_SetHandler+0x8>)
    f316:	6018      	str	r0, [r3, #0]
}
    f318:	4770      	bx	lr
    f31a:	46c0      	nop			; (mov r8, r8)
    f31c:	20000f28 	.word	0x20000f28

0000f320 <millis>:
static volatile uint32_t _ulTickCount=0 ;

uint32_t millis( void )
{
// todo: ensure no interrupts
  return _ulTickCount ;
    f320:	4b01      	ldr	r3, [pc, #4]	; (f328 <millis+0x8>)
    f322:	6818      	ldr	r0, [r3, #0]
}
    f324:	4770      	bx	lr
    f326:	46c0      	nop			; (mov r8, r8)
    f328:	20000f2c 	.word	0x20000f2c

0000f32c <micros>:
// Interrupt-compatible version of micros
// Theory: repeatedly take readings of SysTick counter, millis counter and SysTick interrupt pending flag.
// When it appears that millis counter and pending is stable and SysTick hasn't rolled over, use these
// values to calculate micros. If there is a pending SysTick, add one to the millis counter in the calculation.
uint32_t micros( void )
{
    f32c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  uint32_t ticks, ticks2;
  uint32_t pend, pend2;
  uint32_t count, count2;

  ticks2  = SysTick->VAL;
    f32e:	4d14      	ldr	r5, [pc, #80]	; (f380 <micros+0x54>)
  pend2   = !!(SCB->ICSR & SCB_ICSR_PENDSTSET_Msk)  ;
    f330:	4c14      	ldr	r4, [pc, #80]	; (f384 <micros+0x58>)
{
  uint32_t ticks, ticks2;
  uint32_t pend, pend2;
  uint32_t count, count2;

  ticks2  = SysTick->VAL;
    f332:	68a9      	ldr	r1, [r5, #8]
  pend2   = !!(SCB->ICSR & SCB_ICSR_PENDSTSET_Msk)  ;
  count2  = _ulTickCount ;
    f334:	4814      	ldr	r0, [pc, #80]	; (f388 <micros+0x5c>)
  uint32_t ticks, ticks2;
  uint32_t pend, pend2;
  uint32_t count, count2;

  ticks2  = SysTick->VAL;
  pend2   = !!(SCB->ICSR & SCB_ICSR_PENDSTSET_Msk)  ;
    f336:	6862      	ldr	r2, [r4, #4]
  count2  = _ulTickCount ;
    f338:	6803      	ldr	r3, [r0, #0]
  uint32_t ticks, ticks2;
  uint32_t pend, pend2;
  uint32_t count, count2;

  ticks2  = SysTick->VAL;
  pend2   = !!(SCB->ICSR & SCB_ICSR_PENDSTSET_Msk)  ;
    f33a:	0152      	lsls	r2, r2, #5
    f33c:	0fd2      	lsrs	r2, r2, #31
    f33e:	1c2e      	adds	r6, r5, #0
    f340:	1c27      	adds	r7, r4, #0
    f342:	4684      	mov	ip, r0
  do
  {
    ticks=ticks2;
    pend=pend2;
    count=count2;
    ticks2  = SysTick->VAL;
    f344:	68b0      	ldr	r0, [r6, #8]
    pend2   = !!(SCB->ICSR & SCB_ICSR_PENDSTSET_Msk)  ;
    f346:	687d      	ldr	r5, [r7, #4]
  do
  {
    ticks=ticks2;
    pend=pend2;
    count=count2;
    ticks2  = SysTick->VAL;
    f348:	9001      	str	r0, [sp, #4]
    pend2   = !!(SCB->ICSR & SCB_ICSR_PENDSTSET_Msk)  ;
    f34a:	016d      	lsls	r5, r5, #5
    count2  = _ulTickCount ;
    f34c:	4660      	mov	r0, ip
  {
    ticks=ticks2;
    pend=pend2;
    count=count2;
    ticks2  = SysTick->VAL;
    pend2   = !!(SCB->ICSR & SCB_ICSR_PENDSTSET_Msk)  ;
    f34e:	0fed      	lsrs	r5, r5, #31
    count2  = _ulTickCount ;
    f350:	6804      	ldr	r4, [r0, #0]
  } while ((pend != pend2) || (count != count2) || (ticks < ticks2));
    f352:	42aa      	cmp	r2, r5
    f354:	d003      	beq.n	f35e <micros+0x32>
    f356:	1c2a      	adds	r2, r5, #0
    f358:	1c23      	adds	r3, r4, #0
    f35a:	9901      	ldr	r1, [sp, #4]
    f35c:	e7f2      	b.n	f344 <micros+0x18>
    f35e:	42a3      	cmp	r3, r4
    f360:	d1fa      	bne.n	f358 <micros+0x2c>
    f362:	9801      	ldr	r0, [sp, #4]
    f364:	4281      	cmp	r1, r0
    f366:	d3f7      	bcc.n	f358 <micros+0x2c>

  return ((count+pend) * 1000) + (((SysTick->LOAD  - ticks)*(1048576/(VARIANT_MCK/1000000)))>>20) ;
    f368:	4805      	ldr	r0, [pc, #20]	; (f380 <micros+0x54>)
    f36a:	18d2      	adds	r2, r2, r3
    f36c:	6840      	ldr	r0, [r0, #4]
    f36e:	23fa      	movs	r3, #250	; 0xfa
    f370:	1a41      	subs	r1, r0, r1
    f372:	4806      	ldr	r0, [pc, #24]	; (f38c <micros+0x60>)
    f374:	009b      	lsls	r3, r3, #2
    f376:	4348      	muls	r0, r1
    f378:	4353      	muls	r3, r2
    f37a:	0d00      	lsrs	r0, r0, #20
    f37c:	18c0      	adds	r0, r0, r3
  // this is an optimization to turn a runtime division into two compile-time divisions and
  // a runtime multiplication and shift, saving a few cycles
}
    f37e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    f380:	e000e010 	.word	0xe000e010
    f384:	e000ed00 	.word	0xe000ed00
    f388:	20000f2c 	.word	0x20000f2c
    f38c:	00005555 	.word	0x00005555

0000f390 <delay>:

void delay( uint32_t ms )
{
    f390:	b570      	push	{r4, r5, r6, lr}
    f392:	1e04      	subs	r4, r0, #0
  if ( ms == 0 )
    f394:	d008      	beq.n	f3a8 <delay+0x18>
  {
    return ;
  }

  uint32_t start = _ulTickCount ;
    f396:	4b05      	ldr	r3, [pc, #20]	; (f3ac <delay+0x1c>)
    f398:	681d      	ldr	r5, [r3, #0]
    f39a:	1c1e      	adds	r6, r3, #0

  do
  {
    yield() ;
    f39c:	f7f7 fba4 	bl	6ae8 <yield>
  } while ( _ulTickCount - start < ms ) ;
    f3a0:	6833      	ldr	r3, [r6, #0]
    f3a2:	1b5b      	subs	r3, r3, r5
    f3a4:	42a3      	cmp	r3, r4
    f3a6:	d3f9      	bcc.n	f39c <delay+0xc>
}
    f3a8:	bd70      	pop	{r4, r5, r6, pc}
    f3aa:	46c0      	nop			; (mov r8, r8)
    f3ac:	20000f2c 	.word	0x20000f2c

0000f3b0 <SysTick_DefaultHandler>:

#include "Reset.h" // for tickReset()

void SysTick_DefaultHandler(void)
{
    f3b0:	b508      	push	{r3, lr}
  // Increment tick count each ms
  _ulTickCount++;
    f3b2:	4b03      	ldr	r3, [pc, #12]	; (f3c0 <SysTick_DefaultHandler+0x10>)
    f3b4:	681a      	ldr	r2, [r3, #0]
    f3b6:	3201      	adds	r2, #1
    f3b8:	601a      	str	r2, [r3, #0]
  tickReset();
    f3ba:	f000 fc67 	bl	fc8c <tickReset>
}
    f3be:	bd08      	pop	{r3, pc}
    f3c0:	20000f2c 	.word	0x20000f2c

0000f3c4 <sysTickHook>:
 * handler provided by Arduino.
 */
static int __false() {
	// Return false
	return 0;
}
    f3c4:	2000      	movs	r0, #0
    f3c6:	4770      	bx	lr

0000f3c8 <SystemInit>:
#define GENERIC_CLOCK_GENERATOR_OSC8M     (3u)
// Constants for Clock multiplexers
#define GENERIC_CLOCK_MULTIPLEXER_DFLL48M (0u)

void SystemInit( void )
{
    f3c8:	b570      	push	{r4, r5, r6, lr}
  /* Set 1 Flash Wait State for 48MHz, cf tables 20.9 and 35.27 in SAMD21 Datasheet */
  NVMCTRL->CTRLB.bit.RWS = NVMCTRL_CTRLB_RWS_HALF_Val ;
    f3ca:	4a4a      	ldr	r2, [pc, #296]	; (f4f4 <SystemInit+0x12c>)
    f3cc:	211e      	movs	r1, #30
    f3ce:	6853      	ldr	r3, [r2, #4]
    f3d0:	2002      	movs	r0, #2
    f3d2:	438b      	bics	r3, r1
    f3d4:	4303      	orrs	r3, r0

  /* Turn on the digital interface clock */
  PM->APBAMASK.reg |= PM_APBAMASK_GCLK ;
    f3d6:	4948      	ldr	r1, [pc, #288]	; (f4f8 <SystemInit+0x130>)
#define GENERIC_CLOCK_MULTIPLEXER_DFLL48M (0u)

void SystemInit( void )
{
  /* Set 1 Flash Wait State for 48MHz, cf tables 20.9 and 35.27 in SAMD21 Datasheet */
  NVMCTRL->CTRLB.bit.RWS = NVMCTRL_CTRLB_RWS_HALF_Val ;
    f3d8:	6053      	str	r3, [r2, #4]

  /* Turn on the digital interface clock */
  PM->APBAMASK.reg |= PM_APBAMASK_GCLK ;
    f3da:	698b      	ldr	r3, [r1, #24]
    f3dc:	2408      	movs	r4, #8
    f3de:	4323      	orrs	r3, r4
    f3e0:	618b      	str	r3, [r1, #24]
#else // has crystal

  /* ----------------------------------------------------------------------------------------------
   * 1) Enable XOSC32K clock (External on-board 32.768Hz oscillator)
   */
  SYSCTRL->XOSC32K.reg = SYSCTRL_XOSC32K_STARTUP( 0x6u ) | /* cf table 15.10 of product datasheet in chapter 15.8.6 */
    f3e2:	4c46      	ldr	r4, [pc, #280]	; (f4fc <SystemInit+0x134>)
    f3e4:	4b46      	ldr	r3, [pc, #280]	; (f500 <SystemInit+0x138>)
    f3e6:	829c      	strh	r4, [r3, #20]
                         SYSCTRL_XOSC32K_XTALEN | SYSCTRL_XOSC32K_EN32K ;
  SYSCTRL->XOSC32K.bit.ENABLE = 1 ; /* separate call, as described in chapter 15.6.3 */
    f3e8:	8a9c      	ldrh	r4, [r3, #20]
    f3ea:	4320      	orrs	r0, r4
    f3ec:	8298      	strh	r0, [r3, #20]
    f3ee:	1c10      	adds	r0, r2, #0

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_XOSC32KRDY) == 0 )
    f3f0:	68da      	ldr	r2, [r3, #12]
    f3f2:	0794      	lsls	r4, r2, #30
    f3f4:	d5fc      	bpl.n	f3f0 <SystemInit+0x28>

  /* Software reset the module to ensure it is re-initialized correctly */
  /* Note: Due to synchronization, there is a delay from writing CTRL.SWRST until the reset is complete.
   * CTRL.SWRST and STATUS.SYNCBUSY will both be cleared when the reset is complete, as described in chapter 13.8.1
   */
  GCLK->CTRL.reg = GCLK_CTRL_SWRST ;
    f3f6:	4a43      	ldr	r2, [pc, #268]	; (f504 <SystemInit+0x13c>)
    f3f8:	2401      	movs	r4, #1
    f3fa:	7014      	strb	r4, [r2, #0]

  while ( (GCLK->CTRL.reg & GCLK_CTRL_SWRST) && (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY) )
    f3fc:	7814      	ldrb	r4, [r2, #0]
    f3fe:	07e5      	lsls	r5, r4, #31
    f400:	d504      	bpl.n	f40c <SystemInit+0x44>
    f402:	4c40      	ldr	r4, [pc, #256]	; (f504 <SystemInit+0x13c>)
    f404:	7864      	ldrb	r4, [r4, #1]
    f406:	b264      	sxtb	r4, r4
    f408:	2c00      	cmp	r4, #0
    f40a:	dbf7      	blt.n	f3fc <SystemInit+0x34>
  }

  /* ----------------------------------------------------------------------------------------------
   * 2) Put XOSC32K as source of Generic Clock Generator 1
   */
  GCLK->GENDIV.reg = GCLK_GENDIV_ID( GENERIC_CLOCK_GENERATOR_XOSC32K ) ; // Generic Clock Generator 1
    f40c:	2401      	movs	r4, #1
    f40e:	6094      	str	r4, [r2, #8]

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
    f410:	7854      	ldrb	r4, [r2, #1]
    f412:	b264      	sxtb	r4, r4
    f414:	2c00      	cmp	r4, #0
    f416:	dbfb      	blt.n	f410 <SystemInit+0x48>
  {
    /* Wait for synchronization */
  }

  /* Write Generic Clock Generator 1 configuration */
  GCLK->GENCTRL.reg = GCLK_GENCTRL_ID( GENERIC_CLOCK_GENERATOR_OSC32K ) | // Generic Clock Generator 1
    f418:	4d3b      	ldr	r5, [pc, #236]	; (f508 <SystemInit+0x140>)
    f41a:	4c3a      	ldr	r4, [pc, #232]	; (f504 <SystemInit+0x13c>)
    f41c:	6065      	str	r5, [r4, #4]
                      GCLK_GENCTRL_SRC_XOSC32K | // Selected source is External 32KHz Oscillator
#endif
//                      GCLK_GENCTRL_OE | // Output clock to a pin for tests
                      GCLK_GENCTRL_GENEN ;

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
    f41e:	7854      	ldrb	r4, [r2, #1]
    f420:	b264      	sxtb	r4, r4
    f422:	2c00      	cmp	r4, #0
    f424:	dbfb      	blt.n	f41e <SystemInit+0x56>
  }

  /* ----------------------------------------------------------------------------------------------
   * 3) Put Generic Clock Generator 1 as source for Generic Clock Multiplexer 0 (DFLL48M reference)
   */
  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID( GENERIC_CLOCK_MULTIPLEXER_DFLL48M ) | // Generic Clock Multiplexer 0
    f426:	2582      	movs	r5, #130	; 0x82
    f428:	4c36      	ldr	r4, [pc, #216]	; (f504 <SystemInit+0x13c>)
    f42a:	01ed      	lsls	r5, r5, #7
    f42c:	8065      	strh	r5, [r4, #2]
                      GCLK_CLKCTRL_GEN_GCLK1 | // Generic Clock Generator 1 is source
                      GCLK_CLKCTRL_CLKEN ;

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
    f42e:	7854      	ldrb	r4, [r2, #1]
    f430:	b264      	sxtb	r4, r4
    f432:	2c00      	cmp	r4, #0
    f434:	dbfb      	blt.n	f42e <SystemInit+0x66>
   */

  /* DFLL Configuration in Closed Loop mode, cf product datasheet chapter 15.6.7.1 - Closed-Loop Operation */

  /* Remove the OnDemand mode, Bug http://avr32.icgroup.norway.atmel.com/bugzilla/show_bug.cgi?id=9905 */
  SYSCTRL->DFLLCTRL.bit.ONDEMAND = 0 ;
    f436:	8c9c      	ldrh	r4, [r3, #36]	; 0x24
    f438:	2580      	movs	r5, #128	; 0x80
    f43a:	43ac      	bics	r4, r5
    f43c:	849c      	strh	r4, [r3, #36]	; 0x24

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) == 0 )
    f43e:	68dc      	ldr	r4, [r3, #12]
    f440:	06e6      	lsls	r6, r4, #27
    f442:	d5fc      	bpl.n	f43e <SystemInit+0x76>
  {
    /* Wait for synchronization */
  }

  SYSCTRL->DFLLMUL.reg = SYSCTRL_DFLLMUL_CSTEP( 31 ) | // Coarse step is 31, half of the max value
    f444:	4d31      	ldr	r5, [pc, #196]	; (f50c <SystemInit+0x144>)
    f446:	4c2e      	ldr	r4, [pc, #184]	; (f500 <SystemInit+0x138>)
    f448:	62e5      	str	r5, [r4, #44]	; 0x2c
                         SYSCTRL_DFLLMUL_FSTEP( 511 ) | // Fine step is 511, half of the max value
                         SYSCTRL_DFLLMUL_MUL( (VARIANT_MCK/VARIANT_MAINOSC) ) ; // External 32KHz is the reference

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) == 0 )
    f44a:	68dd      	ldr	r5, [r3, #12]
    f44c:	4c2c      	ldr	r4, [pc, #176]	; (f500 <SystemInit+0x138>)
    f44e:	06ee      	lsls	r6, r5, #27
    f450:	d5fb      	bpl.n	f44a <SystemInit+0x82>
  SYSCTRL->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_ENABLE ;

#else   // has crystal

  /* Write full configuration to DFLL control register */
  SYSCTRL->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_MODE | /* Enable the closed loop mode */
    f452:	8ca5      	ldrh	r5, [r4, #36]	; 0x24
    f454:	4e2e      	ldr	r6, [pc, #184]	; (f510 <SystemInit+0x148>)
    f456:	4335      	orrs	r5, r6
    f458:	84a5      	strh	r5, [r4, #36]	; 0x24
                           SYSCTRL_DFLLCTRL_WAITLOCK |
                           SYSCTRL_DFLLCTRL_QLDIS ; /* Disable Quick lock */

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) == 0 )
    f45a:	68dd      	ldr	r5, [r3, #12]
    f45c:	4c28      	ldr	r4, [pc, #160]	; (f500 <SystemInit+0x138>)
    f45e:	06ee      	lsls	r6, r5, #27
    f460:	d5fb      	bpl.n	f45a <SystemInit+0x92>
  {
    /* Wait for synchronization */
  }

  /* Enable the DFLL */
  SYSCTRL->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_ENABLE ;
    f462:	8ca5      	ldrh	r5, [r4, #36]	; 0x24
    f464:	2602      	movs	r6, #2
    f466:	4335      	orrs	r5, r6
    f468:	84a5      	strh	r5, [r4, #36]	; 0x24

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLLCKC) == 0 ||
    f46a:	68dc      	ldr	r4, [r3, #12]
    f46c:	0625      	lsls	r5, r4, #24
    f46e:	d5fc      	bpl.n	f46a <SystemInit+0xa2>
          (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLLCKF) == 0 )
    f470:	4c23      	ldr	r4, [pc, #140]	; (f500 <SystemInit+0x138>)
    f472:	68e4      	ldr	r4, [r4, #12]
  }

  /* Enable the DFLL */
  SYSCTRL->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_ENABLE ;

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLLCKC) == 0 ||
    f474:	0666      	lsls	r6, r4, #25
    f476:	d5f8      	bpl.n	f46a <SystemInit+0xa2>
    /* Wait for locks flags */
  }

#endif

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) == 0 )
    f478:	68dc      	ldr	r4, [r3, #12]
    f47a:	06e5      	lsls	r5, r4, #27
    f47c:	d5fc      	bpl.n	f478 <SystemInit+0xb0>
  }

  /* ----------------------------------------------------------------------------------------------
   * 5) Switch Generic Clock Generator 0 to DFLL48M. CPU will run at 48MHz.
   */
  GCLK->GENDIV.reg = GCLK_GENDIV_ID( GENERIC_CLOCK_GENERATOR_MAIN ) ; // Generic Clock Generator 0
    f47e:	2400      	movs	r4, #0
    f480:	6094      	str	r4, [r2, #8]

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
    f482:	7854      	ldrb	r4, [r2, #1]
    f484:	b264      	sxtb	r4, r4
    f486:	2c00      	cmp	r4, #0
    f488:	dbfb      	blt.n	f482 <SystemInit+0xba>
  {
    /* Wait for synchronization */
  }

  /* Write Generic Clock Generator 0 configuration */
  GCLK->GENCTRL.reg = GCLK_GENCTRL_ID( GENERIC_CLOCK_GENERATOR_MAIN ) | // Generic Clock Generator 0
    f48a:	4d22      	ldr	r5, [pc, #136]	; (f514 <SystemInit+0x14c>)
    f48c:	4c1d      	ldr	r4, [pc, #116]	; (f504 <SystemInit+0x13c>)
    f48e:	6065      	str	r5, [r4, #4]
                      GCLK_GENCTRL_SRC_DFLL48M | // Selected source is DFLL 48MHz
//                      GCLK_GENCTRL_OE | // Output clock to a pin for tests
                      GCLK_GENCTRL_IDC | // Set 50/50 duty cycle
                      GCLK_GENCTRL_GENEN ;

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
    f490:	7855      	ldrb	r5, [r2, #1]
    f492:	4c1c      	ldr	r4, [pc, #112]	; (f504 <SystemInit+0x13c>)
    f494:	b26d      	sxtb	r5, r5
    f496:	2d00      	cmp	r5, #0
    f498:	dbfa      	blt.n	f490 <SystemInit+0xc8>
  }

  /* ----------------------------------------------------------------------------------------------
   * 6) Modify PRESCaler value of OSC8M to have 8MHz
   */
  SYSCTRL->OSC8M.bit.PRESC = SYSCTRL_OSC8M_PRESC_0_Val ;  //CMSIS 4.5 changed the prescaler defines
    f49a:	6a1e      	ldr	r6, [r3, #32]
    f49c:	4d1e      	ldr	r5, [pc, #120]	; (f518 <SystemInit+0x150>)
    f49e:	4035      	ands	r5, r6
    f4a0:	621d      	str	r5, [r3, #32]
  SYSCTRL->OSC8M.bit.ONDEMAND = 0 ;
    f4a2:	6a1d      	ldr	r5, [r3, #32]
    f4a4:	2680      	movs	r6, #128	; 0x80
    f4a6:	43b5      	bics	r5, r6
    f4a8:	621d      	str	r5, [r3, #32]

  /* ----------------------------------------------------------------------------------------------
   * 7) Put OSC8M as source for Generic Clock Generator 3
   */
  GCLK->GENDIV.reg = GCLK_GENDIV_ID( GENERIC_CLOCK_GENERATOR_OSC8M ) ; // Generic Clock Generator 3
    f4aa:	2303      	movs	r3, #3
    f4ac:	60a3      	str	r3, [r4, #8]

  /* Write Generic Clock Generator 3 configuration */
  GCLK->GENCTRL.reg = GCLK_GENCTRL_ID( GENERIC_CLOCK_GENERATOR_OSC8M ) | // Generic Clock Generator 3
    f4ae:	4b1b      	ldr	r3, [pc, #108]	; (f51c <SystemInit+0x154>)
    f4b0:	6063      	str	r3, [r4, #4]
                      GCLK_GENCTRL_SRC_OSC8M | // Selected source is RC OSC 8MHz (already enabled at reset)
//                      GCLK_GENCTRL_OE | // Output clock to a pin for tests
                      GCLK_GENCTRL_GENEN ;

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
    f4b2:	7853      	ldrb	r3, [r2, #1]
    f4b4:	b25b      	sxtb	r3, r3
    f4b6:	2b00      	cmp	r3, #0
    f4b8:	dbfb      	blt.n	f4b2 <SystemInit+0xea>

  /*
   * Now that all system clocks are configured, we can set CPU and APBx BUS clocks.
   * There values are normally the one present after Reset.
   */
  PM->CPUSEL.reg  = PM_CPUSEL_CPUDIV_DIV1 ;
    f4ba:	2300      	movs	r3, #0
    f4bc:	720b      	strb	r3, [r1, #8]
  PM->APBASEL.reg = PM_APBASEL_APBADIV_DIV1_Val ;
  PM->APBBSEL.reg = PM_APBBSEL_APBBDIV_DIV1_Val ;
  PM->APBCSEL.reg = PM_APBCSEL_APBCDIV_DIV1_Val ;

  SystemCoreClock=VARIANT_MCK ;
    f4be:	4a18      	ldr	r2, [pc, #96]	; (f520 <SystemInit+0x158>)
  /*
   * Now that all system clocks are configured, we can set CPU and APBx BUS clocks.
   * There values are normally the one present after Reset.
   */
  PM->CPUSEL.reg  = PM_CPUSEL_CPUDIV_DIV1 ;
  PM->APBASEL.reg = PM_APBASEL_APBADIV_DIV1_Val ;
    f4c0:	724b      	strb	r3, [r1, #9]
  PM->APBBSEL.reg = PM_APBBSEL_APBBDIV_DIV1_Val ;
    f4c2:	728b      	strb	r3, [r1, #10]
  PM->APBCSEL.reg = PM_APBCSEL_APBCDIV_DIV1_Val ;
    f4c4:	72cb      	strb	r3, [r1, #11]

  SystemCoreClock=VARIANT_MCK ;
    f4c6:	4b17      	ldr	r3, [pc, #92]	; (f524 <SystemInit+0x15c>)

  // ADC Linearity bits 4:0
  uint32_t linearity = (*((uint32_t *) ADC_FUSES_LINEARITY_0_ADDR) & ADC_FUSES_LINEARITY_0_Msk) >> ADC_FUSES_LINEARITY_0_Pos;

  // ADC Linearity bits 7:5
  linearity |= ((*((uint32_t *) ADC_FUSES_LINEARITY_1_ADDR) & ADC_FUSES_LINEARITY_1_Msk) >> ADC_FUSES_LINEARITY_1_Pos) << 5;
    f4c8:	21ff      	movs	r1, #255	; 0xff
  PM->CPUSEL.reg  = PM_CPUSEL_CPUDIV_DIV1 ;
  PM->APBASEL.reg = PM_APBASEL_APBADIV_DIV1_Val ;
  PM->APBBSEL.reg = PM_APBBSEL_APBBDIV_DIV1_Val ;
  PM->APBCSEL.reg = PM_APBCSEL_APBCDIV_DIV1_Val ;

  SystemCoreClock=VARIANT_MCK ;
    f4ca:	601a      	str	r2, [r3, #0]
  /* ----------------------------------------------------------------------------------------------
   * 8) Load ADC factory calibration values
   */

  // ADC Bias Calibration
  uint32_t bias = (*((uint32_t *) ADC_FUSES_BIASCAL_ADDR) & ADC_FUSES_BIASCAL_Msk) >> ADC_FUSES_BIASCAL_Pos;
    f4cc:	4b16      	ldr	r3, [pc, #88]	; (f528 <SystemInit+0x160>)

  // ADC Linearity bits 4:0
  uint32_t linearity = (*((uint32_t *) ADC_FUSES_LINEARITY_0_ADDR) & ADC_FUSES_LINEARITY_0_Msk) >> ADC_FUSES_LINEARITY_0_Pos;
    f4ce:	4a17      	ldr	r2, [pc, #92]	; (f52c <SystemInit+0x164>)
  /* ----------------------------------------------------------------------------------------------
   * 8) Load ADC factory calibration values
   */

  // ADC Bias Calibration
  uint32_t bias = (*((uint32_t *) ADC_FUSES_BIASCAL_ADDR) & ADC_FUSES_BIASCAL_Msk) >> ADC_FUSES_BIASCAL_Pos;
    f4d0:	681b      	ldr	r3, [r3, #0]

  // ADC Linearity bits 4:0
  uint32_t linearity = (*((uint32_t *) ADC_FUSES_LINEARITY_0_ADDR) & ADC_FUSES_LINEARITY_0_Msk) >> ADC_FUSES_LINEARITY_0_Pos;
    f4d2:	6812      	ldr	r2, [r2, #0]

  // ADC Linearity bits 7:5
  linearity |= ((*((uint32_t *) ADC_FUSES_LINEARITY_1_ADDR) & ADC_FUSES_LINEARITY_1_Msk) >> ADC_FUSES_LINEARITY_1_Pos) << 5;
    f4d4:	015c      	lsls	r4, r3, #5

  // ADC Bias Calibration
  uint32_t bias = (*((uint32_t *) ADC_FUSES_BIASCAL_ADDR) & ADC_FUSES_BIASCAL_Msk) >> ADC_FUSES_BIASCAL_Pos;

  // ADC Linearity bits 4:0
  uint32_t linearity = (*((uint32_t *) ADC_FUSES_LINEARITY_0_ADDR) & ADC_FUSES_LINEARITY_0_Msk) >> ADC_FUSES_LINEARITY_0_Pos;
    f4d6:	0ed2      	lsrs	r2, r2, #27

  // ADC Linearity bits 7:5
  linearity |= ((*((uint32_t *) ADC_FUSES_LINEARITY_1_ADDR) & ADC_FUSES_LINEARITY_1_Msk) >> ADC_FUSES_LINEARITY_1_Pos) << 5;
    f4d8:	4021      	ands	r1, r4
    f4da:	4311      	orrs	r1, r2
  /* ----------------------------------------------------------------------------------------------
   * 8) Load ADC factory calibration values
   */

  // ADC Bias Calibration
  uint32_t bias = (*((uint32_t *) ADC_FUSES_BIASCAL_ADDR) & ADC_FUSES_BIASCAL_Msk) >> ADC_FUSES_BIASCAL_Pos;
    f4dc:	069a      	lsls	r2, r3, #26
    f4de:	0f52      	lsrs	r2, r2, #29
  uint32_t linearity = (*((uint32_t *) ADC_FUSES_LINEARITY_0_ADDR) & ADC_FUSES_LINEARITY_0_Msk) >> ADC_FUSES_LINEARITY_0_Pos;

  // ADC Linearity bits 7:5
  linearity |= ((*((uint32_t *) ADC_FUSES_LINEARITY_1_ADDR) & ADC_FUSES_LINEARITY_1_Msk) >> ADC_FUSES_LINEARITY_1_Pos) << 5;

  ADC->CALIB.reg = ADC_CALIB_BIAS_CAL(bias) | ADC_CALIB_LINEARITY_CAL(linearity);
    f4e0:	0212      	lsls	r2, r2, #8
    f4e2:	1c0b      	adds	r3, r1, #0
    f4e4:	4313      	orrs	r3, r2
    f4e6:	4a12      	ldr	r2, [pc, #72]	; (f530 <SystemInit+0x168>)
    f4e8:	8513      	strh	r3, [r2, #40]	; 0x28

  /*
   * 9) Disable automatic NVM write operations
   */
  NVMCTRL->CTRLB.bit.MANW = 1;
    f4ea:	6843      	ldr	r3, [r0, #4]
    f4ec:	2280      	movs	r2, #128	; 0x80
    f4ee:	4313      	orrs	r3, r2
    f4f0:	6043      	str	r3, [r0, #4]
}
    f4f2:	bd70      	pop	{r4, r5, r6, pc}
    f4f4:	41004000 	.word	0x41004000
    f4f8:	40000400 	.word	0x40000400
    f4fc:	0000060c 	.word	0x0000060c
    f500:	40000800 	.word	0x40000800
    f504:	40000c00 	.word	0x40000c00
    f508:	00010501 	.word	0x00010501
    f50c:	7dff05b8 	.word	0x7dff05b8
    f510:	00000a04 	.word	0x00000a04
    f514:	00030700 	.word	0x00030700
    f518:	fffffcff 	.word	0xfffffcff
    f51c:	00010603 	.word	0x00010603
    f520:	02dc6c00 	.word	0x02dc6c00
    f524:	20000098 	.word	0x20000098
    f528:	00806024 	.word	0x00806024
    f52c:	00806020 	.word	0x00806020
    f530:	42004000 	.word	0x42004000

0000f534 <init>:
 *   - During reset, all PORT lines are configured as inputs with input buffers, output buffers and pull disabled.
 */
void init( void )
{
  // Set Systick to 1ms interval, common to all Cortex-M variants
  if ( SysTick_Config( SystemCoreClock / 1000 ) )
    f534:	4b31      	ldr	r3, [pc, #196]	; (f5fc <init+0xc8>)
    f536:	21fa      	movs	r1, #250	; 0xfa
    f538:	6818      	ldr	r0, [r3, #0]
 *   - At reset, ResetHandler did the system clock configuration. Core is running at 48MHz.
 *   - Watchdog is disabled by default, unless someone plays with NVM User page
 *   - During reset, all PORT lines are configured as inputs with input buffers, output buffers and pull disabled.
 */
void init( void )
{
    f53a:	b510      	push	{r4, lr}
  // Set Systick to 1ms interval, common to all Cortex-M variants
  if ( SysTick_Config( SystemCoreClock / 1000 ) )
    f53c:	0089      	lsls	r1, r1, #2
    f53e:	f001 ff2b 	bl	11398 <__aeabi_uidiv>
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
    f542:	4b2f      	ldr	r3, [pc, #188]	; (f600 <init+0xcc>)
    f544:	3801      	subs	r0, #1
    f546:	4298      	cmp	r0, r3
    f548:	d824      	bhi.n	f594 <init+0x60>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    f54a:	4a2e      	ldr	r2, [pc, #184]	; (f604 <init+0xd0>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    f54c:	4b2e      	ldr	r3, [pc, #184]	; (f608 <init+0xd4>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    f54e:	6050      	str	r0, [r2, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    f550:	6a18      	ldr	r0, [r3, #32]
    f552:	21c0      	movs	r1, #192	; 0xc0
    f554:	0200      	lsls	r0, r0, #8
    f556:	0a00      	lsrs	r0, r0, #8
    f558:	0609      	lsls	r1, r1, #24
    f55a:	4301      	orrs	r1, r0
    f55c:	6219      	str	r1, [r3, #32]
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
    f55e:	2400      	movs	r4, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    f560:	2107      	movs	r1, #7
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
    f562:	6094      	str	r4, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    f564:	6011      	str	r1, [r2, #0]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    f566:	6a19      	ldr	r1, [r3, #32]
    f568:	2280      	movs	r2, #128	; 0x80
    f56a:	0209      	lsls	r1, r1, #8
    f56c:	0a09      	lsrs	r1, r1, #8
    f56e:	0612      	lsls	r2, r2, #24
    f570:	430a      	orrs	r2, r1
    f572:	621a      	str	r2, [r3, #32]
//
//  // Clock EIC for I/O interrupts
//  PM->APBAMASK.reg |= PM_APBAMASK_EIC ;

  // Clock SERCOM for Serial
  PM->APBCMASK.reg |= PM_APBCMASK_SERCOM0 | PM_APBCMASK_SERCOM1 | PM_APBCMASK_SERCOM2 | PM_APBCMASK_SERCOM3 | PM_APBCMASK_SERCOM4 | PM_APBCMASK_SERCOM5 ;
    f574:	4b25      	ldr	r3, [pc, #148]	; (f60c <init+0xd8>)
    f576:	21fc      	movs	r1, #252	; 0xfc
    f578:	6a1a      	ldr	r2, [r3, #32]
    f57a:	430a      	orrs	r2, r1
    f57c:	621a      	str	r2, [r3, #32]

  // Clock TC/TCC for Pulse and Analog
  PM->APBCMASK.reg |= PM_APBCMASK_TCC0 | PM_APBCMASK_TCC1 | PM_APBCMASK_TCC2 | PM_APBCMASK_TC3 | PM_APBCMASK_TC4 | PM_APBCMASK_TC5 ;
    f57e:	6a19      	ldr	r1, [r3, #32]
    f580:	22fc      	movs	r2, #252	; 0xfc
    f582:	0192      	lsls	r2, r2, #6
    f584:	430a      	orrs	r2, r1
    f586:	621a      	str	r2, [r3, #32]

  // Clock ADC/DAC for Analog
  PM->APBCMASK.reg |= PM_APBCMASK_ADC | PM_APBCMASK_DAC ;
    f588:	6a19      	ldr	r1, [r3, #32]
    f58a:	22a0      	movs	r2, #160	; 0xa0
    f58c:	02d2      	lsls	r2, r2, #11
    f58e:	430a      	orrs	r2, r1
    f590:	621a      	str	r2, [r3, #32]
    f592:	e000      	b.n	f596 <init+0x62>
    f594:	e7fe      	b.n	f594 <init+0x60>

  // Setup all pins (digital and analog) in INPUT mode (default is nothing)
  for (uint32_t ul = 0 ; ul < NUM_DIGITAL_PINS ; ul++ )
  {
    pinMode( ul, INPUT ) ;
    f596:	1c20      	adds	r0, r4, #0
    f598:	2100      	movs	r1, #0

  // Clock ADC/DAC for Analog
  PM->APBCMASK.reg |= PM_APBCMASK_ADC | PM_APBCMASK_DAC ;

  // Setup all pins (digital and analog) in INPUT mode (default is nothing)
  for (uint32_t ul = 0 ; ul < NUM_DIGITAL_PINS ; ul++ )
    f59a:	3401      	adds	r4, #1
  {
    pinMode( ul, INPUT ) ;
    f59c:	f000 f9e4 	bl	f968 <pinMode>

  // Clock ADC/DAC for Analog
  PM->APBCMASK.reg |= PM_APBCMASK_ADC | PM_APBCMASK_DAC ;

  // Setup all pins (digital and analog) in INPUT mode (default is nothing)
  for (uint32_t ul = 0 ; ul < NUM_DIGITAL_PINS ; ul++ )
    f5a0:	2c14      	cmp	r4, #20
    f5a2:	d1f8      	bne.n	f596 <init+0x62>
    pinMode( ul, INPUT ) ;
  }

  // Initialize Analog Controller
  // Setting clock
  while(GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY);
    f5a4:	4c1a      	ldr	r4, [pc, #104]	; (f610 <init+0xdc>)
    f5a6:	7863      	ldrb	r3, [r4, #1]
    f5a8:	b25b      	sxtb	r3, r3
    f5aa:	2b00      	cmp	r3, #0
    f5ac:	dbfa      	blt.n	f5a4 <init+0x70>

  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID( GCM_ADC ) | // Generic Clock ADC
    f5ae:	4b19      	ldr	r3, [pc, #100]	; (f614 <init+0xe0>)
    f5b0:	8063      	strh	r3, [r4, #2]
                      GCLK_CLKCTRL_GEN_GCLK0     | // Generic Clock Generator 0 is source
                      GCLK_CLKCTRL_CLKEN ;

  while( ADC->STATUS.bit.SYNCBUSY == 1 );          // Wait for synchronization of registers between the clock domains
    f5b2:	4b19      	ldr	r3, [pc, #100]	; (f618 <init+0xe4>)
    f5b4:	7e5a      	ldrb	r2, [r3, #25]
    f5b6:	09d2      	lsrs	r2, r2, #7
    f5b8:	2a01      	cmp	r2, #1
    f5ba:	d0fa      	beq.n	f5b2 <init+0x7e>

  ADC->CTRLB.reg = ADC_CTRLB_PRESCALER_DIV512 |    // Divide Clock by 512.
    f5bc:	22e4      	movs	r2, #228	; 0xe4
    f5be:	00d2      	lsls	r2, r2, #3
    f5c0:	809a      	strh	r2, [r3, #4]
                   ADC_CTRLB_RESSEL_10BIT;         // 10 bits resolution as default

  ADC->SAMPCTRL.reg = 0x3f;                        // Set max Sampling Time Length
    f5c2:	223f      	movs	r2, #63	; 0x3f
    f5c4:	70da      	strb	r2, [r3, #3]

  while( ADC->STATUS.bit.SYNCBUSY == 1 );          // Wait for synchronization of registers between the clock domains
    f5c6:	7e59      	ldrb	r1, [r3, #25]
    f5c8:	4a13      	ldr	r2, [pc, #76]	; (f618 <init+0xe4>)
    f5ca:	09c9      	lsrs	r1, r1, #7
    f5cc:	2901      	cmp	r1, #1
    f5ce:	d0fa      	beq.n	f5c6 <init+0x92>

  ADC->INPUTCTRL.reg = ADC_INPUTCTRL_MUXNEG_GND;   // No Negative input (Internal Ground)
    f5d0:	23c0      	movs	r3, #192	; 0xc0
    f5d2:	015b      	lsls	r3, r3, #5

  // Averaging (see datasheet table in AVGCTRL register description)
  ADC->AVGCTRL.reg = ADC_AVGCTRL_SAMPLENUM_1 |    // 1 sample only (no oversampling nor averaging)
    f5d4:	2000      	movs	r0, #0

  ADC->SAMPCTRL.reg = 0x3f;                        // Set max Sampling Time Length

  while( ADC->STATUS.bit.SYNCBUSY == 1 );          // Wait for synchronization of registers between the clock domains

  ADC->INPUTCTRL.reg = ADC_INPUTCTRL_MUXNEG_GND;   // No Negative input (Internal Ground)
    f5d6:	6113      	str	r3, [r2, #16]

  // Averaging (see datasheet table in AVGCTRL register description)
  ADC->AVGCTRL.reg = ADC_AVGCTRL_SAMPLENUM_1 |    // 1 sample only (no oversampling nor averaging)
    f5d8:	7090      	strb	r0, [r2, #2]
                     ADC_AVGCTRL_ADJRES(0x0ul);   // Adjusting result by 0

  analogReference( AR_DEFAULT ) ; // Analog Reference is AREF pin (3.3v)
    f5da:	f000 f833 	bl	f644 <analogReference>

  // Initialize DAC
  // Setting clock
  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY );
    f5de:	7863      	ldrb	r3, [r4, #1]
    f5e0:	b25b      	sxtb	r3, r3
    f5e2:	2b00      	cmp	r3, #0
    f5e4:	dbfb      	blt.n	f5de <init+0xaa>
  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID( GCM_DAC ) | // Generic Clock ADC
    f5e6:	4a0d      	ldr	r2, [pc, #52]	; (f61c <init+0xe8>)
    f5e8:	4b09      	ldr	r3, [pc, #36]	; (f610 <init+0xdc>)
    f5ea:	805a      	strh	r2, [r3, #2]
                      GCLK_CLKCTRL_GEN_GCLK0     | // Generic Clock Generator 0 is source
                      GCLK_CLKCTRL_CLKEN ;

  while ( DAC->STATUS.bit.SYNCBUSY == 1 ); // Wait for synchronization of registers between the clock domains
    f5ec:	4b0c      	ldr	r3, [pc, #48]	; (f620 <init+0xec>)
    f5ee:	79da      	ldrb	r2, [r3, #7]
    f5f0:	09d2      	lsrs	r2, r2, #7
    f5f2:	2a01      	cmp	r2, #1
    f5f4:	d0fa      	beq.n	f5ec <init+0xb8>
  DAC->CTRLB.reg = DAC_CTRLB_REFSEL_AVCC | // Using the 3.3V reference
    f5f6:	2241      	movs	r2, #65	; 0x41
    f5f8:	705a      	strb	r2, [r3, #1]
                   DAC_CTRLB_EOEN ;        // External Output Enable (Vout)
}
    f5fa:	bd10      	pop	{r4, pc}
    f5fc:	20000098 	.word	0x20000098
    f600:	00ffffff 	.word	0x00ffffff
    f604:	e000e010 	.word	0xe000e010
    f608:	e000ed00 	.word	0xe000ed00
    f60c:	40000400 	.word	0x40000400
    f610:	40000c00 	.word	0x40000c00
    f614:	0000401e 	.word	0x0000401e
    f618:	42004000 	.word	0x42004000
    f61c:	00004021 	.word	0x00004021
    f620:	42004800 	.word	0x42004800

0000f624 <mapResolution>:
  _writeResolution = res;
}

static inline uint32_t mapResolution(uint32_t value, uint32_t from, uint32_t to)
{
  if (from == to) {
    f624:	4291      	cmp	r1, r2
    f626:	d005      	beq.n	f634 <mapResolution+0x10>
    return value;
  }
  if (from > to) {
    f628:	d902      	bls.n	f630 <mapResolution+0xc>
    return value >> (from-to);
    f62a:	1a89      	subs	r1, r1, r2
    f62c:	40c8      	lsrs	r0, r1
    f62e:	e001      	b.n	f634 <mapResolution+0x10>
  }
  return value << (to-from);
    f630:	1a51      	subs	r1, r2, r1
    f632:	4088      	lsls	r0, r1
}
    f634:	4770      	bx	lr
	...

0000f638 <analogWriteResolution>:
  syncADC();
}

void analogWriteResolution(int res)
{
  _writeResolution = res;
    f638:	4b01      	ldr	r3, [pc, #4]	; (f640 <analogWriteResolution+0x8>)
    f63a:	6018      	str	r0, [r3, #0]
}
    f63c:	4770      	bx	lr
    f63e:	46c0      	nop			; (mov r8, r8)
    f640:	200000a0 	.word	0x200000a0

0000f644 <analogReference>:
 * External Reference should be between 1v and VDDANA-0.6v=2.7v
 *
 * Warning : On Arduino Zero board the input/output voltage for SAMD21G18 is 3.3 volts maximum
 */
void analogReference(eAnalogReference mode)
{
    f644:	b500      	push	{lr}
static int _writeResolution = 8;

// Wait for synchronization of registers between the clock domains
static __inline__ void syncADC() __attribute__((always_inline, unused));
static void syncADC() {
  while (ADC->STATUS.bit.SYNCBUSY == 1)
    f646:	4a14      	ldr	r2, [pc, #80]	; (f698 <analogReference+0x54>)
    f648:	7e51      	ldrb	r1, [r2, #25]
    f64a:	1c13      	adds	r3, r2, #0
    f64c:	09c9      	lsrs	r1, r1, #7
    f64e:	2901      	cmp	r1, #1
    f650:	d0f9      	beq.n	f646 <analogReference+0x2>
 * Warning : On Arduino Zero board the input/output voltage for SAMD21G18 is 3.3 volts maximum
 */
void analogReference(eAnalogReference mode)
{
  syncADC();
  switch (mode)
    f652:	3801      	subs	r0, #1
    f654:	2804      	cmp	r0, #4
    f656:	d813      	bhi.n	f680 <analogReference+0x3c>
      ADC->INPUTCTRL.bit.GAIN = ADC_INPUTCTRL_GAIN_1X_Val;      // Gain Factor Selection
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INT1V_Val;   // 1.0V voltage reference
      break;

    case AR_INTERNAL1V65:
      ADC->INPUTCTRL.bit.GAIN = ADC_INPUTCTRL_GAIN_1X_Val;      // Gain Factor Selection
    f658:	6919      	ldr	r1, [r3, #16]
    f65a:	4a10      	ldr	r2, [pc, #64]	; (f69c <analogReference+0x58>)
    f65c:	400a      	ands	r2, r1
    f65e:	611a      	str	r2, [r3, #16]
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INTVCC1_Val; // 1/2 VDDANA = 0.5* 3V3 = 1.65V
    f660:	785a      	ldrb	r2, [r3, #1]
    f662:	210f      	movs	r1, #15
    f664:	438a      	bics	r2, r1
 * Warning : On Arduino Zero board the input/output voltage for SAMD21G18 is 3.3 volts maximum
 */
void analogReference(eAnalogReference mode)
{
  syncADC();
  switch (mode)
    f666:	f001 fe83 	bl	11370 <__gnu_thumb1_case_uqi>
    f66a:	0503      	.short	0x0503
    f66c:	0709      	.short	0x0709
    f66e:	03          	.byte	0x03
    f66f:	00          	.byte	0x00
  {
    case AR_INTERNAL:
    case AR_INTERNAL2V23:
      ADC->INPUTCTRL.bit.GAIN = ADC_INPUTCTRL_GAIN_1X_Val;      // Gain Factor Selection
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INTVCC0_Val; // 1/1.48 VDDANA = 1/1.48* 3V3 = 2.2297
    f670:	2101      	movs	r1, #1
    f672:	e002      	b.n	f67a <analogReference+0x36>
      break;

    case AR_EXTERNAL:
      ADC->INPUTCTRL.bit.GAIN = ADC_INPUTCTRL_GAIN_1X_Val;      // Gain Factor Selection
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_AREFA_Val;
    f674:	2103      	movs	r1, #3
    f676:	e000      	b.n	f67a <analogReference+0x36>
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INT1V_Val;   // 1.0V voltage reference
      break;

    case AR_INTERNAL1V65:
      ADC->INPUTCTRL.bit.GAIN = ADC_INPUTCTRL_GAIN_1X_Val;      // Gain Factor Selection
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INTVCC1_Val; // 1/2 VDDANA = 0.5* 3V3 = 1.65V
    f678:	2102      	movs	r1, #2
    f67a:	430a      	orrs	r2, r1
    f67c:	705a      	strb	r2, [r3, #1]
      break;
    f67e:	e00a      	b.n	f696 <analogReference+0x52>

    case AR_DEFAULT:
    default:
      ADC->INPUTCTRL.bit.GAIN = ADC_INPUTCTRL_GAIN_DIV2_Val;
    f680:	6911      	ldr	r1, [r2, #16]
    f682:	23f0      	movs	r3, #240	; 0xf0
    f684:	051b      	lsls	r3, r3, #20
    f686:	430b      	orrs	r3, r1
    f688:	6113      	str	r3, [r2, #16]
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INTVCC1_Val; // 1/2 VDDANA = 0.5* 3V3 = 1.65V
    f68a:	7853      	ldrb	r3, [r2, #1]
    f68c:	210f      	movs	r1, #15
    f68e:	438b      	bics	r3, r1
    f690:	2102      	movs	r1, #2
    f692:	430b      	orrs	r3, r1
    f694:	7053      	strb	r3, [r2, #1]
      break;
  }
}
    f696:	bd00      	pop	{pc}
    f698:	42004000 	.word	0x42004000
    f69c:	f0ffffff 	.word	0xf0ffffff

0000f6a0 <analogRead>:

uint32_t analogRead(uint32_t pin)
{
    f6a0:	b510      	push	{r4, lr}
    f6a2:	1e04      	subs	r4, r0, #0
  uint32_t valueRead = 0;

  if (pin < A0) {
    f6a4:	2c0d      	cmp	r4, #13
    f6a6:	d800      	bhi.n	f6aa <analogRead+0xa>
    pin += A0;
    f6a8:	340e      	adds	r4, #14
  }

  pinPeripheral(pin, PIO_ANALOG);
    f6aa:	1c20      	adds	r0, r4, #0
    f6ac:	2101      	movs	r1, #1
    f6ae:	f000 f9e5 	bl	fa7c <pinPeripheral>

  if (pin == A0) { // Disable DAC, if analogWrite(A0,dval) used previously the DAC is enabled
    f6b2:	2c0e      	cmp	r4, #14
    f6b4:	d10c      	bne.n	f6d0 <analogRead+0x30>
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncDAC() __attribute__((always_inline, unused));
static void syncDAC() {
  while (DAC->STATUS.bit.SYNCBUSY == 1)
    f6b6:	4b2a      	ldr	r3, [pc, #168]	; (f760 <analogRead+0xc0>)
    f6b8:	79da      	ldrb	r2, [r3, #7]
    f6ba:	09d2      	lsrs	r2, r2, #7
    f6bc:	2a01      	cmp	r2, #1
    f6be:	d0fa      	beq.n	f6b6 <analogRead+0x16>

  pinPeripheral(pin, PIO_ANALOG);

  if (pin == A0) { // Disable DAC, if analogWrite(A0,dval) used previously the DAC is enabled
    syncDAC();
    DAC->CTRLA.bit.ENABLE = 0x00; // Disable DAC
    f6c0:	781a      	ldrb	r2, [r3, #0]
    f6c2:	2102      	movs	r1, #2
    f6c4:	438a      	bics	r2, r1
    f6c6:	701a      	strb	r2, [r3, #0]
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncDAC() __attribute__((always_inline, unused));
static void syncDAC() {
  while (DAC->STATUS.bit.SYNCBUSY == 1)
    f6c8:	79da      	ldrb	r2, [r3, #7]
    f6ca:	09d2      	lsrs	r2, r2, #7
    f6cc:	2a01      	cmp	r2, #1
    f6ce:	d0fb      	beq.n	f6c8 <analogRead+0x28>
static int _writeResolution = 8;

// Wait for synchronization of registers between the clock domains
static __inline__ void syncADC() __attribute__((always_inline, unused));
static void syncADC() {
  while (ADC->STATUS.bit.SYNCBUSY == 1)
    f6d0:	4b24      	ldr	r3, [pc, #144]	; (f764 <analogRead+0xc4>)
    f6d2:	7e5a      	ldrb	r2, [r3, #25]
    f6d4:	09d2      	lsrs	r2, r2, #7
    f6d6:	2a01      	cmp	r2, #1
    f6d8:	d0fa      	beq.n	f6d0 <analogRead+0x30>
    //DAC->CTRLB.bit.EOEN = 0x00; // The DAC output is turned off.
    syncDAC();
  }

  syncADC();
  ADC->INPUTCTRL.bit.MUXPOS = g_APinDescription[pin].ulADCChannelNumber; // Selection for the positive ADC input
    f6da:	2218      	movs	r2, #24
    f6dc:	4354      	muls	r4, r2
    f6de:	4a22      	ldr	r2, [pc, #136]	; (f768 <analogRead+0xc8>)
    f6e0:	6918      	ldr	r0, [r3, #16]
    f6e2:	1914      	adds	r4, r2, r4
    f6e4:	7c21      	ldrb	r1, [r4, #16]
    f6e6:	221f      	movs	r2, #31
    f6e8:	4390      	bics	r0, r2
    f6ea:	4011      	ands	r1, r2
    f6ec:	1c02      	adds	r2, r0, #0
    f6ee:	430a      	orrs	r2, r1
    f6f0:	611a      	str	r2, [r3, #16]
static int _writeResolution = 8;

// Wait for synchronization of registers between the clock domains
static __inline__ void syncADC() __attribute__((always_inline, unused));
static void syncADC() {
  while (ADC->STATUS.bit.SYNCBUSY == 1)
    f6f2:	7e59      	ldrb	r1, [r3, #25]
    f6f4:	4a1b      	ldr	r2, [pc, #108]	; (f764 <analogRead+0xc4>)
    f6f6:	09c9      	lsrs	r1, r1, #7
    f6f8:	2901      	cmp	r1, #1
    f6fa:	d0fa      	beq.n	f6f2 <analogRead+0x52>
   *
   * Before enabling the ADC, the asynchronous clock source must be selected and enabled, and the ADC reference must be
   * configured. The first conversion after the reference is changed must not be used.
   */
  syncADC();
  ADC->CTRLA.bit.ENABLE = 0x01;             // Enable ADC
    f6fc:	7811      	ldrb	r1, [r2, #0]
    f6fe:	2002      	movs	r0, #2
    f700:	4301      	orrs	r1, r0
    f702:	7011      	strb	r1, [r2, #0]
static int _writeResolution = 8;

// Wait for synchronization of registers between the clock domains
static __inline__ void syncADC() __attribute__((always_inline, unused));
static void syncADC() {
  while (ADC->STATUS.bit.SYNCBUSY == 1)
    f704:	7e59      	ldrb	r1, [r3, #25]
    f706:	4a17      	ldr	r2, [pc, #92]	; (f764 <analogRead+0xc4>)
    f708:	09c9      	lsrs	r1, r1, #7
    f70a:	2901      	cmp	r1, #1
    f70c:	d0fa      	beq.n	f704 <analogRead+0x64>
  syncADC();
  ADC->CTRLA.bit.ENABLE = 0x01;             // Enable ADC

  // Start conversion
  syncADC();
  ADC->SWTRIG.bit.START = 1;
    f70e:	7b11      	ldrb	r1, [r2, #12]
    f710:	2002      	movs	r0, #2
    f712:	4301      	orrs	r1, r0
    f714:	7311      	strb	r1, [r2, #12]

  // Clear the Data Ready flag
  ADC->INTFLAG.reg = ADC_INTFLAG_RESRDY;
    f716:	2101      	movs	r1, #1
    f718:	7611      	strb	r1, [r2, #24]
static int _writeResolution = 8;

// Wait for synchronization of registers between the clock domains
static __inline__ void syncADC() __attribute__((always_inline, unused));
static void syncADC() {
  while (ADC->STATUS.bit.SYNCBUSY == 1)
    f71a:	7e59      	ldrb	r1, [r3, #25]
    f71c:	4a11      	ldr	r2, [pc, #68]	; (f764 <analogRead+0xc4>)
    f71e:	09c9      	lsrs	r1, r1, #7
    f720:	2901      	cmp	r1, #1
    f722:	d0fa      	beq.n	f71a <analogRead+0x7a>
  // Clear the Data Ready flag
  ADC->INTFLAG.reg = ADC_INTFLAG_RESRDY;

  // Start conversion again, since The first conversion after the reference is changed must not be used.
  syncADC();
  ADC->SWTRIG.bit.START = 1;
    f724:	7b11      	ldrb	r1, [r2, #12]
    f726:	2002      	movs	r0, #2
    f728:	4301      	orrs	r1, r0
    f72a:	7311      	strb	r1, [r2, #12]

  // Store the value
  while (ADC->INTFLAG.bit.RESRDY == 0);   // Waiting for conversion to complete
    f72c:	7e1a      	ldrb	r2, [r3, #24]
    f72e:	07d1      	lsls	r1, r2, #31
    f730:	d5fc      	bpl.n	f72c <analogRead+0x8c>
  valueRead = ADC->RESULT.reg;
    f732:	4a0c      	ldr	r2, [pc, #48]	; (f764 <analogRead+0xc4>)
    f734:	8b50      	ldrh	r0, [r2, #26]
    f736:	b280      	uxth	r0, r0
static int _writeResolution = 8;

// Wait for synchronization of registers between the clock domains
static __inline__ void syncADC() __attribute__((always_inline, unused));
static void syncADC() {
  while (ADC->STATUS.bit.SYNCBUSY == 1)
    f738:	7e59      	ldrb	r1, [r3, #25]
    f73a:	4a0a      	ldr	r2, [pc, #40]	; (f764 <analogRead+0xc4>)
    f73c:	09c9      	lsrs	r1, r1, #7
    f73e:	2901      	cmp	r1, #1
    f740:	d0fa      	beq.n	f738 <analogRead+0x98>
  // Store the value
  while (ADC->INTFLAG.bit.RESRDY == 0);   // Waiting for conversion to complete
  valueRead = ADC->RESULT.reg;

  syncADC();
  ADC->CTRLA.bit.ENABLE = 0x00;             // Disable ADC
    f742:	7811      	ldrb	r1, [r2, #0]
    f744:	2402      	movs	r4, #2
    f746:	43a1      	bics	r1, r4
    f748:	7011      	strb	r1, [r2, #0]
static int _writeResolution = 8;

// Wait for synchronization of registers between the clock domains
static __inline__ void syncADC() __attribute__((always_inline, unused));
static void syncADC() {
  while (ADC->STATUS.bit.SYNCBUSY == 1)
    f74a:	7e5a      	ldrb	r2, [r3, #25]
    f74c:	09d2      	lsrs	r2, r2, #7
    f74e:	2a01      	cmp	r2, #1
    f750:	d0fb      	beq.n	f74a <analogRead+0xaa>

  syncADC();
  ADC->CTRLA.bit.ENABLE = 0x00;             // Disable ADC
  syncADC();

  return mapResolution(valueRead, _ADCResolution, _readResolution);
    f752:	4b06      	ldr	r3, [pc, #24]	; (f76c <analogRead+0xcc>)
    f754:	6819      	ldr	r1, [r3, #0]
    f756:	4b06      	ldr	r3, [pc, #24]	; (f770 <analogRead+0xd0>)
    f758:	681a      	ldr	r2, [r3, #0]
    f75a:	f7ff ff63 	bl	f624 <mapResolution>
}
    f75e:	bd10      	pop	{r4, pc}
    f760:	42004800 	.word	0x42004800
    f764:	42004000 	.word	0x42004000
    f768:	000156a8 	.word	0x000156a8
    f76c:	2000009c 	.word	0x2000009c
    f770:	200000a4 	.word	0x200000a4

0000f774 <analogWrite>:
// hardware support.  These are defined in the appropriate
// pins_*.c file.  For the rest of the pins, we default
// to digital output.
void analogWrite(uint32_t pin, uint32_t value)
{
  PinDescription pinDesc = g_APinDescription[pin];
    f774:	2318      	movs	r3, #24
    f776:	4343      	muls	r3, r0
// Right now, PWM output only works on the pins with
// hardware support.  These are defined in the appropriate
// pins_*.c file.  For the rest of the pins, we default
// to digital output.
void analogWrite(uint32_t pin, uint32_t value)
{
    f778:	b5f0      	push	{r4, r5, r6, r7, lr}
  PinDescription pinDesc = g_APinDescription[pin];
    f77a:	4a72      	ldr	r2, [pc, #456]	; (f944 <analogWrite+0x1d0>)
// Right now, PWM output only works on the pins with
// hardware support.  These are defined in the appropriate
// pins_*.c file.  For the rest of the pins, we default
// to digital output.
void analogWrite(uint32_t pin, uint32_t value)
{
    f77c:	b089      	sub	sp, #36	; 0x24
  PinDescription pinDesc = g_APinDescription[pin];
    f77e:	189b      	adds	r3, r3, r2
    f780:	68da      	ldr	r2, [r3, #12]
    f782:	8a5b      	ldrh	r3, [r3, #18]
// Right now, PWM output only works on the pins with
// hardware support.  These are defined in the appropriate
// pins_*.c file.  For the rest of the pins, we default
// to digital output.
void analogWrite(uint32_t pin, uint32_t value)
{
    f784:	1c05      	adds	r5, r0, #0
    f786:	1c0c      	adds	r4, r1, #0
  PinDescription pinDesc = g_APinDescription[pin];
    f788:	9201      	str	r2, [sp, #4]
    f78a:	9302      	str	r3, [sp, #8]
  uint32_t attr = pinDesc.ulPinAttribute;

  if ((attr & PIN_ATTR_ANALOG) == PIN_ATTR_ANALOG)
    f78c:	0792      	lsls	r2, r2, #30
    f78e:	d51e      	bpl.n	f7ce <analogWrite+0x5a>
  {
    // DAC handling code

    if (pin != PIN_A0) { // Only 1 DAC on A0 (PA02)
    f790:	280e      	cmp	r0, #14
    f792:	d000      	beq.n	f796 <analogWrite+0x22>
    f794:	e0d4      	b.n	f940 <analogWrite+0x1cc>
      return;
    }

    value = mapResolution(value, _writeResolution, 10);
    f796:	4b6c      	ldr	r3, [pc, #432]	; (f948 <analogWrite+0x1d4>)
    f798:	1c20      	adds	r0, r4, #0
    f79a:	6819      	ldr	r1, [r3, #0]
    f79c:	220a      	movs	r2, #10
    f79e:	f7ff ff41 	bl	f624 <mapResolution>
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncDAC() __attribute__((always_inline, unused));
static void syncDAC() {
  while (DAC->STATUS.bit.SYNCBUSY == 1)
    f7a2:	4b6a      	ldr	r3, [pc, #424]	; (f94c <analogWrite+0x1d8>)
    f7a4:	79da      	ldrb	r2, [r3, #7]
    f7a6:	09d2      	lsrs	r2, r2, #7
    f7a8:	2a01      	cmp	r2, #1
    f7aa:	d0fa      	beq.n	f7a2 <analogWrite+0x2e>
    }

    value = mapResolution(value, _writeResolution, 10);

    syncDAC();
    DAC->DATA.reg = value & 0x3FF;  // DAC on 10 bits.
    f7ac:	0580      	lsls	r0, r0, #22
    f7ae:	0d80      	lsrs	r0, r0, #22
    f7b0:	8118      	strh	r0, [r3, #8]
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncDAC() __attribute__((always_inline, unused));
static void syncDAC() {
  while (DAC->STATUS.bit.SYNCBUSY == 1)
    f7b2:	79d9      	ldrb	r1, [r3, #7]
    f7b4:	4a65      	ldr	r2, [pc, #404]	; (f94c <analogWrite+0x1d8>)
    f7b6:	09c9      	lsrs	r1, r1, #7
    f7b8:	2901      	cmp	r1, #1
    f7ba:	d0fa      	beq.n	f7b2 <analogWrite+0x3e>
    value = mapResolution(value, _writeResolution, 10);

    syncDAC();
    DAC->DATA.reg = value & 0x3FF;  // DAC on 10 bits.
    syncDAC();
    DAC->CTRLA.bit.ENABLE = 0x01;     // Enable DAC
    f7bc:	7811      	ldrb	r1, [r2, #0]
    f7be:	2002      	movs	r0, #2
    f7c0:	4301      	orrs	r1, r0
    f7c2:	7011      	strb	r1, [r2, #0]
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncDAC() __attribute__((always_inline, unused));
static void syncDAC() {
  while (DAC->STATUS.bit.SYNCBUSY == 1)
    f7c4:	79da      	ldrb	r2, [r3, #7]
    f7c6:	09d2      	lsrs	r2, r2, #7
    f7c8:	2a01      	cmp	r2, #1
    f7ca:	d0fb      	beq.n	f7c4 <analogWrite+0x50>
    f7cc:	e0b8      	b.n	f940 <analogWrite+0x1cc>
    DAC->CTRLA.bit.ENABLE = 0x01;     // Enable DAC
    syncDAC();
    return;
  }

  if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)
    f7ce:	9b01      	ldr	r3, [sp, #4]
    f7d0:	2708      	movs	r7, #8
    f7d2:	403b      	ands	r3, r7
    f7d4:	9303      	str	r3, [sp, #12]
    f7d6:	4e5c      	ldr	r6, [pc, #368]	; (f948 <analogWrite+0x1d4>)
    f7d8:	d100      	bne.n	f7dc <analogWrite+0x68>
    f7da:	e0a0      	b.n	f91e <analogWrite+0x1aa>
  {
    value = mapResolution(value, _writeResolution, 8);
    f7dc:	6831      	ldr	r1, [r6, #0]
    f7de:	1c3a      	adds	r2, r7, #0
    f7e0:	1c20      	adds	r0, r4, #0
    f7e2:	f7ff ff1f 	bl	f624 <mapResolution>

    uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);
    f7e6:	9a02      	ldr	r2, [sp, #8]
    uint8_t tcChannel = GetTCChannelNumber(pinDesc.ulPWMChannel);
    static bool tcEnabled[TCC_INST_NUM+TC_INST_NUM];

    if (attr & PIN_ATTR_TIMER) {
    f7e8:	9b01      	ldr	r3, [sp, #4]

  if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)
  {
    value = mapResolution(value, _writeResolution, 8);

    uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);
    f7ea:	b214      	sxth	r4, r2
    return;
  }

  if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)
  {
    value = mapResolution(value, _writeResolution, 8);
    f7ec:	1c06      	adds	r6, r0, #0

    uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);
    f7ee:	413c      	asrs	r4, r7
      if (pinDesc.ulPinType == PIO_TIMER_ALT) {
        pinPeripheral(pin, PIO_TIMER_ALT);
      } else
      #endif
      {
        pinPeripheral(pin, PIO_TIMER);
    f7f0:	1c28      	adds	r0, r5, #0
  if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)
  {
    value = mapResolution(value, _writeResolution, 8);

    uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);
    uint8_t tcChannel = GetTCChannelNumber(pinDesc.ulPWMChannel);
    f7f2:	b2d7      	uxtb	r7, r2
      if (pinDesc.ulPinType == PIO_TIMER_ALT) {
        pinPeripheral(pin, PIO_TIMER_ALT);
      } else
      #endif
      {
        pinPeripheral(pin, PIO_TIMER);
    f7f4:	2104      	movs	r1, #4

    uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);
    uint8_t tcChannel = GetTCChannelNumber(pinDesc.ulPWMChannel);
    static bool tcEnabled[TCC_INST_NUM+TC_INST_NUM];

    if (attr & PIN_ATTR_TIMER) {
    f7f6:	06db      	lsls	r3, r3, #27
    f7f8:	d400      	bmi.n	f7fc <analogWrite+0x88>
      {
        pinPeripheral(pin, PIO_TIMER);
      }
    } else {
      // We suppose that attr has PIN_ATTR_TIMER_ALT bit set...
      pinPeripheral(pin, PIO_TIMER_ALT);
    f7fa:	2105      	movs	r1, #5
    f7fc:	f000 f93e 	bl	fa7c <pinPeripheral>
    }

    if (!tcEnabled[tcNum]) {
    f800:	4b53      	ldr	r3, [pc, #332]	; (f950 <analogWrite+0x1dc>)
    f802:	5d1a      	ldrb	r2, [r3, r4]
    f804:	2a00      	cmp	r2, #0
    f806:	d166      	bne.n	f8d6 <analogWrite+0x162>
      tcEnabled[tcNum] = true;
    f808:	2201      	movs	r2, #1
    f80a:	551a      	strb	r2, [r3, r4]

      uint16_t GCLK_CLKCTRL_IDs[] = {
    f80c:	a804      	add	r0, sp, #16
    f80e:	2210      	movs	r2, #16
    f810:	4950      	ldr	r1, [pc, #320]	; (f954 <analogWrite+0x1e0>)
    f812:	f001 fed2 	bl	115ba <memcpy>
        GCLK_CLKCTRL_ID(GCM_TC4_TC5),   // TC4
        GCLK_CLKCTRL_ID(GCM_TC4_TC5),   // TC5
        GCLK_CLKCTRL_ID(GCM_TC6_TC7),   // TC6
        GCLK_CLKCTRL_ID(GCM_TC6_TC7),   // TC7
      };
      GCLK->CLKCTRL.reg = (uint16_t) (GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN_GCLK0 | GCLK_CLKCTRL_IDs[tcNum]);
    f816:	0063      	lsls	r3, r4, #1
    f818:	466a      	mov	r2, sp
    f81a:	3310      	adds	r3, #16
    f81c:	5a9b      	ldrh	r3, [r3, r2]
    f81e:	2280      	movs	r2, #128	; 0x80
    f820:	01d2      	lsls	r2, r2, #7
    f822:	431a      	orrs	r2, r3
    f824:	4b4c      	ldr	r3, [pc, #304]	; (f958 <analogWrite+0x1e4>)
    f826:	805a      	strh	r2, [r3, #2]
      while (GCLK->STATUS.bit.SYNCBUSY == 1);
    f828:	785a      	ldrb	r2, [r3, #1]
    f82a:	09d2      	lsrs	r2, r2, #7
    f82c:	2a01      	cmp	r2, #1
    f82e:	d0fb      	beq.n	f828 <analogWrite+0xb4>
    f830:	4b4a      	ldr	r3, [pc, #296]	; (f95c <analogWrite+0x1e8>)

      // Set PORT
      if (tcNum >= TCC_INST_NUM) {
    f832:	2c02      	cmp	r4, #2
    f834:	d922      	bls.n	f87c <analogWrite+0x108>
        // -- Configure TC
        Tc* TCx = (Tc*) GetTC(pinDesc.ulPWMChannel);
    f836:	00a4      	lsls	r4, r4, #2
    f838:	591b      	ldr	r3, [r3, r4]
        // Disable TCx
        TCx->COUNT8.CTRLA.bit.ENABLE = 0;
    f83a:	2102      	movs	r1, #2
    f83c:	881a      	ldrh	r2, [r3, #0]
    f83e:	438a      	bics	r2, r1
    f840:	801a      	strh	r2, [r3, #0]
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncTC_8(Tc* TCx) __attribute__((always_inline, unused));
static void syncTC_8(Tc* TCx) {
  while (TCx->COUNT8.STATUS.bit.SYNCBUSY);
    f842:	7bda      	ldrb	r2, [r3, #15]
    f844:	09d2      	lsrs	r2, r2, #7
    f846:	d1fc      	bne.n	f842 <analogWrite+0xce>
        Tc* TCx = (Tc*) GetTC(pinDesc.ulPWMChannel);
        // Disable TCx
        TCx->COUNT8.CTRLA.bit.ENABLE = 0;
        syncTC_8(TCx);
        // Set Timer counter Mode to 8 bits, normal PWM, prescaler 1/256
        TCx->COUNT8.CTRLA.reg |= TC_CTRLA_MODE_COUNT8 | TC_CTRLA_WAVEGEN_NPWM | TC_CTRLA_PRESCALER_DIV256;
    f848:	881a      	ldrh	r2, [r3, #0]
    f84a:	4945      	ldr	r1, [pc, #276]	; (f960 <analogWrite+0x1ec>)
    f84c:	430a      	orrs	r2, r1
    f84e:	801a      	strh	r2, [r3, #0]
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncTC_8(Tc* TCx) __attribute__((always_inline, unused));
static void syncTC_8(Tc* TCx) {
  while (TCx->COUNT8.STATUS.bit.SYNCBUSY);
    f850:	7bda      	ldrb	r2, [r3, #15]
    f852:	09d2      	lsrs	r2, r2, #7
    f854:	d1fc      	bne.n	f850 <analogWrite+0xdc>
        syncTC_8(TCx);
        // Set Timer counter Mode to 8 bits, normal PWM, prescaler 1/256
        TCx->COUNT8.CTRLA.reg |= TC_CTRLA_MODE_COUNT8 | TC_CTRLA_WAVEGEN_NPWM | TC_CTRLA_PRESCALER_DIV256;
        syncTC_8(TCx);
        // Set the initial value
        TCx->COUNT8.CC[tcChannel].reg = (uint8_t) value;
    f856:	b2f6      	uxtb	r6, r6
    f858:	19df      	adds	r7, r3, r7
    f85a:	763e      	strb	r6, [r7, #24]
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncTC_8(Tc* TCx) __attribute__((always_inline, unused));
static void syncTC_8(Tc* TCx) {
  while (TCx->COUNT8.STATUS.bit.SYNCBUSY);
    f85c:	7bda      	ldrb	r2, [r3, #15]
    f85e:	09d2      	lsrs	r2, r2, #7
    f860:	d1fc      	bne.n	f85c <analogWrite+0xe8>
        syncTC_8(TCx);
        // Set the initial value
        TCx->COUNT8.CC[tcChannel].reg = (uint8_t) value;
        syncTC_8(TCx);
        // Set PER to maximum counter value (resolution : 0xFF)
        TCx->COUNT8.PER.reg = 0xFF;
    f862:	22ff      	movs	r2, #255	; 0xff
    f864:	751a      	strb	r2, [r3, #20]
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncTC_8(Tc* TCx) __attribute__((always_inline, unused));
static void syncTC_8(Tc* TCx) {
  while (TCx->COUNT8.STATUS.bit.SYNCBUSY);
    f866:	7bda      	ldrb	r2, [r3, #15]
    f868:	09d2      	lsrs	r2, r2, #7
    f86a:	d1fc      	bne.n	f866 <analogWrite+0xf2>
        syncTC_8(TCx);
        // Set PER to maximum counter value (resolution : 0xFF)
        TCx->COUNT8.PER.reg = 0xFF;
        syncTC_8(TCx);
        // Enable TCx
        TCx->COUNT8.CTRLA.bit.ENABLE = 1;
    f86c:	881a      	ldrh	r2, [r3, #0]
    f86e:	2102      	movs	r1, #2
    f870:	430a      	orrs	r2, r1
    f872:	801a      	strh	r2, [r3, #0]
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncTC_8(Tc* TCx) __attribute__((always_inline, unused));
static void syncTC_8(Tc* TCx) {
  while (TCx->COUNT8.STATUS.bit.SYNCBUSY);
    f874:	7bda      	ldrb	r2, [r3, #15]
    f876:	09d2      	lsrs	r2, r2, #7
    f878:	d1fc      	bne.n	f874 <analogWrite+0x100>
    f87a:	e061      	b.n	f940 <analogWrite+0x1cc>
        // Enable TCx
        TCx->COUNT8.CTRLA.bit.ENABLE = 1;
        syncTC_8(TCx);
      } else {
        // -- Configure TCC
        Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);
    f87c:	00a4      	lsls	r4, r4, #2
    f87e:	591b      	ldr	r3, [r3, r4]
        // Disable TCCx
        TCCx->CTRLA.bit.ENABLE = 0;
    f880:	2102      	movs	r1, #2
    f882:	681a      	ldr	r2, [r3, #0]
    f884:	438a      	bics	r2, r1
    f886:	601a      	str	r2, [r3, #0]
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncTCC(Tcc* TCCx) __attribute__((always_inline, unused));
static void syncTCC(Tcc* TCCx) {
  while (TCCx->SYNCBUSY.reg & TCC_SYNCBUSY_MASK);
    f888:	6899      	ldr	r1, [r3, #8]
    f88a:	4a36      	ldr	r2, [pc, #216]	; (f964 <analogWrite+0x1f0>)
    f88c:	4211      	tst	r1, r2
    f88e:	d1fb      	bne.n	f888 <analogWrite+0x114>
        Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);
        // Disable TCCx
        TCCx->CTRLA.bit.ENABLE = 0;
        syncTCC(TCCx);
        // Set prescaler to 1/256
        TCCx->CTRLA.reg |= TCC_CTRLA_PRESCALER_DIV256;
    f890:	6818      	ldr	r0, [r3, #0]
    f892:	21c0      	movs	r1, #192	; 0xc0
    f894:	00c9      	lsls	r1, r1, #3
    f896:	4301      	orrs	r1, r0
    f898:	6019      	str	r1, [r3, #0]
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncTCC(Tcc* TCCx) __attribute__((always_inline, unused));
static void syncTCC(Tcc* TCCx) {
  while (TCCx->SYNCBUSY.reg & TCC_SYNCBUSY_MASK);
    f89a:	6899      	ldr	r1, [r3, #8]
    f89c:	4211      	tst	r1, r2
    f89e:	d1fc      	bne.n	f89a <analogWrite+0x126>
        syncTCC(TCCx);
        // Set prescaler to 1/256
        TCCx->CTRLA.reg |= TCC_CTRLA_PRESCALER_DIV256;
        syncTCC(TCCx);
        // Set TCx as normal PWM
        TCCx->WAVE.reg |= TCC_WAVE_WAVEGEN_NPWM;
    f8a0:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
    f8a2:	2002      	movs	r0, #2
    f8a4:	4301      	orrs	r1, r0
    f8a6:	63d9      	str	r1, [r3, #60]	; 0x3c
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncTCC(Tcc* TCCx) __attribute__((always_inline, unused));
static void syncTCC(Tcc* TCCx) {
  while (TCCx->SYNCBUSY.reg & TCC_SYNCBUSY_MASK);
    f8a8:	6899      	ldr	r1, [r3, #8]
    f8aa:	4211      	tst	r1, r2
    f8ac:	d1fc      	bne.n	f8a8 <analogWrite+0x134>
        syncTCC(TCCx);
        // Set TCx as normal PWM
        TCCx->WAVE.reg |= TCC_WAVE_WAVEGEN_NPWM;
        syncTCC(TCCx);
        // Set the initial value
        TCCx->CC[tcChannel].reg = (uint32_t) value;
    f8ae:	3710      	adds	r7, #16
    f8b0:	00bf      	lsls	r7, r7, #2
    f8b2:	19df      	adds	r7, r3, r7
    f8b4:	607e      	str	r6, [r7, #4]
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncTCC(Tcc* TCCx) __attribute__((always_inline, unused));
static void syncTCC(Tcc* TCCx) {
  while (TCCx->SYNCBUSY.reg & TCC_SYNCBUSY_MASK);
    f8b6:	6899      	ldr	r1, [r3, #8]
    f8b8:	4211      	tst	r1, r2
    f8ba:	d1fc      	bne.n	f8b6 <analogWrite+0x142>
        syncTCC(TCCx);
        // Set the initial value
        TCCx->CC[tcChannel].reg = (uint32_t) value;
        syncTCC(TCCx);
        // Set PER to maximum counter value (resolution : 0xFF)
        TCCx->PER.reg = 0xFF;
    f8bc:	21ff      	movs	r1, #255	; 0xff
    f8be:	6419      	str	r1, [r3, #64]	; 0x40
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncTCC(Tcc* TCCx) __attribute__((always_inline, unused));
static void syncTCC(Tcc* TCCx) {
  while (TCCx->SYNCBUSY.reg & TCC_SYNCBUSY_MASK);
    f8c0:	6899      	ldr	r1, [r3, #8]
    f8c2:	4211      	tst	r1, r2
    f8c4:	d1fc      	bne.n	f8c0 <analogWrite+0x14c>
        syncTCC(TCCx);
        // Set PER to maximum counter value (resolution : 0xFF)
        TCCx->PER.reg = 0xFF;
        syncTCC(TCCx);
        // Enable TCCx
        TCCx->CTRLA.bit.ENABLE = 1;
    f8c6:	6819      	ldr	r1, [r3, #0]
    f8c8:	2002      	movs	r0, #2
    f8ca:	4301      	orrs	r1, r0
    f8cc:	6019      	str	r1, [r3, #0]
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncTCC(Tcc* TCCx) __attribute__((always_inline, unused));
static void syncTCC(Tcc* TCCx) {
  while (TCCx->SYNCBUSY.reg & TCC_SYNCBUSY_MASK);
    f8ce:	6899      	ldr	r1, [r3, #8]
    f8d0:	4211      	tst	r1, r2
    f8d2:	d1fc      	bne.n	f8ce <analogWrite+0x15a>
    f8d4:	e034      	b.n	f940 <analogWrite+0x1cc>
    f8d6:	4b21      	ldr	r3, [pc, #132]	; (f95c <analogWrite+0x1e8>)
        // Enable TCCx
        TCCx->CTRLA.bit.ENABLE = 1;
        syncTCC(TCCx);
      }
    } else {
      if (tcNum >= TCC_INST_NUM) {
    f8d8:	2c02      	cmp	r4, #2
    f8da:	d908      	bls.n	f8ee <analogWrite+0x17a>
        Tc* TCx = (Tc*) GetTC(pinDesc.ulPWMChannel);
    f8dc:	00a4      	lsls	r4, r4, #2
    f8de:	591b      	ldr	r3, [r3, r4]
        TCx->COUNT8.CC[tcChannel].reg = (uint8_t) value;
    f8e0:	b2f6      	uxtb	r6, r6
    f8e2:	19df      	adds	r7, r3, r7
    f8e4:	763e      	strb	r6, [r7, #24]
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncTC_8(Tc* TCx) __attribute__((always_inline, unused));
static void syncTC_8(Tc* TCx) {
  while (TCx->COUNT8.STATUS.bit.SYNCBUSY);
    f8e6:	7bda      	ldrb	r2, [r3, #15]
    f8e8:	09d2      	lsrs	r2, r2, #7
    f8ea:	d1fc      	bne.n	f8e6 <analogWrite+0x172>
    f8ec:	e028      	b.n	f940 <analogWrite+0x1cc>
      if (tcNum >= TCC_INST_NUM) {
        Tc* TCx = (Tc*) GetTC(pinDesc.ulPWMChannel);
        TCx->COUNT8.CC[tcChannel].reg = (uint8_t) value;
        syncTC_8(TCx);
    } else {
        Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);
    f8ee:	00a4      	lsls	r4, r4, #2
    f8f0:	591b      	ldr	r3, [r3, r4]
        TCCx->CTRLBSET.bit.LUPD = 1;
    f8f2:	2102      	movs	r1, #2
    f8f4:	795a      	ldrb	r2, [r3, #5]
    f8f6:	430a      	orrs	r2, r1
    f8f8:	715a      	strb	r2, [r3, #5]
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncTCC(Tcc* TCCx) __attribute__((always_inline, unused));
static void syncTCC(Tcc* TCCx) {
  while (TCCx->SYNCBUSY.reg & TCC_SYNCBUSY_MASK);
    f8fa:	6899      	ldr	r1, [r3, #8]
    f8fc:	4a19      	ldr	r2, [pc, #100]	; (f964 <analogWrite+0x1f0>)
    f8fe:	4211      	tst	r1, r2
    f900:	d1fb      	bne.n	f8fa <analogWrite+0x186>
        syncTC_8(TCx);
    } else {
        Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);
        TCCx->CTRLBSET.bit.LUPD = 1;
        syncTCC(TCCx);
        TCCx->CCB[tcChannel].reg = (uint32_t) value;
    f902:	371c      	adds	r7, #28
    f904:	00bf      	lsls	r7, r7, #2
    f906:	50fe      	str	r6, [r7, r3]
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncTCC(Tcc* TCCx) __attribute__((always_inline, unused));
static void syncTCC(Tcc* TCCx) {
  while (TCCx->SYNCBUSY.reg & TCC_SYNCBUSY_MASK);
    f908:	6899      	ldr	r1, [r3, #8]
    f90a:	4211      	tst	r1, r2
    f90c:	d1fc      	bne.n	f908 <analogWrite+0x194>
        Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);
        TCCx->CTRLBSET.bit.LUPD = 1;
        syncTCC(TCCx);
        TCCx->CCB[tcChannel].reg = (uint32_t) value;
        syncTCC(TCCx);
        TCCx->CTRLBCLR.bit.LUPD = 1;
    f90e:	7919      	ldrb	r1, [r3, #4]
    f910:	2002      	movs	r0, #2
    f912:	4301      	orrs	r1, r0
    f914:	7119      	strb	r1, [r3, #4]
}

// Wait for synchronization of registers between the clock domains
static __inline__ void syncTCC(Tcc* TCCx) __attribute__((always_inline, unused));
static void syncTCC(Tcc* TCCx) {
  while (TCCx->SYNCBUSY.reg & TCC_SYNCBUSY_MASK);
    f916:	6899      	ldr	r1, [r3, #8]
    f918:	4211      	tst	r1, r2
    f91a:	d1fc      	bne.n	f916 <analogWrite+0x1a2>
    f91c:	e010      	b.n	f940 <analogWrite+0x1cc>
    }
    return;
  }

  // -- Defaults to digital write
  pinMode(pin, OUTPUT);
    f91e:	2101      	movs	r1, #1
    f920:	f000 f822 	bl	f968 <pinMode>
  value = mapResolution(value, _writeResolution, 8);
    f924:	6831      	ldr	r1, [r6, #0]
    f926:	1c20      	adds	r0, r4, #0
    f928:	1c3a      	adds	r2, r7, #0
    f92a:	f7ff fe7b 	bl	f624 <mapResolution>
  if (value < 128) {
    f92e:	287f      	cmp	r0, #127	; 0x7f
    f930:	d802      	bhi.n	f938 <analogWrite+0x1c4>
    digitalWrite(pin, LOW);
    f932:	1c28      	adds	r0, r5, #0
    f934:	9903      	ldr	r1, [sp, #12]
    f936:	e001      	b.n	f93c <analogWrite+0x1c8>
  } else {
    digitalWrite(pin, HIGH);
    f938:	1c28      	adds	r0, r5, #0
    f93a:	2101      	movs	r1, #1
    f93c:	f000 f86e 	bl	fa1c <digitalWrite>
  }
}
    f940:	b009      	add	sp, #36	; 0x24
    f942:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f944:	000156a8 	.word	0x000156a8
    f948:	200000a0 	.word	0x200000a0
    f94c:	42004800 	.word	0x42004800
    f950:	20000f30 	.word	0x20000f30
    f954:	00015ac8 	.word	0x00015ac8
    f958:	40000c00 	.word	0x40000c00
    f95c:	20000080 	.word	0x20000080
    f960:	00000644 	.word	0x00000644
    f964:	007f0fff 	.word	0x007f0fff

0000f968 <pinMode>:
#ifdef __cplusplus
 extern "C" {
#endif

void pinMode( uint32_t ulPin, uint32_t ulMode )
{
    f968:	b510      	push	{r4, lr}
  // Handle the case the pin isn't usable as PIO
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    f96a:	2418      	movs	r4, #24
#ifdef __cplusplus
 extern "C" {
#endif

void pinMode( uint32_t ulPin, uint32_t ulMode )
{
    f96c:	1c02      	adds	r2, r0, #0
  // Handle the case the pin isn't usable as PIO
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    f96e:	1c20      	adds	r0, r4, #0
    f970:	4350      	muls	r0, r2
    f972:	4b27      	ldr	r3, [pc, #156]	; (fa10 <pinMode+0xa8>)
    f974:	1818      	adds	r0, r3, r0
    f976:	7a00      	ldrb	r0, [r0, #8]
    f978:	b240      	sxtb	r0, r0
    f97a:	3001      	adds	r0, #1
    f97c:	d046      	beq.n	fa0c <pinMode+0xa4>
  {
    return ;
  }

  // Set pin mode according to chapter '22.6.3 I/O Pin Configuration'
  switch ( ulMode )
    f97e:	2903      	cmp	r1, #3
    f980:	d844      	bhi.n	fa0c <pinMode+0xa4>
    f982:	1c08      	adds	r0, r1, #0
    f984:	1c21      	adds	r1, r4, #0
    f986:	f001 fcf3 	bl	11370 <__gnu_thumb1_case_uqi>
    f98a:	3302      	.short	0x3302
    f98c:	2111      	.short	0x2111
  {
    case INPUT:
      // Set pin to input mode
      PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg=(uint8_t)(PORT_PINCFG_INEN) ;
    f98e:	4362      	muls	r2, r4
    f990:	5698      	ldrsb	r0, [r3, r2]
    f992:	189a      	adds	r2, r3, r2
    f994:	01c3      	lsls	r3, r0, #7
    f996:	481f      	ldr	r0, [pc, #124]	; (fa14 <pinMode+0xac>)
    f998:	6852      	ldr	r2, [r2, #4]
    f99a:	181b      	adds	r3, r3, r0
    f99c:	1899      	adds	r1, r3, r2
    f99e:	3140      	adds	r1, #64	; 0x40
    f9a0:	2002      	movs	r0, #2
    f9a2:	7008      	strb	r0, [r1, #0]
      PORT->Group[g_APinDescription[ulPin].ulPort].DIRCLR.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
    f9a4:	2101      	movs	r1, #1
    f9a6:	4091      	lsls	r1, r2
    f9a8:	6059      	str	r1, [r3, #4]
    break ;
    f9aa:	e02f      	b.n	fa0c <pinMode+0xa4>

    case INPUT_PULLUP:
      // Set pin to input mode with pull-up resistor enabled
      PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg=(uint8_t)(PORT_PINCFG_INEN|PORT_PINCFG_PULLEN) ;
    f9ac:	4362      	muls	r2, r4
    f9ae:	5698      	ldrsb	r0, [r3, r2]
    f9b0:	4918      	ldr	r1, [pc, #96]	; (fa14 <pinMode+0xac>)
    f9b2:	189a      	adds	r2, r3, r2
    f9b4:	6852      	ldr	r2, [r2, #4]
    f9b6:	01c3      	lsls	r3, r0, #7
    f9b8:	185b      	adds	r3, r3, r1
    f9ba:	1899      	adds	r1, r3, r2
    f9bc:	3140      	adds	r1, #64	; 0x40
    f9be:	2006      	movs	r0, #6
    f9c0:	7008      	strb	r0, [r1, #0]
      PORT->Group[g_APinDescription[ulPin].ulPort].DIRCLR.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
    f9c2:	2101      	movs	r1, #1
    f9c4:	4091      	lsls	r1, r2
    f9c6:	6059      	str	r1, [r3, #4]

      // Enable pull level (cf '22.6.3.2 Input Configuration' and '22.8.7 Data Output Value Set')
      PORT->Group[g_APinDescription[ulPin].ulPort].OUTSET.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
    f9c8:	6199      	str	r1, [r3, #24]
    break ;
    f9ca:	e01f      	b.n	fa0c <pinMode+0xa4>

    case INPUT_PULLDOWN:
      // Set pin to input mode with pull-down resistor enabled
      PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg=(uint8_t)(PORT_PINCFG_INEN|PORT_PINCFG_PULLEN) ;
    f9cc:	4351      	muls	r1, r2
    f9ce:	565a      	ldrsb	r2, [r3, r1]
    f9d0:	4810      	ldr	r0, [pc, #64]	; (fa14 <pinMode+0xac>)
    f9d2:	1859      	adds	r1, r3, r1
    f9d4:	684b      	ldr	r3, [r1, #4]
    f9d6:	01d2      	lsls	r2, r2, #7
    f9d8:	1811      	adds	r1, r2, r0
    f9da:	18c8      	adds	r0, r1, r3
    f9dc:	3040      	adds	r0, #64	; 0x40
    f9de:	2406      	movs	r4, #6
    f9e0:	7004      	strb	r4, [r0, #0]
      PORT->Group[g_APinDescription[ulPin].ulPort].DIRCLR.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
    f9e2:	2001      	movs	r0, #1
    f9e4:	4098      	lsls	r0, r3
    f9e6:	6048      	str	r0, [r1, #4]

      // Enable pull level (cf '22.6.3.2 Input Configuration' and '22.8.6 Data Output Value Clear')
      PORT->Group[g_APinDescription[ulPin].ulPort].OUTCLR.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
    f9e8:	490b      	ldr	r1, [pc, #44]	; (fa18 <pinMode+0xb0>)
    f9ea:	1852      	adds	r2, r2, r1
    f9ec:	6050      	str	r0, [r2, #4]
    break ;
    f9ee:	e00d      	b.n	fa0c <pinMode+0xa4>

    case OUTPUT:
      // enable input, to support reading back values, with pullups disabled
      PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg=(uint8_t)(PORT_PINCFG_INEN) ;
    f9f0:	4362      	muls	r2, r4
    f9f2:	5698      	ldrsb	r0, [r3, r2]
    f9f4:	189a      	adds	r2, r3, r2
    f9f6:	01c3      	lsls	r3, r0, #7
    f9f8:	4806      	ldr	r0, [pc, #24]	; (fa14 <pinMode+0xac>)
    f9fa:	6852      	ldr	r2, [r2, #4]
    f9fc:	181b      	adds	r3, r3, r0
    f9fe:	1899      	adds	r1, r3, r2
    fa00:	3140      	adds	r1, #64	; 0x40
    fa02:	2002      	movs	r0, #2
    fa04:	7008      	strb	r0, [r1, #0]

      // Set pin to output mode
      PORT->Group[g_APinDescription[ulPin].ulPort].DIRSET.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
    fa06:	2101      	movs	r1, #1
    fa08:	4091      	lsls	r1, r2
    fa0a:	6099      	str	r1, [r3, #8]

    default:
      // do nothing
    break ;
  }
}
    fa0c:	bd10      	pop	{r4, pc}
    fa0e:	46c0      	nop			; (mov r8, r8)
    fa10:	000156a8 	.word	0x000156a8
    fa14:	41004400 	.word	0x41004400
    fa18:	41004410 	.word	0x41004410

0000fa1c <digitalWrite>:

void digitalWrite( uint32_t ulPin, uint32_t ulVal )
{
  // Handle the case the pin isn't usable as PIO
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    fa1c:	2318      	movs	r3, #24
    fa1e:	4358      	muls	r0, r3
    fa20:	4a13      	ldr	r2, [pc, #76]	; (fa70 <digitalWrite+0x54>)
    break ;
  }
}

void digitalWrite( uint32_t ulPin, uint32_t ulVal )
{
    fa22:	b5f0      	push	{r4, r5, r6, r7, lr}
  // Handle the case the pin isn't usable as PIO
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    fa24:	1813      	adds	r3, r2, r0
    fa26:	2408      	movs	r4, #8
    fa28:	571c      	ldrsb	r4, [r3, r4]
    fa2a:	3401      	adds	r4, #1
    fa2c:	d01f      	beq.n	fa6e <digitalWrite+0x52>

  EPortType port = g_APinDescription[ulPin].ulPort;
  uint32_t pin = g_APinDescription[ulPin].ulPin;
  uint32_t pinMask = (1ul << pin);

  if ( (PORT->Group[port].DIRSET.reg & pinMask) == 0 ) {
    fa2e:	5682      	ldrsb	r2, [r0, r2]
    fa30:	4e10      	ldr	r6, [pc, #64]	; (fa74 <digitalWrite+0x58>)
    fa32:	01d2      	lsls	r2, r2, #7
  {
    return ;
  }

  EPortType port = g_APinDescription[ulPin].ulPort;
  uint32_t pin = g_APinDescription[ulPin].ulPin;
    fa34:	685d      	ldr	r5, [r3, #4]
  uint32_t pinMask = (1ul << pin);
    fa36:	2401      	movs	r4, #1

  if ( (PORT->Group[port].DIRSET.reg & pinMask) == 0 ) {
    fa38:	1990      	adds	r0, r2, r6
    return ;
  }

  EPortType port = g_APinDescription[ulPin].ulPort;
  uint32_t pin = g_APinDescription[ulPin].ulPin;
  uint32_t pinMask = (1ul << pin);
    fa3a:	1c23      	adds	r3, r4, #0

  if ( (PORT->Group[port].DIRSET.reg & pinMask) == 0 ) {
    fa3c:	6886      	ldr	r6, [r0, #8]
    return ;
  }

  EPortType port = g_APinDescription[ulPin].ulPort;
  uint32_t pin = g_APinDescription[ulPin].ulPin;
  uint32_t pinMask = (1ul << pin);
    fa3e:	40ab      	lsls	r3, r5

  if ( (PORT->Group[port].DIRSET.reg & pinMask) == 0 ) {
    fa40:	421e      	tst	r6, r3
    fa42:	d10b      	bne.n	fa5c <digitalWrite+0x40>
    // the pin is not an output, disable pull-up if val is LOW, otherwise enable pull-up
    PORT->Group[port].PINCFG[pin].bit.PULLEN = ((ulVal == LOW) ? 0 : 1) ;
    fa44:	1c0e      	adds	r6, r1, #0
    fa46:	1e77      	subs	r7, r6, #1
    fa48:	41be      	sbcs	r6, r7
    fa4a:	1940      	adds	r0, r0, r5
    fa4c:	4034      	ands	r4, r6
    fa4e:	3040      	adds	r0, #64	; 0x40
    fa50:	00a5      	lsls	r5, r4, #2
    fa52:	7804      	ldrb	r4, [r0, #0]
    fa54:	2604      	movs	r6, #4
    fa56:	43b4      	bics	r4, r6
    fa58:	432c      	orrs	r4, r5
    fa5a:	7004      	strb	r4, [r0, #0]
  }

  switch ( ulVal )
    fa5c:	2900      	cmp	r1, #0
    fa5e:	d103      	bne.n	fa68 <digitalWrite+0x4c>
  {
    case LOW:
      PORT->Group[port].OUTCLR.reg = pinMask;
    fa60:	4905      	ldr	r1, [pc, #20]	; (fa78 <digitalWrite+0x5c>)
    fa62:	1852      	adds	r2, r2, r1
    fa64:	6053      	str	r3, [r2, #4]
    break ;
    fa66:	e002      	b.n	fa6e <digitalWrite+0x52>

    default:
      PORT->Group[port].OUTSET.reg = pinMask;
    fa68:	4e02      	ldr	r6, [pc, #8]	; (fa74 <digitalWrite+0x58>)
    fa6a:	1992      	adds	r2, r2, r6
    fa6c:	6193      	str	r3, [r2, #24]
    break ;
  }

  return ;
}
    fa6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    fa70:	000156a8 	.word	0x000156a8
    fa74:	41004400 	.word	0x41004400
    fa78:	41004410 	.word	0x41004410

0000fa7c <pinPeripheral>:
#include "wiring_private.h"

int pinPeripheral( uint32_t ulPin, EPioType ulPeripheral )
{
  // Handle the case the pin isn't usable as PIO
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    fa7c:	2218      	movs	r2, #24
    fa7e:	4342      	muls	r2, r0

#include "Arduino.h"
#include "wiring_private.h"

int pinPeripheral( uint32_t ulPin, EPioType ulPeripheral )
{
    fa80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // Handle the case the pin isn't usable as PIO
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    fa82:	4d2d      	ldr	r5, [pc, #180]	; (fb38 <pinPeripheral+0xbc>)
    fa84:	2408      	movs	r4, #8
    fa86:	18aa      	adds	r2, r5, r2
    fa88:	5714      	ldrsb	r4, [r2, r4]

#include "Arduino.h"
#include "wiring_private.h"

int pinPeripheral( uint32_t ulPin, EPioType ulPeripheral )
{
    fa8a:	1c03      	adds	r3, r0, #0
  // Handle the case the pin isn't usable as PIO
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    fa8c:	1c62      	adds	r2, r4, #1
    fa8e:	d050      	beq.n	fb32 <pinPeripheral+0xb6>
  {
    return -1 ;
  }

  switch ( ulPeripheral )
    fa90:	1c48      	adds	r0, r1, #1
    case PIO_NOT_A_PIN:
      return -1l ;
    break ;
  }

  return 0l ;
    fa92:	2400      	movs	r4, #0
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
  {
    return -1 ;
  }

  switch ( ulPeripheral )
    fa94:	280c      	cmp	r0, #12
    fa96:	d84c      	bhi.n	fb32 <pinPeripheral+0xb6>
    fa98:	f001 fc6a 	bl	11370 <__gnu_thumb1_case_uqi>
    fa9c:	1e1e1e07 	.word	0x1e1e1e07
    faa0:	1e1e1e1e 	.word	0x1e1e1e1e
    faa4:	0a0a0a1e 	.word	0x0a0a0a1e
    faa8:	0a          	.byte	0x0a
    faa9:	00          	.byte	0x00
      }
#endif
    break ;

    case PIO_NOT_A_PIN:
      return -1l ;
    faaa:	2401      	movs	r4, #1
    faac:	4264      	negs	r4, r4
    faae:	e040      	b.n	fb32 <pinPeripheral+0xb6>
    case PIO_OUTPUT:
      // Disable peripheral muxing, done in pinMode
//			PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].bit.PMUXEN = 0 ;

      // Configure pin mode, if requested
      if ( ulPeripheral == PIO_INPUT )
    fab0:	2909      	cmp	r1, #9
    fab2:	d102      	bne.n	faba <pinPeripheral+0x3e>
      {
        pinMode( ulPin, INPUT ) ;
    fab4:	1c18      	adds	r0, r3, #0
    fab6:	2100      	movs	r1, #0
    fab8:	e003      	b.n	fac2 <pinPeripheral+0x46>
      }
      else
      {
        if ( ulPeripheral == PIO_INPUT_PULLUP )
    faba:	290a      	cmp	r1, #10
    fabc:	d104      	bne.n	fac8 <pinPeripheral+0x4c>
        {
          pinMode( ulPin, INPUT_PULLUP ) ;
    fabe:	1c18      	adds	r0, r3, #0
    fac0:	2102      	movs	r1, #2
    fac2:	f7ff ff51 	bl	f968 <pinMode>
    fac6:	e023      	b.n	fb10 <pinPeripheral+0x94>
    case PIO_NOT_A_PIN:
      return -1l ;
    break ;
  }

  return 0l ;
    fac8:	2400      	movs	r4, #0
        {
          pinMode( ulPin, INPUT_PULLUP ) ;
        }
        else
        {
          if ( ulPeripheral == PIO_OUTPUT )
    faca:	290b      	cmp	r1, #11
    facc:	d131      	bne.n	fb32 <pinPeripheral+0xb6>
          {
            pinMode( ulPin, OUTPUT ) ;
    face:	1c18      	adds	r0, r3, #0
    fad0:	2101      	movs	r1, #1
    fad2:	f7ff ff49 	bl	f968 <pinMode>
    fad6:	e02c      	b.n	fb32 <pinPeripheral+0xb6>
                                                                    PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_PMUXEN | PORT_WRCONFIG_PMUX( ulPeripheral ) |
                                                                    PORT_WRCONFIG_WRPINCFG |
                                                                    PORT_WRCONFIG_PINMASK( g_APinDescription[ulPin].ulPin - 16 ) ;
      }
#else
      if ( g_APinDescription[ulPin].ulPin & 1 ) // is pin odd?
    fad8:	2218      	movs	r2, #24
    fada:	4353      	muls	r3, r2
    fadc:	18ea      	adds	r2, r5, r3
    fade:	6852      	ldr	r2, [r2, #4]
    fae0:	56eb      	ldrsb	r3, [r5, r3]
    fae2:	2001      	movs	r0, #1
    fae4:	1c14      	adds	r4, r2, #0
    fae6:	4004      	ands	r4, r0
    fae8:	0855      	lsrs	r5, r2, #1
      {
        uint32_t temp ;

        // Get whole current setup for both odd and even pins and remove odd one
        temp = (PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg) & PORT_PMUX_PMUXE( 0xF ) ;
    faea:	01db      	lsls	r3, r3, #7
                                                                    PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_PMUXEN | PORT_WRCONFIG_PMUX( ulPeripheral ) |
                                                                    PORT_WRCONFIG_WRPINCFG |
                                                                    PORT_WRCONFIG_PINMASK( g_APinDescription[ulPin].ulPin - 16 ) ;
      }
#else
      if ( g_APinDescription[ulPin].ulPin & 1 ) // is pin odd?
    faec:	2c00      	cmp	r4, #0
    faee:	d011      	beq.n	fb14 <pinPeripheral+0x98>
      {
        uint32_t temp ;

        // Get whole current setup for both odd and even pins and remove odd one
        temp = (PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg) & PORT_PMUX_PMUXE( 0xF ) ;
    faf0:	4c12      	ldr	r4, [pc, #72]	; (fb3c <pinPeripheral+0xc0>)
    faf2:	191b      	adds	r3, r3, r4
    faf4:	195d      	adds	r5, r3, r5
    faf6:	3530      	adds	r5, #48	; 0x30
    faf8:	782e      	ldrb	r6, [r5, #0]
        // Set new muxing
        PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg = temp|PORT_PMUX_PMUXO( ulPeripheral ) ;
    fafa:	010c      	lsls	r4, r1, #4
      if ( g_APinDescription[ulPin].ulPin & 1 ) // is pin odd?
      {
        uint32_t temp ;

        // Get whole current setup for both odd and even pins and remove odd one
        temp = (PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg) & PORT_PMUX_PMUXE( 0xF ) ;
    fafc:	210f      	movs	r1, #15
    fafe:	4031      	ands	r1, r6
        // Set new muxing
        PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg = temp|PORT_PMUX_PMUXO( ulPeripheral ) ;
    fb00:	4321      	orrs	r1, r4
        // Enable port mux
        PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg |= PORT_PINCFG_PMUXEN ;
    fb02:	189a      	adds	r2, r3, r2
        uint32_t temp ;

        // Get whole current setup for both odd and even pins and remove odd one
        temp = (PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg) & PORT_PMUX_PMUXE( 0xF ) ;
        // Set new muxing
        PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg = temp|PORT_PMUX_PMUXO( ulPeripheral ) ;
    fb04:	b2c9      	uxtb	r1, r1
    fb06:	7029      	strb	r1, [r5, #0]
        // Enable port mux
        PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg |= PORT_PINCFG_PMUXEN ;
    fb08:	3240      	adds	r2, #64	; 0x40
    fb0a:	7813      	ldrb	r3, [r2, #0]
    fb0c:	4318      	orrs	r0, r3
    fb0e:	7010      	strb	r0, [r2, #0]
    case PIO_NOT_A_PIN:
      return -1l ;
    break ;
  }

  return 0l ;
    fb10:	2400      	movs	r4, #0
    fb12:	e00e      	b.n	fb32 <pinPeripheral+0xb6>
      }
      else // even pin
      {
        uint32_t temp ;

        temp = (PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg) & PORT_PMUX_PMUXO( 0xF ) ;
    fb14:	4e09      	ldr	r6, [pc, #36]	; (fb3c <pinPeripheral+0xc0>)
    fb16:	270f      	movs	r7, #15
    fb18:	199b      	adds	r3, r3, r6
    fb1a:	195d      	adds	r5, r3, r5
    fb1c:	3530      	adds	r5, #48	; 0x30
    fb1e:	782e      	ldrb	r6, [r5, #0]
        PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg = temp|PORT_PMUX_PMUXE( ulPeripheral ) ;
        PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg |= PORT_PINCFG_PMUXEN ; // Enable port mux
    fb20:	189a      	adds	r2, r3, r2
      }
      else // even pin
      {
        uint32_t temp ;

        temp = (PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg) & PORT_PMUX_PMUXO( 0xF ) ;
    fb22:	43be      	bics	r6, r7
        PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg = temp|PORT_PMUX_PMUXE( ulPeripheral ) ;
    fb24:	4331      	orrs	r1, r6
    fb26:	b2c9      	uxtb	r1, r1
    fb28:	7029      	strb	r1, [r5, #0]
        PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg |= PORT_PINCFG_PMUXEN ; // Enable port mux
    fb2a:	3240      	adds	r2, #64	; 0x40
    fb2c:	7813      	ldrb	r3, [r2, #0]
    fb2e:	4318      	orrs	r0, r3
    fb30:	7010      	strb	r0, [r2, #0]
      return -1l ;
    break ;
  }

  return 0l ;
}
    fb32:	1c20      	adds	r0, r4, #0
    fb34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    fb36:	46c0      	nop			; (mov r8, r8)
    fb38:	000156a8 	.word	0x000156a8
    fb3c:	41004400 	.word	0x41004400

0000fb40 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
    fb40:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    fb42:	188a      	adds	r2, r1, r2
    fb44:	1c06      	adds	r6, r0, #0
    fb46:	1c0d      	adds	r5, r1, #0
    fb48:	9201      	str	r2, [sp, #4]
  size_t n = 0;
  while (size--) {
    fb4a:	1c0c      	adds	r4, r1, #0
    fb4c:	9b01      	ldr	r3, [sp, #4]
    fb4e:	1b67      	subs	r7, r4, r5
    fb50:	429c      	cmp	r4, r3
    fb52:	d007      	beq.n	fb64 <_ZN5Print5writeEPKhj+0x24>
    if (write(*buffer++)) n++;
    fb54:	6833      	ldr	r3, [r6, #0]
    fb56:	7821      	ldrb	r1, [r4, #0]
    fb58:	681b      	ldr	r3, [r3, #0]
    fb5a:	1c30      	adds	r0, r6, #0
    fb5c:	4798      	blx	r3
    fb5e:	3401      	adds	r4, #1
    fb60:	2800      	cmp	r0, #0
    fb62:	d1f3      	bne.n	fb4c <_ZN5Print5writeEPKhj+0xc>
    else break;
  }
  return n;
}
    fb64:	1c38      	adds	r0, r7, #0
    fb66:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0000fb68 <_ZN5Print5printEmi.part.3>:
  } else {
    return printNumber(n, base);
  }
}

size_t Print::print(unsigned long n, int base)
    fb68:	b508      	push	{r3, lr}
{
  if (base == 0) return write(n);
    fb6a:	6803      	ldr	r3, [r0, #0]
    fb6c:	b2c9      	uxtb	r1, r1
    fb6e:	681b      	ldr	r3, [r3, #0]
    fb70:	4798      	blx	r3
  else return printNumber(n, base);
}
    fb72:	bd08      	pop	{r3, pc}

0000fb74 <_ZN5Print5printEPKc>:
{
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
    fb74:	b508      	push	{r3, lr}
  return write(str);
    fb76:	f7fe faa5 	bl	e0c4 <_ZN5Print5writeEPKc>
}
    fb7a:	bd08      	pop	{r3, pc}

0000fb7c <_ZN5Print5printEc>:

size_t Print::print(char c)
{
    fb7c:	b508      	push	{r3, lr}
  return write(c);
    fb7e:	6803      	ldr	r3, [r0, #0]
    fb80:	681b      	ldr	r3, [r3, #0]
    fb82:	4798      	blx	r3
}
    fb84:	bd08      	pop	{r3, pc}
	...

0000fb88 <_ZN5Print7printlnEv>:
{
  return x.printTo(*this);
}

size_t Print::println(void)
{
    fb88:	b508      	push	{r3, lr}
  return write("\r\n");
    fb8a:	4902      	ldr	r1, [pc, #8]	; (fb94 <_ZN5Print7printlnEv+0xc>)
    fb8c:	f7fe fa9a 	bl	e0c4 <_ZN5Print5writeEPKc>
}
    fb90:	bd08      	pop	{r3, pc}
    fb92:	46c0      	nop			; (mov r8, r8)
    fb94:	00015ad8 	.word	0x00015ad8

0000fb98 <_ZN5Print7printlnEPKc>:
  n += println();
  return n;
}

size_t Print::println(const char c[])
{
    fb98:	b538      	push	{r3, r4, r5, lr}
    fb9a:	1c04      	adds	r4, r0, #0
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
    fb9c:	f7fe fa92 	bl	e0c4 <_ZN5Print5writeEPKc>
    fba0:	1c05      	adds	r5, r0, #0
}

size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
    fba2:	1c20      	adds	r0, r4, #0
    fba4:	f7ff fff0 	bl	fb88 <_ZN5Print7printlnEv>
    fba8:	1828      	adds	r0, r5, r0
  return n;
}
    fbaa:	bd38      	pop	{r3, r4, r5, pc}

0000fbac <_ZN5Print11printNumberEmh>:
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
{
    fbac:	b5f0      	push	{r4, r5, r6, r7, lr}
    fbae:	b08d      	sub	sp, #52	; 0x34
    fbb0:	1c16      	adds	r6, r2, #0
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
    fbb2:	ab0b      	add	r3, sp, #44	; 0x2c
    fbb4:	2200      	movs	r2, #0
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
{
    fbb6:	9001      	str	r0, [sp, #4]
    fbb8:	1c0c      	adds	r4, r1, #0
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
    fbba:	701a      	strb	r2, [r3, #0]

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
    fbbc:	2e01      	cmp	r6, #1
    fbbe:	d800      	bhi.n	fbc2 <_ZN5Print11printNumberEmh+0x16>
    fbc0:	260a      	movs	r6, #10
    fbc2:	466d      	mov	r5, sp
    fbc4:	352b      	adds	r5, #43	; 0x2b

  do {
    char c = n % base;
    fbc6:	1c20      	adds	r0, r4, #0
    fbc8:	1c31      	adds	r1, r6, #0
    fbca:	f001 fc29 	bl	11420 <__aeabi_uidivmod>
    n /= base;
    fbce:	1c20      	adds	r0, r4, #0

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    char c = n % base;
    fbd0:	b2cf      	uxtb	r7, r1
    n /= base;
    fbd2:	1c31      	adds	r1, r6, #0
    fbd4:	f001 fbe0 	bl	11398 <__aeabi_uidiv>

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    fbd8:	1c29      	adds	r1, r5, #0
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    char c = n % base;
    n /= base;
    fbda:	1c04      	adds	r4, r0, #0

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    fbdc:	2f09      	cmp	r7, #9
    fbde:	d801      	bhi.n	fbe4 <_ZN5Print11printNumberEmh+0x38>
    fbe0:	3730      	adds	r7, #48	; 0x30
    fbe2:	e000      	b.n	fbe6 <_ZN5Print11printNumberEmh+0x3a>
    fbe4:	3737      	adds	r7, #55	; 0x37
    fbe6:	b2ff      	uxtb	r7, r7
    fbe8:	702f      	strb	r7, [r5, #0]
    fbea:	3d01      	subs	r5, #1
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    fbec:	2c00      	cmp	r4, #0
    fbee:	d1ea      	bne.n	fbc6 <_ZN5Print11printNumberEmh+0x1a>
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
    fbf0:	9801      	ldr	r0, [sp, #4]
    fbf2:	f7fe fa67 	bl	e0c4 <_ZN5Print5writeEPKc>
}
    fbf6:	b00d      	add	sp, #52	; 0x34
    fbf8:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000fbfa <_ZN5Print5printEli>:
{
  return print((unsigned long) n, base);
}

size_t Print::print(long n, int base)
{
    fbfa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    fbfc:	1c04      	adds	r4, r0, #0
    fbfe:	1c0d      	adds	r5, r1, #0
    fc00:	1e16      	subs	r6, r2, #0
  if (base == 0) {
    fc02:	d104      	bne.n	fc0e <_ZN5Print5printEli+0x14>
    return write(n);
    fc04:	6803      	ldr	r3, [r0, #0]
    fc06:	b2c9      	uxtb	r1, r1
    fc08:	681b      	ldr	r3, [r3, #0]
    fc0a:	4798      	blx	r3
    fc0c:	e012      	b.n	fc34 <_ZN5Print5printEli+0x3a>
  } else if (base == 10) {
    fc0e:	2a0a      	cmp	r2, #10
    fc10:	d10d      	bne.n	fc2e <_ZN5Print5printEli+0x34>
    if (n < 0) {
    fc12:	2900      	cmp	r1, #0
    fc14:	da0a      	bge.n	fc2c <_ZN5Print5printEli+0x32>
      int t = print('-');
    fc16:	212d      	movs	r1, #45	; 0x2d
    fc18:	f7ff ffb0 	bl	fb7c <_ZN5Print5printEc>
      n = -n;
    fc1c:	4269      	negs	r1, r5
{
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
      int t = print('-');
    fc1e:	1c07      	adds	r7, r0, #0
      n = -n;
      return printNumber(n, 10) + t;
    fc20:	1c32      	adds	r2, r6, #0
    fc22:	1c20      	adds	r0, r4, #0
    fc24:	f7ff ffc2 	bl	fbac <_ZN5Print11printNumberEmh>
    fc28:	19c0      	adds	r0, r0, r7
    fc2a:	e003      	b.n	fc34 <_ZN5Print5printEli+0x3a>
    fc2c:	e000      	b.n	fc30 <_ZN5Print5printEli+0x36>
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
    fc2e:	b2d2      	uxtb	r2, r2
    fc30:	f7ff ffbc 	bl	fbac <_ZN5Print11printNumberEmh>
  }
}
    fc34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000fc36 <_ZN5Print5printEii>:
{
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
    fc36:	b508      	push	{r3, lr}
  return print((long) n, base);
    fc38:	f7ff ffdf 	bl	fbfa <_ZN5Print5printEli>
}
    fc3c:	bd08      	pop	{r3, pc}

0000fc3e <_ZN5Print5printEmi>:
    return printNumber(n, base);
  }
}

size_t Print::print(unsigned long n, int base)
{
    fc3e:	b508      	push	{r3, lr}
  if (base == 0) return write(n);
    fc40:	2a00      	cmp	r2, #0
    fc42:	d102      	bne.n	fc4a <_ZN5Print5printEmi+0xc>
    fc44:	f7ff ff90 	bl	fb68 <_ZN5Print5printEmi.part.3>
    fc48:	e002      	b.n	fc50 <_ZN5Print5printEmi+0x12>
  else return printNumber(n, base);
    fc4a:	b2d2      	uxtb	r2, r2
    fc4c:	f7ff ffae 	bl	fbac <_ZN5Print11printNumberEmh>
}
    fc50:	bd08      	pop	{r3, pc}

0000fc52 <_ZN5Print5printEhi>:
{
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
    fc52:	b508      	push	{r3, lr}
  return print((unsigned long) b, base);
    fc54:	f7ff fff3 	bl	fc3e <_ZN5Print5printEmi>
}
    fc58:	bd08      	pop	{r3, pc}

0000fc5a <_ZN5Print7printlnEmi>:
  n += println();
  return n;
}

size_t Print::println(unsigned long num, int base)
{
    fc5a:	b538      	push	{r3, r4, r5, lr}
    fc5c:	1c04      	adds	r4, r0, #0
  size_t n = print(num, base);
    fc5e:	f7ff ffee 	bl	fc3e <_ZN5Print5printEmi>
    fc62:	1c05      	adds	r5, r0, #0
  n += println();
    fc64:	1c20      	adds	r0, r4, #0
    fc66:	f7ff ff8f 	bl	fb88 <_ZN5Print7printlnEv>
    fc6a:	1940      	adds	r0, r0, r5
  return n;
}
    fc6c:	bd38      	pop	{r3, r4, r5, pc}
	...

0000fc70 <initiateReset>:
}

static int ticks = -1;

void initiateReset(int _ticks) {
	ticks = _ticks;
    fc70:	4b01      	ldr	r3, [pc, #4]	; (fc78 <initiateReset+0x8>)
    fc72:	6018      	str	r0, [r3, #0]
}
    fc74:	4770      	bx	lr
    fc76:	46c0      	nop			; (mov r8, r8)
    fc78:	200000a8 	.word	0x200000a8

0000fc7c <cancelReset>:

void cancelReset() {
	ticks = -1;
    fc7c:	4b02      	ldr	r3, [pc, #8]	; (fc88 <cancelReset+0xc>)
    fc7e:	2201      	movs	r2, #1
    fc80:	4252      	negs	r2, r2
    fc82:	601a      	str	r2, [r3, #0]
}
    fc84:	4770      	bx	lr
    fc86:	46c0      	nop			; (mov r8, r8)
    fc88:	200000a8 	.word	0x200000a8

0000fc8c <tickReset>:

void tickReset() {
	if (ticks == -1)
    fc8c:	4a15      	ldr	r2, [pc, #84]	; (fce4 <tickReset+0x58>)
    fc8e:	6813      	ldr	r3, [r2, #0]
    fc90:	1c58      	adds	r0, r3, #1
    fc92:	d025      	beq.n	fce0 <tickReset+0x54>
		return;
	ticks--;
    fc94:	3b01      	subs	r3, #1
    fc96:	6013      	str	r3, [r2, #0]
	if (ticks == 0)
    fc98:	2b00      	cmp	r3, #0
    fc9a:	d121      	bne.n	fce0 <tickReset+0x54>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    fc9c:	b672      	cpsid	i
	__disable_irq();

	// Avoid erasing the application if APP_START is < than the minimum bootloader size
	// This could happen if without_bootloader linker script was chosen
	// Minimum bootloader size in SAMD21 family is 512bytes (RM section 22.6.5)
	if (APP_START < (0x400 + 4)) {
    fc9e:	4a12      	ldr	r2, [pc, #72]	; (fce8 <tickReset+0x5c>)
    fca0:	4b12      	ldr	r3, [pc, #72]	; (fcec <tickReset+0x60>)
    fca2:	3204      	adds	r2, #4
    fca4:	429a      	cmp	r2, r3
    fca6:	d807      	bhi.n	fcb8 <tickReset+0x2c>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    fca8:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                 SCB_AIRCR_SYSRESETREQ_Msk);
    fcac:	4a10      	ldr	r2, [pc, #64]	; (fcf0 <tickReset+0x64>)
    fcae:	4b11      	ldr	r3, [pc, #68]	; (fcf4 <tickReset+0x68>)
    fcb0:	60da      	str	r2, [r3, #12]
    fcb2:	f3bf 8f4f 	dsb	sy
    fcb6:	e011      	b.n	fcdc <tickReset+0x50>
#else
#define APP_START 0x00004004
#endif

static inline bool nvmReady(void) {
        return NVMCTRL->INTFLAG.reg & NVMCTRL_INTFLAG_READY;
    fcb8:	4b0f      	ldr	r3, [pc, #60]	; (fcf8 <tickReset+0x6c>)
    fcba:	7d19      	ldrb	r1, [r3, #20]
	if (APP_START < (0x400 + 4)) {
		goto reset;
	}

	// Erase application
	while (!nvmReady())
    fcbc:	07c8      	lsls	r0, r1, #31
    fcbe:	d5fb      	bpl.n	fcb8 <tickReset+0x2c>
		;
	NVMCTRL->STATUS.reg |= NVMCTRL_STATUS_MASK;
    fcc0:	8b18      	ldrh	r0, [r3, #24]
    fcc2:	2120      	movs	r1, #32
    fcc4:	31ff      	adds	r1, #255	; 0xff
	NVMCTRL->ADDR.reg  = (uintptr_t)&NVM_MEMORY[APP_START / 4];
    fcc6:	0892      	lsrs	r2, r2, #2
    fcc8:	0052      	lsls	r2, r2, #1
	}

	// Erase application
	while (!nvmReady())
		;
	NVMCTRL->STATUS.reg |= NVMCTRL_STATUS_MASK;
    fcca:	4301      	orrs	r1, r0
    fccc:	8319      	strh	r1, [r3, #24]
	NVMCTRL->ADDR.reg  = (uintptr_t)&NVM_MEMORY[APP_START / 4];
    fcce:	61da      	str	r2, [r3, #28]
	NVMCTRL->CTRLA.reg = NVMCTRL_CTRLA_CMD_ER | NVMCTRL_CTRLA_CMDEX_KEY;
    fcd0:	4a0a      	ldr	r2, [pc, #40]	; (fcfc <tickReset+0x70>)
    fcd2:	801a      	strh	r2, [r3, #0]
#else
#define APP_START 0x00004004
#endif

static inline bool nvmReady(void) {
        return NVMCTRL->INTFLAG.reg & NVMCTRL_INTFLAG_READY;
    fcd4:	7d1a      	ldrb	r2, [r3, #20]
	while (!nvmReady())
		;
	NVMCTRL->STATUS.reg |= NVMCTRL_STATUS_MASK;
	NVMCTRL->ADDR.reg  = (uintptr_t)&NVM_MEMORY[APP_START / 4];
	NVMCTRL->CTRLA.reg = NVMCTRL_CTRLA_CMD_ER | NVMCTRL_CTRLA_CMDEX_KEY;
	while (!nvmReady())
    fcd6:	07d1      	lsls	r1, r2, #31
    fcd8:	d5fc      	bpl.n	fcd4 <tickReset+0x48>
    fcda:	e7e5      	b.n	fca8 <tickReset+0x1c>
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
    fcdc:	46c0      	nop			; (mov r8, r8)
    fcde:	e7fd      	b.n	fcdc <tickReset+0x50>
	if (ticks == -1)
		return;
	ticks--;
	if (ticks == 0)
		banzai();
}
    fce0:	4770      	bx	lr
    fce2:	46c0      	nop			; (mov r8, r8)
    fce4:	200000a8 	.word	0x200000a8
    fce8:	00004000 	.word	0x00004000
    fcec:	00000403 	.word	0x00000403
    fcf0:	05fa0004 	.word	0x05fa0004
    fcf4:	e000ed00 	.word	0xe000ed00
    fcf8:	41004000 	.word	0x41004000
    fcfc:	ffffa502 	.word	0xffffa502

0000fd00 <_ZN6SERCOMC1EP6Sercom>:
#include "SERCOM.h"
#include "variant.h"

SERCOM::SERCOM(Sercom* s)
{
  sercom = s;
    fd00:	6001      	str	r1, [r0, #0]
}
    fd02:	4770      	bx	lr

0000fd04 <_ZN6SERCOM9initFrameE18SercomUartCharSize15SercomDataOrder16SercomParityMode19SercomNumberStopBit>:
    sercom->USART.BAUD.FRAC.FP   = (baudTimes8 % 8);
    sercom->USART.BAUD.FRAC.BAUD = (baudTimes8 / 8);
  }
}
void SERCOM::initFrame(SercomUartCharSize charSize, SercomDataOrder dataOrder, SercomParityMode parityMode, SercomNumberStopBit nbStopBits)
{
    fd04:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    fd06:	ac08      	add	r4, sp, #32
    fd08:	7826      	ldrb	r6, [r4, #0]
  //Setting the CTRLA register
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_FORM( (parityMode == SERCOM_NO_PARITY ? 0 : 1) ) |
                dataOrder << SERCOM_USART_CTRLA_DORD_Pos;
    fd0a:	6804      	ldr	r4, [r0, #0]
  }
}
void SERCOM::initFrame(SercomUartCharSize charSize, SercomDataOrder dataOrder, SercomParityMode parityMode, SercomNumberStopBit nbStopBits)
{
  //Setting the CTRLA register
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_FORM( (parityMode == SERCOM_NO_PARITY ? 0 : 1) ) |
    fd0c:	1e9d      	subs	r5, r3, #2
                dataOrder << SERCOM_USART_CTRLA_DORD_Pos;
    fd0e:	6827      	ldr	r7, [r4, #0]
  }
}
void SERCOM::initFrame(SercomUartCharSize charSize, SercomDataOrder dataOrder, SercomParityMode parityMode, SercomNumberStopBit nbStopBits)
{
  //Setting the CTRLA register
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_FORM( (parityMode == SERCOM_NO_PARITY ? 0 : 1) ) |
    fd10:	1e6c      	subs	r4, r5, #1
    fd12:	41a5      	sbcs	r5, r4
    fd14:	b2ec      	uxtb	r4, r5
                dataOrder << SERCOM_USART_CTRLA_DORD_Pos;
    fd16:	0792      	lsls	r2, r2, #30
    fd18:	6805      	ldr	r5, [r0, #0]
  }
}
void SERCOM::initFrame(SercomUartCharSize charSize, SercomDataOrder dataOrder, SercomParityMode parityMode, SercomNumberStopBit nbStopBits)
{
  //Setting the CTRLA register
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_FORM( (parityMode == SERCOM_NO_PARITY ? 0 : 1) ) |
    fd1a:	433a      	orrs	r2, r7
    fd1c:	0627      	lsls	r7, r4, #24
                dataOrder << SERCOM_USART_CTRLA_DORD_Pos;
    fd1e:	433a      	orrs	r2, r7
    fd20:	602a      	str	r2, [r5, #0]

  //Setting the CTRLB register
  sercom->USART.CTRLB.reg |=	SERCOM_USART_CTRLB_CHSIZE(charSize) |
                nbStopBits << SERCOM_USART_CTRLB_SBMODE_Pos |
                (parityMode == SERCOM_NO_PARITY ? 0 : parityMode) << SERCOM_USART_CTRLB_PMODE_Pos; //If no parity use default value
    fd22:	6802      	ldr	r2, [r0, #0]
  //Setting the CTRLA register
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_FORM( (parityMode == SERCOM_NO_PARITY ? 0 : 1) ) |
                dataOrder << SERCOM_USART_CTRLA_DORD_Pos;

  //Setting the CTRLB register
  sercom->USART.CTRLB.reg |=	SERCOM_USART_CTRLB_CHSIZE(charSize) |
    fd24:	2507      	movs	r5, #7
    fd26:	4029      	ands	r1, r5
                nbStopBits << SERCOM_USART_CTRLB_SBMODE_Pos |
                (parityMode == SERCOM_NO_PARITY ? 0 : parityMode) << SERCOM_USART_CTRLB_PMODE_Pos; //If no parity use default value
    fd28:	6850      	ldr	r0, [r2, #4]
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_FORM( (parityMode == SERCOM_NO_PARITY ? 0 : 1) ) |
                dataOrder << SERCOM_USART_CTRLA_DORD_Pos;

  //Setting the CTRLB register
  sercom->USART.CTRLB.reg |=	SERCOM_USART_CTRLB_CHSIZE(charSize) |
                nbStopBits << SERCOM_USART_CTRLB_SBMODE_Pos |
    fd2a:	01b5      	lsls	r5, r6, #6
    fd2c:	2c00      	cmp	r4, #0
    fd2e:	d000      	beq.n	fd32 <_ZN6SERCOM9initFrameE18SercomUartCharSize15SercomDataOrder16SercomParityMode19SercomNumberStopBit+0x2e>
    fd30:	035c      	lsls	r4, r3, #13
  //Setting the CTRLA register
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_FORM( (parityMode == SERCOM_NO_PARITY ? 0 : 1) ) |
                dataOrder << SERCOM_USART_CTRLA_DORD_Pos;

  //Setting the CTRLB register
  sercom->USART.CTRLB.reg |=	SERCOM_USART_CTRLB_CHSIZE(charSize) |
    fd32:	4329      	orrs	r1, r5
                nbStopBits << SERCOM_USART_CTRLB_SBMODE_Pos |
    fd34:	4301      	orrs	r1, r0
                (parityMode == SERCOM_NO_PARITY ? 0 : parityMode) << SERCOM_USART_CTRLB_PMODE_Pos; //If no parity use default value
    fd36:	430c      	orrs	r4, r1
    fd38:	6054      	str	r4, [r2, #4]
}
    fd3a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

0000fd3c <_ZN6SERCOM8initPadsE15SercomUartTXPad11SercomRXPad>:

void SERCOM::initPads(SercomUartTXPad txPad, SercomRXPad rxPad)
{
    fd3c:	b530      	push	{r4, r5, lr}
  //Setting the CTRLA register
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_TXPO(txPad) |
                SERCOM_USART_CTRLA_RXPO(rxPad);
    fd3e:	6803      	ldr	r3, [r0, #0]
    fd40:	25c0      	movs	r5, #192	; 0xc0
    fd42:	681c      	ldr	r4, [r3, #0]
    fd44:	03ad      	lsls	r5, r5, #14
    fd46:	0512      	lsls	r2, r2, #20
    fd48:	402a      	ands	r2, r5
}

void SERCOM::initPads(SercomUartTXPad txPad, SercomRXPad rxPad)
{
  //Setting the CTRLA register
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_TXPO(txPad) |
    fd4a:	4322      	orrs	r2, r4
    fd4c:	24c0      	movs	r4, #192	; 0xc0
    fd4e:	02a4      	lsls	r4, r4, #10
    fd50:	0409      	lsls	r1, r1, #16
    fd52:	4021      	ands	r1, r4
                SERCOM_USART_CTRLA_RXPO(rxPad);
    fd54:	4311      	orrs	r1, r2
    fd56:	6019      	str	r1, [r3, #0]

  // Enable Transceiver and Receiver
  sercom->USART.CTRLB.reg |= SERCOM_USART_CTRLB_TXEN | SERCOM_USART_CTRLB_RXEN ;
    fd58:	6803      	ldr	r3, [r0, #0]
    fd5a:	685a      	ldr	r2, [r3, #4]
    fd5c:	4314      	orrs	r4, r2
    fd5e:	605c      	str	r4, [r3, #4]
}
    fd60:	bd30      	pop	{r4, r5, pc}

0000fd62 <_ZN6SERCOM9resetUARTEv>:

void SERCOM::resetUART()
{
  // Start the Software Reset
  sercom->USART.CTRLA.bit.SWRST = 1 ;
    fd62:	6803      	ldr	r3, [r0, #0]
    fd64:	2101      	movs	r1, #1
    fd66:	681a      	ldr	r2, [r3, #0]
    fd68:	430a      	orrs	r2, r1
    fd6a:	601a      	str	r2, [r3, #0]

  while ( sercom->USART.CTRLA.bit.SWRST || sercom->USART.SYNCBUSY.bit.SWRST )
    fd6c:	6802      	ldr	r2, [r0, #0]
    fd6e:	6811      	ldr	r1, [r2, #0]
    fd70:	2301      	movs	r3, #1
    fd72:	4219      	tst	r1, r3
    fd74:	d1fb      	bne.n	fd6e <_ZN6SERCOM9resetUARTEv+0xc>
    fd76:	69d1      	ldr	r1, [r2, #28]
    fd78:	4219      	tst	r1, r3
    fd7a:	d1f8      	bne.n	fd6e <_ZN6SERCOM9resetUARTEv+0xc>
  {
    // Wait for both bits Software Reset from CTRLA and SYNCBUSY coming back to 0
  }
}
    fd7c:	4770      	bx	lr

0000fd7e <_ZN6SERCOM10enableUARTEv>:

void SERCOM::enableUART()
{
  //Setting  the enable bit to 1
  sercom->USART.CTRLA.bit.ENABLE = 0x1u;
    fd7e:	6803      	ldr	r3, [r0, #0]
    fd80:	2102      	movs	r1, #2
    fd82:	681a      	ldr	r2, [r3, #0]
    fd84:	430a      	orrs	r2, r1
    fd86:	601a      	str	r2, [r3, #0]

  //Wait for then enable bit from SYNCBUSY is equal to 0;
  while(sercom->USART.SYNCBUSY.bit.ENABLE);
    fd88:	6802      	ldr	r2, [r0, #0]
    fd8a:	69d3      	ldr	r3, [r2, #28]
    fd8c:	0799      	lsls	r1, r3, #30
    fd8e:	d4fc      	bmi.n	fd8a <_ZN6SERCOM10enableUARTEv+0xc>
}
    fd90:	4770      	bx	lr

0000fd92 <_ZN6SERCOM9flushUARTEv>:
}

bool SERCOM::isDataRegisterEmptyUART()
{
  //DRE : Data Register Empty
  return sercom->USART.INTFLAG.bit.DRE;
    fd92:	6803      	ldr	r3, [r0, #0]
    fd94:	7e1a      	ldrb	r2, [r3, #24]
}

void SERCOM::flushUART()
{
  // Skip checking transmission completion if data register is empty
  if(isDataRegisterEmptyUART())
    fd96:	07d1      	lsls	r1, r2, #31
    fd98:	d402      	bmi.n	fda0 <_ZN6SERCOM9flushUARTEv+0xe>
    return;

  // Wait for transmission to complete
  while(!sercom->USART.INTFLAG.bit.TXC);
    fd9a:	7e1a      	ldrb	r2, [r3, #24]
    fd9c:	0791      	lsls	r1, r2, #30
    fd9e:	d5fc      	bpl.n	fd9a <_ZN6SERCOM9flushUARTEv+0x8>
}
    fda0:	4770      	bx	lr

0000fda2 <_ZN6SERCOM15clearStatusUARTEv>:

void SERCOM::clearStatusUART()
{
  //Reset (with 0) the STATUS register
  sercom->USART.STATUS.reg = SERCOM_USART_STATUS_RESETVALUE;
    fda2:	6803      	ldr	r3, [r0, #0]
    fda4:	2200      	movs	r2, #0
    fda6:	835a      	strh	r2, [r3, #26]
}
    fda8:	4770      	bx	lr

0000fdaa <_ZN6SERCOM17availableDataUARTEv>:

bool SERCOM::availableDataUART()
{
  //RXC : Receive Complete
  return sercom->USART.INTFLAG.bit.RXC;
    fdaa:	6803      	ldr	r3, [r0, #0]
    fdac:	7e18      	ldrb	r0, [r3, #24]
    fdae:	0740      	lsls	r0, r0, #29
    fdb0:	0fc0      	lsrs	r0, r0, #31
}
    fdb2:	4770      	bx	lr

0000fdb4 <_ZN6SERCOM11isUARTErrorEv>:

bool SERCOM::isUARTError()
{
  return sercom->USART.INTFLAG.bit.ERROR;
    fdb4:	6803      	ldr	r3, [r0, #0]
    fdb6:	7e18      	ldrb	r0, [r3, #24]
    fdb8:	09c0      	lsrs	r0, r0, #7
}
    fdba:	4770      	bx	lr

0000fdbc <_ZN6SERCOM20acknowledgeUARTErrorEv>:

void SERCOM::acknowledgeUARTError()
{
  sercom->USART.INTFLAG.bit.ERROR = 1;
    fdbc:	6803      	ldr	r3, [r0, #0]
    fdbe:	2280      	movs	r2, #128	; 0x80
    fdc0:	7e19      	ldrb	r1, [r3, #24]
    fdc2:	4252      	negs	r2, r2
    fdc4:	430a      	orrs	r2, r1
    fdc6:	761a      	strb	r2, [r3, #24]
}
    fdc8:	4770      	bx	lr

0000fdca <_ZN6SERCOM12readDataUARTEv>:
  return sercom->USART.INTFLAG.bit.DRE;
}

uint8_t SERCOM::readDataUART()
{
  return sercom->USART.DATA.bit.DATA;
    fdca:	6803      	ldr	r3, [r0, #0]
    fdcc:	8d18      	ldrh	r0, [r3, #40]	; 0x28
    fdce:	b2c0      	uxtb	r0, r0
}
    fdd0:	4770      	bx	lr

0000fdd2 <_ZN6SERCOM13writeDataUARTEh>:
}

bool SERCOM::isDataRegisterEmptyUART()
{
  //DRE : Data Register Empty
  return sercom->USART.INTFLAG.bit.DRE;
    fdd2:	6803      	ldr	r3, [r0, #0]
    fdd4:	7e1a      	ldrb	r2, [r3, #24]
    fdd6:	2001      	movs	r0, #1
}

int SERCOM::writeDataUART(uint8_t data)
{
  // Wait for data register to be empty
  while(!isDataRegisterEmptyUART());
    fdd8:	4202      	tst	r2, r0
    fdda:	d0fb      	beq.n	fdd4 <_ZN6SERCOM13writeDataUARTEh+0x2>

  //Put data into DATA register
  sercom->USART.DATA.reg = (uint16_t)data;
    fddc:	8519      	strh	r1, [r3, #40]	; 0x28
  return 1;
}
    fdde:	4770      	bx	lr

0000fde0 <_ZN6SERCOM12initSPIClockE18SercomSpiClockModem>:


}

void SERCOM::initSPIClock(SercomSpiClockMode clockMode, uint32_t baudrate)
{
    fde0:	b570      	push	{r4, r5, r6, lr}
  else
    cpol = 1;

  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg |=	( cpha << SERCOM_SPI_CTRLA_CPHA_Pos ) |
                            ( cpol << SERCOM_SPI_CTRLA_CPOL_Pos );
    fde2:	6803      	ldr	r3, [r0, #0]
{
  //Extract data from clockMode
  int cpha, cpol;

  if((clockMode & (0x1ul)) == 0 )
    cpha = 0;
    fde4:	2601      	movs	r6, #1
  else
    cpha = 1;

  if((clockMode & (0x2ul)) == 0)
    fde6:	078d      	lsls	r5, r1, #30
    fde8:	0fed      	lsrs	r5, r5, #31
{
  //Extract data from clockMode
  int cpha, cpol;

  if((clockMode & (0x1ul)) == 0 )
    cpha = 0;
    fdea:	4031      	ands	r1, r6
  else
    cpol = 1;

  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg |=	( cpha << SERCOM_SPI_CTRLA_CPHA_Pos ) |
                            ( cpol << SERCOM_SPI_CTRLA_CPOL_Pos );
    fdec:	681c      	ldr	r4, [r3, #0]
    fdee:	076d      	lsls	r5, r5, #29
    cpol = 0;
  else
    cpol = 1;

  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg |=	( cpha << SERCOM_SPI_CTRLA_CPHA_Pos ) |
    fdf0:	0709      	lsls	r1, r1, #28
    fdf2:	4329      	orrs	r1, r5
                            ( cpol << SERCOM_SPI_CTRLA_CPOL_Pos );
    fdf4:	4321      	orrs	r1, r4
    fdf6:	6019      	str	r1, [r3, #0]

  //Synchronous arithmetic
  sercom->SPI.BAUD.reg = calculateBaudrateSynchronous(baudrate);
    fdf8:	6804      	ldr	r4, [r0, #0]
//	return sercom->SPI.INTFLAG.bit.RXC;
//}

uint8_t SERCOM::calculateBaudrateSynchronous(uint32_t baudrate)
{
  return SERCOM_FREQ_REF / (2 * baudrate) - 1;
    fdfa:	0051      	lsls	r1, r2, #1
    fdfc:	4803      	ldr	r0, [pc, #12]	; (fe0c <_ZN6SERCOM12initSPIClockE18SercomSpiClockModem+0x2c>)
    fdfe:	f001 facb 	bl	11398 <__aeabi_uidiv>
    fe02:	3801      	subs	r0, #1
    fe04:	b2c0      	uxtb	r0, r0
  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg |=	( cpha << SERCOM_SPI_CTRLA_CPHA_Pos ) |
                            ( cpol << SERCOM_SPI_CTRLA_CPOL_Pos );

  //Synchronous arithmetic
  sercom->SPI.BAUD.reg = calculateBaudrateSynchronous(baudrate);
    fe06:	7320      	strb	r0, [r4, #12]
}
    fe08:	bd70      	pop	{r4, r5, r6, pc}
    fe0a:	46c0      	nop			; (mov r8, r8)
    fe0c:	02dc6c00 	.word	0x02dc6c00

0000fe10 <_ZN6SERCOM8resetSPIEv>:

void SERCOM::resetSPI()
{
  //Setting the Software Reset bit to 1
  sercom->SPI.CTRLA.bit.SWRST = 1;
    fe10:	6803      	ldr	r3, [r0, #0]
    fe12:	2101      	movs	r1, #1
    fe14:	681a      	ldr	r2, [r3, #0]
    fe16:	430a      	orrs	r2, r1
    fe18:	601a      	str	r2, [r3, #0]

  //Wait both bits Software Reset from CTRLA and SYNCBUSY are equal to 0
  while(sercom->SPI.CTRLA.bit.SWRST || sercom->SPI.SYNCBUSY.bit.SWRST);
    fe1a:	6802      	ldr	r2, [r0, #0]
    fe1c:	6811      	ldr	r1, [r2, #0]
    fe1e:	2301      	movs	r3, #1
    fe20:	4219      	tst	r1, r3
    fe22:	d1fb      	bne.n	fe1c <_ZN6SERCOM8resetSPIEv+0xc>
    fe24:	69d1      	ldr	r1, [r2, #28]
    fe26:	4219      	tst	r1, r3
    fe28:	d1f8      	bne.n	fe1c <_ZN6SERCOM8resetSPIEv+0xc>
}
    fe2a:	4770      	bx	lr

0000fe2c <_ZN6SERCOM9enableSPIEv>:

void SERCOM::enableSPI()
{
  //Setting the enable bit to 1
  sercom->SPI.CTRLA.bit.ENABLE = 1;
    fe2c:	6803      	ldr	r3, [r0, #0]
    fe2e:	2102      	movs	r1, #2
    fe30:	681a      	ldr	r2, [r3, #0]
    fe32:	430a      	orrs	r2, r1
    fe34:	601a      	str	r2, [r3, #0]

  while(sercom->SPI.SYNCBUSY.bit.ENABLE)
    fe36:	6802      	ldr	r2, [r0, #0]
    fe38:	69d3      	ldr	r3, [r2, #28]
    fe3a:	0799      	lsls	r1, r3, #30
    fe3c:	d4fc      	bmi.n	fe38 <_ZN6SERCOM9enableSPIEv+0xc>
  {
    //Waiting then enable bit from SYNCBUSY is equal to 0;
  }
}
    fe3e:	4770      	bx	lr

0000fe40 <_ZN6SERCOM10disableSPIEv>:

void SERCOM::disableSPI()
{
  while(sercom->SPI.SYNCBUSY.bit.ENABLE)
    fe40:	6803      	ldr	r3, [r0, #0]
    fe42:	69da      	ldr	r2, [r3, #28]
    fe44:	0791      	lsls	r1, r2, #30
    fe46:	d4fc      	bmi.n	fe42 <_ZN6SERCOM10disableSPIEv+0x2>
  {
    //Waiting then enable bit from SYNCBUSY is equal to 0;
  }

  //Setting the enable bit to 0
  sercom->SPI.CTRLA.bit.ENABLE = 0;
    fe48:	681a      	ldr	r2, [r3, #0]
    fe4a:	2102      	movs	r1, #2
    fe4c:	438a      	bics	r2, r1
    fe4e:	601a      	str	r2, [r3, #0]
}
    fe50:	4770      	bx	lr
	...

0000fe54 <_ZN6SERCOM14setBaudrateSPIEh>:
{
  return (sercom->SPI.CTRLA.bit.DORD ? LSB_FIRST : MSB_FIRST);
}

void SERCOM::setBaudrateSPI(uint8_t divider)
{
    fe54:	b570      	push	{r4, r5, r6, lr}
    fe56:	1c04      	adds	r4, r0, #0
    fe58:	1e0d      	subs	r5, r1, #0
  //Can't divide by 0
  if(divider == 0)
    fe5a:	d010      	beq.n	fe7e <_ZN6SERCOM14setBaudrateSPIEh+0x2a>
    return;

  //Register enable-protected
  disableSPI();
    fe5c:	f7ff fff0 	bl	fe40 <_ZN6SERCOM10disableSPIEv>

  sercom->SPI.BAUD.reg = calculateBaudrateSynchronous( SERCOM_FREQ_REF / divider );
    fe60:	1c29      	adds	r1, r5, #0
    fe62:	4807      	ldr	r0, [pc, #28]	; (fe80 <_ZN6SERCOM14setBaudrateSPIEh+0x2c>)
    fe64:	f001 fae6 	bl	11434 <__aeabi_idiv>
//	return sercom->SPI.INTFLAG.bit.RXC;
//}

uint8_t SERCOM::calculateBaudrateSynchronous(uint32_t baudrate)
{
  return SERCOM_FREQ_REF / (2 * baudrate) - 1;
    fe68:	0041      	lsls	r1, r0, #1
    fe6a:	4805      	ldr	r0, [pc, #20]	; (fe80 <_ZN6SERCOM14setBaudrateSPIEh+0x2c>)
    fe6c:	f001 fa94 	bl	11398 <__aeabi_uidiv>
    return;

  //Register enable-protected
  disableSPI();

  sercom->SPI.BAUD.reg = calculateBaudrateSynchronous( SERCOM_FREQ_REF / divider );
    fe70:	6826      	ldr	r6, [r4, #0]
//	return sercom->SPI.INTFLAG.bit.RXC;
//}

uint8_t SERCOM::calculateBaudrateSynchronous(uint32_t baudrate)
{
  return SERCOM_FREQ_REF / (2 * baudrate) - 1;
    fe72:	3801      	subs	r0, #1
    fe74:	b2c0      	uxtb	r0, r0
    return;

  //Register enable-protected
  disableSPI();

  sercom->SPI.BAUD.reg = calculateBaudrateSynchronous( SERCOM_FREQ_REF / divider );
    fe76:	7330      	strb	r0, [r6, #12]

  enableSPI();
    fe78:	1c20      	adds	r0, r4, #0
    fe7a:	f7ff ffd7 	bl	fe2c <_ZN6SERCOM9enableSPIEv>
}
    fe7e:	bd70      	pop	{r4, r5, r6, pc}
    fe80:	02dc6c00 	.word	0x02dc6c00

0000fe84 <_ZN6SERCOM15transferDataSPIEh>:
  enableSPI();
}

uint8_t SERCOM::transferDataSPI(uint8_t data)
{
  sercom->SPI.DATA.bit.DATA = data; // Writing data into Data register
    fe84:	6803      	ldr	r3, [r0, #0]
    fe86:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    fe88:	0a52      	lsrs	r2, r2, #9
    fe8a:	0252      	lsls	r2, r2, #9
    fe8c:	4311      	orrs	r1, r2
    fe8e:	6299      	str	r1, [r3, #40]	; 0x28

  while( sercom->SPI.INTFLAG.bit.RXC == 0 )
    fe90:	6803      	ldr	r3, [r0, #0]
    fe92:	7e1a      	ldrb	r2, [r3, #24]
    fe94:	0751      	lsls	r1, r2, #29
    fe96:	d5fc      	bpl.n	fe92 <_ZN6SERCOM15transferDataSPIEh+0xe>
  {
    // Waiting Complete Reception
  }

  return sercom->SPI.DATA.bit.DATA;  // Reading data
    fe98:	6a98      	ldr	r0, [r3, #40]	; 0x28
    fe9a:	b2c0      	uxtb	r0, r0
}
    fe9c:	4770      	bx	lr
	...

0000fea0 <_ZN6SERCOM13initClockNVICEv>:
void SERCOM::initClockNVIC( void )
{
  uint8_t clockId = 0;
  IRQn_Type IdNvic=PendSV_IRQn ; // Dummy init to intercept potential error later

  if(sercom == SERCOM0)
    fea0:	6803      	ldr	r3, [r0, #0]
    fea2:	4a22      	ldr	r2, [pc, #136]	; (ff2c <_ZN6SERCOM13initClockNVICEv+0x8c>)
  }
}


void SERCOM::initClockNVIC( void )
{
    fea4:	b530      	push	{r4, r5, lr}
  uint8_t clockId = 0;
  IRQn_Type IdNvic=PendSV_IRQn ; // Dummy init to intercept potential error later

  if(sercom == SERCOM0)
    fea6:	4293      	cmp	r3, r2
    fea8:	d011      	beq.n	fece <_ZN6SERCOM13initClockNVICEv+0x2e>
  {
    clockId = GCM_SERCOM0_CORE;
    IdNvic = SERCOM0_IRQn;
  }
  else if(sercom == SERCOM1)
    feaa:	4a21      	ldr	r2, [pc, #132]	; (ff30 <_ZN6SERCOM13initClockNVICEv+0x90>)
    feac:	4293      	cmp	r3, r2
    feae:	d011      	beq.n	fed4 <_ZN6SERCOM13initClockNVICEv+0x34>
  {
    clockId = GCM_SERCOM1_CORE;
    IdNvic = SERCOM1_IRQn;
  }
  else if(sercom == SERCOM2)
    feb0:	4a20      	ldr	r2, [pc, #128]	; (ff34 <_ZN6SERCOM13initClockNVICEv+0x94>)
    feb2:	4293      	cmp	r3, r2
    feb4:	d011      	beq.n	feda <_ZN6SERCOM13initClockNVICEv+0x3a>
  {
    clockId = GCM_SERCOM2_CORE;
    IdNvic = SERCOM2_IRQn;
  }
  else if(sercom == SERCOM3)
    feb6:	4a20      	ldr	r2, [pc, #128]	; (ff38 <_ZN6SERCOM13initClockNVICEv+0x98>)
    feb8:	4293      	cmp	r3, r2
    feba:	d011      	beq.n	fee0 <_ZN6SERCOM13initClockNVICEv+0x40>
  {
    clockId = GCM_SERCOM3_CORE;
    IdNvic = SERCOM3_IRQn;
  }
  else if(sercom == SERCOM4)
    febc:	4a1f      	ldr	r2, [pc, #124]	; (ff3c <_ZN6SERCOM13initClockNVICEv+0x9c>)
    febe:	4293      	cmp	r3, r2
    fec0:	d011      	beq.n	fee6 <_ZN6SERCOM13initClockNVICEv+0x46>
  {
    clockId = GCM_SERCOM4_CORE;
    IdNvic = SERCOM4_IRQn;
  }
  else if(sercom == SERCOM5)
    fec2:	4a1f      	ldr	r2, [pc, #124]	; (ff40 <_ZN6SERCOM13initClockNVICEv+0xa0>)
    fec4:	4293      	cmp	r3, r2
    fec6:	d130      	bne.n	ff2a <_ZN6SERCOM13initClockNVICEv+0x8a>
  {
    clockId = GCM_SERCOM5_CORE;
    IdNvic = SERCOM5_IRQn;
    fec8:	230e      	movs	r3, #14
    clockId = GCM_SERCOM4_CORE;
    IdNvic = SERCOM4_IRQn;
  }
  else if(sercom == SERCOM5)
  {
    clockId = GCM_SERCOM5_CORE;
    feca:	2219      	movs	r2, #25
    fecc:	e00d      	b.n	feea <_ZN6SERCOM13initClockNVICEv+0x4a>
  IRQn_Type IdNvic=PendSV_IRQn ; // Dummy init to intercept potential error later

  if(sercom == SERCOM0)
  {
    clockId = GCM_SERCOM0_CORE;
    IdNvic = SERCOM0_IRQn;
    fece:	2309      	movs	r3, #9
  uint8_t clockId = 0;
  IRQn_Type IdNvic=PendSV_IRQn ; // Dummy init to intercept potential error later

  if(sercom == SERCOM0)
  {
    clockId = GCM_SERCOM0_CORE;
    fed0:	2214      	movs	r2, #20
    fed2:	e00a      	b.n	feea <_ZN6SERCOM13initClockNVICEv+0x4a>
    IdNvic = SERCOM0_IRQn;
  }
  else if(sercom == SERCOM1)
  {
    clockId = GCM_SERCOM1_CORE;
    IdNvic = SERCOM1_IRQn;
    fed4:	230a      	movs	r3, #10
    clockId = GCM_SERCOM0_CORE;
    IdNvic = SERCOM0_IRQn;
  }
  else if(sercom == SERCOM1)
  {
    clockId = GCM_SERCOM1_CORE;
    fed6:	2215      	movs	r2, #21
    fed8:	e007      	b.n	feea <_ZN6SERCOM13initClockNVICEv+0x4a>
    IdNvic = SERCOM1_IRQn;
  }
  else if(sercom == SERCOM2)
  {
    clockId = GCM_SERCOM2_CORE;
    IdNvic = SERCOM2_IRQn;
    feda:	230b      	movs	r3, #11
    clockId = GCM_SERCOM1_CORE;
    IdNvic = SERCOM1_IRQn;
  }
  else if(sercom == SERCOM2)
  {
    clockId = GCM_SERCOM2_CORE;
    fedc:	2216      	movs	r2, #22
    fede:	e004      	b.n	feea <_ZN6SERCOM13initClockNVICEv+0x4a>
    IdNvic = SERCOM2_IRQn;
  }
  else if(sercom == SERCOM3)
  {
    clockId = GCM_SERCOM3_CORE;
    IdNvic = SERCOM3_IRQn;
    fee0:	230c      	movs	r3, #12
    clockId = GCM_SERCOM2_CORE;
    IdNvic = SERCOM2_IRQn;
  }
  else if(sercom == SERCOM3)
  {
    clockId = GCM_SERCOM3_CORE;
    fee2:	2217      	movs	r2, #23
    fee4:	e001      	b.n	feea <_ZN6SERCOM13initClockNVICEv+0x4a>
    IdNvic = SERCOM3_IRQn;
  }
  else if(sercom == SERCOM4)
  {
    clockId = GCM_SERCOM4_CORE;
    IdNvic = SERCOM4_IRQn;
    fee6:	230d      	movs	r3, #13
    clockId = GCM_SERCOM3_CORE;
    IdNvic = SERCOM3_IRQn;
  }
  else if(sercom == SERCOM4)
  {
    clockId = GCM_SERCOM4_CORE;
    fee8:	2218      	movs	r2, #24
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    feea:	b2dc      	uxtb	r4, r3
    feec:	4915      	ldr	r1, [pc, #84]	; (ff44 <_ZN6SERCOM13initClockNVICEv+0xa4>)
    feee:	2001      	movs	r0, #1
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    fef0:	089b      	lsrs	r3, r3, #2
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    fef2:	40a0      	lsls	r0, r4
    fef4:	009b      	lsls	r3, r3, #2
    fef6:	6008      	str	r0, [r1, #0]
    fef8:	185b      	adds	r3, r3, r1
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    fefa:	2003      	movs	r0, #3
    fefc:	21c0      	movs	r1, #192	; 0xc0
    fefe:	0089      	lsls	r1, r1, #2
    ff00:	4004      	ands	r4, r0
    ff02:	585d      	ldr	r5, [r3, r1]
    ff04:	00e0      	lsls	r0, r4, #3
    ff06:	24ff      	movs	r4, #255	; 0xff
    ff08:	4084      	lsls	r4, r0
    ff0a:	43a5      	bics	r5, r4
    ff0c:	1c2c      	adds	r4, r5, #0
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
    ff0e:	25c0      	movs	r5, #192	; 0xc0
    ff10:	4085      	lsls	r5, r0
    ff12:	1c28      	adds	r0, r5, #0
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    ff14:	4320      	orrs	r0, r4
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
    ff16:	5058      	str	r0, [r3, r1]
  NVIC_SetPriority (IdNvic, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority */

  //Setting clock
  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID( clockId ) | // Generic Clock 0 (SERCOMx)
                      GCLK_CLKCTRL_GEN_GCLK0 | // Generic Clock Generator 0 is source
                      GCLK_CLKCTRL_CLKEN ;
    ff18:	2380      	movs	r3, #128	; 0x80
    ff1a:	01db      	lsls	r3, r3, #7
    ff1c:	431a      	orrs	r2, r3
    ff1e:	4b0a      	ldr	r3, [pc, #40]	; (ff48 <_ZN6SERCOM13initClockNVICEv+0xa8>)
    ff20:	805a      	strh	r2, [r3, #2]

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
    ff22:	785a      	ldrb	r2, [r3, #1]
    ff24:	b252      	sxtb	r2, r2
    ff26:	2a00      	cmp	r2, #0
    ff28:	dbfb      	blt.n	ff22 <_ZN6SERCOM13initClockNVICEv+0x82>
  {
    /* Wait for synchronization */
  }
}
    ff2a:	bd30      	pop	{r4, r5, pc}
    ff2c:	42000800 	.word	0x42000800
    ff30:	42000c00 	.word	0x42000c00
    ff34:	42001000 	.word	0x42001000
    ff38:	42001400 	.word	0x42001400
    ff3c:	42001800 	.word	0x42001800
    ff40:	42001c00 	.word	0x42001c00
    ff44:	e000e100 	.word	0xe000e100
    ff48:	40000c00 	.word	0x40000c00

0000ff4c <_ZN6SERCOM8initUARTE14SercomUartMode20SercomUartSampleRatem>:
/* 	=========================
 *	===== Sercom UART
 *	=========================
*/
void SERCOM::initUART(SercomUartMode mode, SercomUartSampleRate sampleRate, uint32_t baudrate)
{
    ff4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ff4e:	1c04      	adds	r4, r0, #0
    ff50:	1c15      	adds	r5, r2, #0
    ff52:	1c0e      	adds	r6, r1, #0
    ff54:	1c1f      	adds	r7, r3, #0
  initClockNVIC();
    ff56:	f7ff ffa3 	bl	fea0 <_ZN6SERCOM13initClockNVICEv>
  resetUART();
    ff5a:	1c20      	adds	r0, r4, #0
    ff5c:	f7ff ff01 	bl	fd62 <_ZN6SERCOM9resetUARTEv>

  //Setting the CTRLA register
  sercom->USART.CTRLA.reg =	SERCOM_USART_CTRLA_MODE(mode) |
    ff60:	00b1      	lsls	r1, r6, #2
    ff62:	221c      	movs	r2, #28
    ff64:	400a      	ands	r2, r1
                SERCOM_USART_CTRLA_SAMPR(sampleRate);
    ff66:	0769      	lsls	r1, r5, #29
    ff68:	6823      	ldr	r3, [r4, #0]
    ff6a:	0c09      	lsrs	r1, r1, #16
{
  initClockNVIC();
  resetUART();

  //Setting the CTRLA register
  sercom->USART.CTRLA.reg =	SERCOM_USART_CTRLA_MODE(mode) |
    ff6c:	430a      	orrs	r2, r1
                SERCOM_USART_CTRLA_SAMPR(sampleRate);
    ff6e:	601a      	str	r2, [r3, #0]

  //Setting the Interrupt register
  sercom->USART.INTENSET.reg =	SERCOM_USART_INTENSET_RXC |  //Received complete
                                SERCOM_USART_INTENSET_ERROR; //All others errors
    ff70:	6822      	ldr	r2, [r4, #0]
    ff72:	2384      	movs	r3, #132	; 0x84
    ff74:	7593      	strb	r3, [r2, #22]

  if ( mode == UART_INT_CLOCK )
    ff76:	2e01      	cmp	r6, #1
    ff78:	d11a      	bne.n	ffb0 <_ZN6SERCOM8initUARTE14SercomUartMode20SercomUartSampleRatem+0x64>
    uint16_t sampleRateValue;

    if (sampleRate == SAMPLE_RATE_x16) {
      sampleRateValue = 16;
    } else {
      sampleRateValue = 8;
    ff7a:	2108      	movs	r1, #8

  if ( mode == UART_INT_CLOCK )
  {
    uint16_t sampleRateValue;

    if (sampleRate == SAMPLE_RATE_x16) {
    ff7c:	2d01      	cmp	r5, #1
    ff7e:	d100      	bne.n	ff82 <_ZN6SERCOM8initUARTE14SercomUartMode20SercomUartSampleRatem+0x36>
      sampleRateValue = 16;
    ff80:	2110      	movs	r1, #16
    }

    // Asynchronous fractional mode (Table 24-2 in datasheet)
    //   BAUD = fref / (sampleRateValue * fbaud)
    // (multiply by 8, to calculate fractional piece)
    uint32_t baudTimes8 = (SystemCoreClock * 8) / (sampleRateValue * baudrate);
    ff82:	4b0c      	ldr	r3, [pc, #48]	; (ffb4 <_ZN6SERCOM8initUARTE14SercomUartMode20SercomUartSampleRatem+0x68>)
    ff84:	4379      	muls	r1, r7
    ff86:	6818      	ldr	r0, [r3, #0]
    ff88:	00c0      	lsls	r0, r0, #3
    ff8a:	f001 fa05 	bl	11398 <__aeabi_uidiv>

    sercom->USART.BAUD.FRAC.FP   = (baudTimes8 % 8);
    ff8e:	6823      	ldr	r3, [r4, #0]
    ff90:	2107      	movs	r1, #7
    ff92:	899a      	ldrh	r2, [r3, #12]
    ff94:	4001      	ands	r1, r0
    ff96:	04d2      	lsls	r2, r2, #19
    ff98:	0349      	lsls	r1, r1, #13
    ff9a:	0cd2      	lsrs	r2, r2, #19
    ff9c:	430a      	orrs	r2, r1
    ff9e:	819a      	strh	r2, [r3, #12]
    sercom->USART.BAUD.FRAC.BAUD = (baudTimes8 / 8);
    ffa0:	6823      	ldr	r3, [r4, #0]
    ffa2:	0400      	lsls	r0, r0, #16
    ffa4:	0cc2      	lsrs	r2, r0, #19
    ffa6:	8998      	ldrh	r0, [r3, #12]
    ffa8:	0b40      	lsrs	r0, r0, #13
    ffaa:	0340      	lsls	r0, r0, #13
    ffac:	4310      	orrs	r0, r2
    ffae:	8198      	strh	r0, [r3, #12]
  }
}
    ffb0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ffb2:	46c0      	nop			; (mov r8, r8)
    ffb4:	20000098 	.word	0x20000098

0000ffb8 <_ZN6SERCOM7initSPIE14SercomSpiTXPad11SercomRXPad17SercomSpiCharSize15SercomDataOrder>:
/*	=========================
 *	===== Sercom SPI
 *	=========================
*/
void SERCOM::initSPI(SercomSpiTXPad mosi, SercomRXPad miso, SercomSpiCharSize charSize, SercomDataOrder dataOrder)
{
    ffb8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    ffba:	9301      	str	r3, [sp, #4]
    ffbc:	ab08      	add	r3, sp, #32
    ffbe:	1c04      	adds	r4, r0, #0
    ffc0:	781f      	ldrb	r7, [r3, #0]
    ffc2:	1c0d      	adds	r5, r1, #0
    ffc4:	1c16      	adds	r6, r2, #0
  resetSPI();
    ffc6:	f7ff ff23 	bl	fe10 <_ZN6SERCOM8resetSPIEv>
  initClockNVIC();
    ffca:	1c20      	adds	r0, r4, #0
    ffcc:	f7ff ff68 	bl	fea0 <_ZN6SERCOM13initClockNVICEv>

  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg =	SERCOM_SPI_CTRLA_MODE_SPI_MASTER |
                          SERCOM_SPI_CTRLA_DOPO(mosi) |
                          SERCOM_SPI_CTRLA_DIPO(miso) |
                          dataOrder << SERCOM_SPI_CTRLA_DORD_Pos;
    ffd0:	07bf      	lsls	r7, r7, #30
  initClockNVIC();

  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg =	SERCOM_SPI_CTRLA_MODE_SPI_MASTER |
                          SERCOM_SPI_CTRLA_DOPO(mosi) |
                          SERCOM_SPI_CTRLA_DIPO(miso) |
    ffd2:	220c      	movs	r2, #12
    ffd4:	4317      	orrs	r7, r2
    ffd6:	22c0      	movs	r2, #192	; 0xc0
    ffd8:	0392      	lsls	r2, r2, #14
    ffda:	0536      	lsls	r6, r6, #20
    ffdc:	4016      	ands	r6, r2
  resetSPI();
  initClockNVIC();

  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg =	SERCOM_SPI_CTRLA_MODE_SPI_MASTER |
                          SERCOM_SPI_CTRLA_DOPO(mosi) |
    ffde:	22c0      	movs	r2, #192	; 0xc0
    ffe0:	0292      	lsls	r2, r2, #10
    ffe2:	042d      	lsls	r5, r5, #16
                          SERCOM_SPI_CTRLA_DIPO(miso) |
                          dataOrder << SERCOM_SPI_CTRLA_DORD_Pos;
    ffe4:	6823      	ldr	r3, [r4, #0]
  initClockNVIC();

  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg =	SERCOM_SPI_CTRLA_MODE_SPI_MASTER |
                          SERCOM_SPI_CTRLA_DOPO(mosi) |
                          SERCOM_SPI_CTRLA_DIPO(miso) |
    ffe6:	433e      	orrs	r6, r7
                          dataOrder << SERCOM_SPI_CTRLA_DORD_Pos;

  //Setting the CTRLB register
  sercom->SPI.CTRLB.reg = SERCOM_SPI_CTRLB_CHSIZE(charSize) |
    ffe8:	9901      	ldr	r1, [sp, #4]
  resetSPI();
  initClockNVIC();

  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg =	SERCOM_SPI_CTRLA_MODE_SPI_MASTER |
                          SERCOM_SPI_CTRLA_DOPO(mosi) |
    ffea:	4015      	ands	r5, r2
                          SERCOM_SPI_CTRLA_DIPO(miso) |
    ffec:	4335      	orrs	r5, r6
                          dataOrder << SERCOM_SPI_CTRLA_DORD_Pos;

  //Setting the CTRLB register
  sercom->SPI.CTRLB.reg = SERCOM_SPI_CTRLB_CHSIZE(charSize) |
    ffee:	2207      	movs	r2, #7

  //Setting the CTRLA register
  sercom->SPI.CTRLA.reg =	SERCOM_SPI_CTRLA_MODE_SPI_MASTER |
                          SERCOM_SPI_CTRLA_DOPO(mosi) |
                          SERCOM_SPI_CTRLA_DIPO(miso) |
                          dataOrder << SERCOM_SPI_CTRLA_DORD_Pos;
    fff0:	601d      	str	r5, [r3, #0]

  //Setting the CTRLB register
  sercom->SPI.CTRLB.reg = SERCOM_SPI_CTRLB_CHSIZE(charSize) |
    fff2:	400a      	ands	r2, r1
    fff4:	2180      	movs	r1, #128	; 0x80
                          SERCOM_SPI_CTRLB_RXEN;	//Active the SPI receiver.
    fff6:	6823      	ldr	r3, [r4, #0]
                          SERCOM_SPI_CTRLA_DOPO(mosi) |
                          SERCOM_SPI_CTRLA_DIPO(miso) |
                          dataOrder << SERCOM_SPI_CTRLA_DORD_Pos;

  //Setting the CTRLB register
  sercom->SPI.CTRLB.reg = SERCOM_SPI_CTRLB_CHSIZE(charSize) |
    fff8:	0289      	lsls	r1, r1, #10
    fffa:	430a      	orrs	r2, r1
                          SERCOM_SPI_CTRLB_RXEN;	//Active the SPI receiver.
    fffc:	605a      	str	r2, [r3, #4]


}
    fffe:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

00010000 <_ZN4UartcvbEv>:
    size_t write(const uint8_t data);
    using Print::write; // pull in write(str) and write(buf, size) from Print

    void IrqHandler();

    operator bool() { return true; }
   10000:	2001      	movs	r0, #1
   10002:	4770      	bx	lr

00010004 <_ZN4Uart5beginEm>:
  uc_padRX=_padRX ;
  uc_padTX=_padTX;
}

void Uart::begin(unsigned long baudrate)
{
   10004:	b508      	push	{r3, lr}
  begin(baudrate, SERIAL_8N1);
   10006:	6803      	ldr	r3, [r0, #0]
   10008:	4a01      	ldr	r2, [pc, #4]	; (10010 <_ZN4Uart5beginEm+0xc>)
   1000a:	69db      	ldr	r3, [r3, #28]
   1000c:	4798      	blx	r3
}
   1000e:	bd08      	pop	{r3, pc}
   10010:	00000413 	.word	0x00000413

00010014 <_ZN4Uart3endEv>:

  sercom->enableUART();
}

void Uart::end()
{
   10014:	b510      	push	{r4, lr}
   10016:	1c04      	adds	r4, r0, #0
  sercom->resetUART();
   10018:	6900      	ldr	r0, [r0, #16]
   1001a:	f7ff fea2 	bl	fd62 <_ZN6SERCOM9resetUARTEv>
  rxBuffer.clear();
   1001e:	1c20      	adds	r0, r4, #0
   10020:	3014      	adds	r0, #20
   10022:	f001 f883 	bl	1112c <_ZN10RingBuffer5clearEv>
}
   10026:	bd10      	pop	{r4, pc}

00010028 <_ZN4Uart5flushEv>:

void Uart::flush()
{
   10028:	b508      	push	{r3, lr}
  sercom->flushUART();
   1002a:	6900      	ldr	r0, [r0, #16]
   1002c:	f7ff feb1 	bl	fd92 <_ZN6SERCOM9flushUARTEv>
}
   10030:	bd08      	pop	{r3, pc}

00010032 <_ZN4Uart9availableEv>:
    sercom->clearStatusUART();
  }
}

int Uart::available()
{
   10032:	b508      	push	{r3, lr}
  return rxBuffer.available();
   10034:	3014      	adds	r0, #20
   10036:	f001 f88b 	bl	11150 <_ZN10RingBuffer9availableEv>
}
   1003a:	bd08      	pop	{r3, pc}

0001003c <_ZN4Uart4peekEv>:
{
  return (sercom->isDataRegisterEmptyUART() ? 1 : 0);
}

int Uart::peek()
{
   1003c:	b508      	push	{r3, lr}
  return rxBuffer.peek();
   1003e:	3014      	adds	r0, #20
   10040:	f001 f88c 	bl	1115c <_ZN10RingBuffer4peekEv>
}
   10044:	bd08      	pop	{r3, pc}

00010046 <_ZN4Uart4readEv>:

int Uart::read()
{
   10046:	b508      	push	{r3, lr}
  return rxBuffer.read_char();
   10048:	3014      	adds	r0, #20
   1004a:	f001 f873 	bl	11134 <_ZN10RingBuffer9read_charEv>
}
   1004e:	bd08      	pop	{r3, pc}

00010050 <_ZN4Uart5writeEh>:

size_t Uart::write(const uint8_t data)
{
   10050:	b508      	push	{r3, lr}
  sercom->writeDataUART(data);
   10052:	6900      	ldr	r0, [r0, #16]
   10054:	f7ff febd 	bl	fdd2 <_ZN6SERCOM13writeDataUARTEh>
  return 1;
}
   10058:	2001      	movs	r0, #1
   1005a:	bd08      	pop	{r3, pc}

0001005c <_ZN4UartC1EP6SERCOMhh11SercomRXPad15SercomUartTXPad>:

#include "Uart.h"
#include "Arduino.h"
#include "wiring_private.h"

Uart::Uart(SERCOM *_s, uint8_t _pinRX, uint8_t _pinTX, SercomRXPad _padRX, SercomUartTXPad _padTX)
   1005c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1005e:	1c1d      	adds	r5, r3, #0
   10060:	ab08      	add	r3, sp, #32
   10062:	781b      	ldrb	r3, [r3, #0]
   10064:	1c04      	adds	r4, r0, #0
   10066:	9300      	str	r3, [sp, #0]
   10068:	ab09      	add	r3, sp, #36	; 0x24
   1006a:	781b      	ldrb	r3, [r3, #0]
   1006c:	1c16      	adds	r6, r2, #0
   1006e:	9301      	str	r3, [sp, #4]
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
   10070:	2300      	movs	r3, #0
   10072:	6043      	str	r3, [r0, #4]
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
   10074:	23fa      	movs	r3, #250	; 0xfa
   10076:	009b      	lsls	r3, r3, #2
   10078:	6083      	str	r3, [r0, #8]
   1007a:	4b09      	ldr	r3, [pc, #36]	; (100a0 <_ZN4UartC1EP6SERCOMhh11SercomRXPad15SercomUartTXPad+0x44>)
   1007c:	1c0f      	adds	r7, r1, #0
   1007e:	3308      	adds	r3, #8
   10080:	6003      	str	r3, [r0, #0]
   10082:	3014      	adds	r0, #20
   10084:	f001 f83c 	bl	11100 <_ZN10RingBufferC1Ev>
{
  sercom = _s;
  uc_pinRX = _pinRX;
  uc_pinTX = _pinTX;
  uc_padRX=_padRX ;
   10088:	9a00      	ldr	r2, [sp, #0]
#include "wiring_private.h"

Uart::Uart(SERCOM *_s, uint8_t _pinRX, uint8_t _pinTX, SercomRXPad _padRX, SercomUartTXPad _padTX)
{
  sercom = _s;
  uc_pinRX = _pinRX;
   1008a:	1c23      	adds	r3, r4, #0
   1008c:	335c      	adds	r3, #92	; 0x5c
#include "Arduino.h"
#include "wiring_private.h"

Uart::Uart(SERCOM *_s, uint8_t _pinRX, uint8_t _pinTX, SercomRXPad _padRX, SercomUartTXPad _padTX)
{
  sercom = _s;
   1008e:	6127      	str	r7, [r4, #16]
  uc_pinRX = _pinRX;
  uc_pinTX = _pinTX;
  uc_padRX=_padRX ;
   10090:	709a      	strb	r2, [r3, #2]
  uc_padTX=_padTX;
   10092:	9a01      	ldr	r2, [sp, #4]
#include "wiring_private.h"

Uart::Uart(SERCOM *_s, uint8_t _pinRX, uint8_t _pinTX, SercomRXPad _padRX, SercomUartTXPad _padTX)
{
  sercom = _s;
  uc_pinRX = _pinRX;
   10094:	701e      	strb	r6, [r3, #0]
  uc_pinTX = _pinTX;
   10096:	705d      	strb	r5, [r3, #1]
  uc_padRX=_padRX ;
  uc_padTX=_padTX;
}
   10098:	1c20      	adds	r0, r4, #0
{
  sercom = _s;
  uc_pinRX = _pinRX;
  uc_pinTX = _pinTX;
  uc_padRX=_padRX ;
  uc_padTX=_padTX;
   1009a:	70da      	strb	r2, [r3, #3]
}
   1009c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1009e:	46c0      	nop			; (mov r8, r8)
   100a0:	00015ae8 	.word	0x00015ae8

000100a4 <_ZN4Uart10IrqHandlerEv>:
{
  sercom->flushUART();
}

void Uart::IrqHandler()
{
   100a4:	b510      	push	{r4, lr}
   100a6:	1c04      	adds	r4, r0, #0
  if (sercom->availableDataUART()) {
   100a8:	6900      	ldr	r0, [r0, #16]
   100aa:	f7ff fe7e 	bl	fdaa <_ZN6SERCOM17availableDataUARTEv>
   100ae:	2800      	cmp	r0, #0
   100b0:	d007      	beq.n	100c2 <_ZN4Uart10IrqHandlerEv+0x1e>
    rxBuffer.store_char(sercom->readDataUART());
   100b2:	6920      	ldr	r0, [r4, #16]
   100b4:	f7ff fe89 	bl	fdca <_ZN6SERCOM12readDataUARTEv>
   100b8:	1c01      	adds	r1, r0, #0
   100ba:	1c20      	adds	r0, r4, #0
   100bc:	3014      	adds	r0, #20
   100be:	f001 f82a 	bl	11116 <_ZN10RingBuffer10store_charEh>
  }

  if (sercom->isUARTError()) {
   100c2:	6920      	ldr	r0, [r4, #16]
   100c4:	f7ff fe76 	bl	fdb4 <_ZN6SERCOM11isUARTErrorEv>
   100c8:	2800      	cmp	r0, #0
   100ca:	d005      	beq.n	100d8 <_ZN4Uart10IrqHandlerEv+0x34>
    sercom->acknowledgeUARTError();
   100cc:	6920      	ldr	r0, [r4, #16]
   100ce:	f7ff fe75 	bl	fdbc <_ZN6SERCOM20acknowledgeUARTErrorEv>
    // TODO: if (sercom->isBufferOverflowErrorUART()) ....
    // TODO: if (sercom->isFrameErrorUART()) ....
    // TODO: if (sercom->isParityErrorUART()) ....
    sercom->clearStatusUART();
   100d2:	6920      	ldr	r0, [r4, #16]
   100d4:	f7ff fe65 	bl	fda2 <_ZN6SERCOM15clearStatusUARTEv>
  }
}
   100d8:	bd10      	pop	{r4, pc}

000100da <_ZN4Uart16extractNbStopBitEt>:
  return 1;
}

SercomNumberStopBit Uart::extractNbStopBit(uint16_t config)
{
  switch(config & HARDSER_STOP_BIT_MASK)
   100da:	23f0      	movs	r3, #240	; 0xf0
   100dc:	1c08      	adds	r0, r1, #0
   100de:	4018      	ands	r0, r3
  {
    case HARDSER_STOP_BIT_1:
    default:
      return SERCOM_STOP_BIT_1;
   100e0:	3830      	subs	r0, #48	; 0x30
   100e2:	4243      	negs	r3, r0
   100e4:	4158      	adcs	r0, r3

    case HARDSER_STOP_BIT_2:
      return SERCOM_STOP_BITS_2;
  }
}
   100e6:	4770      	bx	lr

000100e8 <_ZN4Uart15extractCharSizeEt>:

SercomUartCharSize Uart::extractCharSize(uint16_t config)
{
  switch(config & HARDSER_DATA_MASK)
   100e8:	23f0      	movs	r3, #240	; 0xf0
   100ea:	011b      	lsls	r3, r3, #4
   100ec:	4019      	ands	r1, r3
   100ee:	2380      	movs	r3, #128	; 0x80
   100f0:	009b      	lsls	r3, r3, #2
   100f2:	4299      	cmp	r1, r3
   100f4:	d00c      	beq.n	10110 <_ZN4Uart15extractCharSizeEt+0x28>
   100f6:	23c0      	movs	r3, #192	; 0xc0
   100f8:	009b      	lsls	r3, r3, #2
   100fa:	4299      	cmp	r1, r3
   100fc:	d006      	beq.n	1010c <_ZN4Uart15extractCharSizeEt+0x24>
   100fe:	2380      	movs	r3, #128	; 0x80
   10100:	005b      	lsls	r3, r3, #1
  {
    case HARDSER_DATA_5:
      return UART_CHAR_SIZE_5_BITS;
   10102:	2005      	movs	r0, #5
  }
}

SercomUartCharSize Uart::extractCharSize(uint16_t config)
{
  switch(config & HARDSER_DATA_MASK)
   10104:	4299      	cmp	r1, r3
   10106:	d004      	beq.n	10112 <_ZN4Uart15extractCharSizeEt+0x2a>
    case HARDSER_DATA_7:
      return UART_CHAR_SIZE_7_BITS;

    case HARDSER_DATA_8:
    default:
      return UART_CHAR_SIZE_8_BITS;
   10108:	2000      	movs	r0, #0
   1010a:	e002      	b.n	10112 <_ZN4Uart15extractCharSizeEt+0x2a>

    case HARDSER_DATA_6:
      return UART_CHAR_SIZE_6_BITS;

    case HARDSER_DATA_7:
      return UART_CHAR_SIZE_7_BITS;
   1010c:	2007      	movs	r0, #7
   1010e:	e000      	b.n	10112 <_ZN4Uart15extractCharSizeEt+0x2a>
  {
    case HARDSER_DATA_5:
      return UART_CHAR_SIZE_5_BITS;

    case HARDSER_DATA_6:
      return UART_CHAR_SIZE_6_BITS;
   10110:	2006      	movs	r0, #6
    case HARDSER_DATA_8:
    default:
      return UART_CHAR_SIZE_8_BITS;

  }
}
   10112:	4770      	bx	lr

00010114 <_ZN4Uart13extractParityEt>:

SercomParityMode Uart::extractParity(uint16_t config)
{
  switch(config & HARDSER_PARITY_MASK)
   10114:	230f      	movs	r3, #15
   10116:	4019      	ands	r1, r3
   10118:	2901      	cmp	r1, #1
   1011a:	d005      	beq.n	10128 <_ZN4Uart13extractParityEt+0x14>
  {
    case HARDSER_PARITY_NONE:
    default:
      return SERCOM_NO_PARITY;
   1011c:	3902      	subs	r1, #2
   1011e:	424b      	negs	r3, r1
   10120:	414b      	adcs	r3, r1
   10122:	2002      	movs	r0, #2
   10124:	1ac0      	subs	r0, r0, r3
   10126:	e000      	b.n	1012a <_ZN4Uart13extractParityEt+0x16>

    case HARDSER_PARITY_EVEN:
      return SERCOM_EVEN_PARITY;
   10128:	2000      	movs	r0, #0

    case HARDSER_PARITY_ODD:
      return SERCOM_ODD_PARITY;
  }
}
   1012a:	4770      	bx	lr

0001012c <_ZN4Uart5beginEmt>:
{
  begin(baudrate, SERIAL_8N1);
}

void Uart::begin(unsigned long baudrate, uint16_t config)
{
   1012c:	b5f0      	push	{r4, r5, r6, r7, lr}
  pinPeripheral(uc_pinRX, g_APinDescription[uc_pinRX].ulPinType);
   1012e:	1c03      	adds	r3, r0, #0
{
  begin(baudrate, SERIAL_8N1);
}

void Uart::begin(unsigned long baudrate, uint16_t config)
{
   10130:	b085      	sub	sp, #20
   10132:	9103      	str	r1, [sp, #12]
  pinPeripheral(uc_pinRX, g_APinDescription[uc_pinRX].ulPinType);
   10134:	335c      	adds	r3, #92	; 0x5c
{
  begin(baudrate, SERIAL_8N1);
}

void Uart::begin(unsigned long baudrate, uint16_t config)
{
   10136:	1c04      	adds	r4, r0, #0
  pinPeripheral(uc_pinRX, g_APinDescription[uc_pinRX].ulPinType);
   10138:	2718      	movs	r7, #24
   1013a:	7818      	ldrb	r0, [r3, #0]
   1013c:	1c3b      	adds	r3, r7, #0
   1013e:	4343      	muls	r3, r0
   10140:	4e1b      	ldr	r6, [pc, #108]	; (101b0 <_ZN4Uart5beginEmt+0x84>)
   10142:	2108      	movs	r1, #8
   10144:	18f3      	adds	r3, r6, r3
   10146:	5659      	ldrsb	r1, [r3, r1]
{
  begin(baudrate, SERIAL_8N1);
}

void Uart::begin(unsigned long baudrate, uint16_t config)
{
   10148:	1c15      	adds	r5, r2, #0
  pinPeripheral(uc_pinRX, g_APinDescription[uc_pinRX].ulPinType);
   1014a:	f7ff fc97 	bl	fa7c <pinPeripheral>
  pinPeripheral(uc_pinTX, g_APinDescription[uc_pinTX].ulPinType);
   1014e:	1c23      	adds	r3, r4, #0
   10150:	335d      	adds	r3, #93	; 0x5d
   10152:	7818      	ldrb	r0, [r3, #0]
   10154:	2108      	movs	r1, #8
   10156:	4347      	muls	r7, r0
   10158:	19f6      	adds	r6, r6, r7
   1015a:	5671      	ldrsb	r1, [r6, r1]
   1015c:	f7ff fc8e 	bl	fa7c <pinPeripheral>

  sercom->initUART(UART_INT_CLOCK, SAMPLE_RATE_x16, baudrate);
   10160:	2101      	movs	r1, #1
   10162:	1c0a      	adds	r2, r1, #0
   10164:	9b03      	ldr	r3, [sp, #12]
   10166:	6920      	ldr	r0, [r4, #16]
   10168:	f7ff fef0 	bl	ff4c <_ZN6SERCOM8initUARTE14SercomUartMode20SercomUartSampleRatem>
  sercom->initFrame(extractCharSize(config), LSB_FIRST, extractParity(config), extractNbStopBit(config));
   1016c:	1c29      	adds	r1, r5, #0
   1016e:	1c20      	adds	r0, r4, #0
   10170:	f7ff ffba 	bl	100e8 <_ZN4Uart15extractCharSizeEt>
   10174:	1c29      	adds	r1, r5, #0
   10176:	1c07      	adds	r7, r0, #0
   10178:	1c20      	adds	r0, r4, #0
   1017a:	f7ff ffcb 	bl	10114 <_ZN4Uart13extractParityEt>
   1017e:	1c29      	adds	r1, r5, #0
   10180:	1c06      	adds	r6, r0, #0
   10182:	1c20      	adds	r0, r4, #0
   10184:	f7ff ffa9 	bl	100da <_ZN4Uart16extractNbStopBitEt>
   10188:	1c39      	adds	r1, r7, #0
   1018a:	9000      	str	r0, [sp, #0]
   1018c:	1c33      	adds	r3, r6, #0
   1018e:	6920      	ldr	r0, [r4, #16]
   10190:	2201      	movs	r2, #1
   10192:	f7ff fdb7 	bl	fd04 <_ZN6SERCOM9initFrameE18SercomUartCharSize15SercomDataOrder16SercomParityMode19SercomNumberStopBit>
  sercom->initPads(uc_padTX, uc_padRX);
   10196:	1c23      	adds	r3, r4, #0
   10198:	335f      	adds	r3, #95	; 0x5f
   1019a:	7819      	ldrb	r1, [r3, #0]
   1019c:	3b01      	subs	r3, #1
   1019e:	781a      	ldrb	r2, [r3, #0]
   101a0:	6920      	ldr	r0, [r4, #16]
   101a2:	f7ff fdcb 	bl	fd3c <_ZN6SERCOM8initPadsE15SercomUartTXPad11SercomRXPad>

  sercom->enableUART();
   101a6:	6920      	ldr	r0, [r4, #16]
   101a8:	f7ff fde9 	bl	fd7e <_ZN6SERCOM10enableUARTEv>
}
   101ac:	b005      	add	sp, #20
   101ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
   101b0:	000156a8 	.word	0x000156a8

000101b4 <_Z10randomSeedm>:
  #include "stdint.h"
}
#include "WMath.h"

extern void randomSeed( uint32_t dwSeed )
{
   101b4:	b508      	push	{r3, lr}
  if ( dwSeed != 0 )
   101b6:	2800      	cmp	r0, #0
   101b8:	d001      	beq.n	101be <_Z10randomSeedm+0xa>
  {
    srand( dwSeed ) ;
   101ba:	f001 faab 	bl	11714 <srand>
  }
}
   101be:	bd08      	pop	{r3, pc}

000101c0 <_Z6randoml>:

extern long random( long howbig )
{
  if ( howbig == 0 )
  {
    return 0 ;
   101c0:	2100      	movs	r1, #0
    srand( dwSeed ) ;
  }
}

extern long random( long howbig )
{
   101c2:	b510      	push	{r4, lr}
   101c4:	1e04      	subs	r4, r0, #0
  if ( howbig == 0 )
   101c6:	428c      	cmp	r4, r1
   101c8:	d004      	beq.n	101d4 <_Z6randoml+0x14>
  {
    return 0 ;
  }

  return rand() % howbig;
   101ca:	f001 fad1 	bl	11770 <rand>
   101ce:	1c21      	adds	r1, r4, #0
   101d0:	f001 f986 	bl	114e0 <__aeabi_idivmod>
}
   101d4:	1c08      	adds	r0, r1, #0
   101d6:	bd10      	pop	{r4, pc}

000101d8 <_Z6randomll>:

extern long random( long howsmall, long howbig )
{
   101d8:	b510      	push	{r4, lr}
   101da:	1e04      	subs	r4, r0, #0
  if (howsmall >= howbig)
   101dc:	428c      	cmp	r4, r1
   101de:	da03      	bge.n	101e8 <_Z6randomll+0x10>
  {
    return howsmall;
  }

  long diff = howbig - howsmall;
   101e0:	1a08      	subs	r0, r1, r0

  return random(diff) + howsmall;
   101e2:	f7ff ffed 	bl	101c0 <_Z6randoml>
   101e6:	1904      	adds	r4, r0, r4
}
   101e8:	1c20      	adds	r0, r4, #0
   101ea:	bd10      	pop	{r4, pc}

000101ec <__cxa_pure_virtual>:
#include <stdlib.h>

extern "C" void __cxa_pure_virtual(void) __attribute__ ((__noreturn__));
extern "C" void __cxa_deleted_virtual(void) __attribute__ ((__noreturn__));

void __cxa_pure_virtual(void) {
   101ec:	e7fe      	b.n	101ec <__cxa_pure_virtual>

000101ee <_Z11initVariantv>:
#include "Arduino.h"

// Weak empty variant initialization function.
// May be redefined by variant files.
void initVariant() __attribute__((weak));
void initVariant() { }
   101ee:	4770      	bx	lr

000101f0 <main>:

/*
 * \brief Main entry point of Arduino application
 */
int main( void )
{
   101f0:	b510      	push	{r4, lr}
  init();
   101f2:	f7ff f99f 	bl	f534 <init>

  __libc_init_array();
   101f6:	f001 f997 	bl	11528 <__libc_init_array>

  initVariant();
   101fa:	f7ff fff8 	bl	101ee <_Z11initVariantv>

  delay(1);
   101fe:	2001      	movs	r0, #1
   10200:	f7ff f8c6 	bl	f390 <delay>
#if defined(USBCON)
  USBDevice.init();
   10204:	4c08      	ldr	r4, [pc, #32]	; (10228 <main+0x38>)
   10206:	1c20      	adds	r0, r4, #0
   10208:	f000 fa34 	bl	10674 <_ZN14USBDeviceClass4initEv>
  USBDevice.attach();
   1020c:	1c20      	adds	r0, r4, #0
   1020e:	f000 fa91 	bl	10734 <_ZN14USBDeviceClass6attachEv>
#endif

  setup();
   10212:	f7f4 fc6f 	bl	4af4 <setup>

  for (;;)
  {
    loop();
   10216:	f7f4 fd43 	bl	4ca0 <loop>
    if (serialEventRun) serialEventRun();
   1021a:	4b04      	ldr	r3, [pc, #16]	; (1022c <main+0x3c>)
   1021c:	2b00      	cmp	r3, #0
   1021e:	d0fa      	beq.n	10216 <main+0x26>
   10220:	e000      	b.n	10224 <main+0x34>
   10222:	bf00      	nop
   10224:	e7f7      	b.n	10216 <main+0x26>
   10226:	46c0      	nop			; (mov r8, r8)
   10228:	200013e3 	.word	0x200013e3
   1022c:	00000000 	.word	0x00000000

00010230 <_Znwj>:
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <stdlib.h>

void *operator new(size_t size) {
   10230:	b508      	push	{r3, lr}
  return malloc(size);
   10232:	f001 f99f 	bl	11574 <malloc>
}
   10236:	bd08      	pop	{r3, pc}

00010238 <_Znaj>:

void *operator new[](size_t size) {
   10238:	b508      	push	{r3, lr}
  return malloc(size);
   1023a:	f001 f99b 	bl	11574 <malloc>
}
   1023e:	bd08      	pop	{r3, pc}

00010240 <_ZdlPv>:

void operator delete(void * ptr) {
   10240:	b508      	push	{r3, lr}
  free(ptr);
   10242:	f001 f9a1 	bl	11588 <free>
}
   10246:	bd08      	pop	{r3, pc}

00010248 <_ZdaPv>:

void operator delete[](void * ptr) {
   10248:	b508      	push	{r3, lr}
  free(ptr);
   1024a:	f001 f99d 	bl	11588 <free>
}
   1024e:	bd08      	pop	{r3, pc}

00010250 <_ZN14USBDeviceClass6initEPEmm.part.4>:
	for (uint8_t i = 1; i < sizeof(EndPoints) && EndPoints[i] != 0; i++) {
		initEP(i, EndPoints[i]);
	}
}

void USBDeviceClass::initEP(uint32_t ep, uint32_t config)
   10250:	b570      	push	{r4, r5, r6, lr}
   10252:	b2c2      	uxtb	r2, r0
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
	inline void epBank0SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
   10254:	4919      	ldr	r1, [pc, #100]	; (102bc <_ZN14USBDeviceClass6initEPEmm.part.4+0x6c>)
   10256:	0153      	lsls	r3, r2, #5
   10258:	18cb      	adds	r3, r1, r3
   1025a:	689e      	ldr	r6, [r3, #8]
   1025c:	4d18      	ldr	r5, [pc, #96]	; (102c0 <_ZN14USBDeviceClass6initEPEmm.part.4+0x70>)
   1025e:	24c0      	movs	r4, #192	; 0xc0
   10260:	402e      	ands	r6, r5
   10262:	05a4      	lsls	r4, r4, #22
   10264:	4326      	orrs	r6, r4
   10266:	609e      	str	r6, [r3, #8]
	}
	else if (config == USB_ENDPOINT_TYPE_CONTROL)
	{
		// Setup Control OUT
		usbd.epBank0SetSize(ep, 64);
		usbd.epBank0SetAddress(ep, &udd_ep_out_cache_buffer[ep]);
   10268:	4e16      	ldr	r6, [pc, #88]	; (102c4 <_ZN14USBDeviceClass6initEPEmm.part.4+0x74>)
   1026a:	0180      	lsls	r0, r0, #6

	// USB Device Endpoints function mapping
	// -------------------------------------

	// Config
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
   1026c:	6809      	ldr	r1, [r1, #0]
   1026e:	1830      	adds	r0, r6, r0
   10270:	3208      	adds	r2, #8
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
   10272:	6058      	str	r0, [r3, #4]

	// USB Device Endpoints function mapping
	// -------------------------------------

	// Config
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
   10274:	0152      	lsls	r2, r2, #5
   10276:	5c50      	ldrb	r0, [r2, r1]
   10278:	2607      	movs	r6, #7
   1027a:	43b0      	bics	r0, r6
   1027c:	2601      	movs	r6, #1
   1027e:	4330      	orrs	r0, r6
   10280:	5450      	strb	r0, [r2, r1]
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
	inline void epBank0SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
	inline void epBank1SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
   10282:	699e      	ldr	r6, [r3, #24]
   10284:	4035      	ands	r5, r6
   10286:	432c      	orrs	r4, r5
   10288:	619c      	str	r4, [r3, #24]
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
   1028a:	4c0f      	ldr	r4, [pc, #60]	; (102c8 <_ZN14USBDeviceClass6initEPEmm.part.4+0x78>)
   1028c:	615c      	str	r4, [r3, #20]
	// USB Device Endpoints function mapping
	// -------------------------------------

	// Config
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
	inline void epBank1SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = type; }
   1028e:	5c50      	ldrb	r0, [r2, r1]
   10290:	2470      	movs	r4, #112	; 0x70
   10292:	43a0      	bics	r0, r4
   10294:	2410      	movs	r4, #16
   10296:	4320      	orrs	r0, r4
   10298:	5450      	strb	r0, [r2, r1]
	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
   1029a:	689c      	ldr	r4, [r3, #8]
   1029c:	480b      	ldr	r0, [pc, #44]	; (102cc <_ZN14USBDeviceClass6initEPEmm.part.4+0x7c>)
	inline void epBank1DisableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENCLR.bit.TRCPT1 = 1; }

	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
   1029e:	188a      	adds	r2, r1, r2
	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
   102a0:	4020      	ands	r0, r4
   102a2:	2480      	movs	r4, #128	; 0x80
   102a4:	0364      	lsls	r4, r4, #13
   102a6:	4320      	orrs	r0, r4
   102a8:	6098      	str	r0, [r3, #8]
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
   102aa:	6898      	ldr	r0, [r3, #8]
	inline void epBank1DisableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENCLR.bit.TRCPT1 = 1; }

	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
   102ac:	2140      	movs	r1, #64	; 0x40
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
   102ae:	0b80      	lsrs	r0, r0, #14
   102b0:	0380      	lsls	r0, r0, #14
   102b2:	6098      	str	r0, [r3, #8]
	inline void epBank1DisableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENCLR.bit.TRCPT1 = 1; }

	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
   102b4:	7953      	ldrb	r3, [r2, #5]
   102b6:	430b      	orrs	r3, r1
   102b8:	7153      	strb	r3, [r2, #5]
		usbd.epBank0SetByteCount(ep, 0);

		// NAK on endpoint OUT, the bank is full.
		usbd.epBank0SetReady(ep);
	}
}
   102ba:	bd70      	pop	{r4, r5, r6, pc}
   102bc:	200013e8 	.word	0x200013e8
   102c0:	8fffffff 	.word	0x8fffffff
   102c4:	20001204 	.word	0x20001204
   102c8:	20001044 	.word	0x20001044
   102cc:	f0003fff 	.word	0xf0003fff

000102d0 <_ZN20USBDevice_SAMD21G18x5resetEv>:

	// Endpoints descriptors table
	__attribute__((__aligned__(4)))	UsbDeviceDescriptor EP[USB_EPT_NUM];
};

void USBDevice_SAMD21G18x::reset() {
   102d0:	b538      	push	{r3, r4, r5, lr}
	usb.CTRLA.bit.SWRST = 1;
   102d2:	1c04      	adds	r4, r0, #0
   102d4:	cc08      	ldmia	r4!, {r3}
   102d6:	2101      	movs	r1, #1
   102d8:	781a      	ldrb	r2, [r3, #0]

	// Endpoints descriptors table
	__attribute__((__aligned__(4)))	UsbDeviceDescriptor EP[USB_EPT_NUM];
};

void USBDevice_SAMD21G18x::reset() {
   102da:	1c05      	adds	r5, r0, #0
	usb.CTRLA.bit.SWRST = 1;
   102dc:	430a      	orrs	r2, r1
   102de:	701a      	strb	r2, [r3, #0]
	memset(EP, 0, sizeof(EP));
   102e0:	2280      	movs	r2, #128	; 0x80
   102e2:	1c20      	adds	r0, r4, #0
   102e4:	2100      	movs	r1, #0
   102e6:	0052      	lsls	r2, r2, #1
   102e8:	f001 f970 	bl	115cc <memset>
	while (usb.SYNCBUSY.bit.SWRST) {}
   102ec:	682b      	ldr	r3, [r5, #0]
   102ee:	789a      	ldrb	r2, [r3, #2]
   102f0:	07d1      	lsls	r1, r2, #31
   102f2:	d4fc      	bmi.n	102ee <_ZN20USBDevice_SAMD21G18x5resetEv+0x1e>
	usb.DESCADD.reg = (uint32_t)(&EP);
   102f4:	625c      	str	r4, [r3, #36]	; 0x24
}
   102f6:	bd38      	pop	{r3, r4, r5, pc}

000102f8 <_ZN20USBDevice_SAMD21G18x9calibrateEv>:
	// Load Pad Calibration data from non-volatile memory
	uint32_t *pad_transn_p = (uint32_t *) USB_FUSES_TRANSN_ADDR;
	uint32_t *pad_transp_p = (uint32_t *) USB_FUSES_TRANSP_ADDR;
	uint32_t *pad_trim_p   = (uint32_t *) USB_FUSES_TRIM_ADDR;

	uint32_t pad_transn = (*pad_transn_p & USB_FUSES_TRANSN_Msk) >> USB_FUSES_TRANSN_Pos;
   102f8:	4b13      	ldr	r3, [pc, #76]	; (10348 <_ZN20USBDevice_SAMD21G18x9calibrateEv+0x50>)
	memset(EP, 0, sizeof(EP));
	while (usb.SYNCBUSY.bit.SWRST) {}
	usb.DESCADD.reg = (uint32_t)(&EP);
}

void USBDevice_SAMD21G18x::calibrate() {
   102fa:	b5f0      	push	{r4, r5, r6, r7, lr}
	// Load Pad Calibration data from non-volatile memory
	uint32_t *pad_transn_p = (uint32_t *) USB_FUSES_TRANSN_ADDR;
	uint32_t *pad_transp_p = (uint32_t *) USB_FUSES_TRANSP_ADDR;
	uint32_t *pad_trim_p   = (uint32_t *) USB_FUSES_TRIM_ADDR;

	uint32_t pad_transn = (*pad_transn_p & USB_FUSES_TRANSN_Msk) >> USB_FUSES_TRANSN_Pos;
   102fc:	681b      	ldr	r3, [r3, #0]
   102fe:	0399      	lsls	r1, r3, #14
	uint32_t pad_transp = (*pad_transp_p & USB_FUSES_TRANSP_Msk) >> USB_FUSES_TRANSP_Pos;
   10300:	025a      	lsls	r2, r3, #9
	uint32_t pad_trim   = (*pad_trim_p   & USB_FUSES_TRIM_Msk  ) >> USB_FUSES_TRIM_Pos;
   10302:	019b      	lsls	r3, r3, #6
	// Load Pad Calibration data from non-volatile memory
	uint32_t *pad_transn_p = (uint32_t *) USB_FUSES_TRANSN_ADDR;
	uint32_t *pad_transp_p = (uint32_t *) USB_FUSES_TRANSP_ADDR;
	uint32_t *pad_trim_p   = (uint32_t *) USB_FUSES_TRIM_ADDR;

	uint32_t pad_transn = (*pad_transn_p & USB_FUSES_TRANSN_Msk) >> USB_FUSES_TRANSN_Pos;
   10304:	0ec9      	lsrs	r1, r1, #27
	uint32_t pad_transp = (*pad_transp_p & USB_FUSES_TRANSP_Msk) >> USB_FUSES_TRANSP_Pos;
   10306:	0ed2      	lsrs	r2, r2, #27
	uint32_t pad_trim   = (*pad_trim_p   & USB_FUSES_TRIM_Msk  ) >> USB_FUSES_TRIM_Pos;
   10308:	0f5b      	lsrs	r3, r3, #29

	if (pad_transn == 0x1F)  // maximum value (31)
   1030a:	291f      	cmp	r1, #31
   1030c:	d100      	bne.n	10310 <_ZN20USBDevice_SAMD21G18x9calibrateEv+0x18>
		pad_transn = 5;
   1030e:	2105      	movs	r1, #5
	if (pad_transp == 0x1F)  // maximum value (31)
   10310:	2a1f      	cmp	r2, #31
   10312:	d100      	bne.n	10316 <_ZN20USBDevice_SAMD21G18x9calibrateEv+0x1e>
		pad_transp = 29;
   10314:	221d      	movs	r2, #29
	if (pad_trim == 0x7)     // maximum value (7)
   10316:	2b07      	cmp	r3, #7
   10318:	d100      	bne.n	1031c <_ZN20USBDevice_SAMD21G18x9calibrateEv+0x24>
		pad_trim = 3;
   1031a:	2303      	movs	r3, #3

	usb.PADCAL.bit.TRANSN = pad_transn;
   1031c:	6804      	ldr	r4, [r0, #0]
   1031e:	018e      	lsls	r6, r1, #6
   10320:	8d27      	ldrh	r7, [r4, #40]	; 0x28
   10322:	490a      	ldr	r1, [pc, #40]	; (1034c <_ZN20USBDevice_SAMD21G18x9calibrateEv+0x54>)
   10324:	251f      	movs	r5, #31
   10326:	4039      	ands	r1, r7
   10328:	4331      	orrs	r1, r6
   1032a:	8521      	strh	r1, [r4, #40]	; 0x28
	usb.PADCAL.bit.TRANSP = pad_transp;
   1032c:	6801      	ldr	r1, [r0, #0]
   1032e:	402a      	ands	r2, r5
   10330:	8d0c      	ldrh	r4, [r1, #40]	; 0x28
   10332:	43ac      	bics	r4, r5
   10334:	4322      	orrs	r2, r4
   10336:	850a      	strh	r2, [r1, #40]	; 0x28
	usb.PADCAL.bit.TRIM   = pad_trim;
   10338:	6802      	ldr	r2, [r0, #0]
   1033a:	0319      	lsls	r1, r3, #12
   1033c:	8d10      	ldrh	r0, [r2, #40]	; 0x28
   1033e:	4b04      	ldr	r3, [pc, #16]	; (10350 <_ZN20USBDevice_SAMD21G18x9calibrateEv+0x58>)
   10340:	4003      	ands	r3, r0
   10342:	430b      	orrs	r3, r1
   10344:	8513      	strh	r3, [r2, #40]	; 0x28
}
   10346:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10348:	00806024 	.word	0x00806024
   1034c:	fffff83f 	.word	0xfffff83f
   10350:	ffff8fff 	.word	0xffff8fff

00010354 <_ZN7__GuardC1Ev>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   10354:	f3ef 8310 	mrs	r3, PRIMASK
 * TODO: Move into a separate header file and make an API out of it
 */

class __Guard {
public:
	__Guard() : primask(__get_PRIMASK()), loops(1) {
   10358:	6003      	str	r3, [r0, #0]
   1035a:	2301      	movs	r3, #1
   1035c:	6043      	str	r3, [r0, #4]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   1035e:	b672      	cpsid	i
		__disable_irq();
	}
   10360:	4770      	bx	lr

00010362 <_ZN7__GuardD1Ev>:
	~__Guard() {
		if (primask == 0) {
   10362:	6803      	ldr	r3, [r0, #0]
   10364:	2b00      	cmp	r3, #0
   10366:	d102      	bne.n	1036e <_ZN7__GuardD1Ev+0xc>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   10368:	b662      	cpsie	i
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
   1036a:	f3bf 8f6f 	isb	sy
			__enable_irq();
			// http://infocenter.arm.com/help/topic/com.arm.doc.dai0321a/BIHBFEIB.html
			__ISB();
		}
	}
   1036e:	4770      	bx	lr

00010370 <_ZNK26DoubleBufferedEPOutHandler9availableEv>:
			release();
		}
	}

	// Returns how many bytes are stored in the buffers
	virtual uint32_t available() const {
   10370:	b537      	push	{r0, r1, r2, r4, r5, lr}
		if (current == 0) {
   10372:	6905      	ldr	r5, [r0, #16]
			release();
		}
	}

	// Returns how many bytes are stored in the buffers
	virtual uint32_t available() const {
   10374:	1c04      	adds	r4, r0, #0
		if (current == 0) {
			bool ready = false;
			synchronized {
   10376:	4668      	mov	r0, sp
		}
	}

	// Returns how many bytes are stored in the buffers
	virtual uint32_t available() const {
		if (current == 0) {
   10378:	2d00      	cmp	r5, #0
   1037a:	d112      	bne.n	103a2 <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x32>
			bool ready = false;
			synchronized {
   1037c:	f7ff ffea 	bl	10354 <_ZN7__GuardC1Ev>
   10380:	9b01      	ldr	r3, [sp, #4]
   10382:	3b01      	subs	r3, #1
   10384:	d303      	bcc.n	1038e <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x1e>
				ready = ready0;
   10386:	1d62      	adds	r2, r4, #5
   10388:	7fd5      	ldrb	r5, [r2, #31]
   1038a:	b2ed      	uxtb	r5, r5
   1038c:	e7f9      	b.n	10382 <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x12>
			}
   1038e:	4668      	mov	r0, sp
   10390:	9301      	str	r3, [sp, #4]
   10392:	f7ff ffe6 	bl	10362 <_ZN7__GuardD1Ev>
			return ready ? (last0 - first0) : 0;
   10396:	2000      	movs	r0, #0
   10398:	4285      	cmp	r5, r0
   1039a:	d017      	beq.n	103cc <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x5c>
   1039c:	6a20      	ldr	r0, [r4, #32]
   1039e:	69e3      	ldr	r3, [r4, #28]
   103a0:	e013      	b.n	103ca <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x5a>
		} else {
			bool ready = false;
			synchronized {
   103a2:	f7ff ffd7 	bl	10354 <_ZN7__GuardC1Ev>
   103a6:	9b01      	ldr	r3, [sp, #4]
			synchronized {
				ready = ready0;
			}
			return ready ? (last0 - first0) : 0;
		} else {
			bool ready = false;
   103a8:	2500      	movs	r5, #0
			synchronized {
   103aa:	3b01      	subs	r3, #1
   103ac:	d304      	bcc.n	103b8 <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x48>
				ready = ready1;
   103ae:	1c22      	adds	r2, r4, #0
   103b0:	3234      	adds	r2, #52	; 0x34
   103b2:	7815      	ldrb	r5, [r2, #0]
   103b4:	b2ed      	uxtb	r5, r5
   103b6:	e7f8      	b.n	103aa <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x3a>
			}
   103b8:	4668      	mov	r0, sp
   103ba:	9301      	str	r3, [sp, #4]
   103bc:	f7ff ffd1 	bl	10362 <_ZN7__GuardD1Ev>
			return ready ? (last1 - first1) : 0;
   103c0:	2000      	movs	r0, #0
   103c2:	4285      	cmp	r5, r0
   103c4:	d002      	beq.n	103cc <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x5c>
   103c6:	6b20      	ldr	r0, [r4, #48]	; 0x30
   103c8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   103ca:	1ac0      	subs	r0, r0, r3
		}
	}
   103cc:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
	...

000103d0 <_ZN26DoubleBufferedEPOutHandler7releaseEv>:
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }

	inline void epBank0EnableSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTENSET.bit.RXSTP = 1; }
	inline void epBank0EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL0 = 1; }
	inline void epBank1EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL1 = 1; }
	inline void epBank0EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT0 = 1; }
   103d0:	6843      	ldr	r3, [r0, #4]
			}
			return ready ? (last1 - first1) : 0;
		}
	}

	void release() {
   103d2:	b510      	push	{r4, lr}
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }

	inline void epBank0EnableSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTENSET.bit.RXSTP = 1; }
	inline void epBank0EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL0 = 1; }
	inline void epBank1EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL1 = 1; }
	inline void epBank0EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT0 = 1; }
   103d4:	681a      	ldr	r2, [r3, #0]
   103d6:	7a03      	ldrb	r3, [r0, #8]
   103d8:	2101      	movs	r1, #1
   103da:	015b      	lsls	r3, r3, #5
   103dc:	18d3      	adds	r3, r2, r3
   103de:	33ff      	adds	r3, #255	; 0xff
   103e0:	7a9a      	ldrb	r2, [r3, #10]
   103e2:	430a      	orrs	r2, r1
   103e4:	729a      	strb	r2, [r3, #10]
   103e6:	7a03      	ldrb	r3, [r0, #8]
	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
   103e8:	6842      	ldr	r2, [r0, #4]
   103ea:	015b      	lsls	r3, r3, #5
   103ec:	18d3      	adds	r3, r2, r3
   103ee:	68c2      	ldr	r2, [r0, #12]
   103f0:	689c      	ldr	r4, [r3, #8]
   103f2:	0491      	lsls	r1, r2, #18
   103f4:	4a0b      	ldr	r2, [pc, #44]	; (10424 <_ZN26DoubleBufferedEPOutHandler7releaseEv+0x54>)
   103f6:	0909      	lsrs	r1, r1, #4
   103f8:	4022      	ands	r2, r4
   103fa:	430a      	orrs	r2, r1
   103fc:	609a      	str	r2, [r3, #8]
   103fe:	7a03      	ldrb	r3, [r0, #8]
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
   10400:	6842      	ldr	r2, [r0, #4]
   10402:	015b      	lsls	r3, r3, #5
   10404:	18d3      	adds	r3, r2, r3
   10406:	689a      	ldr	r2, [r3, #8]
	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
   10408:	2140      	movs	r1, #64	; 0x40
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
   1040a:	0b92      	lsrs	r2, r2, #14
   1040c:	0392      	lsls	r2, r2, #14
   1040e:	609a      	str	r2, [r3, #8]
	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
   10410:	6843      	ldr	r3, [r0, #4]
   10412:	681a      	ldr	r2, [r3, #0]
   10414:	7a03      	ldrb	r3, [r0, #8]
   10416:	3308      	adds	r3, #8
   10418:	015b      	lsls	r3, r3, #5
   1041a:	18d3      	adds	r3, r2, r3
   1041c:	791a      	ldrb	r2, [r3, #4]
   1041e:	430a      	orrs	r2, r1
   10420:	711a      	strb	r2, [r3, #4]
		// Release OUT EP
		usbd.epBank0EnableTransferComplete(ep);
		usbd.epBank0SetMultiPacketSize(ep, size);
		usbd.epBank0SetByteCount(ep, 0);
		usbd.epBank0ResetReady(ep);
	}
   10422:	bd10      	pop	{r4, pc}
   10424:	f0003fff 	.word	0xf0003fff

00010428 <_ZN26DoubleBufferedEPOutHandler4recvEPvm>:
		usbd.epBank0SetAddress(ep, const_cast<uint8_t *>(data0));

		release();
	}

	virtual uint32_t recv(void *_data, uint32_t len)
   10428:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	{
		uint8_t *data = reinterpret_cast<uint8_t *>(_data);

		// R/W: current, first0/1, ready0/1, notify
		// R  : last0/1, data0/1
		if (current == 0) {
   1042a:	6905      	ldr	r5, [r0, #16]
		usbd.epBank0SetAddress(ep, const_cast<uint8_t *>(data0));

		release();
	}

	virtual uint32_t recv(void *_data, uint32_t len)
   1042c:	1c04      	adds	r4, r0, #0
   1042e:	1c0e      	adds	r6, r1, #0
   10430:	1c17      	adds	r7, r2, #0
		uint8_t *data = reinterpret_cast<uint8_t *>(_data);

		// R/W: current, first0/1, ready0/1, notify
		// R  : last0/1, data0/1
		if (current == 0) {
			synchronized {
   10432:	4668      	mov	r0, sp
	{
		uint8_t *data = reinterpret_cast<uint8_t *>(_data);

		// R/W: current, first0/1, ready0/1, notify
		// R  : last0/1, data0/1
		if (current == 0) {
   10434:	2d00      	cmp	r5, #0
   10436:	d11f      	bne.n	10478 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x50>
			synchronized {
   10438:	f7ff ff8c 	bl	10354 <_ZN7__GuardC1Ev>
   1043c:	9b01      	ldr	r3, [sp, #4]
   1043e:	3b01      	subs	r3, #1
   10440:	1c5a      	adds	r2, r3, #1
   10442:	d006      	beq.n	10452 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x2a>
				if (!ready0) {
   10444:	1d62      	adds	r2, r4, #5
   10446:	7fd1      	ldrb	r1, [r2, #31]
   10448:	1e5a      	subs	r2, r3, #1
   1044a:	2900      	cmp	r1, #0
   1044c:	d03a      	beq.n	104c4 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x9c>
   1044e:	1c13      	adds	r3, r2, #0
   10450:	e7f6      	b.n	10440 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x18>
					return 0;
				}
			}
   10452:	4668      	mov	r0, sp
   10454:	9301      	str	r3, [sp, #4]
   10456:	f7ff ff84 	bl	10362 <_ZN7__GuardD1Ev>
			// when ready0==true the buffer is not being filled and last0 is constant
			uint32_t i;
			for (i=0; i<len && first0 < last0; i++) {
   1045a:	2500      	movs	r5, #0
   1045c:	69e3      	ldr	r3, [r4, #28]
   1045e:	42bd      	cmp	r5, r7
   10460:	d035      	beq.n	104ce <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xa6>
   10462:	6a22      	ldr	r2, [r4, #32]
   10464:	4293      	cmp	r3, r2
   10466:	d232      	bcs.n	104ce <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xa6>
				data[i] = data0[first0++];
   10468:	1c5a      	adds	r2, r3, #1
   1046a:	61e2      	str	r2, [r4, #28]
   1046c:	69a2      	ldr	r2, [r4, #24]
   1046e:	18d3      	adds	r3, r2, r3
   10470:	781b      	ldrb	r3, [r3, #0]
   10472:	5573      	strb	r3, [r6, r5]
					return 0;
				}
			}
			// when ready0==true the buffer is not being filled and last0 is constant
			uint32_t i;
			for (i=0; i<len && first0 < last0; i++) {
   10474:	3501      	adds	r5, #1
   10476:	e7f1      	b.n	1045c <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x34>
					}
				}
			}
			return i;
		} else {
			synchronized {
   10478:	f7ff ff6c 	bl	10354 <_ZN7__GuardC1Ev>
   1047c:	9b01      	ldr	r3, [sp, #4]
   1047e:	3b01      	subs	r3, #1
   10480:	1c5a      	adds	r2, r3, #1
   10482:	d008      	beq.n	10496 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x6e>
				if (!ready1) {
   10484:	1c22      	adds	r2, r4, #0
   10486:	3234      	adds	r2, #52	; 0x34
   10488:	7815      	ldrb	r5, [r2, #0]
   1048a:	1e5a      	subs	r2, r3, #1
   1048c:	b2ed      	uxtb	r5, r5
   1048e:	2d00      	cmp	r5, #0
   10490:	d018      	beq.n	104c4 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x9c>
   10492:	1c13      	adds	r3, r2, #0
   10494:	e7f4      	b.n	10480 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x58>
					return 0;
				}
			}
   10496:	4668      	mov	r0, sp
   10498:	9301      	str	r3, [sp, #4]
   1049a:	f7ff ff62 	bl	10362 <_ZN7__GuardD1Ev>
			// when ready1==true the buffer is not being filled and last1 is constant
			uint32_t i;
			for (i=0; i<len && first1 < last1; i++) {
   1049e:	2500      	movs	r5, #0
   104a0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   104a2:	42bd      	cmp	r5, r7
   104a4:	d026      	beq.n	104f4 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xcc>
   104a6:	6b22      	ldr	r2, [r4, #48]	; 0x30
   104a8:	4293      	cmp	r3, r2
   104aa:	d341      	bcc.n	10530 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x108>
   104ac:	e022      	b.n	104f4 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xcc>
			}
			if (first0 == last0) {
				first0 = 0;
				current = 1;
				synchronized {
					ready0 = false;
   104ae:	1d62      	adds	r2, r4, #5
   104b0:	2100      	movs	r1, #0
   104b2:	77d1      	strb	r1, [r2, #31]
					if (notify) {
   104b4:	3230      	adds	r2, #48	; 0x30
   104b6:	7816      	ldrb	r6, [r2, #0]
   104b8:	1e58      	subs	r0, r3, #1
   104ba:	428e      	cmp	r6, r1
   104bc:	d114      	bne.n	104e8 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xc0>
   104be:	1c03      	adds	r3, r0, #0
				data[i] = data0[first0++];
			}
			if (first0 == last0) {
				first0 = 0;
				current = 1;
				synchronized {
   104c0:	1c5a      	adds	r2, r3, #1
   104c2:	d1f4      	bne.n	104ae <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x86>
					ready1 = false;
					if (notify) {
						notify = false;
						release();
					}
				}
   104c4:	4668      	mov	r0, sp
   104c6:	9301      	str	r3, [sp, #4]
   104c8:	f7ff ff4b 	bl	10362 <_ZN7__GuardD1Ev>
   104cc:	e038      	b.n	10540 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x118>
			// when ready0==true the buffer is not being filled and last0 is constant
			uint32_t i;
			for (i=0; i<len && first0 < last0; i++) {
				data[i] = data0[first0++];
			}
			if (first0 == last0) {
   104ce:	6a22      	ldr	r2, [r4, #32]
   104d0:	4293      	cmp	r3, r2
   104d2:	d135      	bne.n	10540 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x118>
				first0 = 0;
   104d4:	2300      	movs	r3, #0
   104d6:	61e3      	str	r3, [r4, #28]
				current = 1;
   104d8:	2301      	movs	r3, #1
   104da:	6123      	str	r3, [r4, #16]
				synchronized {
   104dc:	4668      	mov	r0, sp
   104de:	f7ff ff39 	bl	10354 <_ZN7__GuardC1Ev>
   104e2:	9b01      	ldr	r3, [sp, #4]
   104e4:	3b01      	subs	r3, #1
   104e6:	e7eb      	b.n	104c0 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x98>
					ready0 = false;
					if (notify) {
						notify = false;
   104e8:	7011      	strb	r1, [r2, #0]
						release();
   104ea:	1c20      	adds	r0, r4, #0
   104ec:	9301      	str	r3, [sp, #4]
   104ee:	f7ff ff6f 	bl	103d0 <_ZN26DoubleBufferedEPOutHandler7releaseEv>
   104f2:	e7f6      	b.n	104e2 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xba>
			// when ready1==true the buffer is not being filled and last1 is constant
			uint32_t i;
			for (i=0; i<len && first1 < last1; i++) {
				data[i] = data1[first1++];
			}
			if (first1 == last1) {
   104f4:	6b22      	ldr	r2, [r4, #48]	; 0x30
   104f6:	4293      	cmp	r3, r2
   104f8:	d122      	bne.n	10540 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x118>
				first1 = 0;
   104fa:	2300      	movs	r3, #0
   104fc:	62e3      	str	r3, [r4, #44]	; 0x2c
				current = 0;
   104fe:	6123      	str	r3, [r4, #16]
				synchronized {
   10500:	4668      	mov	r0, sp
   10502:	f7ff ff27 	bl	10354 <_ZN7__GuardC1Ev>
   10506:	9b01      	ldr	r3, [sp, #4]
   10508:	3b01      	subs	r3, #1
   1050a:	1c5a      	adds	r2, r3, #1
   1050c:	d0da      	beq.n	104c4 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x9c>
					ready1 = false;
   1050e:	1c22      	adds	r2, r4, #0
   10510:	3234      	adds	r2, #52	; 0x34
   10512:	2100      	movs	r1, #0
   10514:	7011      	strb	r1, [r2, #0]
					if (notify) {
   10516:	3201      	adds	r2, #1
   10518:	7816      	ldrb	r6, [r2, #0]
   1051a:	1e58      	subs	r0, r3, #1
   1051c:	428e      	cmp	r6, r1
   1051e:	d101      	bne.n	10524 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xfc>
   10520:	1c03      	adds	r3, r0, #0
   10522:	e7f2      	b.n	1050a <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xe2>
						notify = false;
   10524:	7011      	strb	r1, [r2, #0]
						release();
   10526:	1c20      	adds	r0, r4, #0
   10528:	9301      	str	r3, [sp, #4]
   1052a:	f7ff ff51 	bl	103d0 <_ZN26DoubleBufferedEPOutHandler7releaseEv>
   1052e:	e7ea      	b.n	10506 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xde>
				}
			}
			// when ready1==true the buffer is not being filled and last1 is constant
			uint32_t i;
			for (i=0; i<len && first1 < last1; i++) {
				data[i] = data1[first1++];
   10530:	1c5a      	adds	r2, r3, #1
   10532:	62e2      	str	r2, [r4, #44]	; 0x2c
   10534:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   10536:	18d3      	adds	r3, r2, r3
   10538:	781b      	ldrb	r3, [r3, #0]
   1053a:	5573      	strb	r3, [r6, r5]
					return 0;
				}
			}
			// when ready1==true the buffer is not being filled and last1 is constant
			uint32_t i;
			for (i=0; i<len && first1 < last1; i++) {
   1053c:	3501      	adds	r5, #1
   1053e:	e7af      	b.n	104a0 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x78>
					}
				}
			}
			return i;
		}
	}
   10540:	1c28      	adds	r0, r5, #0
   10542:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

00010544 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv>:

	virtual void handleEndpoint()
   10544:	b537      	push	{r0, r1, r2, r4, r5, lr}
	inline uint16_t epInterruptSummary() { return usb.EPINTSMRY.reg; }

	inline bool epBank0IsSetupReceived(ep_t ep)     { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.RXSTP; }
	inline bool epBank0IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL0; }
	inline bool epBank1IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL1; }
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
   10546:	6843      	ldr	r3, [r0, #4]
   10548:	7a02      	ldrb	r2, [r0, #8]
   1054a:	681b      	ldr	r3, [r3, #0]
   1054c:	3208      	adds	r2, #8
   1054e:	0152      	lsls	r2, r2, #5
   10550:	189a      	adds	r2, r3, r2
			}
			return i;
		}
	}

	virtual void handleEndpoint()
   10552:	1c04      	adds	r4, r0, #0
	inline uint16_t epInterruptSummary() { return usb.EPINTSMRY.reg; }

	inline bool epBank0IsSetupReceived(ep_t ep)     { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.RXSTP; }
	inline bool epBank0IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL0; }
	inline bool epBank1IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL1; }
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
   10554:	79d0      	ldrb	r0, [r2, #7]
   10556:	2301      	movs	r3, #1
   10558:	21ff      	movs	r1, #255	; 0xff

	virtual void handleEndpoint()
	{
		// R/W : incoming, ready0/1
		//   W : last0/1, notify
		if (usbd.epBank0IsTransferComplete(ep))
   1055a:	4218      	tst	r0, r3
   1055c:	d053      	beq.n	10606 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0xc2>
	inline bool epBank1IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT1; }

	inline void epBank0AckSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP; }
	inline void epBank0AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(1); }
	inline void epBank1AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(2); }
	inline void epBank0AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(1); }
   1055e:	71d3      	strb	r3, [r2, #7]
   10560:	68a0      	ldr	r0, [r4, #8]
			// Ack Transfer complete
			usbd.epBank0AckTransferComplete(ep);
			//usbd.epBank0AckTransferFailed(ep); // XXX

			// Update counters and swap banks
			if (incoming == 0) {
   10562:	6965      	ldr	r5, [r4, #20]
   10564:	6862      	ldr	r2, [r4, #4]
   10566:	4001      	ands	r1, r0
   10568:	2d00      	cmp	r5, #0
   1056a:	d120      	bne.n	105ae <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0x6a>
	inline void epBank1SetStallReq(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.STALLRQ1 = 1; }
	inline void epBank0ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ0 = 1; }
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
   1056c:	0149      	lsls	r1, r1, #5
   1056e:	1852      	adds	r2, r2, r1
   10570:	6891      	ldr	r1, [r2, #8]
			//usbd.epBank0AckTransferFailed(ep); // XXX

			// Update counters and swap banks
			if (incoming == 0) {
				last0 = usbd.epBank0ByteCount(ep);
				incoming = 1;
   10572:	6163      	str	r3, [r4, #20]
	inline void epBank1SetStallReq(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.STALLRQ1 = 1; }
	inline void epBank0ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ0 = 1; }
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
   10574:	0489      	lsls	r1, r1, #18
   10576:	0c89      	lsrs	r1, r1, #18
			usbd.epBank0AckTransferComplete(ep);
			//usbd.epBank0AckTransferFailed(ep); // XXX

			// Update counters and swap banks
			if (incoming == 0) {
				last0 = usbd.epBank0ByteCount(ep);
   10578:	6221      	str	r1, [r4, #32]
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
   1057a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
			if (incoming == 0) {
				last0 = usbd.epBank0ByteCount(ep);
				incoming = 1;
				usbd.epBank0SetAddress(ep, const_cast<uint8_t *>(data1));
				ready0 = true;
				synchronized {
   1057c:	4668      	mov	r0, sp
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
   1057e:	6051      	str	r1, [r2, #4]
			// Update counters and swap banks
			if (incoming == 0) {
				last0 = usbd.epBank0ByteCount(ep);
				incoming = 1;
				usbd.epBank0SetAddress(ep, const_cast<uint8_t *>(data1));
				ready0 = true;
   10580:	1d62      	adds	r2, r4, #5
   10582:	77d3      	strb	r3, [r2, #31]
				synchronized {
   10584:	f7ff fee6 	bl	10354 <_ZN7__GuardC1Ev>
   10588:	9b01      	ldr	r3, [sp, #4]
   1058a:	3b01      	subs	r3, #1
   1058c:	1c5a      	adds	r2, r3, #1
   1058e:	d033      	beq.n	105f8 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0xb4>
					if (ready1) {
   10590:	1c22      	adds	r2, r4, #0
   10592:	3234      	adds	r2, #52	; 0x34
   10594:	7811      	ldrb	r1, [r2, #0]
   10596:	1e58      	subs	r0, r3, #1
   10598:	b2c9      	uxtb	r1, r1
   1059a:	3201      	adds	r2, #1
   1059c:	2900      	cmp	r1, #0
   1059e:	d003      	beq.n	105a8 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0x64>
   105a0:	9301      	str	r3, [sp, #4]
						notify = true;
   105a2:	2301      	movs	r3, #1
   105a4:	7013      	strb	r3, [r2, #0]
   105a6:	e023      	b.n	105f0 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0xac>
						return;
					}
					notify = false;
   105a8:	7011      	strb	r1, [r2, #0]
   105aa:	1c03      	adds	r3, r0, #0
   105ac:	e7ee      	b.n	1058c <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0x48>
	inline void epBank1SetStallReq(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.STALLRQ1 = 1; }
	inline void epBank0ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ0 = 1; }
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
   105ae:	014b      	lsls	r3, r1, #5
   105b0:	18d3      	adds	r3, r2, r3
   105b2:	689a      	ldr	r2, [r3, #8]
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
   105b4:	69a5      	ldr	r5, [r4, #24]
	inline void epBank1SetStallReq(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.STALLRQ1 = 1; }
	inline void epBank0ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ0 = 1; }
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
   105b6:	0492      	lsls	r2, r2, #18
   105b8:	0c92      	lsrs	r2, r2, #18
						return;
					}
					notify = false;
				}
			} else {
				last1 = usbd.epBank0ByteCount(ep);
   105ba:	6322      	str	r2, [r4, #48]	; 0x30
				incoming = 0;
   105bc:	2200      	movs	r2, #0
   105be:	6162      	str	r2, [r4, #20]
				usbd.epBank0SetAddress(ep, const_cast<uint8_t *>(data0));
				synchronized {
   105c0:	4668      	mov	r0, sp
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
   105c2:	605d      	str	r5, [r3, #4]
				}
			} else {
				last1 = usbd.epBank0ByteCount(ep);
				incoming = 0;
				usbd.epBank0SetAddress(ep, const_cast<uint8_t *>(data0));
				synchronized {
   105c4:	f7ff fec6 	bl	10354 <_ZN7__GuardC1Ev>
   105c8:	9b01      	ldr	r3, [sp, #4]
   105ca:	3b01      	subs	r3, #1
   105cc:	e001      	b.n	105d2 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0x8e>
					ready1 = true;
					if (ready0) {
						notify = true;
						return;
					}
					notify = false;
   105ce:	7011      	strb	r1, [r2, #0]
   105d0:	1c2b      	adds	r3, r5, #0
				}
			} else {
				last1 = usbd.epBank0ByteCount(ep);
				incoming = 0;
				usbd.epBank0SetAddress(ep, const_cast<uint8_t *>(data0));
				synchronized {
   105d2:	1c59      	adds	r1, r3, #1
   105d4:	d010      	beq.n	105f8 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0xb4>
					ready1 = true;
   105d6:	1c22      	adds	r2, r4, #0
   105d8:	3234      	adds	r2, #52	; 0x34
   105da:	2001      	movs	r0, #1
   105dc:	7010      	strb	r0, [r2, #0]
					if (ready0) {
   105de:	1d62      	adds	r2, r4, #5
   105e0:	7fd1      	ldrb	r1, [r2, #31]
   105e2:	1e5d      	subs	r5, r3, #1
   105e4:	b2c9      	uxtb	r1, r1
   105e6:	3230      	adds	r2, #48	; 0x30
   105e8:	2900      	cmp	r1, #0
   105ea:	d0f0      	beq.n	105ce <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0x8a>
   105ec:	9301      	str	r3, [sp, #4]
						notify = true;
   105ee:	7010      	strb	r0, [r2, #0]
						return;
   105f0:	4668      	mov	r0, sp
   105f2:	f7ff feb6 	bl	10362 <_ZN7__GuardD1Ev>
   105f6:	e006      	b.n	10606 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0xc2>
					}
					notify = false;
				}
   105f8:	4668      	mov	r0, sp
   105fa:	9301      	str	r3, [sp, #4]
   105fc:	f7ff feb1 	bl	10362 <_ZN7__GuardD1Ev>
			}
			release();
   10600:	1c20      	adds	r0, r4, #0
   10602:	f7ff fee5 	bl	103d0 <_ZN26DoubleBufferedEPOutHandler7releaseEv>
		}
	}
   10606:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

00010608 <_ZN14USBDeviceClass14SendInterfacesEPm>:
		sendControl(_pack_buffer, _pack_size);
	}
}

uint8_t USBDeviceClass::SendInterfaces(uint32_t* total)
{
   10608:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint8_t interfaces = 0;
   1060a:	2300      	movs	r3, #0
   1060c:	466c      	mov	r4, sp
   1060e:	71e3      	strb	r3, [r4, #7]
   10610:	3407      	adds	r4, #7

#if defined(CDC_ENABLED)
	total[0] += CDC_GetInterface(&interfaces);
   10612:	1c20      	adds	r0, r4, #0
		sendControl(_pack_buffer, _pack_size);
	}
}

uint8_t USBDeviceClass::SendInterfaces(uint32_t* total)
{
   10614:	1c0d      	adds	r5, r1, #0
	uint8_t interfaces = 0;

#if defined(CDC_ENABLED)
	total[0] += CDC_GetInterface(&interfaces);
   10616:	f000 fdf1 	bl	111fc <_Z16CDC_GetInterfacePh>
   1061a:	682b      	ldr	r3, [r5, #0]
   1061c:	1818      	adds	r0, r3, r0
   1061e:	6028      	str	r0, [r5, #0]
#endif

#ifdef PLUGGABLE_USB_ENABLED
	total[0] += PluggableUSB().getInterface(&interfaces);
   10620:	f000 fe94 	bl	1134c <_Z12PluggableUSBv>
   10624:	1c21      	adds	r1, r4, #0
   10626:	f000 fe4b 	bl	112c0 <_ZN13PluggableUSB_12getInterfaceEPh>
   1062a:	682b      	ldr	r3, [r5, #0]
   1062c:	1818      	adds	r0, r3, r0
   1062e:	6028      	str	r0, [r5, #0]
#endif

	return interfaces;
   10630:	7820      	ldrb	r0, [r4, #0]
}
   10632:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

00010634 <_ZN14USBDeviceClass14handleEndpointEh>:
}

void USBDeviceClass::handleEndpoint(uint8_t ep)
{
#if defined(CDC_ENABLED)
	if (ep == CDC_ENDPOINT_IN)
   10634:	2903      	cmp	r1, #3
   10636:	d10b      	bne.n	10650 <_ZN14USBDeviceClass14handleEndpointEh+0x1c>
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
	inline void epBank1ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK1RDY = 1; }
   10638:	4b0d      	ldr	r3, [pc, #52]	; (10670 <_ZN14USBDeviceClass14handleEndpointEh+0x3c>)
   1063a:	22b2      	movs	r2, #178	; 0xb2
   1063c:	681b      	ldr	r3, [r3, #0]
   1063e:	0052      	lsls	r2, r2, #1
   10640:	5c98      	ldrb	r0, [r3, r2]
   10642:	2180      	movs	r1, #128	; 0x80
   10644:	4249      	negs	r1, r1
   10646:	4301      	orrs	r1, r0
   10648:	5499      	strb	r1, [r3, r2]

	inline void epBank0AckSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP; }
	inline void epBank0AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(1); }
	inline void epBank1AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(2); }
	inline void epBank0AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(1); }
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }
   1064a:	2102      	movs	r1, #2
   1064c:	2268      	movs	r2, #104	; 0x68
   1064e:	e00c      	b.n	1066a <_ZN14USBDeviceClass14handleEndpointEh+0x36>
	{
		// NAK on endpoint IN, the bank is not yet filled in.
		usbd.epBank1ResetReady(CDC_ENDPOINT_IN);
		usbd.epBank1AckTransferComplete(CDC_ENDPOINT_IN);
	}
	if (ep == CDC_ENDPOINT_ACM)
   10650:	2901      	cmp	r1, #1
   10652:	d10c      	bne.n	1066e <_ZN14USBDeviceClass14handleEndpointEh+0x3a>
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
	inline void epBank1ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK1RDY = 1; }
   10654:	4b06      	ldr	r3, [pc, #24]	; (10670 <_ZN14USBDeviceClass14handleEndpointEh+0x3c>)
   10656:	2292      	movs	r2, #146	; 0x92
   10658:	681b      	ldr	r3, [r3, #0]
   1065a:	0052      	lsls	r2, r2, #1
   1065c:	5c98      	ldrb	r0, [r3, r2]
   1065e:	2180      	movs	r1, #128	; 0x80
   10660:	4249      	negs	r1, r1
   10662:	4301      	orrs	r1, r0
   10664:	5499      	strb	r1, [r3, r2]

	inline void epBank0AckSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP; }
	inline void epBank0AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(1); }
	inline void epBank1AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(2); }
	inline void epBank0AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(1); }
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }
   10666:	2102      	movs	r1, #2
   10668:	2228      	movs	r2, #40	; 0x28
   1066a:	32ff      	adds	r2, #255	; 0xff
   1066c:	5499      	strb	r1, [r3, r2]
#endif

#if defined(PLUGGABLE_USB_ENABLED)
	// Empty
#endif
}
   1066e:	4770      	bx	lr
   10670:	200013e8 	.word	0x200013e8

00010674 <_ZN14USBDeviceClass4initEv>:

void USBDeviceClass::init()
{
   10674:	b538      	push	{r3, r4, r5, lr}
	pinMode(PIN_LED_RXL, OUTPUT);
	digitalWrite(PIN_LED_RXL, HIGH);
#endif

	// Enable USB clock
	PM->APBBMASK.reg |= PM_APBBMASK_USB;
   10676:	4b26      	ldr	r3, [pc, #152]	; (10710 <_ZN14USBDeviceClass4initEv+0x9c>)
   10678:	2120      	movs	r1, #32
   1067a:	69da      	ldr	r2, [r3, #28]
	// Empty
#endif
}

void USBDeviceClass::init()
{
   1067c:	1c05      	adds	r5, r0, #0
	pinMode(PIN_LED_RXL, OUTPUT);
	digitalWrite(PIN_LED_RXL, HIGH);
#endif

	// Enable USB clock
	PM->APBBMASK.reg |= PM_APBBMASK_USB;
   1067e:	430a      	orrs	r2, r1
   10680:	61da      	str	r2, [r3, #28]

	// Set up the USB DP/DN pins
	PORT->Group[0].PINCFG[PIN_PA24G_USB_DM].bit.PMUXEN = 1;
   10682:	4b24      	ldr	r3, [pc, #144]	; (10714 <_ZN14USBDeviceClass4initEv+0xa0>)
   10684:	2001      	movs	r0, #1
   10686:	781a      	ldrb	r2, [r3, #0]
	PORT->Group[0].PMUX[PIN_PA24G_USB_DM/2].reg &= ~(0xF << (4 * (PIN_PA24G_USB_DM & 0x01u)));
	PORT->Group[0].PMUX[PIN_PA24G_USB_DM/2].reg |= MUX_PA24G_USB_DM << (4 * (PIN_PA24G_USB_DM & 0x01u));
   10688:	2406      	movs	r4, #6

	// Enable USB clock
	PM->APBBMASK.reg |= PM_APBBMASK_USB;

	// Set up the USB DP/DN pins
	PORT->Group[0].PINCFG[PIN_PA24G_USB_DM].bit.PMUXEN = 1;
   1068a:	4302      	orrs	r2, r0
   1068c:	701a      	strb	r2, [r3, #0]
	PORT->Group[0].PMUX[PIN_PA24G_USB_DM/2].reg &= ~(0xF << (4 * (PIN_PA24G_USB_DM & 0x01u)));
   1068e:	4b22      	ldr	r3, [pc, #136]	; (10718 <_ZN14USBDeviceClass4initEv+0xa4>)
   10690:	220f      	movs	r2, #15
   10692:	7819      	ldrb	r1, [r3, #0]
   10694:	4391      	bics	r1, r2
   10696:	7019      	strb	r1, [r3, #0]
	PORT->Group[0].PMUX[PIN_PA24G_USB_DM/2].reg |= MUX_PA24G_USB_DM << (4 * (PIN_PA24G_USB_DM & 0x01u));
   10698:	7819      	ldrb	r1, [r3, #0]
   1069a:	4321      	orrs	r1, r4
   1069c:	7019      	strb	r1, [r3, #0]
	PORT->Group[0].PINCFG[PIN_PA25G_USB_DP].bit.PMUXEN = 1;
   1069e:	491f      	ldr	r1, [pc, #124]	; (1071c <_ZN14USBDeviceClass4initEv+0xa8>)
   106a0:	780c      	ldrb	r4, [r1, #0]
   106a2:	4320      	orrs	r0, r4
   106a4:	7008      	strb	r0, [r1, #0]
	PORT->Group[0].PMUX[PIN_PA25G_USB_DP/2].reg &= ~(0xF << (4 * (PIN_PA25G_USB_DP & 0x01u)));
   106a6:	7819      	ldrb	r1, [r3, #0]
   106a8:	400a      	ands	r2, r1
   106aa:	701a      	strb	r2, [r3, #0]
	PORT->Group[0].PMUX[PIN_PA25G_USB_DP/2].reg |= MUX_PA25G_USB_DP << (4 * (PIN_PA25G_USB_DP & 0x01u));
   106ac:	781a      	ldrb	r2, [r3, #0]
   106ae:	2160      	movs	r1, #96	; 0x60
   106b0:	430a      	orrs	r2, r1
   106b2:	701a      	strb	r2, [r3, #0]

	// Put Generic Clock Generator 0 as source for Generic Clock Multiplexer 6 (USB reference)
	GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(6)     | // Generic Clock Multiplexer 6
	                    GCLK_CLKCTRL_GEN_GCLK0 | // Generic Clock Generator 0 is source
	                    GCLK_CLKCTRL_CLKEN;
   106b4:	4b1a      	ldr	r3, [pc, #104]	; (10720 <_ZN14USBDeviceClass4initEv+0xac>)
   106b6:	4a1b      	ldr	r2, [pc, #108]	; (10724 <_ZN14USBDeviceClass4initEv+0xb0>)
   106b8:	805a      	strh	r2, [r3, #2]
	while (GCLK->STATUS.bit.SYNCBUSY)
   106ba:	785a      	ldrb	r2, [r3, #1]
   106bc:	09d2      	lsrs	r2, r2, #7
   106be:	d1fc      	bne.n	106ba <_ZN14USBDeviceClass4initEv+0x46>
		;

	USB_SetHandler(&UDD_Handler);
   106c0:	4819      	ldr	r0, [pc, #100]	; (10728 <_ZN14USBDeviceClass4initEv+0xb4>)
   106c2:	f7fe fe27 	bl	f314 <USB_SetHandler>

	// Reset USB Device
	usbd.reset();
   106c6:	4c19      	ldr	r4, [pc, #100]	; (1072c <_ZN14USBDeviceClass4initEv+0xb8>)
   106c8:	1c20      	adds	r0, r4, #0
   106ca:	f7ff fe01 	bl	102d0 <_ZN20USBDevice_SAMD21G18x5resetEv>

	usbd.calibrate();
   106ce:	1c20      	adds	r0, r4, #0
   106d0:	f7ff fe12 	bl	102f8 <_ZN20USBDevice_SAMD21G18x9calibrateEv>
	// Enable
	inline void enable()  { usb.CTRLA.bit.ENABLE = 1; }
	inline void disable() { usb.CTRLA.bit.ENABLE = 0; }

	// USB mode (device/host)
	inline void setUSBDeviceMode() { usb.CTRLA.bit.MODE = USB_CTRLA_MODE_DEVICE_Val; }
   106d4:	6823      	ldr	r3, [r4, #0]
   106d6:	227f      	movs	r2, #127	; 0x7f
   106d8:	7819      	ldrb	r1, [r3, #0]
   106da:	400a      	ands	r2, r1
   106dc:	701a      	strb	r2, [r3, #0]
	inline void setUSBHostMode()   { usb.CTRLA.bit.MODE = USB_CTRLA_MODE_HOST_Val;   }

	inline void runInStandby()   { usb.CTRLA.bit.RUNSTDBY = 1; }
   106de:	781a      	ldrb	r2, [r3, #0]
   106e0:	2104      	movs	r1, #4
   106e2:	430a      	orrs	r2, r1
   106e4:	701a      	strb	r2, [r3, #0]
	inline void noRunInStandby() { usb.CTRLA.bit.RUNSTDBY = 0; }

	// USB speed
	inline void setFullSpeed()       { usb.CTRLB.bit.SPDCONF = USB_DEVICE_CTRLB_SPDCONF_FS_Val;   }
   106e6:	891a      	ldrh	r2, [r3, #8]
   106e8:	210c      	movs	r1, #12
   106ea:	438a      	bics	r2, r1
   106ec:	811a      	strh	r2, [r3, #8]
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
   106ee:	21c1      	movs	r1, #193	; 0xc1
   106f0:	4a0f      	ldr	r2, [pc, #60]	; (10730 <_ZN14USBDeviceClass4initEv+0xbc>)
   106f2:	0089      	lsls	r1, r1, #2
   106f4:	5850      	ldr	r0, [r2, r1]
   106f6:	0200      	lsls	r0, r0, #8
   106f8:	0a00      	lsrs	r0, r0, #8
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
   106fa:	5050      	str	r0, [r2, r1]
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
   106fc:	2180      	movs	r1, #128	; 0x80
   106fe:	6011      	str	r1, [r2, #0]

	// Reset USB Device
	void reset();

	// Enable
	inline void enable()  { usb.CTRLA.bit.ENABLE = 1; }
   10700:	781a      	ldrb	r2, [r3, #0]
   10702:	2102      	movs	r1, #2
   10704:	430a      	orrs	r2, r1
   10706:	701a      	strb	r2, [r3, #0]
	NVIC_SetPriority((IRQn_Type) USB_IRQn, 0UL);
	NVIC_EnableIRQ((IRQn_Type) USB_IRQn);

	usbd.enable();

	initialized = true;
   10708:	2301      	movs	r3, #1
   1070a:	702b      	strb	r3, [r5, #0]
}
   1070c:	bd38      	pop	{r3, r4, r5, pc}
   1070e:	46c0      	nop			; (mov r8, r8)
   10710:	40000400 	.word	0x40000400
   10714:	41004458 	.word	0x41004458
   10718:	4100443c 	.word	0x4100443c
   1071c:	41004459 	.word	0x41004459
   10720:	40000c00 	.word	0x40000c00
   10724:	00004006 	.word	0x00004006
   10728:	000110e1 	.word	0x000110e1
   1072c:	200013e8 	.word	0x200013e8
   10730:	e000e100 	.word	0xe000e100

00010734 <_ZN14USBDeviceClass6attachEv>:

bool USBDeviceClass::attach()
{
	if (!initialized)
   10734:	7800      	ldrb	r0, [r0, #0]
   10736:	2800      	cmp	r0, #0
   10738:	d010      	beq.n	1075c <_ZN14USBDeviceClass6attachEv+0x28>
	inline void setLowSpeed()        { usb.CTRLB.bit.SPDCONF = USB_DEVICE_CTRLB_SPDCONF_LS_Val;   }
	inline void setHiSpeed()         { usb.CTRLB.bit.SPDCONF = USB_DEVICE_CTRLB_SPDCONF_HS_Val;   }
	inline void setHiSpeedTestMode() { usb.CTRLB.bit.SPDCONF = USB_DEVICE_CTRLB_SPDCONF_HSTM_Val; }

	// Authorize attach if Vbus is present
	inline void attach() { usb.CTRLB.bit.DETACH = 0; }
   1073a:	4b09      	ldr	r3, [pc, #36]	; (10760 <_ZN14USBDeviceClass6attachEv+0x2c>)
   1073c:	2101      	movs	r1, #1
   1073e:	681b      	ldr	r3, [r3, #0]
   10740:	891a      	ldrh	r2, [r3, #8]
   10742:	438a      	bics	r2, r1
   10744:	811a      	strh	r2, [r3, #8]
	inline void detach() { usb.CTRLB.bit.DETACH = 1; }

	// USB Interrupts
	inline bool isEndOfResetInterrupt()        { return usb.INTFLAG.bit.EORST; }
	inline void ackEndOfResetInterrupt()       { usb.INTFLAG.reg = USB_DEVICE_INTFLAG_EORST; }
	inline void enableEndOfResetInterrupt()    { usb.INTENSET.bit.EORST = 1; }
   10746:	8b1a      	ldrh	r2, [r3, #24]
   10748:	2108      	movs	r1, #8
   1074a:	430a      	orrs	r2, r1
   1074c:	831a      	strh	r2, [r3, #24]
	inline void disableEndOfResetInterrupt()   { usb.INTENCLR.bit.EORST = 1; }

	inline bool isStartOfFrameInterrupt()      { return usb.INTFLAG.bit.SOF; }
	inline void ackStartOfFrameInterrupt()     { usb.INTFLAG.reg = USB_DEVICE_INTFLAG_SOF; }
	inline void enableStartOfFrameInterrupt()  { usb.INTENSET.bit.SOF = 1; }
   1074e:	8b1a      	ldrh	r2, [r3, #24]
   10750:	2104      	movs	r1, #4
   10752:	430a      	orrs	r2, r1
   10754:	831a      	strh	r2, [r3, #24]

	usbd.attach();
	usbd.enableEndOfResetInterrupt();
	usbd.enableStartOfFrameInterrupt();

	_usbConfiguration = 0;
   10756:	4b03      	ldr	r3, [pc, #12]	; (10764 <_ZN14USBDeviceClass6attachEv+0x30>)
   10758:	2200      	movs	r2, #0
   1075a:	601a      	str	r2, [r3, #0]
	return true;
}
   1075c:	4770      	bx	lr
   1075e:	46c0      	nop			; (mov r8, r8)
   10760:	200013e8 	.word	0x200013e8
   10764:	200014ec 	.word	0x200014ec

00010768 <_ZN14USBDeviceClass10setAddressEm>:

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
   10768:	4b0f      	ldr	r3, [pc, #60]	; (107a8 <_ZN14USBDeviceClass10setAddressEm+0x40>)
   1076a:	699a      	ldr	r2, [r3, #24]
   1076c:	0b92      	lsrs	r2, r2, #14
   1076e:	0392      	lsls	r2, r2, #14
   10770:	619a      	str	r2, [r3, #24]

	inline void epBank0AckSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP; }
	inline void epBank0AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(1); }
	inline void epBank1AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(2); }
	inline void epBank0AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(1); }
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }
   10772:	681b      	ldr	r3, [r3, #0]
   10774:	2202      	movs	r2, #2
   10776:	33ff      	adds	r3, #255	; 0xff
   10778:	721a      	strb	r2, [r3, #8]

	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
   1077a:	7998      	ldrb	r0, [r3, #6]
   1077c:	2280      	movs	r2, #128	; 0x80
   1077e:	4252      	negs	r2, r2
   10780:	4302      	orrs	r2, r0
   10782:	719a      	strb	r2, [r3, #6]

	inline bool epBank0IsSetupReceived(ep_t ep)     { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.RXSTP; }
	inline bool epBank0IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL0; }
	inline bool epBank1IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL1; }
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
	inline bool epBank1IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT1; }
   10784:	7a1a      	ldrb	r2, [r3, #8]

	// RAM buffer is full, we can send data (IN)
	usbd.epBank1SetReady(0);

	// Wait for transfer to complete
	while (!usbd.epBank1IsTransferComplete(0)) {}
   10786:	0790      	lsls	r0, r2, #30
   10788:	d5fc      	bpl.n	10784 <_ZN14USBDeviceClass10setAddressEm+0x1c>

	// Set USB address to addr
	USB->DEVICE.DADD.bit.DADD = addr; // Address
   1078a:	4b08      	ldr	r3, [pc, #32]	; (107ac <_ZN14USBDeviceClass10setAddressEm+0x44>)
   1078c:	1c08      	adds	r0, r1, #0
   1078e:	7a99      	ldrb	r1, [r3, #10]
   10790:	227f      	movs	r2, #127	; 0x7f
   10792:	4010      	ands	r0, r2
   10794:	4391      	bics	r1, r2
   10796:	4301      	orrs	r1, r0
   10798:	7299      	strb	r1, [r3, #10]
	USB->DEVICE.DADD.bit.ADDEN = 1; // Enable
   1079a:	7a99      	ldrb	r1, [r3, #10]
   1079c:	2280      	movs	r2, #128	; 0x80
   1079e:	4252      	negs	r2, r2
   107a0:	430a      	orrs	r2, r1
   107a2:	729a      	strb	r2, [r3, #10]
}
   107a4:	4770      	bx	lr
   107a6:	46c0      	nop			; (mov r8, r8)
   107a8:	200013e8 	.word	0x200013e8
   107ac:	41005000 	.word	0x41005000

000107b0 <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup>:
{
	return _usbConfiguration != 0;
}

bool USBDeviceClass::handleClassInterfaceSetup(USBSetup& setup)
{
   107b0:	b510      	push	{r4, lr}
	uint8_t i = setup.wIndex;

	#if defined(CDC_ENABLED)
	if (CDC_ACM_INTERFACE == i)
   107b2:	790b      	ldrb	r3, [r1, #4]
{
	return _usbConfiguration != 0;
}

bool USBDeviceClass::handleClassInterfaceSetup(USBSetup& setup)
{
   107b4:	1c0c      	adds	r4, r1, #0
	uint8_t i = setup.wIndex;

	#if defined(CDC_ENABLED)
	if (CDC_ACM_INTERFACE == i)
   107b6:	2b00      	cmp	r3, #0
   107b8:	d10b      	bne.n	107d2 <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup+0x22>
	{
		if (CDC_Setup(setup) == false) {
   107ba:	1c08      	adds	r0, r1, #0
   107bc:	f000 fd2c 	bl	11218 <_Z9CDC_SetupR8USBSetup>
   107c0:	2800      	cmp	r0, #0
   107c2:	d104      	bne.n	107ce <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup+0x1e>

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
   107c4:	4b09      	ldr	r3, [pc, #36]	; (107ec <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup+0x3c>)
   107c6:	699a      	ldr	r2, [r3, #24]
   107c8:	0b92      	lsrs	r2, r2, #14
   107ca:	0392      	lsls	r2, r2, #14
   107cc:	619a      	str	r2, [r3, #24]
			sendZlp(0);
		}
		return true;
   107ce:	2001      	movs	r0, #1
   107d0:	e00b      	b.n	107ea <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup+0x3a>
	}
	#endif

	#if defined(PLUGGABLE_USB_ENABLED)
	bool ret = PluggableUSB().setup(setup);
   107d2:	f000 fdbb 	bl	1134c <_Z12PluggableUSBv>
   107d6:	1c21      	adds	r1, r4, #0
   107d8:	f000 fda6 	bl	11328 <_ZN13PluggableUSB_5setupER8USBSetup>
	if ( ret == false) {
   107dc:	2800      	cmp	r0, #0
   107de:	d1f6      	bne.n	107ce <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup+0x1e>
   107e0:	4b02      	ldr	r3, [pc, #8]	; (107ec <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup+0x3c>)
   107e2:	699a      	ldr	r2, [r3, #24]
   107e4:	0b92      	lsrs	r2, r2, #14
   107e6:	0392      	lsls	r2, r2, #14
   107e8:	619a      	str	r2, [r3, #24]
	}
	return ret;
	#endif

	return false;
}
   107ea:	bd10      	pop	{r4, pc}
   107ec:	200013e8 	.word	0x200013e8

000107f0 <_ZN14USBDeviceClass6initEPEmm>:
		initEP(i, EndPoints[i]);
	}
}

void USBDeviceClass::initEP(uint32_t ep, uint32_t config)
{
   107f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   107f2:	1c0d      	adds	r5, r1, #0
	if (config == (USB_ENDPOINT_TYPE_INTERRUPT | USB_ENDPOINT_IN(0)))
   107f4:	2a83      	cmp	r2, #131	; 0x83
   107f6:	d116      	bne.n	10826 <_ZN14USBDeviceClass6initEPEmm+0x36>
   107f8:	b2ca      	uxtb	r2, r1
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
	inline void epBank0SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
	inline void epBank1SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
   107fa:	4942      	ldr	r1, [pc, #264]	; (10904 <_ZN14USBDeviceClass6initEPEmm+0x114>)
   107fc:	0153      	lsls	r3, r2, #5
   107fe:	18cb      	adds	r3, r1, r3
   10800:	699c      	ldr	r4, [r3, #24]
   10802:	4841      	ldr	r0, [pc, #260]	; (10908 <_ZN14USBDeviceClass6initEPEmm+0x118>)
	{
		usbd.epBank1SetSize(ep, 64);
		usbd.epBank1SetAddress(ep, &udd_ep_in_cache_buffer[ep]);
   10804:	01ad      	lsls	r5, r5, #6
   10806:	4020      	ands	r0, r4
   10808:	24c0      	movs	r4, #192	; 0xc0
   1080a:	05a4      	lsls	r4, r4, #22
   1080c:	4320      	orrs	r0, r4
   1080e:	6198      	str	r0, [r3, #24]
   10810:	483e      	ldr	r0, [pc, #248]	; (1090c <_ZN14USBDeviceClass6initEPEmm+0x11c>)
	// USB Device Endpoints function mapping
	// -------------------------------------

	// Config
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
	inline void epBank1SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = type; }
   10812:	3208      	adds	r2, #8
   10814:	1945      	adds	r5, r0, r5
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
   10816:	615d      	str	r5, [r3, #20]
	// USB Device Endpoints function mapping
	// -------------------------------------

	// Config
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
	inline void epBank1SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = type; }
   10818:	680b      	ldr	r3, [r1, #0]
   1081a:	0152      	lsls	r2, r2, #5
   1081c:	5cd1      	ldrb	r1, [r2, r3]
   1081e:	2070      	movs	r0, #112	; 0x70
   10820:	4381      	bics	r1, r0
   10822:	2040      	movs	r0, #64	; 0x40
   10824:	e065      	b.n	108f2 <_ZN14USBDeviceClass6initEPEmm+0x102>
		usbd.epBank1SetType(ep, 4); // INTERRUPT IN
	}
	else if (config == (USB_ENDPOINT_TYPE_BULK | USB_ENDPOINT_OUT(0)))
   10826:	2a02      	cmp	r2, #2
   10828:	d145      	bne.n	108b6 <_ZN14USBDeviceClass6initEPEmm+0xc6>
	{
		epHandlers[ep] = new DoubleBufferedEPOutHandler(usbd, ep, 256);
   1082a:	2038      	movs	r0, #56	; 0x38
   1082c:	f7ff fd00 	bl	10230 <_Znwj>
		usbd(usbDev),
		ep(endPoint), size(bufferSize),
		current(0), incoming(0),
		first0(0), last0(0), ready0(false),
		first1(0), last1(0), ready1(false),
		notify(false)
   10830:	4b37      	ldr	r3, [pc, #220]	; (10910 <_ZN14USBDeviceClass6initEPEmm+0x120>)
   10832:	4f34      	ldr	r7, [pc, #208]	; (10904 <_ZN14USBDeviceClass6initEPEmm+0x114>)
   10834:	2680      	movs	r6, #128	; 0x80
   10836:	6003      	str	r3, [r0, #0]
   10838:	0076      	lsls	r6, r6, #1
   1083a:	2300      	movs	r3, #0
   1083c:	1d42      	adds	r2, r0, #5
   1083e:	6203      	str	r3, [r0, #32]
   10840:	6103      	str	r3, [r0, #16]
   10842:	6143      	str	r3, [r0, #20]
   10844:	61c3      	str	r3, [r0, #28]
   10846:	6047      	str	r7, [r0, #4]
   10848:	6085      	str	r5, [r0, #8]
   1084a:	60c6      	str	r6, [r0, #12]
   1084c:	77d3      	strb	r3, [r2, #31]
   1084e:	322f      	adds	r2, #47	; 0x2f
   10850:	1c04      	adds	r4, r0, #0
   10852:	62c3      	str	r3, [r0, #44]	; 0x2c
   10854:	6303      	str	r3, [r0, #48]	; 0x30
   10856:	7013      	strb	r3, [r2, #0]
	{
		data0 = reinterpret_cast<uint8_t *>(malloc(size));
   10858:	1c30      	adds	r0, r6, #0
		usbd(usbDev),
		ep(endPoint), size(bufferSize),
		current(0), incoming(0),
		first0(0), last0(0), ready0(false),
		first1(0), last1(0), ready1(false),
		notify(false)
   1085a:	7053      	strb	r3, [r2, #1]
	{
		data0 = reinterpret_cast<uint8_t *>(malloc(size));
   1085c:	f000 fe8a 	bl	11574 <malloc>
   10860:	61a0      	str	r0, [r4, #24]
		data1 = reinterpret_cast<uint8_t *>(malloc(size));
   10862:	1c30      	adds	r0, r6, #0
   10864:	f000 fe86 	bl	11574 <malloc>
   10868:	23ff      	movs	r3, #255	; 0xff
   1086a:	1c2a      	adds	r2, r5, #0
   1086c:	401a      	ands	r2, r3
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
	inline void epBank0SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
   1086e:	0152      	lsls	r2, r2, #5
		first0(0), last0(0), ready0(false),
		first1(0), last1(0), ready1(false),
		notify(false)
	{
		data0 = reinterpret_cast<uint8_t *>(malloc(size));
		data1 = reinterpret_cast<uint8_t *>(malloc(size));
   10870:	62a0      	str	r0, [r4, #40]	; 0x28
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
	inline void epBank0SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
   10872:	18bf      	adds	r7, r7, r2
   10874:	68b9      	ldr	r1, [r7, #8]
   10876:	4a24      	ldr	r2, [pc, #144]	; (10908 <_ZN14USBDeviceClass6initEPEmm+0x118>)

	// USB Device Endpoints function mapping
	// -------------------------------------

	// Config
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
   10878:	2607      	movs	r6, #7
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
	inline void epBank0SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
   1087a:	400a      	ands	r2, r1
   1087c:	21c0      	movs	r1, #192	; 0xc0
   1087e:	0589      	lsls	r1, r1, #22
   10880:	430a      	orrs	r2, r1
   10882:	60ba      	str	r2, [r7, #8]
   10884:	68a1      	ldr	r1, [r4, #8]

	// USB Device Endpoints function mapping
	// -------------------------------------

	// Config
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
   10886:	6862      	ldr	r2, [r4, #4]
   10888:	4019      	ands	r1, r3
   1088a:	6812      	ldr	r2, [r2, #0]
   1088c:	3108      	adds	r1, #8
   1088e:	0149      	lsls	r1, r1, #5
   10890:	5c88      	ldrb	r0, [r1, r2]
   10892:	00ad      	lsls	r5, r5, #2
   10894:	43b0      	bics	r0, r6
   10896:	2603      	movs	r6, #3
   10898:	4330      	orrs	r0, r6
   1089a:	5488      	strb	r0, [r1, r2]
   1089c:	68a1      	ldr	r1, [r4, #8]
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
   1089e:	6862      	ldr	r2, [r4, #4]
   108a0:	400b      	ands	r3, r1
   108a2:	015b      	lsls	r3, r3, #5
   108a4:	69a1      	ldr	r1, [r4, #24]
   108a6:	18d3      	adds	r3, r2, r3
   108a8:	6059      	str	r1, [r3, #4]
		usbd.epBank0SetSize(ep, 64);
		usbd.epBank0SetType(ep, 3); // BULK OUT

		usbd.epBank0SetAddress(ep, const_cast<uint8_t *>(data0));

		release();
   108aa:	1c20      	adds	r0, r4, #0
   108ac:	f7ff fd90 	bl	103d0 <_ZN26DoubleBufferedEPOutHandler7releaseEv>
   108b0:	4b18      	ldr	r3, [pc, #96]	; (10914 <_ZN14USBDeviceClass6initEPEmm+0x124>)
   108b2:	50ec      	str	r4, [r5, r3]
   108b4:	e025      	b.n	10902 <_ZN14USBDeviceClass6initEPEmm+0x112>
	}
	else if (config == (USB_ENDPOINT_TYPE_BULK | USB_ENDPOINT_IN(0)))
   108b6:	2a82      	cmp	r2, #130	; 0x82
   108b8:	d11e      	bne.n	108f8 <_ZN14USBDeviceClass6initEPEmm+0x108>
   108ba:	b2ca      	uxtb	r2, r1
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
	inline void epBank0SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
	inline void epBank1SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
   108bc:	4911      	ldr	r1, [pc, #68]	; (10904 <_ZN14USBDeviceClass6initEPEmm+0x114>)
   108be:	0153      	lsls	r3, r2, #5
   108c0:	18cb      	adds	r3, r1, r3
   108c2:	699c      	ldr	r4, [r3, #24]
   108c4:	4810      	ldr	r0, [pc, #64]	; (10908 <_ZN14USBDeviceClass6initEPEmm+0x118>)
	{
		usbd.epBank1SetSize(ep, 64);
		usbd.epBank1SetAddress(ep, &udd_ep_in_cache_buffer[ep]);
   108c6:	01ad      	lsls	r5, r5, #6
   108c8:	4020      	ands	r0, r4
   108ca:	24c0      	movs	r4, #192	; 0xc0
   108cc:	05a4      	lsls	r4, r4, #22
   108ce:	4320      	orrs	r0, r4
   108d0:	6198      	str	r0, [r3, #24]
   108d2:	480e      	ldr	r0, [pc, #56]	; (1090c <_ZN14USBDeviceClass6initEPEmm+0x11c>)
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
	inline void epBank1ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK1RDY = 1; }
   108d4:	3208      	adds	r2, #8
   108d6:	1945      	adds	r5, r0, r5
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
   108d8:	615d      	str	r5, [r3, #20]
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
	inline void epBank1ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK1RDY = 1; }
   108da:	680b      	ldr	r3, [r1, #0]
   108dc:	0152      	lsls	r2, r2, #5
   108de:	1899      	adds	r1, r3, r2
   108e0:	790c      	ldrb	r4, [r1, #4]
   108e2:	2080      	movs	r0, #128	; 0x80
   108e4:	4240      	negs	r0, r0
   108e6:	4320      	orrs	r0, r4
   108e8:	7108      	strb	r0, [r1, #4]
	// USB Device Endpoints function mapping
	// -------------------------------------

	// Config
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
	inline void epBank1SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = type; }
   108ea:	5cd1      	ldrb	r1, [r2, r3]
   108ec:	2070      	movs	r0, #112	; 0x70
   108ee:	4381      	bics	r1, r0
   108f0:	2030      	movs	r0, #48	; 0x30
   108f2:	4301      	orrs	r1, r0
   108f4:	54d1      	strb	r1, [r2, r3]
   108f6:	e004      	b.n	10902 <_ZN14USBDeviceClass6initEPEmm+0x112>
		// NAK on endpoint IN, the bank is not yet filled in.
		usbd.epBank1ResetReady(ep);

		usbd.epBank1SetType(ep, 3); // BULK IN
	}
	else if (config == USB_ENDPOINT_TYPE_CONTROL)
   108f8:	2a00      	cmp	r2, #0
   108fa:	d102      	bne.n	10902 <_ZN14USBDeviceClass6initEPEmm+0x112>
   108fc:	1c08      	adds	r0, r1, #0
   108fe:	f7ff fca7 	bl	10250 <_ZN14USBDeviceClass6initEPEmm.part.4>
		usbd.epBank0SetByteCount(ep, 0);

		// NAK on endpoint OUT, the bank is full.
		usbd.epBank0SetReady(ep);
	}
}
   10902:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   10904:	200013e8 	.word	0x200013e8
   10908:	8fffffff 	.word	0x8fffffff
   1090c:	20001044 	.word	0x20001044
   10910:	00015b20 	.word	0x00015b20
   10914:	200013c4 	.word	0x200013c4

00010918 <_ZN14USBDeviceClass13initEndpointsEv>:
	0,
	0,
#endif
};

void USBDeviceClass::initEndpoints() {
   10918:	b538      	push	{r3, r4, r5, lr}
   1091a:	1c05      	adds	r5, r0, #0
	for (uint8_t i = 1; i < sizeof(EndPoints) && EndPoints[i] != 0; i++) {
   1091c:	2401      	movs	r4, #1
   1091e:	4b06      	ldr	r3, [pc, #24]	; (10938 <_ZN14USBDeviceClass13initEndpointsEv+0x20>)
   10920:	00a2      	lsls	r2, r4, #2
   10922:	58d2      	ldr	r2, [r2, r3]
   10924:	2a00      	cmp	r2, #0
   10926:	d006      	beq.n	10936 <_ZN14USBDeviceClass13initEndpointsEv+0x1e>
		initEP(i, EndPoints[i]);
   10928:	1c21      	adds	r1, r4, #0
   1092a:	1c28      	adds	r0, r5, #0
	0,
#endif
};

void USBDeviceClass::initEndpoints() {
	for (uint8_t i = 1; i < sizeof(EndPoints) && EndPoints[i] != 0; i++) {
   1092c:	3401      	adds	r4, #1
		initEP(i, EndPoints[i]);
   1092e:	f7ff ff5f 	bl	107f0 <_ZN14USBDeviceClass6initEPEmm>
	0,
#endif
};

void USBDeviceClass::initEndpoints() {
	for (uint8_t i = 1; i < sizeof(EndPoints) && EndPoints[i] != 0; i++) {
   10932:	b2e4      	uxtb	r4, r4
   10934:	e7f3      	b.n	1091e <_ZN14USBDeviceClass13initEndpointsEv+0x6>
		initEP(i, EndPoints[i]);
	}
}
   10936:	bd38      	pop	{r3, r4, r5, pc}
   10938:	200000ac 	.word	0x200000ac

0001093c <_ZN14USBDeviceClass9availableEm>:
	return read;
}

// Number of bytes, assumes a rx endpoint
uint32_t USBDeviceClass::available(uint32_t ep)
{
   1093c:	b508      	push	{r3, lr}
	if (epHandlers[ep]) {
   1093e:	4b08      	ldr	r3, [pc, #32]	; (10960 <_ZN14USBDeviceClass9availableEm+0x24>)
   10940:	008a      	lsls	r2, r1, #2
   10942:	58d0      	ldr	r0, [r2, r3]
   10944:	2800      	cmp	r0, #0
   10946:	d003      	beq.n	10950 <_ZN14USBDeviceClass9availableEm+0x14>
		return epHandlers[ep]->available();
   10948:	6803      	ldr	r3, [r0, #0]
   1094a:	689b      	ldr	r3, [r3, #8]
   1094c:	4798      	blx	r3
   1094e:	e006      	b.n	1095e <_ZN14USBDeviceClass9availableEm+0x22>
   10950:	b2c9      	uxtb	r1, r1
	inline void epBank1SetStallReq(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.STALLRQ1 = 1; }
	inline void epBank0ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ0 = 1; }
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
   10952:	4b04      	ldr	r3, [pc, #16]	; (10964 <_ZN14USBDeviceClass9availableEm+0x28>)
   10954:	0149      	lsls	r1, r1, #5
   10956:	1859      	adds	r1, r3, r1
   10958:	6888      	ldr	r0, [r1, #8]
   1095a:	0480      	lsls	r0, r0, #18
   1095c:	0c80      	lsrs	r0, r0, #18
	} else {
		return usbd.epBank0ByteCount(ep);
	}
}
   1095e:	bd08      	pop	{r3, pc}
   10960:	200013c4 	.word	0x200013c4
   10964:	200013e8 	.word	0x200013e8

00010968 <_ZN14USBDeviceClass5flushEm>:
		usbd.epBank0SetReady(ep);
	}
}

void USBDeviceClass::flush(uint32_t ep)
{
   10968:	b510      	push	{r4, lr}
   1096a:	1c0c      	adds	r4, r1, #0
	if (available(ep)) {
   1096c:	f7ff ffe6 	bl	1093c <_ZN14USBDeviceClass9availableEm>
   10970:	2800      	cmp	r0, #0
   10972:	d00c      	beq.n	1098e <_ZN14USBDeviceClass5flushEm+0x26>

	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
   10974:	4b06      	ldr	r3, [pc, #24]	; (10990 <_ZN14USBDeviceClass5flushEm+0x28>)
   10976:	b2e1      	uxtb	r1, r4
   10978:	681b      	ldr	r3, [r3, #0]
   1097a:	3108      	adds	r1, #8
   1097c:	0149      	lsls	r1, r1, #5
   1097e:	1859      	adds	r1, r3, r1
   10980:	794a      	ldrb	r2, [r1, #5]
   10982:	2380      	movs	r3, #128	; 0x80
   10984:	425b      	negs	r3, r3
   10986:	4313      	orrs	r3, r2
   10988:	714b      	strb	r3, [r1, #5]

	inline void epBank0AckSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP; }
	inline void epBank0AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(1); }
	inline void epBank1AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(2); }
	inline void epBank0AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(1); }
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }
   1098a:	2302      	movs	r3, #2
   1098c:	71cb      	strb	r3, [r1, #7]
		usbd.epBank1SetReady(ep);

	 	// Clear the transfer complete flag
		usbd.epBank1AckTransferComplete(ep);
	}
}
   1098e:	bd10      	pop	{r4, pc}
   10990:	200013e8 	.word	0x200013e8

00010994 <_ZN14USBDeviceClass14armRecvCtrlOUTEm>:
		return c;
	}
}

uint8_t USBDeviceClass::armRecvCtrlOUT(uint32_t ep)
{
   10994:	b570      	push	{r4, r5, r6, lr}
   10996:	b2ca      	uxtb	r2, r1
	// Get endpoint configuration from setting register
	usbd.epBank0SetAddress(ep, &udd_ep_out_cache_buffer[ep]);
   10998:	4b13      	ldr	r3, [pc, #76]	; (109e8 <_ZN14USBDeviceClass14armRecvCtrlOUTEm+0x54>)
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
   1099a:	4814      	ldr	r0, [pc, #80]	; (109ec <_ZN14USBDeviceClass14armRecvCtrlOUTEm+0x58>)
   1099c:	0154      	lsls	r4, r2, #5
   1099e:	0189      	lsls	r1, r1, #6
   109a0:	1859      	adds	r1, r3, r1
   109a2:	1903      	adds	r3, r0, r4
   109a4:	6059      	str	r1, [r3, #4]
	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
   109a6:	689d      	ldr	r5, [r3, #8]
   109a8:	4911      	ldr	r1, [pc, #68]	; (109f0 <_ZN14USBDeviceClass14armRecvCtrlOUTEm+0x5c>)
	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
   109aa:	3208      	adds	r2, #8
	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
   109ac:	4029      	ands	r1, r5
   109ae:	2580      	movs	r5, #128	; 0x80
   109b0:	02ad      	lsls	r5, r5, #10
   109b2:	4329      	orrs	r1, r5
   109b4:	6099      	str	r1, [r3, #8]
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
   109b6:	6899      	ldr	r1, [r3, #8]
	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
   109b8:	2640      	movs	r6, #64	; 0x40
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
   109ba:	0b89      	lsrs	r1, r1, #14
   109bc:	0389      	lsls	r1, r1, #14
   109be:	6099      	str	r1, [r3, #8]
	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
   109c0:	6803      	ldr	r3, [r0, #0]
   109c2:	0151      	lsls	r1, r2, #5
   109c4:	1859      	adds	r1, r3, r1
   109c6:	790d      	ldrb	r5, [r1, #4]
   109c8:	4335      	orrs	r5, r6
   109ca:	710d      	strb	r5, [r1, #4]
	inline void epBank1DisableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENCLR.bit.STALL1 = 1; }
	inline void epBank0DisableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENCLR.bit.TRCPT0 = 1; }
	inline void epBank1DisableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENCLR.bit.TRCPT1 = 1; }

	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
   109cc:	0151      	lsls	r1, r2, #5
   109ce:	1859      	adds	r1, r3, r1
   109d0:	7989      	ldrb	r1, [r1, #6]
	usbd.epBank0SetByteCount(ep, 0);

	usbd.epBank0ResetReady(ep);

	// Wait OUT
	while (!usbd.epBank0IsReady(ep)) {}
   109d2:	064d      	lsls	r5, r1, #25
   109d4:	d5fa      	bpl.n	109cc <_ZN14USBDeviceClass14armRecvCtrlOUTEm+0x38>
	inline uint16_t epInterruptSummary() { return usb.EPINTSMRY.reg; }

	inline bool epBank0IsSetupReceived(ep_t ep)     { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.RXSTP; }
	inline bool epBank0IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL0; }
	inline bool epBank1IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL1; }
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
   109d6:	0151      	lsls	r1, r2, #5
   109d8:	1859      	adds	r1, r3, r1
   109da:	79c9      	ldrb	r1, [r1, #7]
	while (!usbd.epBank0IsTransferComplete(ep)) {}
   109dc:	07cd      	lsls	r5, r1, #31
   109de:	d5fa      	bpl.n	109d6 <_ZN14USBDeviceClass14armRecvCtrlOUTEm+0x42>
	inline void epBank1SetStallReq(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.STALLRQ1 = 1; }
	inline void epBank0ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ0 = 1; }
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
   109e0:	1904      	adds	r4, r0, r4
   109e2:	68a0      	ldr	r0, [r4, #8]
	return usbd.epBank0ByteCount(ep);
   109e4:	b2c0      	uxtb	r0, r0
}
   109e6:	bd70      	pop	{r4, r5, r6, pc}
   109e8:	20001204 	.word	0x20001204
   109ec:	200013e8 	.word	0x200013e8
   109f0:	f0003fff 	.word	0xf0003fff

000109f4 <_ZN14USBDeviceClass11recvControlEPvm>:
	return f != USB->DEVICE.FNUM.bit.FNUM;
}


uint32_t USBDeviceClass::recvControl(void *_data, uint32_t len)
{
   109f4:	b538      	push	{r3, r4, r5, lr}
	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
   109f6:	4b0c      	ldr	r3, [pc, #48]	; (10a28 <_ZN14USBDeviceClass11recvControlEPvm+0x34>)
   109f8:	1c14      	adds	r4, r2, #0
   109fa:	681b      	ldr	r3, [r3, #0]
   109fc:	1c0d      	adds	r5, r1, #0
   109fe:	33ff      	adds	r3, #255	; 0xff
   10a00:	795a      	ldrb	r2, [r3, #5]
   10a02:	2140      	movs	r1, #64	; 0x40
   10a04:	430a      	orrs	r2, r1
   10a06:	715a      	strb	r2, [r3, #5]

	// The RAM Buffer is empty: we can receive data
	usbd.epBank0ResetReady(0);

	//usbd.epBank0AckSetupReceived(0);
	uint32_t read = armRecvCtrlOUT(0);
   10a08:	2100      	movs	r1, #0
   10a0a:	f7ff ffc3 	bl	10994 <_ZN14USBDeviceClass14armRecvCtrlOUTEm>
   10a0e:	42a0      	cmp	r0, r4
   10a10:	d900      	bls.n	10a14 <_ZN14USBDeviceClass11recvControlEPvm+0x20>
   10a12:	1c20      	adds	r0, r4, #0
	if (read > len)
		read = len;
	//while (!usbd.epBank0AckTransferComplete(0)) {}
	uint8_t *buffer = udd_ep_out_cache_buffer[0];
	for (uint32_t i=0; i<len; i++) {
   10a14:	2300      	movs	r3, #0
   10a16:	42a3      	cmp	r3, r4
   10a18:	d004      	beq.n	10a24 <_ZN14USBDeviceClass11recvControlEPvm+0x30>
		data[i] = buffer[i];
   10a1a:	4a04      	ldr	r2, [pc, #16]	; (10a2c <_ZN14USBDeviceClass11recvControlEPvm+0x38>)
   10a1c:	5c9a      	ldrb	r2, [r3, r2]
   10a1e:	54ea      	strb	r2, [r5, r3]
	uint32_t read = armRecvCtrlOUT(0);
	if (read > len)
		read = len;
	//while (!usbd.epBank0AckTransferComplete(0)) {}
	uint8_t *buffer = udd_ep_out_cache_buffer[0];
	for (uint32_t i=0; i<len; i++) {
   10a20:	3301      	adds	r3, #1
   10a22:	e7f8      	b.n	10a16 <_ZN14USBDeviceClass11recvControlEPvm+0x22>
		data[i] = buffer[i];
	}

	return read;
}
   10a24:	bd38      	pop	{r3, r4, r5, pc}
   10a26:	46c0      	nop			; (mov r8, r8)
   10a28:	200013e8 	.word	0x200013e8
   10a2c:	20001204 	.word	0x20001204

00010a30 <_ZN14USBDeviceClass7armRecvEm>:
	while (!usbd.epBank0IsTransferComplete(ep)) {}
	return usbd.epBank0ByteCount(ep);
}

uint8_t USBDeviceClass::armRecv(uint32_t ep)
{
   10a30:	b510      	push	{r4, lr}
   10a32:	b2c9      	uxtb	r1, r1
	inline void epBank1SetStallReq(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.STALLRQ1 = 1; }
	inline void epBank0ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ0 = 1; }
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
   10a34:	480c      	ldr	r0, [pc, #48]	; (10a68 <_ZN14USBDeviceClass7armRecvEm+0x38>)
   10a36:	0149      	lsls	r1, r1, #5
   10a38:	1843      	adds	r3, r0, r1
   10a3a:	689a      	ldr	r2, [r3, #8]
   10a3c:	0492      	lsls	r2, r2, #18
   10a3e:	0c92      	lsrs	r2, r2, #18
	uint16_t count = usbd.epBank0ByteCount(ep);
	if (count >= 64) {
   10a40:	2a3f      	cmp	r2, #63	; 0x3f
   10a42:	d908      	bls.n	10a56 <_ZN14USBDeviceClass7armRecvEm+0x26>
		usbd.epBank0SetByteCount(ep, count - 64);
   10a44:	1c14      	adds	r4, r2, #0
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
   10a46:	689a      	ldr	r2, [r3, #8]
   10a48:	3c40      	subs	r4, #64	; 0x40
   10a4a:	04a4      	lsls	r4, r4, #18
   10a4c:	0b92      	lsrs	r2, r2, #14
   10a4e:	0ca4      	lsrs	r4, r4, #18
   10a50:	0392      	lsls	r2, r2, #14
   10a52:	4322      	orrs	r2, r4
   10a54:	e002      	b.n	10a5c <_ZN14USBDeviceClass7armRecvEm+0x2c>
   10a56:	689a      	ldr	r2, [r3, #8]
   10a58:	0b92      	lsrs	r2, r2, #14
   10a5a:	0392      	lsls	r2, r2, #14
   10a5c:	609a      	str	r2, [r3, #8]
	inline void epBank1SetStallReq(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.STALLRQ1 = 1; }
	inline void epBank0ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ0 = 1; }
	inline void epBank1ResetStallReq(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.STALLRQ1 = 1; }

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
   10a5e:	1841      	adds	r1, r0, r1
   10a60:	6888      	ldr	r0, [r1, #8]
	} else {
		usbd.epBank0SetByteCount(ep, 0);
	}
	return usbd.epBank0ByteCount(ep);
   10a62:	b2c0      	uxtb	r0, r0
}
   10a64:	bd10      	pop	{r4, pc}
   10a66:	46c0      	nop			; (mov r8, r8)
   10a68:	200013e8 	.word	0x200013e8

00010a6c <_ZN14USBDeviceClass4recvEmPvm>:
}

// Non Blocking receive
// Return number of bytes read
uint32_t USBDeviceClass::recv(uint32_t ep, void *_data, uint32_t len)
{
   10a6c:	b5f0      	push	{r4, r5, r6, r7, lr}
   10a6e:	1c1c      	adds	r4, r3, #0
	if (!_usbConfiguration)
   10a70:	4b2a      	ldr	r3, [pc, #168]	; (10b1c <_ZN14USBDeviceClass4recvEmPvm+0xb0>)
}

// Non Blocking receive
// Return number of bytes read
uint32_t USBDeviceClass::recv(uint32_t ep, void *_data, uint32_t len)
{
   10a72:	b085      	sub	sp, #20
	if (!_usbConfiguration)
   10a74:	681b      	ldr	r3, [r3, #0]
}

// Non Blocking receive
// Return number of bytes read
uint32_t USBDeviceClass::recv(uint32_t ep, void *_data, uint32_t len)
{
   10a76:	1c06      	adds	r6, r0, #0
   10a78:	1c0d      	adds	r5, r1, #0
   10a7a:	9202      	str	r2, [sp, #8]
	if (!_usbConfiguration)
   10a7c:	2b00      	cmp	r3, #0
   10a7e:	d046      	beq.n	10b0e <_ZN14USBDeviceClass4recvEmPvm+0xa2>
		digitalWrite(PIN_LED_RXL, LOW);

	rxLEDPulse = TX_RX_LED_PULSE_MS;
#endif

	if (epHandlers[ep]) {
   10a80:	4b27      	ldr	r3, [pc, #156]	; (10b20 <_ZN14USBDeviceClass4recvEmPvm+0xb4>)
   10a82:	008a      	lsls	r2, r1, #2
   10a84:	58d0      	ldr	r0, [r2, r3]
   10a86:	2800      	cmp	r0, #0
   10a88:	d005      	beq.n	10a96 <_ZN14USBDeviceClass4recvEmPvm+0x2a>
		return epHandlers[ep]->recv(_data, len);
   10a8a:	6803      	ldr	r3, [r0, #0]
   10a8c:	9902      	ldr	r1, [sp, #8]
   10a8e:	685b      	ldr	r3, [r3, #4]
   10a90:	1c22      	adds	r2, r4, #0
   10a92:	4798      	blx	r3
   10a94:	e03f      	b.n	10b16 <_ZN14USBDeviceClass4recvEmPvm+0xaa>
	}

	if (available(ep) < len)
   10a96:	1c30      	adds	r0, r6, #0
   10a98:	f7ff ff50 	bl	1093c <_ZN14USBDeviceClass9availableEm>
   10a9c:	42a0      	cmp	r0, r4
   10a9e:	d204      	bcs.n	10aaa <_ZN14USBDeviceClass4recvEmPvm+0x3e>
		len = available(ep);
   10aa0:	1c30      	adds	r0, r6, #0
   10aa2:	1c29      	adds	r1, r5, #0
   10aa4:	f7ff ff4a 	bl	1093c <_ZN14USBDeviceClass9availableEm>
   10aa8:	1c04      	adds	r4, r0, #0

	armRecv(ep);
   10aaa:	1c29      	adds	r1, r5, #0
   10aac:	1c30      	adds	r0, r6, #0
   10aae:	f7ff ffbf 	bl	10a30 <_ZN14USBDeviceClass7armRecvEm>
	inline void epBank1EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT1 = 1; }

	inline void epBank0DisableSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTENCLR.bit.RXSTP = 1; }
	inline void epBank0DisableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENCLR.bit.STALL0 = 1; }
	inline void epBank1DisableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENCLR.bit.STALL1 = 1; }
	inline void epBank0DisableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENCLR.bit.TRCPT0 = 1; }
   10ab2:	4f1c      	ldr	r7, [pc, #112]	; (10b24 <_ZN14USBDeviceClass4recvEmPvm+0xb8>)
   10ab4:	b2e9      	uxtb	r1, r5
   10ab6:	014a      	lsls	r2, r1, #5
   10ab8:	9101      	str	r1, [sp, #4]
   10aba:	6839      	ldr	r1, [r7, #0]
   10abc:	9203      	str	r2, [sp, #12]
   10abe:	188b      	adds	r3, r1, r2
   10ac0:	33ff      	adds	r3, #255	; 0xff
   10ac2:	7a5a      	ldrb	r2, [r3, #9]
   10ac4:	2101      	movs	r1, #1
   10ac6:	430a      	orrs	r2, r1

	usbd.epBank0DisableTransferComplete(ep);

	memcpy(_data, udd_ep_out_cache_buffer[ep], len);
   10ac8:	4917      	ldr	r1, [pc, #92]	; (10b28 <_ZN14USBDeviceClass4recvEmPvm+0xbc>)
   10aca:	725a      	strb	r2, [r3, #9]
   10acc:	01ab      	lsls	r3, r5, #6
   10ace:	18c9      	adds	r1, r1, r3
   10ad0:	9802      	ldr	r0, [sp, #8]
   10ad2:	1c22      	adds	r2, r4, #0
   10ad4:	f000 fd71 	bl	115ba <memcpy>

	// release empty buffer
	if (len && !available(ep)) {
   10ad8:	2c00      	cmp	r4, #0
   10ada:	d01b      	beq.n	10b14 <_ZN14USBDeviceClass4recvEmPvm+0xa8>
   10adc:	1c30      	adds	r0, r6, #0
   10ade:	1c29      	adds	r1, r5, #0
   10ae0:	f7ff ff2c 	bl	1093c <_ZN14USBDeviceClass9availableEm>
   10ae4:	2800      	cmp	r0, #0
   10ae6:	d115      	bne.n	10b14 <_ZN14USBDeviceClass4recvEmPvm+0xa8>
	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
   10ae8:	9b01      	ldr	r3, [sp, #4]
   10aea:	683a      	ldr	r2, [r7, #0]
   10aec:	3308      	adds	r3, #8
   10aee:	015b      	lsls	r3, r3, #5
   10af0:	18d3      	adds	r3, r2, r3
   10af2:	7919      	ldrb	r1, [r3, #4]
   10af4:	2040      	movs	r0, #64	; 0x40
   10af6:	4301      	orrs	r1, r0
   10af8:	7119      	strb	r1, [r3, #4]
	inline bool epBank1IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT1; }

	inline void epBank0AckSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP; }
	inline void epBank0AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(1); }
	inline void epBank1AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(2); }
	inline void epBank0AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(1); }
   10afa:	2101      	movs	r1, #1
   10afc:	71d9      	strb	r1, [r3, #7]
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }

	inline void epBank0EnableSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTENSET.bit.RXSTP = 1; }
	inline void epBank0EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL0 = 1; }
	inline void epBank1EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL1 = 1; }
	inline void epBank0EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT0 = 1; }
   10afe:	9903      	ldr	r1, [sp, #12]
   10b00:	1853      	adds	r3, r2, r1
   10b02:	33ff      	adds	r3, #255	; 0xff
   10b04:	7a9a      	ldrb	r2, [r3, #10]
   10b06:	2101      	movs	r1, #1
   10b08:	430a      	orrs	r2, r1
   10b0a:	729a      	strb	r2, [r3, #10]
   10b0c:	e002      	b.n	10b14 <_ZN14USBDeviceClass4recvEmPvm+0xa8>
// Non Blocking receive
// Return number of bytes read
uint32_t USBDeviceClass::recv(uint32_t ep, void *_data, uint32_t len)
{
	if (!_usbConfiguration)
		return -1;
   10b0e:	2001      	movs	r0, #1
   10b10:	4240      	negs	r0, r0
   10b12:	e000      	b.n	10b16 <_ZN14USBDeviceClass4recvEmPvm+0xaa>
   10b14:	1c20      	adds	r0, r4, #0
		// Enable Transfer complete 0 interrupt
		usbd.epBank0EnableTransferComplete(ep);
	}

	return len;
}
   10b16:	b005      	add	sp, #20
   10b18:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10b1a:	46c0      	nop			; (mov r8, r8)
   10b1c:	200014ec 	.word	0x200014ec
   10b20:	200013c4 	.word	0x200013c4
   10b24:	200013e8 	.word	0x200013e8
   10b28:	20001204 	.word	0x20001204

00010b2c <_ZN14USBDeviceClass4recvEm>:

// Recv 1 byte if ready
int USBDeviceClass::recv(uint32_t ep)
{
   10b2c:	b513      	push	{r0, r1, r4, lr}
	uint8_t c;
	if (recv(ep, &c, 1) != 1) {
   10b2e:	466c      	mov	r4, sp
   10b30:	3407      	adds	r4, #7
   10b32:	1c22      	adds	r2, r4, #0
   10b34:	2301      	movs	r3, #1
   10b36:	f7ff ff99 	bl	10a6c <_ZN14USBDeviceClass4recvEmPvm>
   10b3a:	2801      	cmp	r0, #1
   10b3c:	d101      	bne.n	10b42 <_ZN14USBDeviceClass4recvEm+0x16>
		return -1;
	} else {
		return c;
   10b3e:	7820      	ldrb	r0, [r4, #0]
   10b40:	e001      	b.n	10b46 <_ZN14USBDeviceClass4recvEm+0x1a>
// Recv 1 byte if ready
int USBDeviceClass::recv(uint32_t ep)
{
	uint8_t c;
	if (recv(ep, &c, 1) != 1) {
		return -1;
   10b42:	2001      	movs	r0, #1
   10b44:	4240      	negs	r0, r0
	} else {
		return c;
	}
}
   10b46:	bd16      	pop	{r1, r2, r4, pc}

00010b48 <_ZN14USBDeviceClass4sendEmPKvm>:
	0
};

// Blocking Send of data to an endpoint
uint32_t USBDeviceClass::send(uint32_t ep, const void *data, uint32_t len)
{
   10b48:	b5f0      	push	{r4, r5, r6, r7, lr}
   10b4a:	1c1c      	adds	r4, r3, #0
	uint32_t written = 0;
	uint32_t length = 0;

	if (!_usbConfiguration)
   10b4c:	4b3a      	ldr	r3, [pc, #232]	; (10c38 <_ZN14USBDeviceClass4sendEmPKvm+0xf0>)
	0
};

// Blocking Send of data to an endpoint
uint32_t USBDeviceClass::send(uint32_t ep, const void *data, uint32_t len)
{
   10b4e:	b085      	sub	sp, #20
	uint32_t written = 0;
	uint32_t length = 0;

	if (!_usbConfiguration)
   10b50:	681b      	ldr	r3, [r3, #0]
	0
};

// Blocking Send of data to an endpoint
uint32_t USBDeviceClass::send(uint32_t ep, const void *data, uint32_t len)
{
   10b52:	1c0e      	adds	r6, r1, #0
   10b54:	9202      	str	r2, [sp, #8]
	uint32_t written = 0;
	uint32_t length = 0;

	if (!_usbConfiguration)
   10b56:	2b00      	cmp	r3, #0
   10b58:	d060      	beq.n	10c1c <_ZN14USBDeviceClass4sendEmPKvm+0xd4>
		return -1;
	if (len > 16384)
   10b5a:	2380      	movs	r3, #128	; 0x80
   10b5c:	01db      	lsls	r3, r3, #7
   10b5e:	429c      	cmp	r4, r3
   10b60:	d85c      	bhi.n	10c1c <_ZN14USBDeviceClass4sendEmPKvm+0xd4>
   10b62:	2200      	movs	r2, #0
   10b64:	9200      	str	r2, [sp, #0]

	txLEDPulse = TX_RX_LED_PULSE_MS;
#endif

	// Flash area
	while (len != 0)
   10b66:	2c00      	cmp	r4, #0
   10b68:	d056      	beq.n	10c18 <_ZN14USBDeviceClass4sendEmPKvm+0xd0>
	inline void epBank0DisableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENCLR.bit.TRCPT0 = 1; }
	inline void epBank1DisableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENCLR.bit.TRCPT1 = 1; }

	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
   10b6a:	4d34      	ldr	r5, [pc, #208]	; (10c3c <_ZN14USBDeviceClass4sendEmPKvm+0xf4>)
   10b6c:	b2f7      	uxtb	r7, r6
   10b6e:	682b      	ldr	r3, [r5, #0]
   10b70:	9301      	str	r3, [sp, #4]
   10b72:	1c3b      	adds	r3, r7, #0
   10b74:	3308      	adds	r3, #8
   10b76:	9a01      	ldr	r2, [sp, #4]
   10b78:	015b      	lsls	r3, r3, #5
   10b7a:	18d3      	adds	r3, r2, r3
   10b7c:	799b      	ldrb	r3, [r3, #6]
   10b7e:	09db      	lsrs	r3, r3, #7
	{
		if (usbd.epBank1IsReady(ep)) {
   10b80:	d01a      	beq.n	10bb8 <_ZN14USBDeviceClass4sendEmPKvm+0x70>
			// previous transfer is still not complete

			// convert the timeout from microseconds to a number of times through
			// the wait loop; it takes (roughly) 23 clock cycles per iteration.
			uint32_t timeout = microsecondsToClockCycles(TX_TIMEOUT_MS * 1000) / 23;
   10b82:	4b2f      	ldr	r3, [pc, #188]	; (10c40 <_ZN14USBDeviceClass4sendEmPKvm+0xf8>)
   10b84:	492f      	ldr	r1, [pc, #188]	; (10c44 <_ZN14USBDeviceClass4sendEmPKvm+0xfc>)
   10b86:	6818      	ldr	r0, [r3, #0]
   10b88:	f000 fc06 	bl	11398 <__aeabi_uidiv>
   10b8c:	4b2e      	ldr	r3, [pc, #184]	; (10c48 <_ZN14USBDeviceClass4sendEmPKvm+0x100>)
   10b8e:	2117      	movs	r1, #23
   10b90:	4358      	muls	r0, r3
   10b92:	f000 fc01 	bl	11398 <__aeabi_uidiv>

	inline bool epBank0IsSetupReceived(ep_t ep)     { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.RXSTP; }
	inline bool epBank0IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL0; }
	inline bool epBank1IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL1; }
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
	inline bool epBank1IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT1; }
   10b96:	1c3b      	adds	r3, r7, #0
   10b98:	3308      	adds	r3, #8
   10b9a:	9a01      	ldr	r2, [sp, #4]
   10b9c:	015b      	lsls	r3, r3, #5
   10b9e:	18d3      	adds	r3, r2, r3
   10ba0:	79db      	ldrb	r3, [r3, #7]

			// Wait for (previous) transfer to complete
			// inspired by Paul Stoffregen's work on Teensy
			while (!usbd.epBank1IsTransferComplete(ep)) {
   10ba2:	079a      	lsls	r2, r3, #30
   10ba4:	d408      	bmi.n	10bb8 <_ZN14USBDeviceClass4sendEmPKvm+0x70>
				if (LastTransmitTimedOut[ep] || timeout-- == 0) {
   10ba6:	4b29      	ldr	r3, [pc, #164]	; (10c4c <_ZN14USBDeviceClass4sendEmPKvm+0x104>)
   10ba8:	5d9a      	ldrb	r2, [r3, r6]
   10baa:	2a00      	cmp	r2, #0
   10bac:	d138      	bne.n	10c20 <_ZN14USBDeviceClass4sendEmPKvm+0xd8>
   10bae:	1e42      	subs	r2, r0, #1
   10bb0:	2800      	cmp	r0, #0
   10bb2:	d035      	beq.n	10c20 <_ZN14USBDeviceClass4sendEmPKvm+0xd8>
   10bb4:	1c10      	adds	r0, r2, #0
   10bb6:	e7ee      	b.n	10b96 <_ZN14USBDeviceClass4sendEmPKvm+0x4e>
					return -1;
				}
			}
		}

		LastTransmitTimedOut[ep] = 0;
   10bb8:	4b24      	ldr	r3, [pc, #144]	; (10c4c <_ZN14USBDeviceClass4sendEmPKvm+0x104>)
   10bba:	2200      	movs	r2, #0
   10bbc:	559a      	strb	r2, [r3, r6]
   10bbe:	1e25      	subs	r5, r4, #0
   10bc0:	2d3f      	cmp	r5, #63	; 0x3f
   10bc2:	d900      	bls.n	10bc6 <_ZN14USBDeviceClass4sendEmPKvm+0x7e>
   10bc4:	253f      	movs	r5, #63	; 0x3f
		} else {
			length = len;
		}

		/* memcopy could be safer in multi threaded environment */
		memcpy(&udd_ep_in_cache_buffer[ep], data, length);
   10bc6:	4a22      	ldr	r2, [pc, #136]	; (10c50 <_ZN14USBDeviceClass4sendEmPKvm+0x108>)
   10bc8:	01b3      	lsls	r3, r6, #6
   10bca:	18d3      	adds	r3, r2, r3
   10bcc:	1c18      	adds	r0, r3, #0
   10bce:	9902      	ldr	r1, [sp, #8]
   10bd0:	1c2a      	adds	r2, r5, #0
   10bd2:	9303      	str	r3, [sp, #12]
   10bd4:	f000 fcf1 	bl	115ba <memcpy>
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
   10bd8:	4a18      	ldr	r2, [pc, #96]	; (10c3c <_ZN14USBDeviceClass4sendEmPKvm+0xf4>)
   10bda:	017b      	lsls	r3, r7, #5
   10bdc:	18d3      	adds	r3, r2, r3
   10bde:	9a03      	ldr	r2, [sp, #12]

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
   10be0:	04a9      	lsls	r1, r5, #18
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
   10be2:	615a      	str	r2, [r3, #20]

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
   10be4:	699a      	ldr	r2, [r3, #24]
   10be6:	0c89      	lsrs	r1, r1, #18
   10be8:	0b92      	lsrs	r2, r2, #14
   10bea:	0392      	lsls	r2, r2, #14
   10bec:	430a      	orrs	r2, r1
   10bee:	619a      	str	r2, [r3, #24]

	inline void epBank0AckSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP; }
	inline void epBank0AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(1); }
	inline void epBank1AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(2); }
	inline void epBank0AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(1); }
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }
   10bf0:	1c3b      	adds	r3, r7, #0
   10bf2:	9a01      	ldr	r2, [sp, #4]
   10bf4:	3308      	adds	r3, #8
   10bf6:	015b      	lsls	r3, r3, #5
   10bf8:	18d3      	adds	r3, r2, r3
   10bfa:	2202      	movs	r2, #2
   10bfc:	71da      	strb	r2, [r3, #7]

	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
   10bfe:	7959      	ldrb	r1, [r3, #5]
   10c00:	2280      	movs	r2, #128	; 0x80
   10c02:	4252      	negs	r2, r2
   10c04:	430a      	orrs	r2, r1
   10c06:	715a      	strb	r2, [r3, #5]
		usbd.epBank1AckTransferComplete(ep);

		// RAM buffer is full, we can send data (IN)
		usbd.epBank1SetReady(ep);

		written += length;
   10c08:	9b00      	ldr	r3, [sp, #0]
		len -= length;
		data = (char *)data + length;
   10c0a:	9a02      	ldr	r2, [sp, #8]
		usbd.epBank1AckTransferComplete(ep);

		// RAM buffer is full, we can send data (IN)
		usbd.epBank1SetReady(ep);

		written += length;
   10c0c:	195b      	adds	r3, r3, r5
		len -= length;
		data = (char *)data + length;
   10c0e:	1952      	adds	r2, r2, r5
		usbd.epBank1AckTransferComplete(ep);

		// RAM buffer is full, we can send data (IN)
		usbd.epBank1SetReady(ep);

		written += length;
   10c10:	9300      	str	r3, [sp, #0]
		len -= length;
   10c12:	1b64      	subs	r4, r4, r5
		data = (char *)data + length;
   10c14:	9202      	str	r2, [sp, #8]
   10c16:	e7a6      	b.n	10b66 <_ZN14USBDeviceClass4sendEmPKvm+0x1e>
   10c18:	9800      	ldr	r0, [sp, #0]
   10c1a:	e00b      	b.n	10c34 <_ZN14USBDeviceClass4sendEmPKvm+0xec>
{
	uint32_t written = 0;
	uint32_t length = 0;

	if (!_usbConfiguration)
		return -1;
   10c1c:	2001      	movs	r0, #1
   10c1e:	e008      	b.n	10c32 <_ZN14USBDeviceClass4sendEmPKvm+0xea>

			// Wait for (previous) transfer to complete
			// inspired by Paul Stoffregen's work on Teensy
			while (!usbd.epBank1IsTransferComplete(ep)) {
				if (LastTransmitTimedOut[ep] || timeout-- == 0) {
					LastTransmitTimedOut[ep] = 1;
   10c20:	2201      	movs	r2, #1
   10c22:	559a      	strb	r2, [r3, r6]

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
   10c24:	017b      	lsls	r3, r7, #5
   10c26:	18ed      	adds	r5, r5, r3
   10c28:	69ab      	ldr	r3, [r5, #24]

					// set byte count to zero, so that ZLP is sent
					// instead of stale data
					usbd.epBank1SetByteCount(ep, 0);
					return -1;
   10c2a:	1c10      	adds	r0, r2, #0
   10c2c:	0b9b      	lsrs	r3, r3, #14
   10c2e:	039b      	lsls	r3, r3, #14
   10c30:	61ab      	str	r3, [r5, #24]
   10c32:	4240      	negs	r0, r0
		written += length;
		len -= length;
		data = (char *)data + length;
	}
	return written;
}
   10c34:	b005      	add	sp, #20
   10c36:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10c38:	200014ec 	.word	0x200014ec
   10c3c:	200013e8 	.word	0x200013e8
   10c40:	20000098 	.word	0x20000098
   10c44:	000f4240 	.word	0x000f4240
   10c48:	00011170 	.word	0x00011170
   10c4c:	2000103a 	.word	0x2000103a
   10c50:	20001044 	.word	0x20001044

00010c54 <_ZN14USBDeviceClass7armSendEmPKvm>:

uint32_t USBDeviceClass::armSend(uint32_t ep, const void* data, uint32_t len)
{
   10c54:	b570      	push	{r4, r5, r6, lr}
	memcpy(&udd_ep_in_cache_buffer[ep], data, len);
   10c56:	4d0e      	ldr	r5, [pc, #56]	; (10c90 <_ZN14USBDeviceClass7armSendEmPKvm+0x3c>)
	}
	return written;
}

uint32_t USBDeviceClass::armSend(uint32_t ep, const void* data, uint32_t len)
{
   10c58:	1c1c      	adds	r4, r3, #0
	memcpy(&udd_ep_in_cache_buffer[ep], data, len);
   10c5a:	018b      	lsls	r3, r1, #6
   10c5c:	18ed      	adds	r5, r5, r3
   10c5e:	1c28      	adds	r0, r5, #0
	}
	return written;
}

uint32_t USBDeviceClass::armSend(uint32_t ep, const void* data, uint32_t len)
{
   10c60:	1c0e      	adds	r6, r1, #0
	memcpy(&udd_ep_in_cache_buffer[ep], data, len);
   10c62:	1c11      	adds	r1, r2, #0
   10c64:	1c22      	adds	r2, r4, #0
   10c66:	f000 fca8 	bl	115ba <memcpy>
   10c6a:	b2f6      	uxtb	r6, r6
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }

	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
   10c6c:	4909      	ldr	r1, [pc, #36]	; (10c94 <_ZN14USBDeviceClass7armSendEmPKvm+0x40>)
   10c6e:	0176      	lsls	r6, r6, #5
   10c70:	1989      	adds	r1, r1, r6
   10c72:	614d      	str	r5, [r1, #20]
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
   10c74:	698a      	ldr	r2, [r1, #24]
   10c76:	4b08      	ldr	r3, [pc, #32]	; (10c98 <_ZN14USBDeviceClass7armSendEmPKvm+0x44>)
	usbd.epBank1SetAddress(ep, &udd_ep_in_cache_buffer[ep]);
	usbd.epBank1SetMultiPacketSize(ep, 0);
	usbd.epBank1SetByteCount(ep, len);

	return len;
}
   10c78:	1c20      	adds	r0, r4, #0
   10c7a:	4013      	ands	r3, r2
   10c7c:	618b      	str	r3, [r1, #24]

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
   10c7e:	698b      	ldr	r3, [r1, #24]
   10c80:	04a2      	lsls	r2, r4, #18
   10c82:	0b9b      	lsrs	r3, r3, #14
   10c84:	0c92      	lsrs	r2, r2, #18
   10c86:	039b      	lsls	r3, r3, #14
   10c88:	4313      	orrs	r3, r2
   10c8a:	618b      	str	r3, [r1, #24]
   10c8c:	bd70      	pop	{r4, r5, r6, pc}
   10c8e:	46c0      	nop			; (mov r8, r8)
   10c90:	20001044 	.word	0x20001044
   10c94:	200013e8 	.word	0x200013e8
   10c98:	f0003fff 	.word	0xf0003fff

00010c9c <_ZN14USBDeviceClass11sendControlEPKvm>:

uint32_t USBDeviceClass::sendControl(const void* _data, uint32_t len)
{
   10c9c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	const uint8_t *data = reinterpret_cast<const uint8_t *>(_data);
	uint32_t length = len;
	uint32_t sent = 0;
	uint32_t pos = 0;

	if (_dry_run == true)
   10c9e:	4b11      	ldr	r3, [pc, #68]	; (10ce4 <_ZN14USBDeviceClass11sendControlEPKvm+0x48>)

	return len;
}

uint32_t USBDeviceClass::sendControl(const void* _data, uint32_t len)
{
   10ca0:	9001      	str	r0, [sp, #4]
	const uint8_t *data = reinterpret_cast<const uint8_t *>(_data);
	uint32_t length = len;
	uint32_t sent = 0;
	uint32_t pos = 0;

	if (_dry_run == true)
   10ca2:	781b      	ldrb	r3, [r3, #0]

	return len;
}

uint32_t USBDeviceClass::sendControl(const void* _data, uint32_t len)
{
   10ca4:	1c0f      	adds	r7, r1, #0
   10ca6:	1c14      	adds	r4, r2, #0
	const uint8_t *data = reinterpret_cast<const uint8_t *>(_data);
	uint32_t length = len;
	uint32_t sent = 0;
	uint32_t pos = 0;

	if (_dry_run == true)
   10ca8:	2b00      	cmp	r3, #0
   10caa:	d119      	bne.n	10ce0 <_ZN14USBDeviceClass11sendControlEPKvm+0x44>
		return length;

	if (_pack_message == true) {
   10cac:	4b0e      	ldr	r3, [pc, #56]	; (10ce8 <_ZN14USBDeviceClass11sendControlEPKvm+0x4c>)
   10cae:	781e      	ldrb	r6, [r3, #0]
   10cb0:	2e00      	cmp	r6, #0
   10cb2:	d101      	bne.n	10cb8 <_ZN14USBDeviceClass11sendControlEPKvm+0x1c>
   10cb4:	1c15      	adds	r5, r2, #0
   10cb6:	e008      	b.n	10cca <_ZN14USBDeviceClass11sendControlEPKvm+0x2e>
		memcpy(&_pack_buffer[_pack_size], data, len);
   10cb8:	4d0c      	ldr	r5, [pc, #48]	; (10cec <_ZN14USBDeviceClass11sendControlEPKvm+0x50>)
   10cba:	480d      	ldr	r0, [pc, #52]	; (10cf0 <_ZN14USBDeviceClass11sendControlEPKvm+0x54>)
   10cbc:	882e      	ldrh	r6, [r5, #0]
   10cbe:	1980      	adds	r0, r0, r6
		_pack_size += len;
   10cc0:	1936      	adds	r6, r6, r4

	if (_dry_run == true)
		return length;

	if (_pack_message == true) {
		memcpy(&_pack_buffer[_pack_size], data, len);
   10cc2:	f000 fc7a 	bl	115ba <memcpy>
		_pack_size += len;
   10cc6:	802e      	strh	r6, [r5, #0]
   10cc8:	e00a      	b.n	10ce0 <_ZN14USBDeviceClass11sendControlEPKvm+0x44>
		return length;
	}

 	while (len > 0)
   10cca:	2d00      	cmp	r5, #0
   10ccc:	d008      	beq.n	10ce0 <_ZN14USBDeviceClass11sendControlEPKvm+0x44>
 	{
		sent = armSend(EP0, data + pos, len);
   10cce:	19ba      	adds	r2, r7, r6
   10cd0:	1c2b      	adds	r3, r5, #0
   10cd2:	9801      	ldr	r0, [sp, #4]
   10cd4:	2100      	movs	r1, #0
   10cd6:	f7ff ffbd 	bl	10c54 <_ZN14USBDeviceClass7armSendEmPKvm>
		pos += sent;
   10cda:	1836      	adds	r6, r6, r0
		len -= sent;
   10cdc:	1a2d      	subs	r5, r5, r0
   10cde:	e7f4      	b.n	10cca <_ZN14USBDeviceClass11sendControlEPKvm+0x2e>
 	}

	return length;
}
   10ce0:	1c20      	adds	r0, r4, #0
   10ce2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   10ce4:	200013e2 	.word	0x200013e2
   10ce8:	200013e0 	.word	0x200013e0
   10cec:	20001038 	.word	0x20001038
   10cf0:	20000f37 	.word	0x20000f37

00010cf4 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh>:

// Send a USB descriptor string. The string is stored as a
// plain ASCII string but is sent out as UTF-16 with the
// correct 2-byte prefix
bool USBDeviceClass::sendStringDescriptor(const uint8_t *string, uint8_t maxlen)
{
   10cf4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10cf6:	1c0e      	adds	r6, r1, #0
   10cf8:	af00      	add	r7, sp, #0
   10cfa:	1e15      	subs	r5, r2, #0
	if (maxlen < 2)
   10cfc:	2d01      	cmp	r5, #1
   10cfe:	d928      	bls.n	10d52 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x5e>
		return false;

	uint8_t buffer[maxlen];
   10d00:	1dd3      	adds	r3, r2, #7
   10d02:	08db      	lsrs	r3, r3, #3
   10d04:	00db      	lsls	r3, r3, #3
   10d06:	466a      	mov	r2, sp
   10d08:	1ad2      	subs	r2, r2, r3
   10d0a:	4695      	mov	sp, r2
	buffer[0] = strlen((const char*)string) * 2 + 2;
   10d0c:	1c08      	adds	r0, r1, #0
   10d0e:	f000 fd85 	bl	1181c <strlen>
   10d12:	3001      	adds	r0, #1
bool USBDeviceClass::sendStringDescriptor(const uint8_t *string, uint8_t maxlen)
{
	if (maxlen < 2)
		return false;

	uint8_t buffer[maxlen];
   10d14:	466c      	mov	r4, sp
	buffer[0] = strlen((const char*)string) * 2 + 2;
   10d16:	0040      	lsls	r0, r0, #1
	buffer[1] = 0x03;
   10d18:	2303      	movs	r3, #3
{
	if (maxlen < 2)
		return false;

	uint8_t buffer[maxlen];
	buffer[0] = strlen((const char*)string) * 2 + 2;
   10d1a:	7020      	strb	r0, [r4, #0]
	buffer[1] = 0x03;
   10d1c:	7063      	strb	r3, [r4, #1]

	uint8_t i;
	for (i = 2; i < maxlen && *string; i++) {
   10d1e:	2202      	movs	r2, #2
   10d20:	42aa      	cmp	r2, r5
   10d22:	d20e      	bcs.n	10d42 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x4e>
   10d24:	7833      	ldrb	r3, [r6, #0]
   10d26:	2b00      	cmp	r3, #0
   10d28:	d00b      	beq.n	10d42 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x4e>
		buffer[i++] = *string++;
   10d2a:	1c51      	adds	r1, r2, #1
   10d2c:	b2c9      	uxtb	r1, r1
   10d2e:	3601      	adds	r6, #1
   10d30:	54a3      	strb	r3, [r4, r2]
		if (i == maxlen) break;
   10d32:	42a9      	cmp	r1, r5
   10d34:	d004      	beq.n	10d40 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x4c>
		buffer[i] = 0;
   10d36:	2300      	movs	r3, #0
	uint8_t buffer[maxlen];
	buffer[0] = strlen((const char*)string) * 2 + 2;
	buffer[1] = 0x03;

	uint8_t i;
	for (i = 2; i < maxlen && *string; i++) {
   10d38:	3202      	adds	r2, #2
		buffer[i++] = *string++;
		if (i == maxlen) break;
		buffer[i] = 0;
   10d3a:	5463      	strb	r3, [r4, r1]
	uint8_t buffer[maxlen];
	buffer[0] = strlen((const char*)string) * 2 + 2;
	buffer[1] = 0x03;

	uint8_t i;
	for (i = 2; i < maxlen && *string; i++) {
   10d3c:	b2d2      	uxtb	r2, r2
   10d3e:	e7ef      	b.n	10d20 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x2c>
		buffer[i++] = *string++;
   10d40:	1c2a      	adds	r2, r5, #0
		if (i == maxlen) break;
		buffer[i] = 0;
	}

	return USBDevice.sendControl(buffer, i);
   10d42:	4805      	ldr	r0, [pc, #20]	; (10d58 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x64>)
   10d44:	1c21      	adds	r1, r4, #0
   10d46:	f7ff ffa9 	bl	10c9c <_ZN14USBDeviceClass11sendControlEPKvm>
   10d4a:	1e43      	subs	r3, r0, #1
   10d4c:	4198      	sbcs	r0, r3
   10d4e:	b2c0      	uxtb	r0, r0
   10d50:	e000      	b.n	10d54 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x60>
// plain ASCII string but is sent out as UTF-16 with the
// correct 2-byte prefix
bool USBDeviceClass::sendStringDescriptor(const uint8_t *string, uint8_t maxlen)
{
	if (maxlen < 2)
		return false;
   10d52:	2000      	movs	r0, #0
		if (i == maxlen) break;
		buffer[i] = 0;
	}

	return USBDevice.sendControl(buffer, i);
}
   10d54:	46bd      	mov	sp, r7
   10d56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   10d58:	200013e3 	.word	0x200013e3

00010d5c <_ZN14USBDeviceClass12packMessagesEb.part.6>:
bool _dry_run = false;
bool _pack_message = false;
uint16_t _pack_size = 0;
uint8_t _pack_buffer[256];

void USBDeviceClass::packMessages(bool val)
   10d5c:	b508      	push	{r3, lr}
{
	if (val) {
		_pack_message = true;
		_pack_size = 0;
	} else {
		_pack_message = false;
   10d5e:	4b04      	ldr	r3, [pc, #16]	; (10d70 <_ZN14USBDeviceClass12packMessagesEb.part.6+0x14>)
   10d60:	2200      	movs	r2, #0
   10d62:	701a      	strb	r2, [r3, #0]
		sendControl(_pack_buffer, _pack_size);
   10d64:	4b03      	ldr	r3, [pc, #12]	; (10d74 <_ZN14USBDeviceClass12packMessagesEb.part.6+0x18>)
   10d66:	4904      	ldr	r1, [pc, #16]	; (10d78 <_ZN14USBDeviceClass12packMessagesEb.part.6+0x1c>)
   10d68:	881a      	ldrh	r2, [r3, #0]
   10d6a:	f7ff ff97 	bl	10c9c <_ZN14USBDeviceClass11sendControlEPKvm>
	}
}
   10d6e:	bd08      	pop	{r3, pc}
   10d70:	200013e0 	.word	0x200013e0
   10d74:	20001038 	.word	0x20001038
   10d78:	20000f37 	.word	0x20000f37

00010d7c <_ZN14USBDeviceClass17sendConfigurationEm>:
}

// Construct a dynamic configuration descriptor
// This really needs dynamic endpoint allocation etc
uint32_t USBDeviceClass::sendConfiguration(uint32_t maxlen)
{
   10d7c:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t total = 0;
	// Count and measure interfaces
	_dry_run = true;
   10d7e:	4a20      	ldr	r2, [pc, #128]	; (10e00 <_ZN14USBDeviceClass17sendConfigurationEm+0x84>)
}

// Construct a dynamic configuration descriptor
// This really needs dynamic endpoint allocation etc
uint32_t USBDeviceClass::sendConfiguration(uint32_t maxlen)
{
   10d80:	b087      	sub	sp, #28
	uint32_t total = 0;
	// Count and measure interfaces
	_dry_run = true;
   10d82:	2301      	movs	r3, #1

// Construct a dynamic configuration descriptor
// This really needs dynamic endpoint allocation etc
uint32_t USBDeviceClass::sendConfiguration(uint32_t maxlen)
{
	uint32_t total = 0;
   10d84:	2600      	movs	r6, #0
}

// Construct a dynamic configuration descriptor
// This really needs dynamic endpoint allocation etc
uint32_t USBDeviceClass::sendConfiguration(uint32_t maxlen)
{
   10d86:	9100      	str	r1, [sp, #0]
	uint32_t total = 0;
	// Count and measure interfaces
	_dry_run = true;
	uint8_t interfaces = SendInterfaces(&total);
   10d88:	a902      	add	r1, sp, #8
// This really needs dynamic endpoint allocation etc
uint32_t USBDeviceClass::sendConfiguration(uint32_t maxlen)
{
	uint32_t total = 0;
	// Count and measure interfaces
	_dry_run = true;
   10d8a:	7013      	strb	r3, [r2, #0]
}

// Construct a dynamic configuration descriptor
// This really needs dynamic endpoint allocation etc
uint32_t USBDeviceClass::sendConfiguration(uint32_t maxlen)
{
   10d8c:	1c05      	adds	r5, r0, #0
	uint32_t total = 0;
   10d8e:	9602      	str	r6, [sp, #8]
	// Count and measure interfaces
	_dry_run = true;
	uint8_t interfaces = SendInterfaces(&total);
   10d90:	f7ff fc3a 	bl	10608 <_ZN14USBDeviceClass14SendInterfacesEPm>

	_Pragma("pack(1)")
	ConfigDescriptor config = D_CONFIG((uint16_t)(total + sizeof(ConfigDescriptor)), interfaces);
   10d94:	ac03      	add	r4, sp, #12
   10d96:	2709      	movs	r7, #9
uint32_t USBDeviceClass::sendConfiguration(uint32_t maxlen)
{
	uint32_t total = 0;
	// Count and measure interfaces
	_dry_run = true;
	uint8_t interfaces = SendInterfaces(&total);
   10d98:	9001      	str	r0, [sp, #4]

	_Pragma("pack(1)")
	ConfigDescriptor config = D_CONFIG((uint16_t)(total + sizeof(ConfigDescriptor)), interfaces);
   10d9a:	1c3a      	adds	r2, r7, #0
   10d9c:	1c20      	adds	r0, r4, #0
   10d9e:	1c31      	adds	r1, r6, #0
   10da0:	f000 fc14 	bl	115cc <memset>
   10da4:	2302      	movs	r3, #2
   10da6:	7063      	strb	r3, [r4, #1]
   10da8:	2380      	movs	r3, #128	; 0x80
   10daa:	71e3      	strb	r3, [r4, #7]
   10dac:	23fa      	movs	r3, #250	; 0xfa
   10dae:	7223      	strb	r3, [r4, #8]
   10db0:	9b02      	ldr	r3, [sp, #8]
   10db2:	2201      	movs	r2, #1
   10db4:	19db      	adds	r3, r3, r7
   10db6:	8063      	strh	r3, [r4, #2]
   10db8:	9b01      	ldr	r3, [sp, #4]
   10dba:	7162      	strb	r2, [r4, #5]
   10dbc:	7123      	strb	r3, [r4, #4]
	_Pragma("pack()")

	//	Now send them
	_dry_run = false;
   10dbe:	4a10      	ldr	r2, [pc, #64]	; (10e00 <_ZN14USBDeviceClass17sendConfigurationEm+0x84>)

	if (maxlen == sizeof(ConfigDescriptor)) {
   10dc0:	9b00      	ldr	r3, [sp, #0]
	// Count and measure interfaces
	_dry_run = true;
	uint8_t interfaces = SendInterfaces(&total);

	_Pragma("pack(1)")
	ConfigDescriptor config = D_CONFIG((uint16_t)(total + sizeof(ConfigDescriptor)), interfaces);
   10dc2:	7027      	strb	r7, [r4, #0]
	_Pragma("pack()")

	//	Now send them
	_dry_run = false;
   10dc4:	7016      	strb	r6, [r2, #0]

	if (maxlen == sizeof(ConfigDescriptor)) {
   10dc6:	42bb      	cmp	r3, r7
   10dc8:	d105      	bne.n	10dd6 <_ZN14USBDeviceClass17sendConfigurationEm+0x5a>
		sendControl(&config, sizeof(ConfigDescriptor));
   10dca:	1c28      	adds	r0, r5, #0
   10dcc:	1c21      	adds	r1, r4, #0
   10dce:	1c1a      	adds	r2, r3, #0
   10dd0:	f7ff ff64 	bl	10c9c <_ZN14USBDeviceClass11sendControlEPKvm>
		return true;
   10dd4:	e011      	b.n	10dfa <_ZN14USBDeviceClass17sendConfigurationEm+0x7e>
uint8_t _pack_buffer[256];

void USBDeviceClass::packMessages(bool val)
{
	if (val) {
		_pack_message = true;
   10dd6:	4b0b      	ldr	r3, [pc, #44]	; (10e04 <_ZN14USBDeviceClass17sendConfigurationEm+0x88>)
   10dd8:	2201      	movs	r2, #1
   10dda:	701a      	strb	r2, [r3, #0]
		_pack_size = 0;
   10ddc:	4b0a      	ldr	r3, [pc, #40]	; (10e08 <_ZN14USBDeviceClass17sendConfigurationEm+0x8c>)
	}

	total = 0;

	packMessages(true);
	sendControl(&config, sizeof(ConfigDescriptor));
   10dde:	1c21      	adds	r1, r4, #0
   10de0:	1c3a      	adds	r2, r7, #0
   10de2:	1c28      	adds	r0, r5, #0

void USBDeviceClass::packMessages(bool val)
{
	if (val) {
		_pack_message = true;
		_pack_size = 0;
   10de4:	801e      	strh	r6, [r3, #0]
	if (maxlen == sizeof(ConfigDescriptor)) {
		sendControl(&config, sizeof(ConfigDescriptor));
		return true;
	}

	total = 0;
   10de6:	9602      	str	r6, [sp, #8]

	packMessages(true);
	sendControl(&config, sizeof(ConfigDescriptor));
   10de8:	f7ff ff58 	bl	10c9c <_ZN14USBDeviceClass11sendControlEPKvm>
	SendInterfaces(&total);
   10dec:	1c28      	adds	r0, r5, #0
   10dee:	a902      	add	r1, sp, #8
   10df0:	f7ff fc0a 	bl	10608 <_ZN14USBDeviceClass14SendInterfacesEPm>
   10df4:	1c28      	adds	r0, r5, #0
   10df6:	f7ff ffb1 	bl	10d5c <_ZN14USBDeviceClass12packMessagesEb.part.6>
	packMessages(false);

	return true;
}
   10dfa:	2001      	movs	r0, #1
   10dfc:	b007      	add	sp, #28
   10dfe:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10e00:	200013e2 	.word	0x200013e2
   10e04:	200013e0 	.word	0x200013e0
   10e08:	20001038 	.word	0x20001038

00010e0c <_ZN14USBDeviceClass14sendDescriptorER8USBSetup>:

bool USBDeviceClass::sendDescriptor(USBSetup &setup)
{
   10e0c:	b570      	push	{r4, r5, r6, lr}
	uint8_t t = setup.wValueH;
   10e0e:	78ce      	ldrb	r6, [r1, #3]

	return true;
}

bool USBDeviceClass::sendDescriptor(USBSetup &setup)
{
   10e10:	b08a      	sub	sp, #40	; 0x28
   10e12:	1c05      	adds	r5, r0, #0
   10e14:	1c0c      	adds	r4, r1, #0
	uint8_t desc_length = 0;
	bool _cdcComposite;
	int ret;
	const uint8_t *desc_addr = 0;

	if (t == USB_CONFIGURATION_DESCRIPTOR_TYPE)
   10e16:	2e02      	cmp	r6, #2
   10e18:	d108      	bne.n	10e2c <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x20>
	{
		return USBDevice.sendConfiguration(setup.wLength);
   10e1a:	88c9      	ldrh	r1, [r1, #6]
   10e1c:	4823      	ldr	r0, [pc, #140]	; (10eac <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xa0>)
   10e1e:	f7ff ffad 	bl	10d7c <_ZN14USBDeviceClass17sendConfigurationEm>
   10e22:	1c03      	adds	r3, r0, #0
   10e24:	1e58      	subs	r0, r3, #1
   10e26:	4183      	sbcs	r3, r0
   10e28:	b2d8      	uxtb	r0, r3
   10e2a:	e03d      	b.n	10ea8 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x9c>
	}

#ifdef PLUGGABLE_USB_ENABLED
	ret = PluggableUSB().getDescriptor(setup);
   10e2c:	f000 fa8e 	bl	1134c <_Z12PluggableUSBv>
   10e30:	1c21      	adds	r1, r4, #0
   10e32:	f000 fa5a 	bl	112ea <_ZN13PluggableUSB_13getDescriptorER8USBSetup>
	if (ret != 0) {
   10e36:	2800      	cmp	r0, #0
   10e38:	d003      	beq.n	10e42 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x36>
		return (ret > 0 ? true : false);
   10e3a:	17c3      	asrs	r3, r0, #31
   10e3c:	1a1b      	subs	r3, r3, r0
   10e3e:	0fd8      	lsrs	r0, r3, #31
   10e40:	e032      	b.n	10ea8 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x9c>
	}
#endif

	if (t == USB_DEVICE_DESCRIPTOR_TYPE)
   10e42:	2e01      	cmp	r6, #1
   10e44:	d104      	bne.n	10e50 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x44>
		if (setup.wLength == 8)
			_cdcComposite = 1;

		desc_addr = _cdcComposite ?  (const uint8_t*)&USB_DeviceDescriptorB : (const uint8_t*)&USB_DeviceDescriptor;

		if (*desc_addr > setup.wLength) {
   10e46:	88e2      	ldrh	r2, [r4, #6]
   10e48:	4919      	ldr	r1, [pc, #100]	; (10eb0 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xa4>)
   10e4a:	2a11      	cmp	r2, #17
   10e4c:	d827      	bhi.n	10e9e <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x92>
   10e4e:	e023      	b.n	10e98 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x8c>
			desc_length = setup.wLength;
		}
	}
	else if (USB_STRING_DESCRIPTOR_TYPE == t)
   10e50:	2e03      	cmp	r6, #3
   10e52:	d129      	bne.n	10ea8 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x9c>
	{
		if (setup.wValueL == 0) {
   10e54:	78a2      	ldrb	r2, [r4, #2]
   10e56:	2a00      	cmp	r2, #0
   10e58:	d105      	bne.n	10e66 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x5a>
#endif
		}
		else {
			return false;
		}
		if (*desc_addr > setup.wLength) {
   10e5a:	4916      	ldr	r1, [pc, #88]	; (10eb4 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xa8>)
   10e5c:	88e2      	ldrh	r2, [r4, #6]
   10e5e:	780b      	ldrb	r3, [r1, #0]
   10e60:	4293      	cmp	r3, r2
   10e62:	d819      	bhi.n	10e98 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x8c>
   10e64:	e01b      	b.n	10e9e <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x92>
	else if (USB_STRING_DESCRIPTOR_TYPE == t)
	{
		if (setup.wValueL == 0) {
			desc_addr = (const uint8_t*)&STRING_LANGUAGE;
		}
		else if (setup.wValueL == IPRODUCT) {
   10e66:	2a02      	cmp	r2, #2
   10e68:	d103      	bne.n	10e72 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x66>
			return sendStringDescriptor(STRING_PRODUCT, setup.wLength);
   10e6a:	79a2      	ldrb	r2, [r4, #6]
   10e6c:	1c28      	adds	r0, r5, #0
   10e6e:	4912      	ldr	r1, [pc, #72]	; (10eb8 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xac>)
   10e70:	e004      	b.n	10e7c <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x70>
		}
		else if (setup.wValueL == IMANUFACTURER) {
   10e72:	2a01      	cmp	r2, #1
   10e74:	d105      	bne.n	10e82 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x76>
			return sendStringDescriptor(STRING_MANUFACTURER, setup.wLength);
   10e76:	79a2      	ldrb	r2, [r4, #6]
   10e78:	4910      	ldr	r1, [pc, #64]	; (10ebc <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xb0>)
   10e7a:	1c28      	adds	r0, r5, #0
   10e7c:	f7ff ff3a 	bl	10cf4 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh>
   10e80:	e012      	b.n	10ea8 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x9c>
		}
		else if (setup.wValueL == ISERIAL) {
   10e82:	2a03      	cmp	r2, #3
   10e84:	d110      	bne.n	10ea8 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x9c>
#ifdef PLUGGABLE_USB_ENABLED
			char name[ISERIAL_MAX_LEN];
			PluggableUSB().getShortName(name);
   10e86:	f000 fa61 	bl	1134c <_Z12PluggableUSBv>
   10e8a:	a901      	add	r1, sp, #4
   10e8c:	f000 fa3d 	bl	1130a <_ZN13PluggableUSB_12getShortNameEPc>
			return sendStringDescriptor((uint8_t*)name, setup.wLength);
   10e90:	79a2      	ldrb	r2, [r4, #6]
   10e92:	1c28      	adds	r0, r5, #0
   10e94:	a901      	add	r1, sp, #4
   10e96:	e7f1      	b.n	10e7c <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x70>
		}
		else {
			return false;
		}
		if (*desc_addr > setup.wLength) {
			desc_length = setup.wLength;
   10e98:	b2d2      	uxtb	r2, r2

	if (desc_addr == 0) {
		return false;
	}

	if (desc_length == 0) {
   10e9a:	2a00      	cmp	r2, #0
   10e9c:	d100      	bne.n	10ea0 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x94>
		desc_length = *desc_addr;
   10e9e:	780a      	ldrb	r2, [r1, #0]
	}

	sendControl(desc_addr, desc_length);
   10ea0:	1c28      	adds	r0, r5, #0
   10ea2:	f7ff fefb 	bl	10c9c <_ZN14USBDeviceClass11sendControlEPKvm>

	return true;
   10ea6:	2001      	movs	r0, #1
}
   10ea8:	b00a      	add	sp, #40	; 0x28
   10eaa:	bd70      	pop	{r4, r5, r6, pc}
   10eac:	200013e3 	.word	0x200013e3
   10eb0:	00015b40 	.word	0x00015b40
   10eb4:	00015b3c 	.word	0x00015b3c
   10eb8:	00015b52 	.word	0x00015b52
   10ebc:	00015b30 	.word	0x00015b30

00010ec0 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup>:
	// Set the byte count as zero
	usbd.epBank1SetByteCount(ep, 0);
}

bool USBDeviceClass::handleStandardSetup(USBSetup &setup)
{
   10ec0:	b573      	push	{r0, r1, r4, r5, r6, lr}
   10ec2:	1c05      	adds	r5, r0, #0
	switch (setup.bRequest) {
   10ec4:	7848      	ldrb	r0, [r1, #1]
	// Set the byte count as zero
	usbd.epBank1SetByteCount(ep, 0);
}

bool USBDeviceClass::handleStandardSetup(USBSetup &setup)
{
   10ec6:	1c0c      	adds	r4, r1, #0
	switch (setup.bRequest) {
   10ec8:	280b      	cmp	r0, #11
   10eca:	d878      	bhi.n	10fbe <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xfe>
   10ecc:	f000 fa50 	bl	11370 <__gnu_thumb1_case_uqi>
   10ed0:	28771c08 	.word	0x28771c08
   10ed4:	06433e77 	.word	0x06433e77
   10ed8:	6f684b47 	.word	0x6f684b47

	case GET_DESCRIPTOR:
		return sendDescriptor(setup);

	case SET_DESCRIPTOR:
		return false;
   10edc:	2000      	movs	r0, #0
   10ede:	e06f      	b.n	10fc0 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x100>

bool USBDeviceClass::handleStandardSetup(USBSetup &setup)
{
	switch (setup.bRequest) {
	case GET_STATUS:
		if (setup.bmRequestType == 0)  // device
   10ee0:	7809      	ldrb	r1, [r1, #0]
   10ee2:	aa01      	add	r2, sp, #4
   10ee4:	2900      	cmp	r1, #0
   10ee6:	d103      	bne.n	10ef0 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x30>
		{
			// Send the device status
			// TODO: Check current configuration for power mode (if device is configured)
			// TODO: Check if remote wake-up is enabled
			uint8_t buff[] = { 0, 0 };
   10ee8:	7011      	strb	r1, [r2, #0]
   10eea:	7051      	strb	r1, [r2, #1]
			armSend(0, buff, 2);
   10eec:	1c28      	adds	r0, r5, #0
   10eee:	e009      	b.n	10f04 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x44>
		// if( setup.bmRequestType == 2 ) // Endpoint:
		else
		{
			// Send the endpoint status
			// Check if the endpoint if currently halted
			uint8_t buff[] = { 0, 0 };
   10ef0:	2300      	movs	r3, #0
   10ef2:	7013      	strb	r3, [r2, #0]
   10ef4:	7053      	strb	r3, [r2, #1]
			if (isEndpointHalt == 1)
   10ef6:	4b33      	ldr	r3, [pc, #204]	; (10fc4 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x104>)
   10ef8:	781b      	ldrb	r3, [r3, #0]
   10efa:	2b01      	cmp	r3, #1
   10efc:	d100      	bne.n	10f00 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x40>
				buff[0] = 1;
   10efe:	7013      	strb	r3, [r2, #0]
			armSend(0, buff, 2);
   10f00:	1c28      	adds	r0, r5, #0
   10f02:	2100      	movs	r1, #0
   10f04:	2302      	movs	r3, #2
   10f06:	e04f      	b.n	10fa8 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xe8>
			return true;
		}

	case CLEAR_FEATURE:
		// Check which is the selected feature
		if (setup.wValueL == 1) // DEVICEREMOTEWAKEUP
   10f08:	788a      	ldrb	r2, [r1, #2]
   10f0a:	2300      	movs	r3, #0
   10f0c:	2a01      	cmp	r2, #1
   10f0e:	d104      	bne.n	10f1a <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x5a>
		{
			// Enable remote wake-up and send a ZLP
			uint8_t buff[] = { 0, 0 };
   10f10:	aa01      	add	r2, sp, #4
   10f12:	7013      	strb	r3, [r2, #0]
   10f14:	7053      	strb	r3, [r2, #1]
			if (isRemoteWakeUpEnabled == 1)
   10f16:	4b2c      	ldr	r3, [pc, #176]	; (10fc8 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x108>)
   10f18:	e7ee      	b.n	10ef8 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x38>
			armSend(0, buff, 2);
			return true;
		}
		else // if( setup.wValueL == 0) // ENDPOINTHALT
		{
			isEndpointHalt = 0;
   10f1a:	4a2a      	ldr	r2, [pc, #168]	; (10fc4 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x104>)
   10f1c:	7013      	strb	r3, [r2, #0]
   10f1e:	e049      	b.n	10fb4 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xf4>
			return true;
		}

	case SET_FEATURE:
		// Check which is the selected feature
		if (setup.wValueL == 1) // DEVICEREMOTEWAKEUP
   10f20:	788e      	ldrb	r6, [r1, #2]
   10f22:	2e01      	cmp	r6, #1
   10f24:	d107      	bne.n	10f36 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x76>
		{
			// Enable remote wake-up and send a ZLP
			isRemoteWakeUpEnabled = 1;
   10f26:	4b28      	ldr	r3, [pc, #160]	; (10fc8 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x108>)
			uint8_t buff[] = { 0 };
   10f28:	aa01      	add	r2, sp, #4
   10f2a:	2100      	movs	r1, #0
	case SET_FEATURE:
		// Check which is the selected feature
		if (setup.wValueL == 1) // DEVICEREMOTEWAKEUP
		{
			// Enable remote wake-up and send a ZLP
			isRemoteWakeUpEnabled = 1;
   10f2c:	701e      	strb	r6, [r3, #0]
			uint8_t buff[] = { 0 };
   10f2e:	7011      	strb	r1, [r2, #0]
			armSend(0, buff, 1);
   10f30:	1c28      	adds	r0, r5, #0
   10f32:	1c33      	adds	r3, r6, #0
   10f34:	e038      	b.n	10fa8 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xe8>
			return true;
		}
		if (setup.wValueL == 0) // ENDPOINTHALT
   10f36:	2e00      	cmp	r6, #0
   10f38:	d108      	bne.n	10f4c <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x8c>
		{
			// Halt endpoint
			isEndpointHalt = 1;
   10f3a:	4a22      	ldr	r2, [pc, #136]	; (10fc4 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x104>)
   10f3c:	2301      	movs	r3, #1
   10f3e:	7013      	strb	r3, [r2, #0]
   10f40:	4a22      	ldr	r2, [pc, #136]	; (10fcc <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x10c>)
   10f42:	6991      	ldr	r1, [r2, #24]
   10f44:	0b89      	lsrs	r1, r1, #14
   10f46:	0389      	lsls	r1, r1, #14
   10f48:	6191      	str	r1, [r2, #24]
   10f4a:	e038      	b.n	10fbe <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xfe>
			sendZlp(0);
			return true;
		}

	case SET_ADDRESS:
		setAddress(setup.wValueL);
   10f4c:	78a1      	ldrb	r1, [r4, #2]
   10f4e:	1c28      	adds	r0, r5, #0
   10f50:	f7ff fc0a 	bl	10768 <_ZN14USBDeviceClass10setAddressEm>
   10f54:	e033      	b.n	10fbe <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xfe>
		return true;

	case GET_DESCRIPTOR:
		return sendDescriptor(setup);
   10f56:	1c28      	adds	r0, r5, #0
   10f58:	f7ff ff58 	bl	10e0c <_ZN14USBDeviceClass14sendDescriptorER8USBSetup>
   10f5c:	e030      	b.n	10fc0 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x100>

	case SET_DESCRIPTOR:
		return false;

	case GET_CONFIGURATION:
		armSend(0, (void*)&_usbConfiguration, 1);
   10f5e:	1c28      	adds	r0, r5, #0
   10f60:	2100      	movs	r1, #0
   10f62:	4a1b      	ldr	r2, [pc, #108]	; (10fd0 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x110>)
   10f64:	e01f      	b.n	10fa6 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xe6>
		return true;

	case SET_CONFIGURATION:
		if (REQUEST_DEVICE == (setup.bmRequestType & REQUEST_RECIPIENT)) {
   10f66:	780a      	ldrb	r2, [r1, #0]
			#endif

			sendZlp(0);
			return true;
		} else {
			return false;
   10f68:	2000      	movs	r0, #0
	case GET_CONFIGURATION:
		armSend(0, (void*)&_usbConfiguration, 1);
		return true;

	case SET_CONFIGURATION:
		if (REQUEST_DEVICE == (setup.bmRequestType & REQUEST_RECIPIENT)) {
   10f6a:	06d3      	lsls	r3, r2, #27
   10f6c:	d128      	bne.n	10fc0 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x100>

			initEndpoints();
   10f6e:	1c28      	adds	r0, r5, #0
   10f70:	f7ff fcd2 	bl	10918 <_ZN14USBDeviceClass13initEndpointsEv>
			_usbConfiguration = setup.wValueL;
   10f74:	78a2      	ldrb	r2, [r4, #2]

	inline void epBank0EnableSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTENSET.bit.RXSTP = 1; }
	inline void epBank0EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL0 = 1; }
	inline void epBank1EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL1 = 1; }
	inline void epBank0EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT0 = 1; }
	inline void epBank1EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT1 = 1; }
   10f76:	4915      	ldr	r1, [pc, #84]	; (10fcc <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x10c>)
   10f78:	4b15      	ldr	r3, [pc, #84]	; (10fd0 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x110>)
   10f7a:	2402      	movs	r4, #2
   10f7c:	601a      	str	r2, [r3, #0]
   10f7e:	680a      	ldr	r2, [r1, #0]
   10f80:	232a      	movs	r3, #42	; 0x2a
   10f82:	33ff      	adds	r3, #255	; 0xff
   10f84:	5cd0      	ldrb	r0, [r2, r3]
   10f86:	4320      	orrs	r0, r4
   10f88:	54d0      	strb	r0, [r2, r3]
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }

	inline void epBank0EnableSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTENSET.bit.RXSTP = 1; }
	inline void epBank0EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL0 = 1; }
	inline void epBank1EnableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENSET.bit.STALL1 = 1; }
	inline void epBank0EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT0 = 1; }
   10f8a:	204a      	movs	r0, #74	; 0x4a
   10f8c:	30ff      	adds	r0, #255	; 0xff
   10f8e:	5c14      	ldrb	r4, [r2, r0]
   10f90:	2301      	movs	r3, #1
   10f92:	431c      	orrs	r4, r3
   10f94:	5414      	strb	r4, [r2, r0]

	// Packet
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
	inline uint16_t epBank1ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT; }
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
   10f96:	698a      	ldr	r2, [r1, #24]
   10f98:	0b92      	lsrs	r2, r2, #14
   10f9a:	0392      	lsls	r2, r2, #14
   10f9c:	618a      	str	r2, [r1, #24]
   10f9e:	e00e      	b.n	10fbe <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xfe>
		} else {
			return false;
		}

	case GET_INTERFACE:
		armSend(0, (void*)&_usbSetInterface, 1);
   10fa0:	4a0c      	ldr	r2, [pc, #48]	; (10fd4 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x114>)
   10fa2:	1c28      	adds	r0, r5, #0
   10fa4:	2100      	movs	r1, #0
   10fa6:	2301      	movs	r3, #1
   10fa8:	f7ff fe54 	bl	10c54 <_ZN14USBDeviceClass7armSendEmPKvm>
   10fac:	e007      	b.n	10fbe <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xfe>
		return true;

	case SET_INTERFACE:
		_usbSetInterface = setup.wValueL;
   10fae:	788a      	ldrb	r2, [r1, #2]
   10fb0:	4b08      	ldr	r3, [pc, #32]	; (10fd4 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x114>)
   10fb2:	601a      	str	r2, [r3, #0]
   10fb4:	4b05      	ldr	r3, [pc, #20]	; (10fcc <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x10c>)
   10fb6:	699a      	ldr	r2, [r3, #24]
   10fb8:	0b92      	lsrs	r2, r2, #14
   10fba:	0392      	lsls	r2, r2, #14
   10fbc:	619a      	str	r2, [r3, #24]
		sendZlp(0);
		return true;

	default:
		return true;
   10fbe:	2001      	movs	r0, #1
	}
}
   10fc0:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
   10fc2:	46c0      	nop			; (mov r8, r8)
   10fc4:	20000f36 	.word	0x20000f36
   10fc8:	200013e1 	.word	0x200013e1
   10fcc:	200013e8 	.word	0x200013e8
   10fd0:	200014ec 	.word	0x200014ec
   10fd4:	200013e4 	.word	0x200013e4

00010fd8 <_ZN14USBDeviceClass10ISRHandlerEv>:

void USBDeviceClass::ISRHandler()
{
   10fd8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

	if (_pack_message == true) {
   10fda:	4b3b      	ldr	r3, [pc, #236]	; (110c8 <_ZN14USBDeviceClass10ISRHandlerEv+0xf0>)
		return true;
	}
}

void USBDeviceClass::ISRHandler()
{
   10fdc:	1c07      	adds	r7, r0, #0

	if (_pack_message == true) {
   10fde:	781c      	ldrb	r4, [r3, #0]
   10fe0:	2c00      	cmp	r4, #0
   10fe2:	d16f      	bne.n	110c4 <_ZN14USBDeviceClass10ISRHandlerEv+0xec>
	// Authorize attach if Vbus is present
	inline void attach() { usb.CTRLB.bit.DETACH = 0; }
	inline void detach() { usb.CTRLB.bit.DETACH = 1; }

	// USB Interrupts
	inline bool isEndOfResetInterrupt()        { return usb.INTFLAG.bit.EORST; }
   10fe4:	4d39      	ldr	r5, [pc, #228]	; (110cc <_ZN14USBDeviceClass10ISRHandlerEv+0xf4>)
   10fe6:	6828      	ldr	r0, [r5, #0]
   10fe8:	8b83      	ldrh	r3, [r0, #28]
		return;
	}
	// End-Of-Reset
	if (usbd.isEndOfResetInterrupt())
   10fea:	0719      	lsls	r1, r3, #28
   10fec:	d50d      	bpl.n	1100a <_ZN14USBDeviceClass10ISRHandlerEv+0x32>
   10fee:	1c20      	adds	r0, r4, #0
   10ff0:	f7ff f92e 	bl	10250 <_ZN14USBDeviceClass6initEPEmm.part.4>
	inline void epBank0AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(1); }
	inline void epBank1AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(2); }
	inline void epBank0AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(1); }
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }

	inline void epBank0EnableSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTENSET.bit.RXSTP = 1; }
   10ff4:	682b      	ldr	r3, [r5, #0]
   10ff6:	2010      	movs	r0, #16
   10ff8:	1c1a      	adds	r2, r3, #0
   10ffa:	32ff      	adds	r2, #255	; 0xff
   10ffc:	7a91      	ldrb	r1, [r2, #10]
   10ffe:	4301      	orrs	r1, r0
   11000:	7291      	strb	r1, [r2, #10]
		initEP(0, USB_ENDPOINT_TYPE_CONTROL);

		// Enable Setup-Received interrupt
		usbd.epBank0EnableSetupReceived(0);

		_usbConfiguration = 0;
   11002:	4a33      	ldr	r2, [pc, #204]	; (110d0 <_ZN14USBDeviceClass10ISRHandlerEv+0xf8>)
   11004:	6014      	str	r4, [r2, #0]
	inline void attach() { usb.CTRLB.bit.DETACH = 0; }
	inline void detach() { usb.CTRLB.bit.DETACH = 1; }

	// USB Interrupts
	inline bool isEndOfResetInterrupt()        { return usb.INTFLAG.bit.EORST; }
	inline void ackEndOfResetInterrupt()       { usb.INTFLAG.reg = USB_DEVICE_INTFLAG_EORST; }
   11006:	2208      	movs	r2, #8
   11008:	839a      	strh	r2, [r3, #28]
	inline void enableEndOfResetInterrupt()    { usb.INTENSET.bit.EORST = 1; }
	inline void disableEndOfResetInterrupt()   { usb.INTENCLR.bit.EORST = 1; }

	inline bool isStartOfFrameInterrupt()      { return usb.INTFLAG.bit.SOF; }
   1100a:	682b      	ldr	r3, [r5, #0]
   1100c:	8b9a      	ldrh	r2, [r3, #28]

		usbd.ackEndOfResetInterrupt();
	}

	// Start-Of-Frame
	if (usbd.isStartOfFrameInterrupt())
   1100e:	0750      	lsls	r0, r2, #29
   11010:	d501      	bpl.n	11016 <_ZN14USBDeviceClass10ISRHandlerEv+0x3e>
	inline void ackStartOfFrameInterrupt()     { usb.INTFLAG.reg = USB_DEVICE_INTFLAG_SOF; }
   11012:	2204      	movs	r2, #4
   11014:	839a      	strh	r2, [r3, #28]
	inline void epBank1SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = type; }

	// Interrupts
	inline uint16_t epInterruptSummary() { return usb.EPINTSMRY.reg; }

	inline bool epBank0IsSetupReceived(ep_t ep)     { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.RXSTP; }
   11016:	33ff      	adds	r3, #255	; 0xff
   11018:	7a1a      	ldrb	r2, [r3, #8]
		}
#endif
	}

	// Endpoint 0 Received Setup interrupt
	if (usbd.epBank0IsSetupReceived(0))
   1101a:	06d1      	lsls	r1, r2, #27
   1101c:	d526      	bpl.n	1106c <_ZN14USBDeviceClass10ISRHandlerEv+0x94>
	inline bool epBank0IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL0; }
	inline bool epBank1IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL1; }
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
	inline bool epBank1IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT1; }

	inline void epBank0AckSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP; }
   1101e:	2210      	movs	r2, #16
   11020:	721a      	strb	r2, [r3, #8]
	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
   11022:	795a      	ldrb	r2, [r3, #5]
   11024:	2140      	movs	r1, #64	; 0x40
   11026:	430a      	orrs	r2, r1
		/* Clear the Bank 0 ready flag on Control OUT */
		// The RAM Buffer is empty: we can receive data
		usbd.epBank0ResetReady(0);

		bool ok;
		if (REQUEST_STANDARD == (setup->bmRequestType & REQUEST_TYPE)) {
   11028:	492a      	ldr	r1, [pc, #168]	; (110d4 <_ZN14USBDeviceClass10ISRHandlerEv+0xfc>)
   1102a:	715a      	strb	r2, [r3, #5]
   1102c:	780a      	ldrb	r2, [r1, #0]
   1102e:	2360      	movs	r3, #96	; 0x60
			// Standard Requests
			ok = handleStandardSetup(*setup);
   11030:	1c38      	adds	r0, r7, #0
		/* Clear the Bank 0 ready flag on Control OUT */
		// The RAM Buffer is empty: we can receive data
		usbd.epBank0ResetReady(0);

		bool ok;
		if (REQUEST_STANDARD == (setup->bmRequestType & REQUEST_TYPE)) {
   11032:	421a      	tst	r2, r3
   11034:	d102      	bne.n	1103c <_ZN14USBDeviceClass10ISRHandlerEv+0x64>
			// Standard Requests
			ok = handleStandardSetup(*setup);
   11036:	f7ff ff43 	bl	10ec0 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup>
   1103a:	e001      	b.n	11040 <_ZN14USBDeviceClass10ISRHandlerEv+0x68>
		} else {
			// Class Interface Requests
			ok = handleClassInterfaceSetup(*setup);
   1103c:	f7ff fbb8 	bl	107b0 <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup>
		}

		if (ok) {
   11040:	2800      	cmp	r0, #0
   11042:	d006      	beq.n	11052 <_ZN14USBDeviceClass10ISRHandlerEv+0x7a>

	// Status
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
   11044:	682b      	ldr	r3, [r5, #0]
   11046:	2280      	movs	r2, #128	; 0x80
   11048:	33ff      	adds	r3, #255	; 0xff
   1104a:	7999      	ldrb	r1, [r3, #6]
   1104c:	4252      	negs	r2, r2
   1104e:	430a      	orrs	r2, r1
   11050:	e001      	b.n	11056 <_ZN14USBDeviceClass10ISRHandlerEv+0x7e>
{
	// TODO: test
	// TODO: use .bit. notation

	// Stall endpoint
	USB->DEVICE.DeviceEndpoint[ep].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_STALLRQ(2);
   11052:	4b21      	ldr	r3, [pc, #132]	; (110d8 <_ZN14USBDeviceClass10ISRHandlerEv+0x100>)
   11054:	2220      	movs	r2, #32
   11056:	719a      	strb	r2, [r3, #6]
	// Interrupts
	inline uint16_t epInterruptSummary() { return usb.EPINTSMRY.reg; }

	inline bool epBank0IsSetupReceived(ep_t ep)     { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.RXSTP; }
	inline bool epBank0IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL0; }
	inline bool epBank1IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL1; }
   11058:	682b      	ldr	r3, [r5, #0]
   1105a:	33ff      	adds	r3, #255	; 0xff
   1105c:	7a1a      	ldrb	r2, [r3, #8]
			usbd.epBank1SetReady(0);
		} else {
			stall(0);
		}

		if (usbd.epBank1IsStalled(0))
   1105e:	0650      	lsls	r0, r2, #25
   11060:	d504      	bpl.n	1106c <_ZN14USBDeviceClass10ISRHandlerEv+0x94>
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
	inline bool epBank1IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT1; }

	inline void epBank0AckSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP; }
	inline void epBank0AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(1); }
	inline void epBank1AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(2); }
   11062:	2240      	movs	r2, #64	; 0x40
   11064:	721a      	strb	r2, [r3, #8]
	inline void epBank0EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT0 = 1; }
	inline void epBank1EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT1 = 1; }

	inline void epBank0DisableSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTENCLR.bit.RXSTP = 1; }
	inline void epBank0DisableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENCLR.bit.STALL0 = 1; }
	inline void epBank1DisableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENCLR.bit.STALL1 = 1; }
   11066:	7a59      	ldrb	r1, [r3, #9]
   11068:	430a      	orrs	r2, r1
   1106a:	725a      	strb	r2, [r3, #9]
	// Config
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
	inline void epBank1SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = type; }

	// Interrupts
	inline uint16_t epInterruptSummary() { return usb.EPINTSMRY.reg; }
   1106c:	6829      	ldr	r1, [r5, #0]
		}

	} // end Received Setup handler

	uint8_t i=0;
	uint8_t ept_int = usbd.epInterruptSummary() & 0xFE; // Remove endpoint number 0 (setup)
   1106e:	23fe      	movs	r3, #254	; 0xfe
   11070:	8c0e      	ldrh	r6, [r1, #32]
	while (ept_int != 0)
   11072:	2400      	movs	r4, #0
		}

	} // end Received Setup handler

	uint8_t i=0;
	uint8_t ept_int = usbd.epInterruptSummary() & 0xFE; // Remove endpoint number 0 (setup)
   11074:	401e      	ands	r6, r3
   11076:	b2e1      	uxtb	r1, r4
	while (ept_int != 0)
   11078:	2e00      	cmp	r6, #0
   1107a:	d023      	beq.n	110c4 <_ZN14USBDeviceClass10ISRHandlerEv+0xec>
	{
		// Check if endpoint has a pending interrupt
		if ((ept_int & (1 << i)) != 0)
   1107c:	1c32      	adds	r2, r6, #0
   1107e:	2301      	movs	r3, #1
   11080:	4122      	asrs	r2, r4
   11082:	421a      	tst	r2, r3
   11084:	d016      	beq.n	110b4 <_ZN14USBDeviceClass10ISRHandlerEv+0xdc>

	inline bool epBank0IsSetupReceived(ep_t ep)     { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.RXSTP; }
	inline bool epBank0IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL0; }
	inline bool epBank1IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL1; }
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
   11086:	1c22      	adds	r2, r4, #0
   11088:	6828      	ldr	r0, [r5, #0]
   1108a:	3208      	adds	r2, #8
   1108c:	0152      	lsls	r2, r2, #5
   1108e:	1882      	adds	r2, r0, r2
   11090:	79d0      	ldrb	r0, [r2, #7]
		{
			// Endpoint Transfer Complete (0/1) Interrupt
			if (usbd.epBank0IsTransferComplete(i) ||
   11092:	4218      	tst	r0, r3
   11094:	d103      	bne.n	1109e <_ZN14USBDeviceClass10ISRHandlerEv+0xc6>
	inline bool epBank1IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT1; }
   11096:	79d2      	ldrb	r2, [r2, #7]
   11098:	40da      	lsrs	r2, r3
   1109a:	421a      	tst	r2, r3
   1109c:	d007      	beq.n	110ae <_ZN14USBDeviceClass10ISRHandlerEv+0xd6>
			    usbd.epBank1IsTransferComplete(i))
			{
				if (epHandlers[i]) {
   1109e:	4b0f      	ldr	r3, [pc, #60]	; (110dc <_ZN14USBDeviceClass10ISRHandlerEv+0x104>)
   110a0:	00a2      	lsls	r2, r4, #2
   110a2:	58d0      	ldr	r0, [r2, r3]
   110a4:	2800      	cmp	r0, #0
   110a6:	d009      	beq.n	110bc <_ZN14USBDeviceClass10ISRHandlerEv+0xe4>
					epHandlers[i]->handleEndpoint();
   110a8:	6803      	ldr	r3, [r0, #0]
   110aa:	681b      	ldr	r3, [r3, #0]
   110ac:	4798      	blx	r3
				} else {
					handleEndpoint(i);
				}
			}
			ept_int &= ~(1 << i);
   110ae:	2301      	movs	r3, #1
   110b0:	40a3      	lsls	r3, r4
   110b2:	439e      	bics	r6, r3
   110b4:	3401      	adds	r4, #1
		}
		i++;
		if (i > USB_EPT_NUM)
   110b6:	2c09      	cmp	r4, #9
   110b8:	d1dd      	bne.n	11076 <_ZN14USBDeviceClass10ISRHandlerEv+0x9e>
   110ba:	e003      	b.n	110c4 <_ZN14USBDeviceClass10ISRHandlerEv+0xec>
			    usbd.epBank1IsTransferComplete(i))
			{
				if (epHandlers[i]) {
					epHandlers[i]->handleEndpoint();
				} else {
					handleEndpoint(i);
   110bc:	1c38      	adds	r0, r7, #0
   110be:	f7ff fab9 	bl	10634 <_ZN14USBDeviceClass14handleEndpointEh>
   110c2:	e7f4      	b.n	110ae <_ZN14USBDeviceClass10ISRHandlerEv+0xd6>
		}
		i++;
		if (i > USB_EPT_NUM)
			break;  // fire exit
	}
}
   110c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   110c6:	46c0      	nop			; (mov r8, r8)
   110c8:	200013e0 	.word	0x200013e0
   110cc:	200013e8 	.word	0x200013e8
   110d0:	200014ec 	.word	0x200014ec
   110d4:	20001204 	.word	0x20001204
   110d8:	410050ff 	.word	0x410050ff
   110dc:	200013c4 	.word	0x200013c4

000110e0 <UDD_Handler>:
static char isEndpointHalt = 0;

extern void (*gpf_isr)(void);

// USB_Handler ISR
extern "C" void UDD_Handler(void) {
   110e0:	b508      	push	{r3, lr}
	USBDevice.ISRHandler();
   110e2:	4802      	ldr	r0, [pc, #8]	; (110ec <UDD_Handler+0xc>)
   110e4:	f7ff ff78 	bl	10fd8 <_ZN14USBDeviceClass10ISRHandlerEv>
}
   110e8:	bd08      	pop	{r3, pc}
   110ea:	46c0      	nop			; (mov r8, r8)
   110ec:	200013e3 	.word	0x200013e3

000110f0 <_GLOBAL__sub_I__ZN20USBDevice_SAMD21G18x5resetEv>:

typedef uint8_t ep_t;

class USBDevice_SAMD21G18x {
public:
	USBDevice_SAMD21G18x() : usb(USB->DEVICE) {
   110f0:	4a01      	ldr	r2, [pc, #4]	; (110f8 <_GLOBAL__sub_I__ZN20USBDevice_SAMD21G18x5resetEv+0x8>)
   110f2:	4b02      	ldr	r3, [pc, #8]	; (110fc <_GLOBAL__sub_I__ZN20USBDevice_SAMD21G18x5resetEv+0xc>)
   110f4:	601a      	str	r2, [r3, #0]
 * USB Device instance
 * -------------------
 */

// USBDevice class instance
USBDeviceClass USBDevice;
   110f6:	4770      	bx	lr
   110f8:	41005000 	.word	0x41005000
   110fc:	200013e8 	.word	0x200013e8

00011100 <_ZN10RingBufferC1Ev>:
*/

#include "RingBuffer.h"
#include <string.h>

RingBuffer::RingBuffer( void )
   11100:	b510      	push	{r4, lr}
{
    memset( _aucBuffer, 0, SERIAL_BUFFER_SIZE ) ;
   11102:	2100      	movs	r1, #0
   11104:	2240      	movs	r2, #64	; 0x40
*/

#include "RingBuffer.h"
#include <string.h>

RingBuffer::RingBuffer( void )
   11106:	1c04      	adds	r4, r0, #0
{
    memset( _aucBuffer, 0, SERIAL_BUFFER_SIZE ) ;
   11108:	f000 fa60 	bl	115cc <memset>
  }
}

void RingBuffer::clear()
{
	_iHead = 0;
   1110c:	2300      	movs	r3, #0

RingBuffer::RingBuffer( void )
{
    memset( _aucBuffer, 0, SERIAL_BUFFER_SIZE ) ;
    clear();
}
   1110e:	1c20      	adds	r0, r4, #0
  }
}

void RingBuffer::clear()
{
	_iHead = 0;
   11110:	6423      	str	r3, [r4, #64]	; 0x40
	_iTail = 0;
   11112:	6463      	str	r3, [r4, #68]	; 0x44

RingBuffer::RingBuffer( void )
{
    memset( _aucBuffer, 0, SERIAL_BUFFER_SIZE ) ;
    clear();
}
   11114:	bd10      	pop	{r4, pc}

00011116 <_ZN10RingBuffer10store_charEh>:

void RingBuffer::store_char( uint8_t c )
{
  int i = nextIndex(_iHead);
   11116:	6c02      	ldr	r2, [r0, #64]	; 0x40
    memset( _aucBuffer, 0, SERIAL_BUFFER_SIZE ) ;
    clear();
}

void RingBuffer::store_char( uint8_t c )
{
   11118:	b510      	push	{r4, lr}
	return _aucBuffer[_iTail];
}

int RingBuffer::nextIndex(int index)
{
	return (uint32_t)(index + 1) % SERIAL_BUFFER_SIZE;
   1111a:	233f      	movs	r3, #63	; 0x3f
   1111c:	1c54      	adds	r4, r2, #1
   1111e:	4023      	ands	r3, r4

  // if we should be storing the received character into the location
  // just before the tail (meaning that the head would advance to the
  // current location of the tail), we're about to overflow the buffer
  // and so we don't write the character or advance the head.
  if ( i != _iTail )
   11120:	6c44      	ldr	r4, [r0, #68]	; 0x44
   11122:	42a3      	cmp	r3, r4
   11124:	d001      	beq.n	1112a <_ZN10RingBuffer10store_charEh+0x14>
  {
    _aucBuffer[_iHead] = c ;
   11126:	5481      	strb	r1, [r0, r2]
    _iHead = i ;
   11128:	6403      	str	r3, [r0, #64]	; 0x40
  }
}
   1112a:	bd10      	pop	{r4, pc}

0001112c <_ZN10RingBuffer5clearEv>:

void RingBuffer::clear()
{
	_iHead = 0;
   1112c:	2300      	movs	r3, #0
   1112e:	6403      	str	r3, [r0, #64]	; 0x40
	_iTail = 0;
   11130:	6443      	str	r3, [r0, #68]	; 0x44
}
   11132:	4770      	bx	lr

00011134 <_ZN10RingBuffer9read_charEv>:

int RingBuffer::read_char()
{
	if(_iTail == _iHead)
   11134:	6c43      	ldr	r3, [r0, #68]	; 0x44
   11136:	6c02      	ldr	r2, [r0, #64]	; 0x40
   11138:	4293      	cmp	r3, r2
   1113a:	d006      	beq.n	1114a <_ZN10RingBuffer9read_charEv+0x16>
		return -1;

	uint8_t value = _aucBuffer[_iTail];
   1113c:	5cc2      	ldrb	r2, [r0, r3]
	return _aucBuffer[_iTail];
}

int RingBuffer::nextIndex(int index)
{
	return (uint32_t)(index + 1) % SERIAL_BUFFER_SIZE;
   1113e:	213f      	movs	r1, #63	; 0x3f
   11140:	3301      	adds	r3, #1
   11142:	400b      	ands	r3, r1
{
	if(_iTail == _iHead)
		return -1;

	uint8_t value = _aucBuffer[_iTail];
	_iTail = nextIndex(_iTail);
   11144:	6443      	str	r3, [r0, #68]	; 0x44

	return value;
   11146:	1c10      	adds	r0, r2, #0
   11148:	e001      	b.n	1114e <_ZN10RingBuffer9read_charEv+0x1a>
}

int RingBuffer::read_char()
{
	if(_iTail == _iHead)
		return -1;
   1114a:	2001      	movs	r0, #1
   1114c:	4240      	negs	r0, r0

	uint8_t value = _aucBuffer[_iTail];
	_iTail = nextIndex(_iTail);

	return value;
}
   1114e:	4770      	bx	lr

00011150 <_ZN10RingBuffer9availableEv>:

int RingBuffer::available()
{
	int delta = _iHead - _iTail;
   11150:	6c02      	ldr	r2, [r0, #64]	; 0x40
   11152:	6c43      	ldr	r3, [r0, #68]	; 0x44
   11154:	1ad0      	subs	r0, r2, r3

	if(delta < 0)
   11156:	d500      	bpl.n	1115a <_ZN10RingBuffer9availableEv+0xa>
		return SERIAL_BUFFER_SIZE + delta;
   11158:	3040      	adds	r0, #64	; 0x40
	else
		return delta;
}
   1115a:	4770      	bx	lr

0001115c <_ZN10RingBuffer4peekEv>:

int RingBuffer::peek()
{
	if(_iTail == _iHead)
   1115c:	6c43      	ldr	r3, [r0, #68]	; 0x44
   1115e:	6c02      	ldr	r2, [r0, #64]	; 0x40
   11160:	4293      	cmp	r3, r2
   11162:	d001      	beq.n	11168 <_ZN10RingBuffer4peekEv+0xc>
		return -1;

	return _aucBuffer[_iTail];
   11164:	5cc0      	ldrb	r0, [r0, r3]
   11166:	e001      	b.n	1116c <_ZN10RingBuffer4peekEv+0x10>
}

int RingBuffer::peek()
{
	if(_iTail == _iHead)
		return -1;
   11168:	2001      	movs	r0, #1
   1116a:	4240      	negs	r0, r0

	return _aucBuffer[_iTail];
}
   1116c:	4770      	bx	lr

0001116e <_ZN7Serial_17availableForWriteEv>:
int Serial_::availableForWrite(void)
{
	// return the number of bytes left in the current bank,
	// always EP size - 1, because bank is flushed on every write
	return (EPX_SIZE - 1);
}
   1116e:	203f      	movs	r0, #63	; 0x3f
   11170:	4770      	bx	lr

00011172 <_ZN7Serial_5writeEh>:
		setWriteError();
		return 0;
	}
}

size_t Serial_::write(uint8_t c) {
   11172:	b513      	push	{r0, r1, r4, lr}
	return write(&c, 1);
   11174:	6802      	ldr	r2, [r0, #0]
		setWriteError();
		return 0;
	}
}

size_t Serial_::write(uint8_t c) {
   11176:	466b      	mov	r3, sp
   11178:	71d9      	strb	r1, [r3, #7]
   1117a:	3307      	adds	r3, #7
	return write(&c, 1);
   1117c:	6854      	ldr	r4, [r2, #4]
   1117e:	1c19      	adds	r1, r3, #0
   11180:	2201      	movs	r2, #1
   11182:	47a0      	blx	r4
}
   11184:	bd16      	pop	{r1, r2, r4, pc}

00011186 <_ZN7Serial_9availableEv>:
void Serial_::end(void)
{
}

int Serial_::available(void)
{
   11186:	b508      	push	{r3, lr}
	return usb.available(CDC_ENDPOINT_OUT);
   11188:	6900      	ldr	r0, [r0, #16]
   1118a:	2102      	movs	r1, #2
   1118c:	f7ff fbd6 	bl	1093c <_ZN14USBDeviceClass9availableEm>
}
   11190:	bd08      	pop	{r3, pc}

00011192 <_ZN7Serial_5flushEv>:
	}
	return count;
}

void Serial_::flush(void)
{
   11192:	b508      	push	{r3, lr}
	usb.flush(CDC_ENDPOINT_IN);
   11194:	6900      	ldr	r0, [r0, #16]
   11196:	2103      	movs	r1, #3
   11198:	f7ff fbe6 	bl	10968 <_ZN14USBDeviceClass5flushEm>
}
   1119c:	bd08      	pop	{r3, pc}

0001119e <_ZN7Serial_5writeEPKhj>:

size_t Serial_::write(const uint8_t *buffer, size_t size)
{
   1119e:	b538      	push	{r3, r4, r5, lr}
   111a0:	1c0d      	adds	r5, r1, #0
   111a2:	1c04      	adds	r4, r0, #0
   111a4:	1c13      	adds	r3, r2, #0
	uint32_t r = usb.send(CDC_ENDPOINT_IN, buffer, size);
   111a6:	6900      	ldr	r0, [r0, #16]
   111a8:	2103      	movs	r1, #3
   111aa:	1c2a      	adds	r2, r5, #0
   111ac:	f7ff fccc 	bl	10b48 <_ZN14USBDeviceClass4sendEmPKvm>

	if (r > 0) {
   111b0:	2800      	cmp	r0, #0
   111b2:	d101      	bne.n	111b8 <_ZN7Serial_5writeEPKhj+0x1a>
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
   111b4:	2301      	movs	r3, #1
   111b6:	6063      	str	r3, [r4, #4]
		return r;
	} else {
		setWriteError();
		return 0;
	}
}
   111b8:	bd38      	pop	{r3, r4, r5, pc}
	...

000111bc <_ZN7Serial_4peekEv>:
}

int _serialPeek = -1;

int Serial_::peek(void)
{
   111bc:	b510      	push	{r4, lr}
	if (_serialPeek != -1)
   111be:	4c05      	ldr	r4, [pc, #20]	; (111d4 <_ZN7Serial_4peekEv+0x18>)
   111c0:	6823      	ldr	r3, [r4, #0]
   111c2:	1c5a      	adds	r2, r3, #1
   111c4:	d104      	bne.n	111d0 <_ZN7Serial_4peekEv+0x14>
		return _serialPeek;
	_serialPeek = read();
   111c6:	6803      	ldr	r3, [r0, #0]
   111c8:	68db      	ldr	r3, [r3, #12]
   111ca:	4798      	blx	r3
   111cc:	6020      	str	r0, [r4, #0]
   111ce:	1c03      	adds	r3, r0, #0
	return _serialPeek;
}
   111d0:	1c18      	adds	r0, r3, #0
   111d2:	bd10      	pop	{r4, pc}
   111d4:	20000124 	.word	0x20000124

000111d8 <_ZN7Serial_4readEv>:

int Serial_::read(void)
{
	if (_serialPeek != -1) {
   111d8:	4a07      	ldr	r2, [pc, #28]	; (111f8 <_ZN7Serial_4readEv+0x20>)
	_serialPeek = read();
	return _serialPeek;
}

int Serial_::read(void)
{
   111da:	b508      	push	{r3, lr}
	if (_serialPeek != -1) {
   111dc:	6813      	ldr	r3, [r2, #0]
   111de:	1c59      	adds	r1, r3, #1
   111e0:	d004      	beq.n	111ec <_ZN7Serial_4readEv+0x14>
		int res = _serialPeek;
		_serialPeek = -1;
   111e2:	2101      	movs	r1, #1
   111e4:	4249      	negs	r1, r1
   111e6:	6011      	str	r1, [r2, #0]
		return res;
   111e8:	1c18      	adds	r0, r3, #0
   111ea:	e003      	b.n	111f4 <_ZN7Serial_4readEv+0x1c>
	}
	return usb.recv(CDC_ENDPOINT_OUT);
   111ec:	6900      	ldr	r0, [r0, #16]
   111ee:	2102      	movs	r1, #2
   111f0:	f7ff fc9c 	bl	10b2c <_ZN14USBDeviceClass4recvEm>
}
   111f4:	bd08      	pop	{r3, pc}
   111f6:	46c0      	nop			; (mov r8, r8)
   111f8:	20000124 	.word	0x20000124

000111fc <_Z16CDC_GetInterfacePh>:
{
	return sizeof(_cdcInterface);
}

int CDC_GetInterface(uint8_t* interfaceNum)
{
   111fc:	b508      	push	{r3, lr}
	interfaceNum[0] += 2;	// uses 2
   111fe:	7803      	ldrb	r3, [r0, #0]
	return USBDevice.sendControl(&_cdcInterface,sizeof(_cdcInterface));
   11200:	4903      	ldr	r1, [pc, #12]	; (11210 <_Z16CDC_GetInterfacePh+0x14>)
	return sizeof(_cdcInterface);
}

int CDC_GetInterface(uint8_t* interfaceNum)
{
	interfaceNum[0] += 2;	// uses 2
   11202:	3302      	adds	r3, #2
   11204:	7003      	strb	r3, [r0, #0]
	return USBDevice.sendControl(&_cdcInterface,sizeof(_cdcInterface));
   11206:	2242      	movs	r2, #66	; 0x42
   11208:	4802      	ldr	r0, [pc, #8]	; (11214 <_Z16CDC_GetInterfacePh+0x18>)
   1120a:	f7ff fd47 	bl	10c9c <_ZN14USBDeviceClass11sendControlEPKvm>
}
   1120e:	bd08      	pop	{r3, pc}
   11210:	200000e0 	.word	0x200000e0
   11214:	200013e3 	.word	0x200013e3

00011218 <_Z9CDC_SetupR8USBSetup>:

bool CDC_Setup(USBSetup& setup)
{
   11218:	b510      	push	{r4, lr}
	uint8_t requestType = setup.bmRequestType;
   1121a:	7801      	ldrb	r1, [r0, #0]
	interfaceNum[0] += 2;	// uses 2
	return USBDevice.sendControl(&_cdcInterface,sizeof(_cdcInterface));
}

bool CDC_Setup(USBSetup& setup)
{
   1121c:	1c03      	adds	r3, r0, #0
	uint8_t requestType = setup.bmRequestType;
	uint8_t r = setup.bRequest;
   1121e:	7842      	ldrb	r2, [r0, #1]
		{
			breakValue = ((uint16_t)setup.wValueH << 8) | setup.wValueL;
			return false;
		}
	}
	return false;
   11220:	2000      	movs	r0, #0
bool CDC_Setup(USBSetup& setup)
{
	uint8_t requestType = setup.bmRequestType;
	uint8_t r = setup.bRequest;

	if (requestType == REQUEST_DEVICETOHOST_CLASS_INTERFACE)
   11222:	29a1      	cmp	r1, #161	; 0xa1
   11224:	d108      	bne.n	11238 <_Z9CDC_SetupR8USBSetup+0x20>
	{
		if (r == CDC_GET_LINE_CODING)
   11226:	2a21      	cmp	r2, #33	; 0x21
   11228:	d12f      	bne.n	1128a <_Z9CDC_SetupR8USBSetup+0x72>
		{
			USBDevice.sendControl((void*)&_usbLineInfo, 7);
   1122a:	4818      	ldr	r0, [pc, #96]	; (1128c <_Z9CDC_SetupR8USBSetup+0x74>)
   1122c:	4918      	ldr	r1, [pc, #96]	; (11290 <_Z9CDC_SetupR8USBSetup+0x78>)
   1122e:	2207      	movs	r2, #7
   11230:	f7ff fd34 	bl	10c9c <_ZN14USBDeviceClass11sendControlEPKvm>
			return true;
   11234:	2001      	movs	r0, #1
   11236:	e028      	b.n	1128a <_Z9CDC_SetupR8USBSetup+0x72>
		}
	}

	if (requestType == REQUEST_HOSTTODEVICE_CLASS_INTERFACE)
   11238:	2921      	cmp	r1, #33	; 0x21
   1123a:	d126      	bne.n	1128a <_Z9CDC_SetupR8USBSetup+0x72>
	{
		if (r == CDC_SET_LINE_CODING)
   1123c:	2a20      	cmp	r2, #32
   1123e:	d105      	bne.n	1124c <_Z9CDC_SetupR8USBSetup+0x34>
		{
			USBDevice.recvControl((void*)&_usbLineInfo, 7);
   11240:	4913      	ldr	r1, [pc, #76]	; (11290 <_Z9CDC_SetupR8USBSetup+0x78>)
   11242:	2207      	movs	r2, #7
   11244:	4811      	ldr	r0, [pc, #68]	; (1128c <_Z9CDC_SetupR8USBSetup+0x74>)
   11246:	f7ff fbd5 	bl	109f4 <_ZN14USBDeviceClass11recvControlEPvm>
   1124a:	e004      	b.n	11256 <_Z9CDC_SetupR8USBSetup+0x3e>
		}

		if (r == CDC_SET_CONTROL_LINE_STATE)
   1124c:	2a22      	cmp	r2, #34	; 0x22
   1124e:	d110      	bne.n	11272 <_Z9CDC_SetupR8USBSetup+0x5a>
		{
			_usbLineInfo.lineState = setup.wValueL;
   11250:	789a      	ldrb	r2, [r3, #2]
   11252:	4b0f      	ldr	r3, [pc, #60]	; (11290 <_Z9CDC_SetupR8USBSetup+0x78>)
   11254:	71da      	strb	r2, [r3, #7]
		if (r == CDC_SET_LINE_CODING || r == CDC_SET_CONTROL_LINE_STATE)
		{
			// auto-reset into the bootloader is triggered when the port, already
			// open at 1200 bps, is closed. We check DTR state to determine if host 
			// port is open (bit 0 of lineState).
			if (_usbLineInfo.dwDTERate == 1200 && (_usbLineInfo.lineState & 0x01) == 0)
   11256:	4b0e      	ldr	r3, [pc, #56]	; (11290 <_Z9CDC_SetupR8USBSetup+0x78>)
   11258:	2296      	movs	r2, #150	; 0x96
   1125a:	6819      	ldr	r1, [r3, #0]
   1125c:	00d2      	lsls	r2, r2, #3
   1125e:	4291      	cmp	r1, r2
   11260:	d110      	bne.n	11284 <_Z9CDC_SetupR8USBSetup+0x6c>
   11262:	79dc      	ldrb	r4, [r3, #7]
   11264:	2301      	movs	r3, #1
   11266:	401c      	ands	r4, r3
   11268:	d10c      	bne.n	11284 <_Z9CDC_SetupR8USBSetup+0x6c>
			{
				initiateReset(250);
   1126a:	20fa      	movs	r0, #250	; 0xfa
   1126c:	f7fe fd00 	bl	fc70 <initiateReset>
   11270:	e00a      	b.n	11288 <_Z9CDC_SetupR8USBSetup+0x70>
				cancelReset();
			}
			return false;
		}

		if (CDC_SEND_BREAK == r)
   11272:	2a23      	cmp	r2, #35	; 0x23
   11274:	d109      	bne.n	1128a <_Z9CDC_SetupR8USBSetup+0x72>
		{
			breakValue = ((uint16_t)setup.wValueH << 8) | setup.wValueL;
   11276:	78da      	ldrb	r2, [r3, #3]
   11278:	789b      	ldrb	r3, [r3, #2]
   1127a:	0212      	lsls	r2, r2, #8
   1127c:	431a      	orrs	r2, r3
   1127e:	4b05      	ldr	r3, [pc, #20]	; (11294 <_Z9CDC_SetupR8USBSetup+0x7c>)
   11280:	601a      	str	r2, [r3, #0]
			return false;
   11282:	e002      	b.n	1128a <_Z9CDC_SetupR8USBSetup+0x72>
			{
				initiateReset(250);
			}
			else
			{
				cancelReset();
   11284:	f7fe fcfa 	bl	fc7c <cancelReset>
			}
			return false;
   11288:	2000      	movs	r0, #0
			breakValue = ((uint16_t)setup.wValueH << 8) | setup.wValueL;
			return false;
		}
	}
	return false;
}
   1128a:	bd10      	pop	{r4, pc}
   1128c:	200013e3 	.word	0x200013e3
   11290:	200000d4 	.word	0x200000d4
   11294:	200000dc 	.word	0x200000dc

00011298 <_GLOBAL__sub_I__Z17_CDC_GetInterfacev>:
  public:
    Print() : write_error(0) {}
   11298:	4b06      	ldr	r3, [pc, #24]	; (112b4 <_GLOBAL__sub_I__Z17_CDC_GetInterfacev+0x1c>)
   1129a:	21fa      	movs	r1, #250	; 0xfa
   1129c:	0089      	lsls	r1, r1, #2
   1129e:	6099      	str	r1, [r3, #8]
//	Serial over CDC (Serial1 is the physical port)

class Serial_ : public Stream
{
public:
	Serial_(USBDeviceClass &_usb) : usb(_usb), stalled(false) { }
   112a0:	4905      	ldr	r1, [pc, #20]	; (112b8 <_GLOBAL__sub_I__Z17_CDC_GetInterfacev+0x20>)
   112a2:	2200      	movs	r2, #0
   112a4:	3108      	adds	r1, #8
   112a6:	6019      	str	r1, [r3, #0]
   112a8:	4904      	ldr	r1, [pc, #16]	; (112bc <_GLOBAL__sub_I__Z17_CDC_GetInterfacev+0x24>)
   112aa:	605a      	str	r2, [r3, #4]
   112ac:	6119      	str	r1, [r3, #16]
   112ae:	761a      	strb	r2, [r3, #24]

bool Serial_::rts() {
	return _usbLineInfo.lineState & 0x2;
}

Serial_ SerialUSB(USBDevice);
   112b0:	4770      	bx	lr
   112b2:	46c0      	nop			; (mov r8, r8)
   112b4:	200014f0 	.word	0x200014f0
   112b8:	00015b60 	.word	0x00015b60
   112bc:	200013e3 	.word	0x200013e3

000112c0 <_ZN13PluggableUSB_12getInterfaceEPh>:
#ifdef PLUGGABLE_USB_ENABLED

extern uint32_t EndPoints[];

int PluggableUSB_::getInterface(uint8_t* interfaceCount)
{
   112c0:	b570      	push	{r4, r5, r6, lr}
	int sent = 0;
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
   112c2:	6844      	ldr	r4, [r0, #4]
#ifdef PLUGGABLE_USB_ENABLED

extern uint32_t EndPoints[];

int PluggableUSB_::getInterface(uint8_t* interfaceCount)
{
   112c4:	1c0e      	adds	r6, r1, #0
	int sent = 0;
   112c6:	2500      	movs	r5, #0
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
   112c8:	2c00      	cmp	r4, #0
   112ca:	d009      	beq.n	112e0 <_ZN13PluggableUSB_12getInterfaceEPh+0x20>
		int res = node->getInterface(interfaceCount);
   112cc:	6823      	ldr	r3, [r4, #0]
   112ce:	1c20      	adds	r0, r4, #0
   112d0:	685b      	ldr	r3, [r3, #4]
   112d2:	1c31      	adds	r1, r6, #0
   112d4:	4798      	blx	r3
		if (res < 0)
   112d6:	2800      	cmp	r0, #0
   112d8:	db04      	blt.n	112e4 <_ZN13PluggableUSB_12getInterfaceEPh+0x24>
			return -1;
		sent += res;
   112da:	182d      	adds	r5, r5, r0

int PluggableUSB_::getInterface(uint8_t* interfaceCount)
{
	int sent = 0;
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
   112dc:	68e4      	ldr	r4, [r4, #12]
   112de:	e7f3      	b.n	112c8 <_ZN13PluggableUSB_12getInterfaceEPh+0x8>
   112e0:	1c28      	adds	r0, r5, #0
   112e2:	e001      	b.n	112e8 <_ZN13PluggableUSB_12getInterfaceEPh+0x28>
		int res = node->getInterface(interfaceCount);
		if (res < 0)
			return -1;
   112e4:	2001      	movs	r0, #1
   112e6:	4240      	negs	r0, r0
		sent += res;
	}
	return sent;
}
   112e8:	bd70      	pop	{r4, r5, r6, pc}

000112ea <_ZN13PluggableUSB_13getDescriptorER8USBSetup>:

int PluggableUSB_::getDescriptor(USBSetup& setup)
{
   112ea:	b538      	push	{r3, r4, r5, lr}
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
   112ec:	6844      	ldr	r4, [r0, #4]
	}
	return sent;
}

int PluggableUSB_::getDescriptor(USBSetup& setup)
{
   112ee:	1c0d      	adds	r5, r1, #0
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
   112f0:	2c00      	cmp	r4, #0
   112f2:	d008      	beq.n	11306 <_ZN13PluggableUSB_13getDescriptorER8USBSetup+0x1c>
		int ret = node->getDescriptor(setup);
   112f4:	6823      	ldr	r3, [r4, #0]
   112f6:	1c20      	adds	r0, r4, #0
   112f8:	689b      	ldr	r3, [r3, #8]
   112fa:	1c29      	adds	r1, r5, #0
   112fc:	4798      	blx	r3
		// ret!=0 -> request has been processed
		if (ret)
   112fe:	2800      	cmp	r0, #0
   11300:	d102      	bne.n	11308 <_ZN13PluggableUSB_13getDescriptorER8USBSetup+0x1e>
}

int PluggableUSB_::getDescriptor(USBSetup& setup)
{
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
   11302:	68e4      	ldr	r4, [r4, #12]
   11304:	e7f4      	b.n	112f0 <_ZN13PluggableUSB_13getDescriptorER8USBSetup+0x6>
		int ret = node->getDescriptor(setup);
		// ret!=0 -> request has been processed
		if (ret)
			return ret;
	}
	return 0;
   11306:	1c20      	adds	r0, r4, #0
}
   11308:	bd38      	pop	{r3, r4, r5, pc}

0001130a <_ZN13PluggableUSB_12getShortNameEPc>:

void PluggableUSB_::getShortName(char *iSerialNum)
{
   1130a:	b538      	push	{r3, r4, r5, lr}
       PluggableUSBModule* node;
       for (node = rootNode; node; node = node->next) {
   1130c:	6844      	ldr	r4, [r0, #4]
	}
	return 0;
}

void PluggableUSB_::getShortName(char *iSerialNum)
{
   1130e:	1c0d      	adds	r5, r1, #0
       PluggableUSBModule* node;
       for (node = rootNode; node; node = node->next) {
   11310:	2c00      	cmp	r4, #0
   11312:	d007      	beq.n	11324 <_ZN13PluggableUSB_12getShortNameEPc+0x1a>
               iSerialNum += node->getShortName(iSerialNum);
   11314:	6823      	ldr	r3, [r4, #0]
   11316:	1c20      	adds	r0, r4, #0
   11318:	1c29      	adds	r1, r5, #0
   1131a:	68db      	ldr	r3, [r3, #12]
   1131c:	4798      	blx	r3
}

void PluggableUSB_::getShortName(char *iSerialNum)
{
       PluggableUSBModule* node;
       for (node = rootNode; node; node = node->next) {
   1131e:	68e4      	ldr	r4, [r4, #12]
               iSerialNum += node->getShortName(iSerialNum);
   11320:	182d      	adds	r5, r5, r0
   11322:	e7f5      	b.n	11310 <_ZN13PluggableUSB_12getShortNameEPc+0x6>
       }
       *iSerialNum = 0;
   11324:	702c      	strb	r4, [r5, #0]
}
   11326:	bd38      	pop	{r3, r4, r5, pc}

00011328 <_ZN13PluggableUSB_5setupER8USBSetup>:

bool PluggableUSB_::setup(USBSetup& setup)
{
   11328:	b538      	push	{r3, r4, r5, lr}
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
   1132a:	6844      	ldr	r4, [r0, #4]
       }
       *iSerialNum = 0;
}

bool PluggableUSB_::setup(USBSetup& setup)
{
   1132c:	1c0d      	adds	r5, r1, #0
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
   1132e:	2c00      	cmp	r4, #0
   11330:	d008      	beq.n	11344 <_ZN13PluggableUSB_5setupER8USBSetup+0x1c>
		if (node->setup(setup)) {
   11332:	6823      	ldr	r3, [r4, #0]
   11334:	1c20      	adds	r0, r4, #0
   11336:	681b      	ldr	r3, [r3, #0]
   11338:	1c29      	adds	r1, r5, #0
   1133a:	4798      	blx	r3
   1133c:	2800      	cmp	r0, #0
   1133e:	d103      	bne.n	11348 <_ZN13PluggableUSB_5setupER8USBSetup+0x20>
}

bool PluggableUSB_::setup(USBSetup& setup)
{
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
   11340:	68e4      	ldr	r4, [r4, #12]
   11342:	e7f4      	b.n	1132e <_ZN13PluggableUSB_5setupER8USBSetup+0x6>
		if (node->setup(setup)) {
			return true;
		}
	}
	return false;
   11344:	1c20      	adds	r0, r4, #0
   11346:	e000      	b.n	1134a <_ZN13PluggableUSB_5setupER8USBSetup+0x22>
bool PluggableUSB_::setup(USBSetup& setup)
{
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
		if (node->setup(setup)) {
			return true;
   11348:	2001      	movs	r0, #1
		}
	}
	return false;
}
   1134a:	bd38      	pop	{r3, r4, r5, pc}

0001134c <_Z12PluggableUSBv>:
	// restart USB layer???
}

PluggableUSB_& PluggableUSB()
{
	static PluggableUSB_ obj;
   1134c:	4b06      	ldr	r3, [pc, #24]	; (11368 <_Z12PluggableUSBv+0x1c>)
   1134e:	2201      	movs	r2, #1
   11350:	6819      	ldr	r1, [r3, #0]
	return true;
	// restart USB layer???
}

PluggableUSB_& PluggableUSB()
{
   11352:	b510      	push	{r4, lr}
	static PluggableUSB_ obj;
   11354:	4011      	ands	r1, r2
   11356:	4805      	ldr	r0, [pc, #20]	; (1136c <_Z12PluggableUSBv+0x20>)
   11358:	d105      	bne.n	11366 <_Z12PluggableUSBv+0x1a>
	return obj;
}

PluggableUSB_::PluggableUSB_() : lastIf(CDC_ACM_INTERFACE + CDC_INTERFACE_COUNT),
                                 lastEp(CDC_FIRST_ENDPOINT + CDC_ENPOINT_COUNT),
                                 rootNode(NULL)
   1135a:	2402      	movs	r4, #2
   1135c:	7004      	strb	r4, [r0, #0]
   1135e:	2404      	movs	r4, #4
   11360:	7044      	strb	r4, [r0, #1]
   11362:	6041      	str	r1, [r0, #4]
	// restart USB layer???
}

PluggableUSB_& PluggableUSB()
{
	static PluggableUSB_ obj;
   11364:	601a      	str	r2, [r3, #0]
	return obj;
}
   11366:	bd10      	pop	{r4, pc}
   11368:	20001514 	.word	0x20001514
   1136c:	2000150c 	.word	0x2000150c

00011370 <__gnu_thumb1_case_uqi>:
   11370:	b402      	push	{r1}
   11372:	4671      	mov	r1, lr
   11374:	0849      	lsrs	r1, r1, #1
   11376:	0049      	lsls	r1, r1, #1
   11378:	5c09      	ldrb	r1, [r1, r0]
   1137a:	0049      	lsls	r1, r1, #1
   1137c:	448e      	add	lr, r1
   1137e:	bc02      	pop	{r1}
   11380:	4770      	bx	lr
   11382:	46c0      	nop			; (mov r8, r8)

00011384 <__gnu_thumb1_case_uhi>:
   11384:	b403      	push	{r0, r1}
   11386:	4671      	mov	r1, lr
   11388:	0849      	lsrs	r1, r1, #1
   1138a:	0040      	lsls	r0, r0, #1
   1138c:	0049      	lsls	r1, r1, #1
   1138e:	5a09      	ldrh	r1, [r1, r0]
   11390:	0049      	lsls	r1, r1, #1
   11392:	448e      	add	lr, r1
   11394:	bc03      	pop	{r0, r1}
   11396:	4770      	bx	lr

00011398 <__aeabi_uidiv>:
   11398:	2900      	cmp	r1, #0
   1139a:	d034      	beq.n	11406 <.udivsi3_skip_div0_test+0x6a>

0001139c <.udivsi3_skip_div0_test>:
   1139c:	2301      	movs	r3, #1
   1139e:	2200      	movs	r2, #0
   113a0:	b410      	push	{r4}
   113a2:	4288      	cmp	r0, r1
   113a4:	d32c      	bcc.n	11400 <.udivsi3_skip_div0_test+0x64>
   113a6:	2401      	movs	r4, #1
   113a8:	0724      	lsls	r4, r4, #28
   113aa:	42a1      	cmp	r1, r4
   113ac:	d204      	bcs.n	113b8 <.udivsi3_skip_div0_test+0x1c>
   113ae:	4281      	cmp	r1, r0
   113b0:	d202      	bcs.n	113b8 <.udivsi3_skip_div0_test+0x1c>
   113b2:	0109      	lsls	r1, r1, #4
   113b4:	011b      	lsls	r3, r3, #4
   113b6:	e7f8      	b.n	113aa <.udivsi3_skip_div0_test+0xe>
   113b8:	00e4      	lsls	r4, r4, #3
   113ba:	42a1      	cmp	r1, r4
   113bc:	d204      	bcs.n	113c8 <.udivsi3_skip_div0_test+0x2c>
   113be:	4281      	cmp	r1, r0
   113c0:	d202      	bcs.n	113c8 <.udivsi3_skip_div0_test+0x2c>
   113c2:	0049      	lsls	r1, r1, #1
   113c4:	005b      	lsls	r3, r3, #1
   113c6:	e7f8      	b.n	113ba <.udivsi3_skip_div0_test+0x1e>
   113c8:	4288      	cmp	r0, r1
   113ca:	d301      	bcc.n	113d0 <.udivsi3_skip_div0_test+0x34>
   113cc:	1a40      	subs	r0, r0, r1
   113ce:	431a      	orrs	r2, r3
   113d0:	084c      	lsrs	r4, r1, #1
   113d2:	42a0      	cmp	r0, r4
   113d4:	d302      	bcc.n	113dc <.udivsi3_skip_div0_test+0x40>
   113d6:	1b00      	subs	r0, r0, r4
   113d8:	085c      	lsrs	r4, r3, #1
   113da:	4322      	orrs	r2, r4
   113dc:	088c      	lsrs	r4, r1, #2
   113de:	42a0      	cmp	r0, r4
   113e0:	d302      	bcc.n	113e8 <.udivsi3_skip_div0_test+0x4c>
   113e2:	1b00      	subs	r0, r0, r4
   113e4:	089c      	lsrs	r4, r3, #2
   113e6:	4322      	orrs	r2, r4
   113e8:	08cc      	lsrs	r4, r1, #3
   113ea:	42a0      	cmp	r0, r4
   113ec:	d302      	bcc.n	113f4 <.udivsi3_skip_div0_test+0x58>
   113ee:	1b00      	subs	r0, r0, r4
   113f0:	08dc      	lsrs	r4, r3, #3
   113f2:	4322      	orrs	r2, r4
   113f4:	2800      	cmp	r0, #0
   113f6:	d003      	beq.n	11400 <.udivsi3_skip_div0_test+0x64>
   113f8:	091b      	lsrs	r3, r3, #4
   113fa:	d001      	beq.n	11400 <.udivsi3_skip_div0_test+0x64>
   113fc:	0909      	lsrs	r1, r1, #4
   113fe:	e7e3      	b.n	113c8 <.udivsi3_skip_div0_test+0x2c>
   11400:	1c10      	adds	r0, r2, #0
   11402:	bc10      	pop	{r4}
   11404:	4770      	bx	lr
   11406:	2800      	cmp	r0, #0
   11408:	d001      	beq.n	1140e <.udivsi3_skip_div0_test+0x72>
   1140a:	2000      	movs	r0, #0
   1140c:	43c0      	mvns	r0, r0
   1140e:	b407      	push	{r0, r1, r2}
   11410:	4802      	ldr	r0, [pc, #8]	; (1141c <.udivsi3_skip_div0_test+0x80>)
   11412:	a102      	add	r1, pc, #8	; (adr r1, 1141c <.udivsi3_skip_div0_test+0x80>)
   11414:	1840      	adds	r0, r0, r1
   11416:	9002      	str	r0, [sp, #8]
   11418:	bd03      	pop	{r0, r1, pc}
   1141a:	46c0      	nop			; (mov r8, r8)
   1141c:	000000d9 	.word	0x000000d9

00011420 <__aeabi_uidivmod>:
   11420:	2900      	cmp	r1, #0
   11422:	d0f0      	beq.n	11406 <.udivsi3_skip_div0_test+0x6a>
   11424:	b503      	push	{r0, r1, lr}
   11426:	f7ff ffb9 	bl	1139c <.udivsi3_skip_div0_test>
   1142a:	bc0e      	pop	{r1, r2, r3}
   1142c:	4342      	muls	r2, r0
   1142e:	1a89      	subs	r1, r1, r2
   11430:	4718      	bx	r3
   11432:	46c0      	nop			; (mov r8, r8)

00011434 <__aeabi_idiv>:
   11434:	2900      	cmp	r1, #0
   11436:	d041      	beq.n	114bc <.divsi3_skip_div0_test+0x84>

00011438 <.divsi3_skip_div0_test>:
   11438:	b410      	push	{r4}
   1143a:	1c04      	adds	r4, r0, #0
   1143c:	404c      	eors	r4, r1
   1143e:	46a4      	mov	ip, r4
   11440:	2301      	movs	r3, #1
   11442:	2200      	movs	r2, #0
   11444:	2900      	cmp	r1, #0
   11446:	d500      	bpl.n	1144a <.divsi3_skip_div0_test+0x12>
   11448:	4249      	negs	r1, r1
   1144a:	2800      	cmp	r0, #0
   1144c:	d500      	bpl.n	11450 <.divsi3_skip_div0_test+0x18>
   1144e:	4240      	negs	r0, r0
   11450:	4288      	cmp	r0, r1
   11452:	d32c      	bcc.n	114ae <.divsi3_skip_div0_test+0x76>
   11454:	2401      	movs	r4, #1
   11456:	0724      	lsls	r4, r4, #28
   11458:	42a1      	cmp	r1, r4
   1145a:	d204      	bcs.n	11466 <.divsi3_skip_div0_test+0x2e>
   1145c:	4281      	cmp	r1, r0
   1145e:	d202      	bcs.n	11466 <.divsi3_skip_div0_test+0x2e>
   11460:	0109      	lsls	r1, r1, #4
   11462:	011b      	lsls	r3, r3, #4
   11464:	e7f8      	b.n	11458 <.divsi3_skip_div0_test+0x20>
   11466:	00e4      	lsls	r4, r4, #3
   11468:	42a1      	cmp	r1, r4
   1146a:	d204      	bcs.n	11476 <.divsi3_skip_div0_test+0x3e>
   1146c:	4281      	cmp	r1, r0
   1146e:	d202      	bcs.n	11476 <.divsi3_skip_div0_test+0x3e>
   11470:	0049      	lsls	r1, r1, #1
   11472:	005b      	lsls	r3, r3, #1
   11474:	e7f8      	b.n	11468 <.divsi3_skip_div0_test+0x30>
   11476:	4288      	cmp	r0, r1
   11478:	d301      	bcc.n	1147e <.divsi3_skip_div0_test+0x46>
   1147a:	1a40      	subs	r0, r0, r1
   1147c:	431a      	orrs	r2, r3
   1147e:	084c      	lsrs	r4, r1, #1
   11480:	42a0      	cmp	r0, r4
   11482:	d302      	bcc.n	1148a <.divsi3_skip_div0_test+0x52>
   11484:	1b00      	subs	r0, r0, r4
   11486:	085c      	lsrs	r4, r3, #1
   11488:	4322      	orrs	r2, r4
   1148a:	088c      	lsrs	r4, r1, #2
   1148c:	42a0      	cmp	r0, r4
   1148e:	d302      	bcc.n	11496 <.divsi3_skip_div0_test+0x5e>
   11490:	1b00      	subs	r0, r0, r4
   11492:	089c      	lsrs	r4, r3, #2
   11494:	4322      	orrs	r2, r4
   11496:	08cc      	lsrs	r4, r1, #3
   11498:	42a0      	cmp	r0, r4
   1149a:	d302      	bcc.n	114a2 <.divsi3_skip_div0_test+0x6a>
   1149c:	1b00      	subs	r0, r0, r4
   1149e:	08dc      	lsrs	r4, r3, #3
   114a0:	4322      	orrs	r2, r4
   114a2:	2800      	cmp	r0, #0
   114a4:	d003      	beq.n	114ae <.divsi3_skip_div0_test+0x76>
   114a6:	091b      	lsrs	r3, r3, #4
   114a8:	d001      	beq.n	114ae <.divsi3_skip_div0_test+0x76>
   114aa:	0909      	lsrs	r1, r1, #4
   114ac:	e7e3      	b.n	11476 <.divsi3_skip_div0_test+0x3e>
   114ae:	1c10      	adds	r0, r2, #0
   114b0:	4664      	mov	r4, ip
   114b2:	2c00      	cmp	r4, #0
   114b4:	d500      	bpl.n	114b8 <.divsi3_skip_div0_test+0x80>
   114b6:	4240      	negs	r0, r0
   114b8:	bc10      	pop	{r4}
   114ba:	4770      	bx	lr
   114bc:	2800      	cmp	r0, #0
   114be:	d006      	beq.n	114ce <.divsi3_skip_div0_test+0x96>
   114c0:	db03      	blt.n	114ca <.divsi3_skip_div0_test+0x92>
   114c2:	2000      	movs	r0, #0
   114c4:	43c0      	mvns	r0, r0
   114c6:	0840      	lsrs	r0, r0, #1
   114c8:	e001      	b.n	114ce <.divsi3_skip_div0_test+0x96>
   114ca:	2080      	movs	r0, #128	; 0x80
   114cc:	0600      	lsls	r0, r0, #24
   114ce:	b407      	push	{r0, r1, r2}
   114d0:	4802      	ldr	r0, [pc, #8]	; (114dc <.divsi3_skip_div0_test+0xa4>)
   114d2:	a102      	add	r1, pc, #8	; (adr r1, 114dc <.divsi3_skip_div0_test+0xa4>)
   114d4:	1840      	adds	r0, r0, r1
   114d6:	9002      	str	r0, [sp, #8]
   114d8:	bd03      	pop	{r0, r1, pc}
   114da:	46c0      	nop			; (mov r8, r8)
   114dc:	00000019 	.word	0x00000019

000114e0 <__aeabi_idivmod>:
   114e0:	2900      	cmp	r1, #0
   114e2:	d0eb      	beq.n	114bc <.divsi3_skip_div0_test+0x84>
   114e4:	b503      	push	{r0, r1, lr}
   114e6:	f7ff ffa7 	bl	11438 <.divsi3_skip_div0_test>
   114ea:	bc0e      	pop	{r1, r2, r3}
   114ec:	4342      	muls	r2, r0
   114ee:	1a89      	subs	r1, r1, r2
   114f0:	4718      	bx	r3
   114f2:	46c0      	nop			; (mov r8, r8)

000114f4 <__aeabi_idiv0>:
   114f4:	4770      	bx	lr
   114f6:	46c0      	nop			; (mov r8, r8)

000114f8 <__aeabi_atexit>:
   114f8:	b508      	push	{r3, lr}
   114fa:	1c03      	adds	r3, r0, #0
   114fc:	1c08      	adds	r0, r1, #0
   114fe:	1c19      	adds	r1, r3, #0
   11500:	f000 f802 	bl	11508 <__cxa_atexit>
   11504:	bd08      	pop	{r3, pc}
	...

00011508 <__cxa_atexit>:
   11508:	b538      	push	{r3, r4, r5, lr}
   1150a:	1c05      	adds	r5, r0, #0
   1150c:	4805      	ldr	r0, [pc, #20]	; (11524 <__cxa_atexit+0x1c>)
   1150e:	1c0c      	adds	r4, r1, #0
   11510:	1c13      	adds	r3, r2, #0
   11512:	2800      	cmp	r0, #0
   11514:	d004      	beq.n	11520 <__cxa_atexit+0x18>
   11516:	2002      	movs	r0, #2
   11518:	1c29      	adds	r1, r5, #0
   1151a:	1c22      	adds	r2, r4, #0
   1151c:	e000      	b.n	11520 <__cxa_atexit+0x18>
   1151e:	bf00      	nop
   11520:	bd38      	pop	{r3, r4, r5, pc}
   11522:	46c0      	nop			; (mov r8, r8)
   11524:	00000000 	.word	0x00000000

00011528 <__libc_init_array>:
   11528:	b570      	push	{r4, r5, r6, lr}
   1152a:	4b0e      	ldr	r3, [pc, #56]	; (11564 <__libc_init_array+0x3c>)
   1152c:	4d0e      	ldr	r5, [pc, #56]	; (11568 <__libc_init_array+0x40>)
   1152e:	2400      	movs	r4, #0
   11530:	1aed      	subs	r5, r5, r3
   11532:	10ad      	asrs	r5, r5, #2
   11534:	1c1e      	adds	r6, r3, #0
   11536:	42ac      	cmp	r4, r5
   11538:	d004      	beq.n	11544 <__libc_init_array+0x1c>
   1153a:	00a3      	lsls	r3, r4, #2
   1153c:	58f3      	ldr	r3, [r6, r3]
   1153e:	4798      	blx	r3
   11540:	3401      	adds	r4, #1
   11542:	e7f8      	b.n	11536 <__libc_init_array+0xe>
   11544:	f000 f9c6 	bl	118d4 <_init>
   11548:	4b08      	ldr	r3, [pc, #32]	; (1156c <__libc_init_array+0x44>)
   1154a:	4d09      	ldr	r5, [pc, #36]	; (11570 <__libc_init_array+0x48>)
   1154c:	2400      	movs	r4, #0
   1154e:	1aed      	subs	r5, r5, r3
   11550:	10ad      	asrs	r5, r5, #2
   11552:	1c1e      	adds	r6, r3, #0
   11554:	42ac      	cmp	r4, r5
   11556:	d004      	beq.n	11562 <__libc_init_array+0x3a>
   11558:	00a3      	lsls	r3, r4, #2
   1155a:	58f3      	ldr	r3, [r6, r3]
   1155c:	4798      	blx	r3
   1155e:	3401      	adds	r4, #1
   11560:	e7f8      	b.n	11554 <__libc_init_array+0x2c>
   11562:	bd70      	pop	{r4, r5, r6, pc}
   11564:	2000018c 	.word	0x2000018c
   11568:	2000018c 	.word	0x2000018c
   1156c:	2000018c 	.word	0x2000018c
   11570:	200001bc 	.word	0x200001bc

00011574 <malloc>:
   11574:	b508      	push	{r3, lr}
   11576:	4b03      	ldr	r3, [pc, #12]	; (11584 <malloc+0x10>)
   11578:	1c01      	adds	r1, r0, #0
   1157a:	6818      	ldr	r0, [r3, #0]
   1157c:	f000 f876 	bl	1166c <_malloc_r>
   11580:	bd08      	pop	{r3, pc}
   11582:	46c0      	nop			; (mov r8, r8)
   11584:	20000188 	.word	0x20000188

00011588 <free>:
   11588:	b508      	push	{r3, lr}
   1158a:	4b03      	ldr	r3, [pc, #12]	; (11598 <free+0x10>)
   1158c:	1c01      	adds	r1, r0, #0
   1158e:	6818      	ldr	r0, [r3, #0]
   11590:	f000 f824 	bl	115dc <_free_r>
   11594:	bd08      	pop	{r3, pc}
   11596:	46c0      	nop			; (mov r8, r8)
   11598:	20000188 	.word	0x20000188

0001159c <memcmp>:
   1159c:	b530      	push	{r4, r5, lr}
   1159e:	2300      	movs	r3, #0
   115a0:	4293      	cmp	r3, r2
   115a2:	d008      	beq.n	115b6 <memcmp+0x1a>
   115a4:	5cc5      	ldrb	r5, [r0, r3]
   115a6:	3301      	adds	r3, #1
   115a8:	18cc      	adds	r4, r1, r3
   115aa:	3c01      	subs	r4, #1
   115ac:	7824      	ldrb	r4, [r4, #0]
   115ae:	42a5      	cmp	r5, r4
   115b0:	d0f6      	beq.n	115a0 <memcmp+0x4>
   115b2:	1b28      	subs	r0, r5, r4
   115b4:	e000      	b.n	115b8 <memcmp+0x1c>
   115b6:	2000      	movs	r0, #0
   115b8:	bd30      	pop	{r4, r5, pc}

000115ba <memcpy>:
   115ba:	b510      	push	{r4, lr}
   115bc:	2300      	movs	r3, #0
   115be:	4293      	cmp	r3, r2
   115c0:	d003      	beq.n	115ca <memcpy+0x10>
   115c2:	5ccc      	ldrb	r4, [r1, r3]
   115c4:	54c4      	strb	r4, [r0, r3]
   115c6:	3301      	adds	r3, #1
   115c8:	e7f9      	b.n	115be <memcpy+0x4>
   115ca:	bd10      	pop	{r4, pc}

000115cc <memset>:
   115cc:	1c03      	adds	r3, r0, #0
   115ce:	1882      	adds	r2, r0, r2
   115d0:	4293      	cmp	r3, r2
   115d2:	d002      	beq.n	115da <memset+0xe>
   115d4:	7019      	strb	r1, [r3, #0]
   115d6:	3301      	adds	r3, #1
   115d8:	e7fa      	b.n	115d0 <memset+0x4>
   115da:	4770      	bx	lr

000115dc <_free_r>:
   115dc:	b530      	push	{r4, r5, lr}
   115de:	2900      	cmp	r1, #0
   115e0:	d040      	beq.n	11664 <_free_r+0x88>
   115e2:	3904      	subs	r1, #4
   115e4:	680b      	ldr	r3, [r1, #0]
   115e6:	2b00      	cmp	r3, #0
   115e8:	da00      	bge.n	115ec <_free_r+0x10>
   115ea:	18c9      	adds	r1, r1, r3
   115ec:	4a1e      	ldr	r2, [pc, #120]	; (11668 <_free_r+0x8c>)
   115ee:	6813      	ldr	r3, [r2, #0]
   115f0:	1c14      	adds	r4, r2, #0
   115f2:	2b00      	cmp	r3, #0
   115f4:	d102      	bne.n	115fc <_free_r+0x20>
   115f6:	604b      	str	r3, [r1, #4]
   115f8:	6011      	str	r1, [r2, #0]
   115fa:	e033      	b.n	11664 <_free_r+0x88>
   115fc:	4299      	cmp	r1, r3
   115fe:	d20f      	bcs.n	11620 <_free_r+0x44>
   11600:	6808      	ldr	r0, [r1, #0]
   11602:	180a      	adds	r2, r1, r0
   11604:	429a      	cmp	r2, r3
   11606:	d105      	bne.n	11614 <_free_r+0x38>
   11608:	6813      	ldr	r3, [r2, #0]
   1160a:	6852      	ldr	r2, [r2, #4]
   1160c:	18c0      	adds	r0, r0, r3
   1160e:	6008      	str	r0, [r1, #0]
   11610:	604a      	str	r2, [r1, #4]
   11612:	e000      	b.n	11616 <_free_r+0x3a>
   11614:	604b      	str	r3, [r1, #4]
   11616:	6021      	str	r1, [r4, #0]
   11618:	e024      	b.n	11664 <_free_r+0x88>
   1161a:	428a      	cmp	r2, r1
   1161c:	d803      	bhi.n	11626 <_free_r+0x4a>
   1161e:	1c13      	adds	r3, r2, #0
   11620:	685a      	ldr	r2, [r3, #4]
   11622:	2a00      	cmp	r2, #0
   11624:	d1f9      	bne.n	1161a <_free_r+0x3e>
   11626:	681d      	ldr	r5, [r3, #0]
   11628:	195c      	adds	r4, r3, r5
   1162a:	428c      	cmp	r4, r1
   1162c:	d10b      	bne.n	11646 <_free_r+0x6a>
   1162e:	6809      	ldr	r1, [r1, #0]
   11630:	1869      	adds	r1, r5, r1
   11632:	1858      	adds	r0, r3, r1
   11634:	6019      	str	r1, [r3, #0]
   11636:	4290      	cmp	r0, r2
   11638:	d114      	bne.n	11664 <_free_r+0x88>
   1163a:	6814      	ldr	r4, [r2, #0]
   1163c:	6852      	ldr	r2, [r2, #4]
   1163e:	1909      	adds	r1, r1, r4
   11640:	6019      	str	r1, [r3, #0]
   11642:	605a      	str	r2, [r3, #4]
   11644:	e00e      	b.n	11664 <_free_r+0x88>
   11646:	428c      	cmp	r4, r1
   11648:	d902      	bls.n	11650 <_free_r+0x74>
   1164a:	230c      	movs	r3, #12
   1164c:	6003      	str	r3, [r0, #0]
   1164e:	e009      	b.n	11664 <_free_r+0x88>
   11650:	6808      	ldr	r0, [r1, #0]
   11652:	180c      	adds	r4, r1, r0
   11654:	4294      	cmp	r4, r2
   11656:	d103      	bne.n	11660 <_free_r+0x84>
   11658:	6814      	ldr	r4, [r2, #0]
   1165a:	6852      	ldr	r2, [r2, #4]
   1165c:	1900      	adds	r0, r0, r4
   1165e:	6008      	str	r0, [r1, #0]
   11660:	604a      	str	r2, [r1, #4]
   11662:	6059      	str	r1, [r3, #4]
   11664:	bd30      	pop	{r4, r5, pc}
   11666:	46c0      	nop			; (mov r8, r8)
   11668:	2000151c 	.word	0x2000151c

0001166c <_malloc_r>:
   1166c:	b570      	push	{r4, r5, r6, lr}
   1166e:	2303      	movs	r3, #3
   11670:	1ccd      	adds	r5, r1, #3
   11672:	439d      	bics	r5, r3
   11674:	3508      	adds	r5, #8
   11676:	1c06      	adds	r6, r0, #0
   11678:	2d0c      	cmp	r5, #12
   1167a:	d201      	bcs.n	11680 <_malloc_r+0x14>
   1167c:	250c      	movs	r5, #12
   1167e:	e001      	b.n	11684 <_malloc_r+0x18>
   11680:	2d00      	cmp	r5, #0
   11682:	db3f      	blt.n	11704 <_malloc_r+0x98>
   11684:	428d      	cmp	r5, r1
   11686:	d33d      	bcc.n	11704 <_malloc_r+0x98>
   11688:	4b20      	ldr	r3, [pc, #128]	; (1170c <_malloc_r+0xa0>)
   1168a:	681c      	ldr	r4, [r3, #0]
   1168c:	1c1a      	adds	r2, r3, #0
   1168e:	1c21      	adds	r1, r4, #0
   11690:	2900      	cmp	r1, #0
   11692:	d013      	beq.n	116bc <_malloc_r+0x50>
   11694:	6808      	ldr	r0, [r1, #0]
   11696:	1b43      	subs	r3, r0, r5
   11698:	d40d      	bmi.n	116b6 <_malloc_r+0x4a>
   1169a:	2b0b      	cmp	r3, #11
   1169c:	d902      	bls.n	116a4 <_malloc_r+0x38>
   1169e:	600b      	str	r3, [r1, #0]
   116a0:	18cc      	adds	r4, r1, r3
   116a2:	e01e      	b.n	116e2 <_malloc_r+0x76>
   116a4:	428c      	cmp	r4, r1
   116a6:	d102      	bne.n	116ae <_malloc_r+0x42>
   116a8:	6863      	ldr	r3, [r4, #4]
   116aa:	6013      	str	r3, [r2, #0]
   116ac:	e01a      	b.n	116e4 <_malloc_r+0x78>
   116ae:	6848      	ldr	r0, [r1, #4]
   116b0:	6060      	str	r0, [r4, #4]
   116b2:	1c0c      	adds	r4, r1, #0
   116b4:	e016      	b.n	116e4 <_malloc_r+0x78>
   116b6:	1c0c      	adds	r4, r1, #0
   116b8:	6849      	ldr	r1, [r1, #4]
   116ba:	e7e9      	b.n	11690 <_malloc_r+0x24>
   116bc:	4c14      	ldr	r4, [pc, #80]	; (11710 <_malloc_r+0xa4>)
   116be:	6820      	ldr	r0, [r4, #0]
   116c0:	2800      	cmp	r0, #0
   116c2:	d103      	bne.n	116cc <_malloc_r+0x60>
   116c4:	1c30      	adds	r0, r6, #0
   116c6:	f000 f88f 	bl	117e8 <_sbrk_r>
   116ca:	6020      	str	r0, [r4, #0]
   116cc:	1c30      	adds	r0, r6, #0
   116ce:	1c29      	adds	r1, r5, #0
   116d0:	f000 f88a 	bl	117e8 <_sbrk_r>
   116d4:	1c43      	adds	r3, r0, #1
   116d6:	d015      	beq.n	11704 <_malloc_r+0x98>
   116d8:	1cc4      	adds	r4, r0, #3
   116da:	2303      	movs	r3, #3
   116dc:	439c      	bics	r4, r3
   116de:	4284      	cmp	r4, r0
   116e0:	d10a      	bne.n	116f8 <_malloc_r+0x8c>
   116e2:	6025      	str	r5, [r4, #0]
   116e4:	1c20      	adds	r0, r4, #0
   116e6:	300b      	adds	r0, #11
   116e8:	2207      	movs	r2, #7
   116ea:	1d23      	adds	r3, r4, #4
   116ec:	4390      	bics	r0, r2
   116ee:	1ac3      	subs	r3, r0, r3
   116f0:	d00b      	beq.n	1170a <_malloc_r+0x9e>
   116f2:	425a      	negs	r2, r3
   116f4:	50e2      	str	r2, [r4, r3]
   116f6:	e008      	b.n	1170a <_malloc_r+0x9e>
   116f8:	1a21      	subs	r1, r4, r0
   116fa:	1c30      	adds	r0, r6, #0
   116fc:	f000 f874 	bl	117e8 <_sbrk_r>
   11700:	3001      	adds	r0, #1
   11702:	d1ee      	bne.n	116e2 <_malloc_r+0x76>
   11704:	230c      	movs	r3, #12
   11706:	6033      	str	r3, [r6, #0]
   11708:	2000      	movs	r0, #0
   1170a:	bd70      	pop	{r4, r5, r6, pc}
   1170c:	2000151c 	.word	0x2000151c
   11710:	20001518 	.word	0x20001518

00011714 <srand>:
   11714:	b538      	push	{r3, r4, r5, lr}
   11716:	4b10      	ldr	r3, [pc, #64]	; (11758 <srand+0x44>)
   11718:	1c05      	adds	r5, r0, #0
   1171a:	681c      	ldr	r4, [r3, #0]
   1171c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1171e:	2b00      	cmp	r3, #0
   11720:	d115      	bne.n	1174e <srand+0x3a>
   11722:	2018      	movs	r0, #24
   11724:	f7ff ff26 	bl	11574 <malloc>
   11728:	4b0c      	ldr	r3, [pc, #48]	; (1175c <srand+0x48>)
   1172a:	63a0      	str	r0, [r4, #56]	; 0x38
   1172c:	8003      	strh	r3, [r0, #0]
   1172e:	4b0c      	ldr	r3, [pc, #48]	; (11760 <srand+0x4c>)
   11730:	8043      	strh	r3, [r0, #2]
   11732:	4b0c      	ldr	r3, [pc, #48]	; (11764 <srand+0x50>)
   11734:	8083      	strh	r3, [r0, #4]
   11736:	4b0c      	ldr	r3, [pc, #48]	; (11768 <srand+0x54>)
   11738:	80c3      	strh	r3, [r0, #6]
   1173a:	4b0c      	ldr	r3, [pc, #48]	; (1176c <srand+0x58>)
   1173c:	8103      	strh	r3, [r0, #8]
   1173e:	2305      	movs	r3, #5
   11740:	8143      	strh	r3, [r0, #10]
   11742:	230b      	movs	r3, #11
   11744:	8183      	strh	r3, [r0, #12]
   11746:	2201      	movs	r2, #1
   11748:	2300      	movs	r3, #0
   1174a:	6102      	str	r2, [r0, #16]
   1174c:	6143      	str	r3, [r0, #20]
   1174e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11750:	2200      	movs	r2, #0
   11752:	611d      	str	r5, [r3, #16]
   11754:	615a      	str	r2, [r3, #20]
   11756:	bd38      	pop	{r3, r4, r5, pc}
   11758:	20000188 	.word	0x20000188
   1175c:	0000330e 	.word	0x0000330e
   11760:	ffffabcd 	.word	0xffffabcd
   11764:	00001234 	.word	0x00001234
   11768:	ffffe66d 	.word	0xffffe66d
   1176c:	ffffdeec 	.word	0xffffdeec

00011770 <rand>:
   11770:	4b17      	ldr	r3, [pc, #92]	; (117d0 <rand+0x60>)
   11772:	b510      	push	{r4, lr}
   11774:	681c      	ldr	r4, [r3, #0]
   11776:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   11778:	2b00      	cmp	r3, #0
   1177a:	d115      	bne.n	117a8 <rand+0x38>
   1177c:	2018      	movs	r0, #24
   1177e:	f7ff fef9 	bl	11574 <malloc>
   11782:	4b14      	ldr	r3, [pc, #80]	; (117d4 <rand+0x64>)
   11784:	63a0      	str	r0, [r4, #56]	; 0x38
   11786:	8003      	strh	r3, [r0, #0]
   11788:	4b13      	ldr	r3, [pc, #76]	; (117d8 <rand+0x68>)
   1178a:	8043      	strh	r3, [r0, #2]
   1178c:	4b13      	ldr	r3, [pc, #76]	; (117dc <rand+0x6c>)
   1178e:	8083      	strh	r3, [r0, #4]
   11790:	4b13      	ldr	r3, [pc, #76]	; (117e0 <rand+0x70>)
   11792:	80c3      	strh	r3, [r0, #6]
   11794:	4b13      	ldr	r3, [pc, #76]	; (117e4 <rand+0x74>)
   11796:	8103      	strh	r3, [r0, #8]
   11798:	2305      	movs	r3, #5
   1179a:	8143      	strh	r3, [r0, #10]
   1179c:	230b      	movs	r3, #11
   1179e:	8183      	strh	r3, [r0, #12]
   117a0:	2201      	movs	r2, #1
   117a2:	2300      	movs	r3, #0
   117a4:	6102      	str	r2, [r0, #16]
   117a6:	6143      	str	r3, [r0, #20]
   117a8:	4b08      	ldr	r3, [pc, #32]	; (117cc <rand+0x5c>)
   117aa:	4a07      	ldr	r2, [pc, #28]	; (117c8 <rand+0x58>)
   117ac:	6ba4      	ldr	r4, [r4, #56]	; 0x38
   117ae:	6920      	ldr	r0, [r4, #16]
   117b0:	6961      	ldr	r1, [r4, #20]
   117b2:	f000 f853 	bl	1185c <__aeabi_lmul>
   117b6:	2201      	movs	r2, #1
   117b8:	2300      	movs	r3, #0
   117ba:	1880      	adds	r0, r0, r2
   117bc:	4159      	adcs	r1, r3
   117be:	6120      	str	r0, [r4, #16]
   117c0:	6161      	str	r1, [r4, #20]
   117c2:	0048      	lsls	r0, r1, #1
   117c4:	0840      	lsrs	r0, r0, #1
   117c6:	bd10      	pop	{r4, pc}
   117c8:	4c957f2d 	.word	0x4c957f2d
   117cc:	5851f42d 	.word	0x5851f42d
   117d0:	20000188 	.word	0x20000188
   117d4:	0000330e 	.word	0x0000330e
   117d8:	ffffabcd 	.word	0xffffabcd
   117dc:	00001234 	.word	0x00001234
   117e0:	ffffe66d 	.word	0xffffe66d
   117e4:	ffffdeec 	.word	0xffffdeec

000117e8 <_sbrk_r>:
   117e8:	b538      	push	{r3, r4, r5, lr}
   117ea:	4c07      	ldr	r4, [pc, #28]	; (11808 <_sbrk_r+0x20>)
   117ec:	2300      	movs	r3, #0
   117ee:	1c05      	adds	r5, r0, #0
   117f0:	1c08      	adds	r0, r1, #0
   117f2:	6023      	str	r3, [r4, #0]
   117f4:	f000 f854 	bl	118a0 <_sbrk>
   117f8:	1c43      	adds	r3, r0, #1
   117fa:	d103      	bne.n	11804 <_sbrk_r+0x1c>
   117fc:	6823      	ldr	r3, [r4, #0]
   117fe:	2b00      	cmp	r3, #0
   11800:	d000      	beq.n	11804 <_sbrk_r+0x1c>
   11802:	602b      	str	r3, [r5, #0]
   11804:	bd38      	pop	{r3, r4, r5, pc}
   11806:	46c0      	nop			; (mov r8, r8)
   11808:	20001580 	.word	0x20001580

0001180c <strcpy>:
   1180c:	1c03      	adds	r3, r0, #0
   1180e:	780a      	ldrb	r2, [r1, #0]
   11810:	3101      	adds	r1, #1
   11812:	701a      	strb	r2, [r3, #0]
   11814:	3301      	adds	r3, #1
   11816:	2a00      	cmp	r2, #0
   11818:	d1f9      	bne.n	1180e <strcpy+0x2>
   1181a:	4770      	bx	lr

0001181c <strlen>:
   1181c:	2300      	movs	r3, #0
   1181e:	5cc2      	ldrb	r2, [r0, r3]
   11820:	3301      	adds	r3, #1
   11822:	2a00      	cmp	r2, #0
   11824:	d1fb      	bne.n	1181e <strlen+0x2>
   11826:	1e58      	subs	r0, r3, #1
   11828:	4770      	bx	lr

0001182a <strstr>:
   1182a:	b510      	push	{r4, lr}
   1182c:	7803      	ldrb	r3, [r0, #0]
   1182e:	2b00      	cmp	r3, #0
   11830:	d106      	bne.n	11840 <strstr+0x16>
   11832:	780b      	ldrb	r3, [r1, #0]
   11834:	425a      	negs	r2, r3
   11836:	4153      	adcs	r3, r2
   11838:	425b      	negs	r3, r3
   1183a:	4018      	ands	r0, r3
   1183c:	e00d      	b.n	1185a <strstr+0x30>
   1183e:	3001      	adds	r0, #1
   11840:	7803      	ldrb	r3, [r0, #0]
   11842:	2b00      	cmp	r3, #0
   11844:	d008      	beq.n	11858 <strstr+0x2e>
   11846:	2300      	movs	r3, #0
   11848:	5cca      	ldrb	r2, [r1, r3]
   1184a:	2a00      	cmp	r2, #0
   1184c:	d005      	beq.n	1185a <strstr+0x30>
   1184e:	5cc4      	ldrb	r4, [r0, r3]
   11850:	4294      	cmp	r4, r2
   11852:	d1f4      	bne.n	1183e <strstr+0x14>
   11854:	3301      	adds	r3, #1
   11856:	e7f7      	b.n	11848 <strstr+0x1e>
   11858:	1c18      	adds	r0, r3, #0
   1185a:	bd10      	pop	{r4, pc}

0001185c <__aeabi_lmul>:
   1185c:	469c      	mov	ip, r3
   1185e:	0403      	lsls	r3, r0, #16
   11860:	b5f0      	push	{r4, r5, r6, r7, lr}
   11862:	0c1b      	lsrs	r3, r3, #16
   11864:	0417      	lsls	r7, r2, #16
   11866:	0c3f      	lsrs	r7, r7, #16
   11868:	0c15      	lsrs	r5, r2, #16
   1186a:	1c1e      	adds	r6, r3, #0
   1186c:	1c04      	adds	r4, r0, #0
   1186e:	0c00      	lsrs	r0, r0, #16
   11870:	437e      	muls	r6, r7
   11872:	436b      	muls	r3, r5
   11874:	4347      	muls	r7, r0
   11876:	4345      	muls	r5, r0
   11878:	18fb      	adds	r3, r7, r3
   1187a:	0c30      	lsrs	r0, r6, #16
   1187c:	1818      	adds	r0, r3, r0
   1187e:	4287      	cmp	r7, r0
   11880:	d902      	bls.n	11888 <__aeabi_lmul+0x2c>
   11882:	2380      	movs	r3, #128	; 0x80
   11884:	025b      	lsls	r3, r3, #9
   11886:	18ed      	adds	r5, r5, r3
   11888:	0c03      	lsrs	r3, r0, #16
   1188a:	18ed      	adds	r5, r5, r3
   1188c:	4663      	mov	r3, ip
   1188e:	435c      	muls	r4, r3
   11890:	434a      	muls	r2, r1
   11892:	0436      	lsls	r6, r6, #16
   11894:	0c36      	lsrs	r6, r6, #16
   11896:	18a1      	adds	r1, r4, r2
   11898:	0400      	lsls	r0, r0, #16
   1189a:	1980      	adds	r0, r0, r6
   1189c:	1949      	adds	r1, r1, r5
   1189e:	bdf0      	pop	{r4, r5, r6, r7, pc}

000118a0 <_sbrk>:
   118a0:	4a09      	ldr	r2, [pc, #36]	; (118c8 <_sbrk+0x28>)
   118a2:	6813      	ldr	r3, [r2, #0]
   118a4:	2b00      	cmp	r3, #0
   118a6:	d00c      	beq.n	118c2 <_sbrk+0x22>
   118a8:	1818      	adds	r0, r3, r0
   118aa:	4669      	mov	r1, sp
   118ac:	4288      	cmp	r0, r1
   118ae:	d802      	bhi.n	118b6 <_sbrk+0x16>
   118b0:	6010      	str	r0, [r2, #0]
   118b2:	1c18      	adds	r0, r3, #0
   118b4:	4770      	bx	lr
   118b6:	4b05      	ldr	r3, [pc, #20]	; (118cc <_sbrk+0x2c>)
   118b8:	220c      	movs	r2, #12
   118ba:	2001      	movs	r0, #1
   118bc:	601a      	str	r2, [r3, #0]
   118be:	4240      	negs	r0, r0
   118c0:	e7f8      	b.n	118b4 <_sbrk+0x14>
   118c2:	4b03      	ldr	r3, [pc, #12]	; (118d0 <_sbrk+0x30>)
   118c4:	6013      	str	r3, [r2, #0]
   118c6:	e7ef      	b.n	118a8 <_sbrk+0x8>
   118c8:	20001520 	.word	0x20001520
   118cc:	20001580 	.word	0x20001580
   118d0:	20001584 	.word	0x20001584

000118d4 <_init>:
   118d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   118d6:	46c0      	nop			; (mov r8, r8)
   118d8:	bcf8      	pop	{r3, r4, r5, r6, r7}
   118da:	bc08      	pop	{r3}
   118dc:	469e      	mov	lr, r3
   118de:	4770      	bx	lr

000118e0 <_fini>:
   118e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   118e2:	46c0      	nop			; (mov r8, r8)
   118e4:	bcf8      	pop	{r3, r4, r5, r6, r7}
   118e6:	bc08      	pop	{r3}
   118e8:	469e      	mov	lr, r3
   118ea:	4770      	bx	lr

000118ec <_ZL10easyOption>:
   118ec:	6145 7973 6720 6d61 0065 0000               Easy game...

000118f8 <_ZL9pauseMenu>:
   118f8:	1935 0001 192c 0001 1904 0001               5...,.......

00011904 <_ZL10undoOption>:
   11904:	6e55 6f64 4800                                   Undo.

00011909 <_ZL10hardOption>:
   11909:	6148 6472 6720 6d61 0065 ec00                    Hard game..

00011914 <_ZL11newGameMenu>:
   11914:	18ec 0001 1909 0001 0000 0000               ............

00011920 <_ZL8patternA>:
   11920:	0045 0118 0000                              E.....

00011926 <_ZL8patternB>:
   11926:	0045 0108 0000                              E.....

0001192c <_ZL13newGameOption>:
   1192c:	654e 2077 6167 656d 5200                         New game.

00011935 <_ZL12resumeOption>:
   11935:	6552 7573 656d 1500                              Resume.

0001193c <_ZL17cursorDetailsData>:
   1193c:	0015 0009 001f 001f 001f 001f 001f 001f     ................
   1194c:	001f 0000 0000 0000 0000 0000 0000 0000     ................
	...
   11968:	001f 001f 001f 001f 0000 0000 001f 0000     ................
   11978:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
   11988:	ffff ffff ffff ffff ffff 0000 001f 001f     ................
   11998:	0000 ffff 0000 001f 0000 ffff ffff ffff     ................
   119a8:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
   119b8:	ffff ffff 0000 001f 0000 ffff ffff 0000     ................
   119c8:	0000 0000 ffff ffff ffff ffff ffff ffff     ................
   119d8:	ffff ffff ffff ffff ffff ffff ffff 0000     ................
   119e8:	0000 ffff ffff ffff ffff ffff ffff ffff     ................
   119f8:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
   11a08:	ffff ffff ffff ffff 0000 001f 0000 ffff     ................
   11a18:	ffff 0000 0000 0000 ffff ffff ffff ffff     ................
   11a28:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
   11a38:	ffff 0000 001f 001f 0000 ffff 0000 001f     ................
   11a48:	0000 ffff ffff ffff ffff ffff ffff ffff     ................
   11a58:	ffff ffff ffff ffff ffff ffff 0000 001f     ................
   11a68:	001f 001f 0000 0000 001f 0000 ffff ffff     ................
   11a78:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
   11a88:	ffff ffff ffff 0000 001f 001f 001f 001f     ................
   11a98:	001f 001f 001f 0000 0000 0000 0000 0000     ................
	...
   11ab8:	001f                                        ..

00011aba <_ZL14suitSpriteData>:
   11aba:	0005 0005 001f 001f 0000 001f 001f 001f     ................
   11aca:	0000 0000 0000 001f 0000 0000 0000 0000     ................
	...
   11ae6:	001f 001f 0000 001f 001f 001f 0000 0000     ................
   11af6:	0000 001f 0000 001f 0000 001f 0000 0000     ................
	...
   11b0e:	0000 001f 0000 001f 0000 001f 001f 0000     ................
   11b1e:	001f 001f 001f b8a2 001f b8a2 001f b8a2     ................
   11b2e:	b8a2 b8a2 b8a2 b8a2 b8a2 b8a2 b8a2 b8a2     ................
   11b3e:	b8a2 001f b8a2 b8a2 b8a2 001f 001f 001f     ................
   11b4e:	b8a2 001f 001f 001f 001f b8a2 001f 001f     ................
   11b5e:	001f b8a2 b8a2 b8a2 001f b8a2 b8a2 b8a2     ................
   11b6e:	b8a2 b8a2 001f b8a2 b8a2 b8a2 001f 001f     ................
   11b7e:	001f b8a2 001f 001f                         ........

00011b86 <_ZL17cardTopSpriteData>:
   11b86:	0009 0003 001f ffff ffff ffff ffff ffff     ................
   11b96:	ffff ffff 001f ffff acd0 acd0 acd0 acd0     ................
   11ba6:	acd0 acd0 acd0 ffff acd0 001f 001f 001f     ................
   11bb6:	001f 001f 001f 001f acd0 001f feb2 feb2     ................
   11bc6:	feb2 feb2 feb2 feb2 feb2 001f feb2 cc68     ..............h.
   11bd6:	cc68 cc68 cc68 cc68 cc68 cc68 feb2 cc68     h.h.h.h.h.h...h.
   11be6:	001f 001f 001f 001f 001f 001f 001f cc68     ..............h.

00011bf6 <_ZL10cursorData>:
   11bf6:	0007 0007 001f 001f 001f 0000 0000 001f     ................
   11c06:	001f 001f 001f 0000 ffff 0000 001f 001f     ................
   11c16:	001f 0000 ffff ffff 0000 0000 0000 0000     ................
   11c26:	ffff ffff ffff ffff ffff 0000 001f 0000     ................
   11c36:	ffff ffff 0000 0000 0000 001f 001f 0000     ................
   11c46:	ffff 0000 001f 001f 001f 001f 001f 0000     ................
   11c56:	0000 001f 001f                              ......

00011c5c <_ZL14cardSpriteData>:
   11c5c:	0009 000e 001f ffff ffff ffff ffff ffff     ................
   11c6c:	ffff ffff 001f ffff ffff ffff ffff ffff     ................
   11c7c:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
   11c8c:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
   11c9c:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
   11cac:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
   11cbc:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
   11ccc:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
   11cdc:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
   11cec:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
   11cfc:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
   11d0c:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
   11d1c:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
   11d2c:	ffff ffff ffff ffff ffff ffff ffff ffff     ................
   11d3c:	ffff ffff ffff ffff ffff ffff ffff 001f     ................
   11d4c:	ffff ffff ffff ffff ffff ffff ffff 001f     ................
   11d5c:	001f feb2 feb2 feb2 feb2 feb2 feb2 feb2     ................
   11d6c:	001f feb2 feb2 feb2 feb2 feb2 feb2 feb2     ................
   11d7c:	feb2 feb2 feb2 feb2 feb2 feb2 feb2 feb2     ................
   11d8c:	feb2 feb2 feb2 feb2 feb2 feb2 feb2 cc68     ..............h.
   11d9c:	feb2 feb2 feb2 feb2 feb2 feb2 feb2 feb2     ................
   11dac:	cc68 feb2 feb2 feb2 feb2 feb2 feb2 cc68     h.............h.
   11dbc:	cc68 cc68 cc68 cc68 feb2 feb2 feb2 feb2     h.h.h.h.........
   11dcc:	feb2 feb2 feb2 feb2 feb2 feb2 feb2 feb2     ................
   11ddc:	feb2 feb2 cc68 cc68 cc68 feb2 feb2 feb2     ....h.h.h.......
   11dec:	feb2 feb2 cc68 feb2 cc68 feb2 cc68 feb2     ....h...h...h...
   11dfc:	feb2 feb2 feb2 feb2 feb2 feb2 feb2 feb2     ................
   11e0c:	feb2 feb2 feb2 feb2 feb2 feb2 fd42 feb2     ............B...
   11e1c:	feb2 feb2 feb2 feb2 feb2 feb2 feb2 feb2     ................
   11e2c:	feb2 feb2 feb2 feb2 feb2 feb2 feb2 feb2     ................
   11e3c:	feb2 feb2 feb2 feb2 feb2 001f feb2 feb2     ................
   11e4c:	feb2 feb2 feb2 feb2 feb2 001f               ............

00011e58 <_ZL19talonBackgroundData>:
   11e58:	0005 000e 001f ffff acd0 ffff acd0 ffff     ................
   11e68:	acd0 ffff acd0 ffff ffff acd0 ffff acd0     ................
   11e78:	ffff ffff acd0 ffff acd0 ffff ffff acd0     ................
   11e88:	ffff acd0 ffff ffff acd0 ffff acd0 ffff     ................
   11e98:	ffff acd0 ffff acd0 ffff ffff acd0 ffff     ................
   11ea8:	acd0 ffff ffff acd0 ffff acd0 ffff ffff     ................
   11eb8:	acd0 ffff acd0 ffff ffff acd0 ffff acd0     ................
   11ec8:	ffff ffff acd0 ffff acd0 ffff ffff acd0     ................
   11ed8:	ffff acd0 ffff 001f ffff acd0 ffff acd0     ................

00011ee8 <_ZL15valueSpriteData>:
   11ee8:	0003 0005 001f 001f 001f 001f 001f 0000     ................
   11ef8:	001f 001f 0000 001f 001f 0000 001f 001f     ................
   11f08:	0000 001f 0000 001f 0000 001f 0000 0000     ................
   11f18:	0000 0000 0000 001f 0000 0000 001f 0000     ................
   11f28:	0000 0000 0000 001f 001f 0000 0000 0000     ................
   11f38:	0000 0000 001f 001f 0000 0000 0000 0000     ................
   11f48:	0000 0000 001f 001f 0000 001f 0000 0000     ................
   11f58:	001f 001f 0000 0000 0000 0000 0000 001f     ................
   11f68:	001f 0000 001f 0000 0000 0000 0000 001f     ................
   11f78:	001f 0000 001f 001f 0000 0000 0000 0000     ................
   11f88:	0000 001f 001f 0000 0000 0000 001f 001f     ................
	...
   11fa8:	001f 001f 0000 0000 0000 0000 001f 0000     ................
	...
   11fc4:	001f 001f 0000 001f 001f 0000 001f 001f     ................
   11fd4:	0000 001f 001f 0000 0000 0000 0000 0000     ................
   11fe4:	001f 0000 0000 0000 0000 0000 001f 0000     ................
	...
   12000:	0000 001f 0000 0000 0000 0000 001f 001f     ................
	...
   12020:	001f 0000 0000 001f 0000 0000 001f 0000     ................
   12030:	0000 0000 0000 001f 001f 0000 001f 001f     ................
   12040:	0000 001f 001f 0000 0000 001f 0000 0000     ................
	...
   1205c:	001f 0000 0000 001f 0000 0000 0000 0000     ................
   1206c:	001f 0000 001f 0000 001f 0000 0000 001f     ................
   1207c:	0000 0000 0000 001f 0000 001f 0000 0000     ................
   1208c:	001f 0000 001f 001f 001f 001f 001f b8a2     ................
   1209c:	001f 001f b8a2 001f 001f b8a2 001f 001f     ................
   120ac:	b8a2 001f b8a2 001f b8a2 001f b8a2 b8a2     ................
   120bc:	b8a2 b8a2 b8a2 001f b8a2 b8a2 001f b8a2     ................
   120cc:	b8a2 b8a2 b8a2 001f 001f b8a2 b8a2 b8a2     ................
   120dc:	b8a2 b8a2 001f 001f b8a2 b8a2 b8a2 b8a2     ................
   120ec:	b8a2 b8a2 001f 001f b8a2 001f b8a2 b8a2     ................
   120fc:	001f 001f b8a2 b8a2 b8a2 b8a2 b8a2 001f     ................
   1210c:	001f b8a2 001f b8a2 b8a2 b8a2 b8a2 001f     ................
   1211c:	001f b8a2 001f 001f b8a2 b8a2 b8a2 b8a2     ................
   1212c:	b8a2 001f 001f b8a2 b8a2 b8a2 001f 001f     ................
   1213c:	b8a2 b8a2 b8a2 b8a2 b8a2 b8a2 b8a2 b8a2     ................
   1214c:	001f 001f b8a2 b8a2 b8a2 b8a2 001f b8a2     ................
   1215c:	b8a2 b8a2 b8a2 b8a2 b8a2 b8a2 001f 001f     ................
   1216c:	b8a2 001f 001f b8a2 001f 001f b8a2 001f     ................
   1217c:	001f b8a2 b8a2 b8a2 b8a2 b8a2 001f b8a2     ................
   1218c:	b8a2 b8a2 b8a2 b8a2 001f b8a2 b8a2 b8a2     ................
   1219c:	b8a2 b8a2 b8a2 b8a2 b8a2 001f b8a2 b8a2     ................
   121ac:	b8a2 b8a2 001f 001f b8a2 b8a2 b8a2 b8a2     ................
   121bc:	b8a2 b8a2 b8a2 b8a2 001f b8a2 b8a2 001f     ................
   121cc:	b8a2 b8a2 001f b8a2 b8a2 b8a2 b8a2 001f     ................
   121dc:	001f b8a2 001f 001f b8a2 001f 001f b8a2     ................
   121ec:	b8a2 001f b8a2 b8a2 b8a2 b8a2 b8a2 b8a2     ................
   121fc:	b8a2 b8a2 001f b8a2 b8a2 001f b8a2 b8a2     ................
   1220c:	b8a2 b8a2 001f b8a2 001f b8a2 001f b8a2     ................
   1221c:	b8a2 001f b8a2 b8a2 b8a2 001f b8a2 001f     ................
   1222c:	b8a2 b8a2 001f b8a2                         ........

00012234 <_ZL14backgroundData>:
   12234:	0050 0040 044a 0409 0409 0409 0409 0409     P.@.J...........
   12244:	0409 0409 044a 044a 044a 044a 044a 0409     ....J.J.J.J.J...
   12254:	0409 0409 0409 0409 0409 0409 044a 044a     ............J.J.
   12264:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   12274:	0409 0409 044a 044a 044a 044a 044a 0409     ....J.J.J.J.J...
   12284:	0409 0409 0409 0409 0409 0409 044a 044a     ............J.J.
   12294:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   122a4:	0409 0409 044a 044a 044a 044a 044a 0409     ....J.J.J.J.J...
   122b4:	0409 0409 0409 0409 0409 0409 044a 044a     ............J.J.
   122c4:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   122d4:	0409 0409 0409 0409 0409 044a 0409 044a     ..........J...J.
   122e4:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   122f4:	0409 0409 044a 0409 0409 0409 0409 044a     ....J.........J.
   12304:	044a 044a 0409 0409 0409 044a 0409 044a     J.J.......J...J.
   12314:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   12324:	0409 0409 044a 0409 0409 0409 0409 044a     ....J.........J.
   12334:	044a 044a 0409 0409 0409 044a 0409 044a     J.J.......J...J.
   12344:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   12354:	0409 0409 044a 0409 0409 0409 0409 044a     ....J.........J.
   12364:	044a 044a 0409 0409 0409 044a 0409 044a     J.J.......J...J.
   12374:	0409 0409 0409 0409 044a 052b 052b 052b     ........J.+.+.+.
   12384:	052b 04eb 04eb 04eb 044a 0409 0409 0409     +.......J.......
   12394:	04eb 052b 052b 052b 04eb 04eb 04eb 0409     ..+.+.+.........
   123a4:	044a 0409 0409 0409 044a 044a 044a 044a     J.......J.J.J.J.
   123b4:	044a 0409 0409 0409 044a 0409 04eb 04eb     J.......J.......
   123c4:	04eb 052b 052b 052b 04eb 0409 0409 0409     ..+.+.+.........
   123d4:	044a 04eb 04eb 04eb 052b 052b 052b 052b     J.......+.+.+.+.
   123e4:	044a 0409 0409 0409 052b 04eb 04eb 04eb     J.......+.......
   123f4:	04eb 052b 052b 044a 0409 0409 0409 04eb     ..+.+.J.........
   12404:	052b 04eb 04eb 04eb 052b 052b 044a 044a     +.......+.+.J.J.
   12414:	044a 0409 0409 0409 052b 052b 052b 052b     J.......+.+.+.+.
   12424:	052b 04eb 04eb 04eb 04eb 0409 0409 04eb     +...............
   12434:	052b 052b 052b 052b 052b 04eb 04eb 04eb     +.+.+.+.+.......
   12444:	0409 0409 0409 0409 044a 044a 044a 044a     ........J.J.J.J.
   12454:	044a 0409 0409 0409 0409 04eb 04eb 04eb     J...............
   12464:	052b 052b 052b 052b 052b 04eb 0409 0409     +.+.+.+.+.......
   12474:	04eb 04eb 04eb 04eb 052b 052b 052b 052b     ........+.+.+.+.
   12484:	052b 0409 0409 04eb 04eb 04eb 04eb 04eb     +...............
   12494:	052b 052b 052b 052b 044a 0409 04eb 04eb     +.+.+.+.J.......
   124a4:	04eb 04eb 04eb 04eb 052b 052b 052b 044a     ........+.+.+.J.
   124b4:	044a 0409 0409 0409 04eb 052b 052b 052b     J.........+.+.+.
   124c4:	04eb 04eb 04eb 04eb 052b 0409 0409 04eb     ........+.......
   124d4:	04eb 052b 052b 052b 04eb 04eb 04eb 04eb     ..+.+.+.........
   124e4:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   124f4:	0409 0409 0409 0409 044a 04eb 04eb 04eb     ........J.......
   12504:	04eb 052b 052b 052b 04eb 04eb 0409 0409     ..+.+.+.........
   12514:	052b 04eb 04eb 04eb 04eb 052b 052b 052b     +.........+.+.+.
   12524:	04eb 0409 0409 04eb 052b 04eb 04eb 04eb     ........+.......
   12534:	04eb 052b 052b 052b 0409 0409 04eb 04eb     ..+.+.+.........
   12544:	052b 04eb 04eb 04eb 04eb 052b 052b 044a     +.........+.+.J.
   12554:	0409 0409 0409 0409 04eb 04eb 052b 04eb     ............+...
   12564:	04eb 04eb 04eb 052b 052b 044a 0409 04eb     ......+.+.J.....
   12574:	04eb 04eb 052b 04eb 04eb 04eb 04eb 052b     ....+.........+.
   12584:	044a 044a 0409 0409 0409 0409 044a 0409     J.J.........J...
   12594:	0409 0409 0409 044a 044a 052b 04eb 04eb     ......J.J.+.....
   125a4:	04eb 04eb 052b 04eb 04eb 04eb 0409 044a     ....+.........J.
   125b4:	052b 052b 04eb 04eb 04eb 04eb 052b 04eb     +.+.........+...
   125c4:	04eb 0409 0409 052b 052b 052b 04eb 04eb     ......+.+.+.....
   125d4:	04eb 04eb 052b 04eb 0409 0409 04eb 052b     ....+.........+.
   125e4:	052b 052b 04eb 04eb 04eb 04eb 052b 0409     +.+.........+...
   125f4:	0409 0409 044a 0409 04eb 04eb 04eb 04eb     ....J...........
   12604:	04eb 04eb 052b 052b 052b 044a 044a 04eb     ....+.+.+.J.J...
   12614:	04eb 04eb 04eb 04eb 04eb 04eb 052b 052b     ............+.+.
   12624:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   12634:	0409 0409 044a 044a 044a 052b 052b 04eb     ....J.J.J.+.+...
   12644:	04eb 04eb 04eb 04eb 04eb 04eb 044a 044a     ............J.J.
   12654:	052b 052b 052b 04eb 04eb 04eb 04eb 04eb     +.+.+...........
   12664:	04eb 0409 044a 052b 052b 052b 052b 04eb     ....J.+.+.+.+...
   12674:	04eb 04eb 04eb 04eb 0409 0409 052b 052b     ............+.+.
   12684:	052b 052b 052b 04eb 04eb 04eb 04eb 0409     +.+.+...........
   12694:	0409 0409 044a 044a 04eb 04eb 04eb 04eb     ....J.J.........
   126a4:	04eb 052b 052b 04eb 04eb 0409 044a 052b     ..+.+.......J.+.
   126b4:	04eb 04eb 04eb 04eb 04eb 052b 052b 052b     ..........+.+.+.
   126c4:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   126d4:	0409 044a 044a 0409 0409 04eb 052b 052b     ..J.J.......+.+.
   126e4:	04eb 04eb 04eb 04eb 04eb 052b 044a 044a     ..........+.J.J.
   126f4:	04eb 052b 052b 052b 04eb 04eb 04eb 04eb     ..+.+.+.........
   12704:	04eb 044a 044a 04eb 04eb 04eb 052b 052b     ..J.J.......+.+.
   12714:	04eb 04eb 04eb 04eb 0409 044a 052b 052b     ..........J.+.+.
   12724:	04eb 052b 052b 052b 04eb 04eb 04eb 0409     ..+.+.+.........
   12734:	0409 044a 044a 044a 052b 04eb 04eb 04eb     ..J.J.J.+.......
   12744:	052b 052b 04eb 052b 04eb 044a 0409 052b     +.+...+...J...+.
   12754:	052b 04eb 04eb 04eb 052b 052b 052b 04eb     +.......+.+.+...
   12764:	0409 0409 044a 044a 044a 0409 0409 0409     ....J.J.J.......
   12774:	044a 044a 0409 044a 0409 052b 04eb 052b     J.J...J...+...+.
   12784:	052b 04eb 04eb 04eb 052b 052b 044a 0409     +.......+.+.J...
   12794:	04eb 04eb 052b 052b 052b 04eb 04eb 04eb     ....+.+.+.......
   127a4:	052b 044a 0409 052b 04eb 052b 04eb 052b     +.J...+...+...+.
   127b4:	052b 04eb 04eb 04eb 044a 044a 052b 04eb     +.......J.J.+...
   127c4:	04eb 04eb 052b 052b 052b 04eb 04eb 0409     ....+.+.+.......
   127d4:	044a 044a 0409 044a 052b 052b 04eb 052b     J.J...J.+.+...+.
   127e4:	052b 052b 04eb 04eb 04eb 0409 0409 052b     +.+...........+.
   127f4:	052b 052b 04eb 052b 052b 052b 04eb 04eb     +.+...+.+.+.....
   12804:	0409 0409 0409 044a 044a 044a 0409 044a     ......J.J.J...J.
   12814:	044a 044a 0409 0409 0409 04eb 04eb 052b     J.J...........+.
   12824:	052b 052b 04eb 052b 052b 052b 0409 0409     +.+...+.+.+.....
   12834:	04eb 04eb 04eb 052b 052b 052b 04eb 052b     ......+.+.+...+.
   12844:	052b 044a 0409 04eb 04eb 04eb 04eb 052b     +.J...........+.
   12854:	052b 052b 04eb 052b 044a 044a 04eb 04eb     +.+...+.J.J.....
   12864:	04eb 04eb 04eb 052b 052b 052b 04eb 044a     ......+.+.+...J.
   12874:	044a 044a 0409 044a 052b 04eb 04eb 04eb     J.J...J.+.......
   12884:	052b 052b 04eb 052b 04eb 044a 0409 052b     +.+...+...J...+.
   12894:	052b 04eb 04eb 04eb 052b 052b 04eb 04eb     +.......+.+.....
   128a4:	0409 0409 0409 044a 044a 0409 0409 0409     ......J.J.......
   128b4:	044a 044a 0409 044a 0409 052b 04eb 052b     J.J...J...+...+.
   128c4:	052b 04eb 04eb 04eb 052b 052b 0409 0409     +.......+.+.....
   128d4:	04eb 04eb 04eb 052b 052b 04eb 04eb 04eb     ......+.+.......
   128e4:	052b 044a 0409 052b 04eb 052b 04eb 052b     +.J...+...+...+.
   128f4:	052b 04eb 04eb 04eb 044a 044a 04eb 04eb     +.......J.J.....
   12904:	04eb 04eb 04eb 052b 052b 04eb 04eb 0409     ......+.+.......
   12914:	044a 044a 044a 044a 04eb 04eb 04eb 04eb     J.J.J.J.........
   12924:	04eb 052b 052b 052b 04eb 044a 044a 052b     ..+.+.+...J.J.+.
   12934:	04eb 04eb 04eb 04eb 04eb 052b 052b 052b     ..........+.+.+.
   12944:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   12954:	0409 044a 044a 044a 0409 052b 052b 052b     ..J.J.J...+.+.+.
   12964:	04eb 04eb 04eb 04eb 04eb 052b 044a 044a     ..........+.J.J.
   12974:	04eb 052b 052b 052b 04eb 04eb 04eb 04eb     ..+.+.+.........
   12984:	04eb 044a 044a 052b 04eb 052b 052b 052b     ..J.J.+...+.+.+.
   12994:	04eb 04eb 04eb 04eb 0409 044a 052b 052b     ..........J.+.+.
   129a4:	04eb 052b 052b 052b 04eb 04eb 04eb 0409     ..+.+.+.........
   129b4:	0409 044a 044a 0409 04eb 04eb 04eb 04eb     ..J.J...........
   129c4:	04eb 04eb 052b 052b 052b 044a 044a 04eb     ....+.+.+.J.J...
   129d4:	04eb 04eb 04eb 04eb 04eb 04eb 052b 052b     ............+.+.
   129e4:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   129f4:	0409 0409 044a 044a 044a 052b 052b 04eb     ....J.J.J.+.+...
   12a04:	04eb 04eb 04eb 04eb 04eb 04eb 044a 044a     ............J.J.
   12a14:	052b 052b 052b 04eb 04eb 04eb 04eb 04eb     +.+.+...........
   12a24:	04eb 0409 044a 052b 052b 052b 052b 04eb     ....J.+.+.+.+...
   12a34:	04eb 04eb 04eb 04eb 0409 0409 052b 052b     ............+.+.
   12a44:	052b 052b 052b 04eb 04eb 04eb 04eb 0409     +.+.+...........
   12a54:	0409 0409 0409 0409 04eb 04eb 052b 04eb     ............+...
   12a64:	04eb 04eb 04eb 052b 052b 044a 0409 04eb     ......+.+.J.....
   12a74:	04eb 052b 04eb 052b 04eb 04eb 04eb 052b     ..+...+.......+.
   12a84:	044a 044a 0409 0409 0409 0409 044a 0409     J.J.........J...
   12a94:	0409 0409 0409 044a 044a 052b 04eb 04eb     ......J.J.+.....
   12aa4:	04eb 052b 04eb 052b 04eb 04eb 0409 044a     ..+...+.......J.
   12ab4:	052b 052b 04eb 04eb 04eb 04eb 052b 04eb     +.+.........+...
   12ac4:	04eb 0409 0409 052b 052b 052b 04eb 04eb     ......+.+.+.....
   12ad4:	04eb 052b 04eb 052b 0409 0409 04eb 052b     ..+...+.......+.
   12ae4:	052b 052b 04eb 04eb 04eb 04eb 052b 0409     +.+.........+...
   12af4:	0409 0409 0409 0409 04eb 052b 052b 052b     ..........+.+.+.
   12b04:	04eb 04eb 04eb 04eb 052b 0409 0409 04eb     ........+.......
   12b14:	052b 052b 052b 052b 052b 04eb 04eb 04eb     +.+.+.+.+.......
   12b24:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   12b34:	0409 0409 0409 0409 044a 04eb 04eb 04eb     ........J.......
   12b44:	052b 052b 052b 052b 052b 04eb 0409 0409     +.+.+.+.+.......
   12b54:	052b 04eb 04eb 04eb 04eb 052b 052b 052b     +.........+.+.+.
   12b64:	04eb 0409 0409 04eb 052b 04eb 04eb 04eb     ........+.......
   12b74:	052b 052b 052b 052b 044a 0409 04eb 04eb     +.+.+.+.J.......
   12b84:	052b 04eb 04eb 04eb 04eb 052b 052b 044a     +.........+.+.J.
   12b94:	0409 0409 0409 0409 044a 052b 052b 052b     ........J.+.+.+.
   12ba4:	052b 04eb 04eb 04eb 0409 0409 0409 0409     +...............
   12bb4:	052b 052b 052b 052b 052b 04eb 04eb 0409     +.+.+.+.+.......
   12bc4:	0409 0409 0409 0409 044a 044a 044a 044a     ........J.J.J.J.
   12bd4:	044a 0409 0409 0409 0409 0409 04eb 04eb     J...............
   12be4:	052b 052b 052b 052b 052b 0409 0409 0409     +.+.+.+.+.......
   12bf4:	0409 04eb 04eb 04eb 052b 052b 052b 052b     ........+.+.+.+.
   12c04:	044a 0409 0409 0409 04eb 04eb 04eb 04eb     J...............
   12c14:	052b 052b 052b 044a 044a 0409 0409 04eb     +.+.+.J.J.......
   12c24:	04eb 04eb 04eb 04eb 052b 052b 044a 044a     ........+.+.J.J.
   12c34:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   12c44:	0409 0409 0409 0409 044a 0409 0409 0409     ........J.......
   12c54:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   12c64:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   12c74:	0409 0409 0409 0409 044a 0409 0409 0409     ........J.......
   12c84:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   12c94:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   12ca4:	0409 0409 0409 0409 044a 0409 0409 0409     ........J.......
   12cb4:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   12cc4:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   12cd4:	0409 0409 0409 0409 0409 0409 044a 0409     ............J...
   12ce4:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   12cf4:	0409 0409 044a 0409 0409 0409 0409 044a     ....J.........J.
   12d04:	044a 044a 0409 0409 0409 0409 044a 0409     J.J.........J...
   12d14:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   12d24:	0409 0409 044a 0409 0409 0409 0409 044a     ....J.........J.
   12d34:	044a 044a 0409 0409 0409 0409 044a 0409     J.J.........J...
   12d44:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   12d54:	0409 0409 044a 0409 0409 0409 0409 044a     ....J.........J.
   12d64:	044a 044a 0409 0409 0409 0409 044a 0409     J.J.........J...
   12d74:	0409 0409 044a 0409 0409 04eb 04eb 04eb     ....J...........
   12d84:	04eb 04eb 052b 052b 044a 044a 044a 0409     ....+.+.J.J.J...
   12d94:	04eb 04eb 04eb 04eb 04eb 04eb 052b 044a     ............+.J.
   12da4:	044a 044a 044a 04eb 04eb 04eb 04eb 04eb     J.J.J...........
   12db4:	04eb 04eb 044a 044a 044a 044a 052b 04eb     ....J.J.J.J.+...
   12dc4:	04eb 04eb 04eb 04eb 04eb 0409 044a 044a     ............J.J.
   12dd4:	044a 052b 052b 04eb 04eb 04eb 04eb 04eb     J.+.+...........
   12de4:	0409 0409 044a 044a 052b 052b 052b 04eb     ....J.J.+.+.+...
   12df4:	04eb 04eb 04eb 0409 0409 0409 044a 052b     ............J.+.
   12e04:	052b 052b 052b 04eb 04eb 04eb 0409 0409     +.+.+...........
   12e14:	0409 0409 044a 044a 04eb 04eb 04eb 04eb     ....J.J.........
   12e24:	04eb 052b 052b 052b 04eb 044a 044a 052b     ..+.+.+...J.J.+.
   12e34:	04eb 04eb 04eb 04eb 04eb 052b 052b 04eb     ..........+.+...
   12e44:	0409 0409 052b 052b 04eb 04eb 04eb 04eb     ....+.+.........
   12e54:	04eb 052b 052b 044a 0409 052b 052b 052b     ..+.+.J...+.+.+.
   12e64:	04eb 04eb 04eb 04eb 04eb 052b 044a 0409     ..........+.J...
   12e74:	04eb 04eb 052b 052b 04eb 04eb 04eb 04eb     ....+.+.........
   12e84:	04eb 044a 044a 052b 04eb 052b 052b 052b     ..J.J.+...+.+.+.
   12e94:	04eb 04eb 04eb 04eb 0409 044a 052b 04eb     ..........J.+...
   12ea4:	04eb 04eb 052b 052b 04eb 04eb 04eb 0409     ....+.+.........
   12eb4:	0409 044a 0409 044a 052b 04eb 04eb 04eb     ..J...J.+.......
   12ec4:	052b 052b 052b 04eb 04eb 0409 044a 052b     +.+.+.......J.+.
   12ed4:	052b 04eb 04eb 04eb 052b 052b 04eb 052b     +.......+.+...+.
   12ee4:	0409 044a 04eb 052b 052b 04eb 04eb 04eb     ..J...+.+.......
   12ef4:	052b 052b 052b 0409 0409 04eb 052b 052b     +.+.+.......+.+.
   12f04:	052b 04eb 04eb 04eb 052b 052b 0409 044a     +.......+.+...J.
   12f14:	04eb 052b 04eb 052b 052b 04eb 04eb 04eb     ..+...+.+.......
   12f24:	052b 044a 044a 04eb 04eb 04eb 052b 052b     +.J.J.......+.+.
   12f34:	052b 04eb 04eb 04eb 044a 044a 04eb 052b     +.......J.J...+.
   12f44:	04eb 052b 04eb 052b 052b 04eb 04eb 0409     ..+...+.+.......
   12f54:	044a 044a 0409 044a 052b 052b 04eb 052b     J.J...J.+.+...+.
   12f64:	052b 052b 04eb 04eb 04eb 0409 0409 052b     +.+...........+.
   12f74:	052b 052b 04eb 052b 052b 052b 04eb 04eb     +.+...+.+.+.....
   12f84:	0409 0409 04eb 052b 052b 052b 04eb 052b     ......+.+.+...+.
   12f94:	052b 052b 04eb 0409 0409 04eb 04eb 052b     +.+...........+.
   12fa4:	052b 052b 04eb 052b 052b 052b 0409 0409     +.+...+.+.+.....
   12fb4:	04eb 04eb 04eb 052b 052b 052b 04eb 052b     ......+.+.+...+.
   12fc4:	052b 044a 0409 04eb 04eb 04eb 04eb 052b     +.J...........+.
   12fd4:	052b 052b 04eb 052b 044a 044a 04eb 04eb     +.+...+.J.J.....
   12fe4:	04eb 04eb 04eb 052b 052b 052b 04eb 044a     ......+.+.+...J.
   12ff4:	044a 044a 0409 044a 052b 04eb 04eb 04eb     J.J...J.+.......
   13004:	052b 052b 04eb 04eb 04eb 0409 0409 052b     +.+...........+.
   13014:	052b 04eb 04eb 04eb 052b 052b 04eb 052b     +.......+.+...+.
   13024:	0409 044a 04eb 052b 052b 04eb 04eb 04eb     ..J...+.+.......
   13034:	052b 052b 04eb 0409 0409 04eb 04eb 052b     +.+...........+.
   13044:	052b 04eb 04eb 04eb 052b 052b 0409 044a     +.......+.+...J.
   13054:	04eb 052b 04eb 052b 052b 04eb 04eb 04eb     ..+...+.+.......
   13064:	052b 044a 0409 04eb 04eb 04eb 04eb 052b     +.J...........+.
   13074:	052b 04eb 04eb 04eb 044a 044a 04eb 052b     +.......J.J...+.
   13084:	04eb 052b 04eb 052b 052b 04eb 04eb 0409     ..+...+.+.......
   13094:	044a 044a 044a 044a 04eb 04eb 04eb 04eb     J.J.J.J.........
   130a4:	04eb 052b 052b 052b 04eb 044a 044a 052b     ..+.+.+...J.J.+.
   130b4:	04eb 04eb 04eb 04eb 04eb 052b 052b 052b     ..........+.+.+.
   130c4:	0409 044a 052b 052b 04eb 04eb 04eb 04eb     ..J.+.+.........
   130d4:	04eb 052b 052b 044a 0409 052b 052b 052b     ..+.+.J...+.+.+.
   130e4:	04eb 04eb 04eb 04eb 04eb 052b 044a 044a     ..........+.J.J.
   130f4:	04eb 052b 052b 052b 04eb 04eb 04eb 04eb     ..+.+.+.........
   13104:	04eb 044a 044a 052b 04eb 052b 052b 052b     ..J.J.+...+.+.+.
   13114:	04eb 04eb 04eb 04eb 0409 044a 052b 052b     ..........J.+.+.
   13124:	04eb 052b 052b 052b 04eb 04eb 04eb 0409     ..+.+.+.........
   13134:	0409 044a 044a 0409 04eb 04eb 04eb 04eb     ..J.J...........
   13144:	04eb 04eb 052b 052b 052b 044a 044a 04eb     ....+.+.+.J.J...
   13154:	04eb 04eb 04eb 04eb 04eb 04eb 052b 052b     ............+.+.
   13164:	044a 044a 052b 04eb 04eb 04eb 04eb 04eb     J.J.+...........
   13174:	04eb 04eb 052b 044a 044a 052b 052b 04eb     ....+.J.J.+.+...
   13184:	04eb 04eb 04eb 04eb 04eb 04eb 044a 044a     ............J.J.
   13194:	052b 052b 052b 04eb 04eb 04eb 04eb 04eb     +.+.+...........
   131a4:	04eb 0409 044a 052b 052b 052b 052b 04eb     ....J.+.+.+.+...
   131b4:	04eb 04eb 04eb 04eb 0409 0409 052b 052b     ............+.+.
   131c4:	052b 052b 052b 04eb 04eb 04eb 04eb 0409     +.+.+...........
   131d4:	0409 0409 0409 0409 04eb 052b 04eb 052b     ..........+...+.
   131e4:	04eb 04eb 04eb 052b 052b 044a 0409 04eb     ......+.+.J.....
   131f4:	04eb 04eb 052b 04eb 04eb 04eb 04eb 052b     ....+.........+.
   13204:	044a 044a 04eb 04eb 04eb 052b 04eb 052b     J.J.......+...+.
   13214:	04eb 04eb 04eb 044a 044a 052b 04eb 04eb     ......J.J.+.....
   13224:	04eb 04eb 052b 04eb 04eb 04eb 0409 044a     ....+.........J.
   13234:	052b 052b 04eb 04eb 04eb 052b 04eb 052b     +.+.......+...+.
   13244:	04eb 0409 0409 052b 052b 052b 04eb 04eb     ......+.+.+.....
   13254:	04eb 04eb 052b 04eb 0409 0409 04eb 052b     ....+.........+.
   13264:	052b 052b 04eb 04eb 04eb 052b 04eb 044a     +.+.......+...J.
   13274:	0409 0409 0409 0409 052b 052b 052b 052b     ........+.+.+.+.
   13284:	052b 04eb 04eb 04eb 052b 0409 0409 04eb     +.......+.......
   13294:	04eb 052b 052b 052b 04eb 04eb 04eb 04eb     ..+.+.+.........
   132a4:	044a 0409 04eb 04eb 052b 052b 052b 052b     J.......+.+.+.+.
   132b4:	052b 04eb 04eb 0409 044a 04eb 04eb 04eb     +.......J.......
   132c4:	04eb 052b 052b 052b 04eb 04eb 0409 0409     ..+.+.+.........
   132d4:	052b 04eb 04eb 04eb 052b 052b 052b 052b     +.......+.+.+.+.
   132e4:	052b 0409 0409 04eb 052b 04eb 04eb 04eb     +.......+.......
   132f4:	04eb 052b 052b 052b 0409 0409 04eb 04eb     ..+.+.+.........
   13304:	052b 04eb 04eb 04eb 052b 052b 052b 044a     +.......+.+.+.J.
   13314:	044a 0409 0409 0409 052b 052b 052b 052b     J.......+.+.+.+.
   13324:	052b 04eb 04eb 04eb 04eb 0409 0409 04eb     +...............
   13334:	052b 052b 052b 052b 052b 04eb 04eb 04eb     +.+.+.+.+.......
   13344:	0409 0409 04eb 04eb 052b 052b 052b 052b     ........+.+.+.+.
   13354:	052b 04eb 04eb 0409 0409 04eb 04eb 04eb     +...............
   13364:	052b 052b 052b 052b 052b 04eb 0409 0409     +.+.+.+.+.......
   13374:	04eb 04eb 04eb 04eb 052b 052b 052b 052b     ........+.+.+.+.
   13384:	052b 0409 0409 04eb 04eb 04eb 04eb 04eb     +...............
   13394:	052b 052b 052b 052b 044a 0409 04eb 04eb     +.+.+.+.J.......
   133a4:	04eb 04eb 04eb 04eb 052b 052b 052b 044a     ........+.+.+.J.
   133b4:	044a 0409 0409 0409 04eb 052b 052b 052b     J.........+.+.+.
   133c4:	04eb 04eb 04eb 04eb 052b 0409 0409 04eb     ........+.......
   133d4:	04eb 052b 052b 052b 04eb 04eb 04eb 04eb     ..+.+.+.........
   133e4:	044a 0409 04eb 04eb 04eb 052b 052b 052b     J.........+.+.+.
   133f4:	04eb 04eb 04eb 0409 044a 04eb 04eb 04eb     ........J.......
   13404:	04eb 052b 052b 052b 04eb 04eb 0409 0409     ..+.+.+.........
   13414:	052b 04eb 04eb 04eb 04eb 052b 052b 052b     +.........+.+.+.
   13424:	04eb 0409 0409 04eb 052b 04eb 04eb 04eb     ........+.......
   13434:	04eb 052b 052b 052b 0409 0409 04eb 04eb     ..+.+.+.........
   13444:	052b 04eb 04eb 04eb 04eb 052b 052b 044a     +.........+.+.J.
   13454:	0409 0409 0409 0409 04eb 04eb 052b 04eb     ............+...
   13464:	04eb 04eb 04eb 052b 052b 044a 0409 04eb     ......+.+.J.....
   13474:	04eb 04eb 052b 04eb 04eb 04eb 04eb 052b     ....+.........+.
   13484:	044a 044a 04eb 04eb 04eb 04eb 052b 04eb     J.J.........+...
   13494:	04eb 04eb 04eb 044a 044a 052b 04eb 04eb     ......J.J.+.....
   134a4:	04eb 04eb 052b 04eb 04eb 04eb 0409 044a     ....+.........J.
   134b4:	052b 052b 04eb 04eb 04eb 04eb 052b 04eb     +.+.........+...
   134c4:	04eb 0409 0409 052b 052b 052b 04eb 04eb     ......+.+.+.....
   134d4:	04eb 04eb 052b 04eb 0409 0409 04eb 052b     ....+.........+.
   134e4:	052b 052b 04eb 04eb 04eb 04eb 052b 0409     +.+.........+...
   134f4:	0409 0409 044a 0409 04eb 04eb 04eb 04eb     ....J...........
   13504:	04eb 04eb 052b 052b 052b 044a 044a 04eb     ....+.+.+.J.J...
   13514:	04eb 04eb 04eb 04eb 04eb 04eb 052b 052b     ............+.+.
   13524:	044a 044a 052b 04eb 04eb 04eb 04eb 04eb     J.J.+...........
   13534:	04eb 04eb 052b 044a 044a 052b 052b 04eb     ....+.J.J.+.+...
   13544:	04eb 04eb 04eb 04eb 04eb 04eb 044a 044a     ............J.J.
   13554:	052b 052b 052b 04eb 04eb 04eb 04eb 04eb     +.+.+...........
   13564:	04eb 0409 044a 052b 052b 052b 052b 04eb     ....J.+.+.+.+...
   13574:	04eb 04eb 04eb 04eb 0409 0409 052b 052b     ............+.+.
   13584:	052b 052b 052b 04eb 04eb 04eb 04eb 0409     +.+.+...........
   13594:	0409 0409 044a 044a 0409 04eb 04eb 04eb     ....J.J.........
   135a4:	04eb 052b 052b 04eb 0409 0409 044a 044a     ..+.+.......J.J.
   135b4:	04eb 04eb 04eb 04eb 04eb 052b 052b 044a     ..........+.+.J.
   135c4:	0409 044a 044a 052b 04eb 04eb 04eb 04eb     ..J.J.+.........
   135d4:	04eb 052b 044a 0409 0409 0409 052b 052b     ..+.J.......+.+.
   135e4:	04eb 04eb 04eb 04eb 04eb 044a 044a 044a     ..........J.J.J.
   135f4:	0409 052b 052b 052b 04eb 04eb 04eb 04eb     ..+.+.+.........
   13604:	0409 044a 044a 0409 04eb 04eb 052b 052b     ..J.J.......+.+.
   13614:	04eb 04eb 04eb 0409 0409 044a 044a 052b     ..........J.J.+.
   13624:	04eb 052b 052b 052b 04eb 04eb 0409 0409     ..+.+.+.........
   13634:	0409 044a 044a 044a 044a 0409 0409 0409     ..J.J.J.J.......
   13644:	044a 044a 0409 044a 0409 044a 0409 044a     J.J...J...J...J.
   13654:	044a 0409 0409 0409 044a 044a 044a 0409     J.......J.J.J...
   13664:	0409 0409 044a 044a 044a 0409 0409 0409     ....J.J.J.......
   13674:	044a 044a 0409 044a 0409 044a 0409 044a     J.J...J...J...J.
   13684:	044a 0409 0409 0409 044a 044a 044a 0409     J.......J.J.J...
   13694:	0409 0409 044a 044a 044a 0409 0409 0409     ....J.J.J.......
   136a4:	044a 044a 0409 044a 0409 044a 0409 044a     J.J...J...J...J.
   136b4:	044a 0409 0409 0409 044a 044a 044a 0409     J.......J.J.J...
   136c4:	0409 0409 044a 044a 044a 0409 0409 0409     ....J.J.J.......
   136d4:	044a 044a 0409 044a 044a 044a 0409 044a     J.J...J.J.J...J.
   136e4:	044a 044a 0409 0409 0409 0409 0409 044a     J.J...........J.
   136f4:	044a 044a 0409 044a 044a 044a 0409 0409     J.J...J.J.J.....
   13704:	0409 0409 0409 044a 044a 044a 0409 044a     ......J.J.J...J.
   13714:	044a 044a 0409 0409 0409 0409 0409 044a     J.J...........J.
   13724:	044a 044a 0409 044a 044a 044a 0409 0409     J.J...J.J.J.....
   13734:	0409 0409 0409 044a 044a 044a 0409 044a     ......J.J.J...J.
   13744:	044a 044a 0409 0409 0409 0409 0409 044a     J.J...........J.
   13754:	044a 044a 0409 044a 044a 044a 0409 0409     J.J...J.J.J.....
   13764:	0409 0409 0409 044a 044a 044a 0409 044a     ......J.J.J...J.
   13774:	044a 044a 0409 044a 044a 0409 0409 0409     J.J...J.J.......
   13784:	044a 044a 0409 044a 0409 044a 0409 044a     J.J...J...J...J.
   13794:	044a 0409 0409 0409 044a 044a 0409 0409     J.......J.J.....
   137a4:	0409 0409 0409 044a 044a 0409 0409 0409     ......J.J.......
   137b4:	044a 044a 0409 044a 0409 044a 0409 044a     J.J...J...J...J.
   137c4:	044a 0409 0409 0409 044a 044a 0409 0409     J.......J.J.....
   137d4:	0409 0409 0409 044a 044a 0409 0409 0409     ......J.J.......
   137e4:	044a 044a 0409 044a 0409 044a 0409 044a     J.J...J...J...J.
   137f4:	044a 0409 0409 0409 044a 044a 0409 0409     J.......J.J.....
   13804:	0409 0409 0409 044a 044a 0409 0409 0409     ......J.J.......
   13814:	044a 044a 044a 044a 0409 0409 0409 0409     J.J.J.J.........
   13824:	0409 044a 044a 044a 0409 044a 044a 044a     ..J.J.J...J.J.J.
   13834:	0409 0409 0409 0409 0409 044a 044a 044a     ..........J.J.J.
   13844:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   13854:	0409 044a 044a 044a 0409 044a 044a 044a     ..J.J.J...J.J.J.
   13864:	0409 0409 0409 0409 0409 044a 044a 044a     ..........J.J.J.
   13874:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   13884:	0409 044a 044a 044a 0409 044a 044a 044a     ..J.J.J...J.J.J.
   13894:	0409 0409 0409 0409 0409 044a 044a 044a     ..........J.J.J.
   138a4:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   138b4:	0409 044a 044a 0409 0409 0409 0409 0409     ..J.J...........
   138c4:	0409 0409 044a 044a 044a 044a 044a 0409     ....J.J.J.J.J...
   138d4:	0409 0409 0409 0409 0409 0409 044a 044a     ............J.J.
   138e4:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   138f4:	0409 0409 044a 044a 044a 044a 044a 0409     ....J.J.J.J.J...
   13904:	0409 0409 0409 0409 0409 0409 044a 044a     ............J.J.
   13914:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   13924:	0409 0409 044a 044a 044a 044a 044a 0409     ....J.J.J.J.J...
   13934:	0409 0409 0409 0409 0409 0409 044a 044a     ............J.J.
   13944:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   13954:	0409 0409 0409 0409 0409 0409 044a 0409     ............J...
   13964:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   13974:	0409 044a 0409 044a 0409 0409 0409 044a     ..J...J.......J.
   13984:	044a 044a 0409 0409 0409 0409 044a 0409     J.J.........J...
   13994:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   139a4:	0409 044a 0409 044a 0409 0409 0409 044a     ..J...J.......J.
   139b4:	044a 044a 0409 0409 0409 0409 044a 0409     J.J.........J...
   139c4:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   139d4:	0409 044a 0409 044a 0409 0409 0409 044a     ..J...J.......J.
   139e4:	044a 044a 0409 0409 0409 0409 044a 0409     J.J.........J...
   139f4:	0409 0409 0409 0409 0409 044a 044a 044a     ..........J.J.J.
   13a04:	0409 0409 0409 0409 044a 0409 0409 0409     ........J.......
   13a14:	044a 044a 044a 044a 044a 0409 0409 0409     J.J.J.J.J.......
   13a24:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   13a34:	0409 0409 0409 0409 044a 0409 0409 0409     ........J.......
   13a44:	044a 044a 044a 044a 044a 0409 0409 0409     J.J.J.J.J.......
   13a54:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   13a64:	0409 0409 0409 0409 044a 0409 0409 0409     ........J.......
   13a74:	044a 044a 044a 044a 044a 0409 0409 0409     J.J.J.J.J.......
   13a84:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   13a94:	0409 0409 0409 0409 044a 044a 044a 044a     ........J.J.J.J.
   13aa4:	044a 0409 0409 0409 0409 0409 0409 0409     J...............
   13ab4:	044a 044a 044a 044a 044a 0409 0409 0409     J.J.J.J.J.......
   13ac4:	0409 0409 0409 0409 044a 044a 044a 044a     ........J.J.J.J.
   13ad4:	044a 0409 0409 0409 0409 0409 0409 0409     J...............
   13ae4:	044a 044a 044a 044a 044a 0409 0409 0409     J.J.J.J.J.......
   13af4:	0409 0409 0409 0409 044a 044a 044a 044a     ........J.J.J.J.
   13b04:	044a 0409 0409 0409 0409 0409 0409 0409     J...............
   13b14:	044a 044a 044a 044a 044a 0409 0409 0409     J.J.J.J.J.......
   13b24:	0409 0409 0409 0409 044a 044a 044a 044a     ........J.J.J.J.
   13b34:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   13b44:	0409 0409 0409 0409 044a 0409 0409 0409     ........J.......
   13b54:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   13b64:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   13b74:	0409 0409 0409 0409 044a 0409 0409 0409     ........J.......
   13b84:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   13b94:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   13ba4:	0409 0409 0409 0409 044a 0409 0409 0409     ........J.......
   13bb4:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   13bc4:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   13bd4:	0409 0409 0409 0409 0409 0409 044a 0409     ............J...
   13be4:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   13bf4:	0409 0409 044a 0409 0409 0409 0409 044a     ....J.........J.
   13c04:	044a 044a 0409 0409 0409 0409 044a 0409     J.J.........J...
   13c14:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   13c24:	0409 0409 044a 0409 0409 0409 0409 044a     ....J.........J.
   13c34:	044a 044a 0409 0409 0409 0409 044a 0409     J.J.........J...
   13c44:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   13c54:	0409 0409 044a 0409 0409 0409 0409 044a     ....J.........J.
   13c64:	044a 044a 0409 0409 0409 0409 044a 0409     J.J.........J...
   13c74:	0409 0409 044a 0409 0409 0409 0409 0409     ....J...........
   13c84:	0409 0409 044a 044a 044a 044a 044a 0409     ....J.J.J.J.J...
   13c94:	0409 0409 0409 0409 0409 0409 044a 044a     ............J.J.
   13ca4:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   13cb4:	0409 0409 044a 044a 044a 044a 044a 0409     ....J.J.J.J.J...
   13cc4:	0409 0409 0409 0409 0409 0409 044a 044a     ............J.J.
   13cd4:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   13ce4:	0409 0409 044a 044a 044a 044a 044a 0409     ....J.J.J.J.J...
   13cf4:	0409 0409 0409 0409 0409 0409 044a 044a     ............J.J.
   13d04:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   13d14:	0409 0409 044a 044a 0409 0409 0409 0409     ....J.J.........
   13d24:	0409 044a 044a 044a 0409 044a 044a 044a     ..J.J.J...J.J.J.
   13d34:	0409 0409 0409 0409 0409 044a 044a 0409     ..........J.J...
   13d44:	0409 0409 044a 044a 0409 0409 0409 0409     ....J.J.........
   13d54:	0409 044a 044a 044a 0409 044a 044a 044a     ..J.J.J...J.J.J.
   13d64:	0409 0409 0409 0409 0409 044a 044a 0409     ..........J.J...
   13d74:	0409 0409 044a 044a 0409 0409 0409 0409     ....J.J.........
   13d84:	0409 044a 044a 044a 0409 044a 044a 044a     ..J.J.J...J.J.J.
   13d94:	0409 0409 0409 0409 0409 044a 044a 0409     ..........J.J...
   13da4:	0409 0409 044a 044a 0409 0409 0409 0409     ....J.J.........
   13db4:	0409 044a 0409 044a 044a 0409 0409 0409     ..J...J.J.......
   13dc4:	044a 044a 044a 0409 0409 0409 044a 044a     J.J.J.......J.J.
   13dd4:	044a 0409 0409 0409 044a 044a 0409 044a     J.......J.J...J.
   13de4:	0409 044a 0409 044a 044a 0409 0409 0409     ..J...J.J.......
   13df4:	044a 044a 044a 0409 0409 0409 044a 044a     J.J.J.......J.J.
   13e04:	044a 0409 0409 0409 044a 044a 0409 044a     J.......J.J...J.
   13e14:	0409 044a 0409 044a 044a 0409 0409 0409     ..J...J.J.......
   13e24:	044a 044a 044a 0409 0409 0409 044a 044a     J.J.J.......J.J.
   13e34:	044a 0409 0409 0409 044a 044a 0409 044a     J.......J.J...J.
   13e44:	0409 044a 0409 044a 044a 0409 0409 0409     ..J...J.J.......
   13e54:	044a 044a 0409 044a 044a 044a 0409 044a     J.J...J.J.J...J.
   13e64:	044a 044a 0409 0409 0409 0409 0409 044a     J.J...........J.
   13e74:	044a 044a 0409 044a 044a 044a 0409 0409     J.J...J.J.J.....
   13e84:	0409 0409 0409 044a 044a 044a 0409 044a     ......J.J.J...J.
   13e94:	044a 044a 0409 0409 0409 0409 0409 044a     J.J...........J.
   13ea4:	044a 044a 0409 044a 044a 044a 0409 0409     J.J...J.J.J.....
   13eb4:	0409 0409 0409 044a 044a 044a 0409 044a     ......J.J.J...J.
   13ec4:	044a 044a 0409 0409 0409 0409 0409 044a     J.J...........J.
   13ed4:	044a 044a 0409 044a 044a 044a 0409 0409     J.J...J.J.J.....
   13ee4:	0409 0409 0409 044a 044a 044a 0409 044a     ......J.J.J...J.
   13ef4:	044a 044a 0409 044a 044a 0409 0409 0409     J.J...J.J.......
   13f04:	044a 044a 0409 0409 0409 0409 0409 044a     J.J...........J.
   13f14:	044a 0409 0409 0409 044a 044a 0409 044a     J.......J.J...J.
   13f24:	0409 044a 0409 044a 044a 0409 0409 0409     ..J...J.J.......
   13f34:	044a 044a 0409 0409 0409 0409 0409 044a     J.J...........J.
   13f44:	044a 0409 0409 0409 044a 044a 0409 044a     J.......J.J...J.
   13f54:	0409 044a 0409 044a 044a 0409 0409 0409     ..J...J.J.......
   13f64:	044a 044a 0409 0409 0409 0409 0409 044a     J.J...........J.
   13f74:	044a 0409 0409 0409 044a 044a 0409 044a     J.......J.J...J.
   13f84:	0409 044a 0409 044a 044a 0409 0409 0409     ..J...J.J.......
   13f94:	044a 044a 044a 044a 0409 0409 0409 0409     J.J.J.J.........
   13fa4:	0409 044a 044a 044a 0409 044a 044a 044a     ..J.J.J...J.J.J.
   13fb4:	0409 0409 0409 0409 0409 044a 044a 044a     ..........J.J.J.
   13fc4:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   13fd4:	0409 044a 044a 044a 0409 044a 044a 044a     ..J.J.J...J.J.J.
   13fe4:	0409 0409 0409 0409 0409 044a 044a 044a     ..........J.J.J.
   13ff4:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   14004:	0409 044a 044a 044a 0409 044a 044a 044a     ..J.J.J...J.J.J.
   14014:	0409 0409 0409 0409 0409 044a 044a 044a     ..........J.J.J.
   14024:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   14034:	0409 044a 044a 0409 0409 0409 0409 0409     ..J.J...........
   14044:	0409 0409 044a 044a 044a 044a 044a 0409     ....J.J.J.J.J...
   14054:	0409 0409 0409 0409 0409 0409 044a 044a     ............J.J.
   14064:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   14074:	0409 0409 044a 044a 044a 044a 044a 0409     ....J.J.J.J.J...
   14084:	0409 0409 0409 0409 0409 0409 044a 044a     ............J.J.
   14094:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   140a4:	0409 0409 044a 044a 044a 044a 044a 0409     ....J.J.J.J.J...
   140b4:	0409 0409 0409 0409 0409 0409 044a 044a     ............J.J.
   140c4:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   140d4:	0409 0409 0409 0409 0409 044a 0409 044a     ..........J...J.
   140e4:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   140f4:	0409 0409 044a 0409 0409 0409 0409 044a     ....J.........J.
   14104:	044a 044a 0409 0409 0409 044a 0409 044a     J.J.......J...J.
   14114:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   14124:	0409 0409 044a 0409 0409 0409 0409 044a     ....J.........J.
   14134:	044a 044a 0409 0409 0409 044a 0409 044a     J.J.......J...J.
   14144:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   14154:	0409 0409 044a 0409 0409 0409 0409 044a     ....J.........J.
   14164:	044a 044a 0409 0409 0409 044a 0409 044a     J.J.......J...J.
   14174:	0409 0409 0409 0409 044a 044a 044a 044a     ........J.J.J.J.
   14184:	044a 0409 0409 0409 044a 0409 0409 0409     J.......J.......
   14194:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   141a4:	044a 0409 0409 0409 044a 044a 044a 044a     J.......J.J.J.J.
   141b4:	044a 0409 0409 0409 044a 0409 0409 0409     J.......J.......
   141c4:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   141d4:	044a 0409 0409 0409 044a 044a 044a 044a     J.......J.J.J.J.
   141e4:	044a 0409 0409 0409 044a 0409 0409 0409     J.......J.......
   141f4:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   14204:	044a 0409 0409 0409 044a 044a 044a 044a     J.......J.J.J.J.
   14214:	044a 0409 0409 0409 044a 044a 044a 044a     J.......J.J.J.J.
   14224:	044a 0409 0409 0409 0409 0409 0409 0409     J...............
   14234:	044a 044a 044a 044a 044a 0409 0409 0409     J.J.J.J.J.......
   14244:	0409 0409 0409 0409 044a 044a 044a 044a     ........J.J.J.J.
   14254:	044a 0409 0409 0409 0409 0409 0409 0409     J...............
   14264:	044a 044a 044a 044a 044a 0409 0409 0409     J.J.J.J.J.......
   14274:	0409 0409 0409 0409 044a 044a 044a 044a     ........J.J.J.J.
   14284:	044a 0409 0409 0409 0409 0409 0409 0409     J...............
   14294:	044a 044a 044a 044a 044a 0409 0409 0409     J.J.J.J.J.......
   142a4:	0409 0409 0409 0409 044a 044a 044a 044a     ........J.J.J.J.
   142b4:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   142c4:	0409 0409 0409 0409 044a 0409 0409 0409     ........J.......
   142d4:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   142e4:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   142f4:	0409 0409 0409 0409 044a 0409 0409 0409     ........J.......
   14304:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   14314:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   14324:	0409 0409 0409 0409 044a 0409 0409 0409     ........J.......
   14334:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   14344:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   14354:	0409 0409 0409 0409 0409 0409 044a 0409     ............J...
   14364:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   14374:	0409 0409 044a 0409 0409 0409 0409 044a     ....J.........J.
   14384:	044a 044a 0409 0409 0409 0409 044a 0409     J.J.........J...
   14394:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   143a4:	0409 0409 044a 0409 0409 0409 0409 044a     ....J.........J.
   143b4:	044a 044a 0409 0409 0409 0409 044a 0409     J.J.........J...
   143c4:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   143d4:	0409 0409 044a 0409 0409 0409 0409 044a     ....J.........J.
   143e4:	044a 044a 0409 0409 0409 0409 044a 0409     J.J.........J...
   143f4:	0409 0409 044a 0409 0409 0409 0409 0409     ....J...........
   14404:	0409 0409 044a 044a 044a 044a 044a 0409     ....J.J.J.J.J...
   14414:	0409 0409 0409 0409 0409 0409 044a 044a     ............J.J.
   14424:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   14434:	0409 0409 044a 044a 044a 044a 044a 0409     ....J.J.J.J.J...
   14444:	0409 0409 0409 0409 0409 0409 044a 044a     ............J.J.
   14454:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   14464:	0409 0409 044a 044a 044a 044a 044a 0409     ....J.J.J.J.J...
   14474:	0409 0409 0409 0409 0409 0409 044a 044a     ............J.J.
   14484:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   14494:	0409 0409 044a 044a 0409 0409 0409 0409     ....J.J.........
   144a4:	0409 044a 044a 0409 0409 0409 044a 044a     ..J.J.......J.J.
   144b4:	0409 0409 0409 0409 0409 044a 044a 044a     ..........J.J.J.
   144c4:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   144d4:	0409 044a 044a 0409 0409 0409 044a 044a     ..J.J.......J.J.
   144e4:	0409 0409 0409 0409 0409 044a 044a 044a     ..........J.J.J.
   144f4:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   14504:	0409 044a 044a 0409 0409 0409 044a 044a     ..J.J.......J.J.
   14514:	0409 0409 0409 0409 0409 044a 044a 044a     ..........J.J.J.
   14524:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   14534:	0409 044a 044a 044a 044a 0409 0409 0409     ..J.J.J.J.......
   14544:	044a 044a 0409 044a 0409 044a 0409 044a     J.J...J...J...J.
   14554:	044a 0409 0409 0409 044a 044a 044a 0409     J.......J.J.J...
   14564:	0409 0409 044a 044a 044a 0409 0409 0409     ....J.J.J.......
   14574:	044a 044a 0409 044a 0409 044a 0409 044a     J.J...J...J...J.
   14584:	044a 0409 0409 0409 044a 044a 044a 0409     J.......J.J.J...
   14594:	0409 0409 044a 044a 044a 0409 0409 0409     ....J.J.J.......
   145a4:	044a 044a 0409 044a 0409 044a 0409 044a     J.J...J...J...J.
   145b4:	044a 0409 0409 0409 044a 044a 044a 0409     J.......J.J.J...
   145c4:	0409 0409 044a 044a 044a 0409 0409 0409     ....J.J.J.......
   145d4:	044a 044a 0409 044a 044a 044a 0409 044a     J.J...J.J.J...J.
   145e4:	044a 044a 0409 0409 0409 0409 0409 044a     J.J...........J.
   145f4:	044a 044a 0409 044a 044a 044a 0409 0409     J.J...J.J.J.....
   14604:	0409 0409 0409 044a 044a 044a 0409 044a     ......J.J.J...J.
   14614:	044a 044a 0409 0409 0409 0409 0409 044a     J.J...........J.
   14624:	044a 044a 0409 044a 044a 044a 0409 0409     J.J...J.J.J.....
   14634:	0409 0409 0409 044a 044a 044a 0409 044a     ......J.J.J...J.
   14644:	044a 044a 0409 0409 0409 0409 0409 044a     J.J...........J.
   14654:	044a 044a 0409 044a 044a 044a 0409 0409     J.J...J.J.J.....
   14664:	0409 0409 0409 044a 044a 044a 0409 044a     ......J.J.J...J.
   14674:	044a 044a 0409 044a 044a 0409 0409 0409     J.J...J.J.......
   14684:	044a 044a 0409 044a 0409 044a 0409 044a     J.J...J...J...J.
   14694:	044a 0409 0409 0409 044a 044a 0409 0409     J.......J.J.....
   146a4:	0409 0409 0409 044a 044a 0409 0409 0409     ......J.J.......
   146b4:	044a 044a 0409 044a 0409 044a 0409 044a     J.J...J...J...J.
   146c4:	044a 0409 0409 0409 044a 044a 0409 0409     J.......J.J.....
   146d4:	0409 0409 0409 044a 044a 0409 0409 0409     ......J.J.......
   146e4:	044a 044a 0409 044a 0409 044a 0409 044a     J.J...J...J...J.
   146f4:	044a 0409 0409 0409 044a 044a 0409 0409     J.......J.J.....
   14704:	0409 0409 0409 044a 044a 0409 0409 0409     ......J.J.......
   14714:	044a 044a 044a 044a 0409 0409 0409 0409     J.J.J.J.........
   14724:	0409 044a 044a 044a 0409 044a 044a 044a     ..J.J.J...J.J.J.
   14734:	0409 0409 0409 0409 0409 044a 044a 044a     ..........J.J.J.
   14744:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   14754:	0409 044a 044a 044a 0409 044a 044a 044a     ..J.J.J...J.J.J.
   14764:	0409 0409 0409 0409 0409 044a 044a 044a     ..........J.J.J.
   14774:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   14784:	0409 044a 044a 044a 0409 044a 044a 044a     ..J.J.J...J.J.J.
   14794:	0409 0409 0409 0409 0409 044a 044a 044a     ..........J.J.J.
   147a4:	0409 044a 044a 044a 0409 0409 0409 0409     ..J.J.J.........
   147b4:	0409 044a 044a 0409 0409 0409 0409 0409     ..J.J...........
   147c4:	0409 0409 044a 044a 044a 044a 044a 0409     ....J.J.J.J.J...
   147d4:	0409 0409 0409 0409 0409 0409 044a 044a     ............J.J.
   147e4:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   147f4:	0409 0409 044a 044a 044a 044a 044a 0409     ....J.J.J.J.J...
   14804:	0409 0409 0409 0409 0409 0409 044a 044a     ............J.J.
   14814:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   14824:	0409 0409 044a 044a 044a 044a 044a 0409     ....J.J.J.J.J...
   14834:	0409 0409 0409 0409 0409 0409 044a 044a     ............J.J.
   14844:	044a 044a 044a 0409 0409 0409 0409 0409     J.J.J...........
   14854:	0409 0409 0409 0409 0409 0409 044a 0409     ............J...
   14864:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   14874:	0409 044a 0409 044a 0409 0409 0409 044a     ..J...J.......J.
   14884:	044a 044a 0409 0409 0409 0409 044a 0409     J.J.........J...
   14894:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   148a4:	0409 044a 0409 044a 0409 0409 0409 044a     ..J...J.......J.
   148b4:	044a 044a 0409 0409 0409 0409 044a 0409     J.J.........J...
   148c4:	0409 0409 0409 044a 044a 044a 0409 0409     ......J.J.J.....
   148d4:	0409 044a 0409 044a 0409 0409 0409 044a     ..J...J.......J.
   148e4:	044a 044a 0409 0409 0409 0409 044a 0409     J.J.........J...
   148f4:	0409 0409 0409 0409 0409 044a 044a 044a     ..........J.J.J.
   14904:	0409 0409 0409 0409 044a 0409 0409 0409     ........J.......
   14914:	044a 044a 044a 044a 044a 0409 0409 0409     J.J.J.J.J.......
   14924:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   14934:	0409 0409 0409 0409 044a 0409 0409 0409     ........J.......
   14944:	044a 044a 044a 044a 044a 0409 0409 0409     J.J.J.J.J.......
   14954:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   14964:	0409 0409 0409 0409 044a 0409 0409 0409     ........J.......
   14974:	044a 044a 044a 044a 044a 0409 0409 0409     J.J.J.J.J.......
   14984:	044a 0409 0409 0409 0409 044a 044a 044a     J.........J.J.J.
   14994:	0409 0409 0409 0409 044a 044a 044a 044a     ........J.J.J.J.
   149a4:	044a 0409 0409 0409 0409 0409 0409 0409     J...............
   149b4:	044a 044a 044a 044a 044a 0409 0409 0409     J.J.J.J.J.......
   149c4:	0409 0409 0409 0409 044a 044a 044a 044a     ........J.J.J.J.
   149d4:	044a 0409 0409 0409 0409 0409 0409 0409     J...............
   149e4:	044a 044a 044a 044a 044a 0409 0409 0409     J.J.J.J.J.......
   149f4:	0409 0409 0409 0409 044a 044a 044a 044a     ........J.J.J.J.
   14a04:	044a 0409 0409 0409 0409 0409 0409 0409     J...............
   14a14:	044a 044a 044a 044a 044a 0409 0409 0409     J.J.J.J.J.......
   14a24:	0409 0409 0409 0409 044a 044a 044a 044a     ........J.J.J.J.
   14a34:	044a 0409                                   J...

00014a38 <_ZTV4File>:
	...
   14a40:	5ceb 0000 5c51 0000 5c35 0000 5c6f 0000     .\..Q\..5\..o\..
   14a50:	5c65 0000 5c5b 0000                         e\..[\..

00014a58 <_ZTV5SdFat>:
	...
   14a60:	5c8d 0000 5c9b 0000 5ca9 0000 5cb7 0000     .\...\...\...\..
   14a70:	4ffc 0001 4fe4 0001 4cf4 0001 4cd4 0001     .O...O...L...L..
   14a80:	4cbc 0001 0007 0106 0205 0304 4954 4c54     .L..........TITL
   14a90:	5345 5243 4545 2e4e 4d42 0050 0000 0000     ESCREEN.BMP.....

00014aa0 <_ZN14Gamebuino_MetaL16settingsDefaultsE>:
   14aa0:	0000 0000 0006 0000 0000 0000 0001 0000     ................
	...
   14ab8:	0002 0001 4da2 0001 000d 0000 0003 0000     .....M..........
   14ac8:	0028 0000 0000 0000 0004 0000 0004 0000     (...............
   14ad8:	0000 0000                                   ....

00014adc <_ZN14Gamebuino_MetaL19lang_homeMenu_READYE>:
   14adc:	0028 0000 4e2d 0001 0033 0000 4e38 0001     (...-N..3...8N..
   14aec:	002f 0000 4e43 0001                         /...CN..

00014af4 <_ZN14Gamebuino_MetaL24lang_titlescreen_a_startE>:
   14af4:	0028 0000 4dae 0001 0033 0000 4db9 0001     (....M..3....M..
   14b04:	002f 0000 4dc7 0001                         /....M..

00014b0c <_ZN14Gamebuino_MetaL20lang_homeMenu_SAVINGE>:
   14b0c:	0028 0000 4e90 0001 0033 0000 4e9b 0001     (....N..3....N..
   14b1c:	002f 0000 4ea6 0001                         /....N..

00014b24 <_ZN14Gamebuino_MetaL10startSoundE>:
   14b24:	0005 0338 03fc 0254 01fc 025c 03fc 0368     ..8...T...\...h.
	...

00014b36 <_ZN14Gamebuino_MetaL15startLightsDataE>:
   14b36:	0002 0004 c000 4000 4000 1000 1000 0000     .......@.@......
   14b46:	0000 0000 3800 a001 1000 3800 0000 1000     .....8.....8....
   14b56:	0000 0000 1000 3001 0000 9006 0000 3003     .......0.......0
   14b66:	0000 1001 0000 1001 0000 3806 0000 a815     ...........8....
   14b76:	1002 4008 0000 1003 0000 1003 1804 5810     ...@...........X
   14b86:	5814 a03f 0000 0000 1809 0000 501f 180d     .X?..........P..
   14b96:	70ff 403f 1818 0000 305f 0000 69ff 0000     .p?@...._0...i..
   14ba6:	289f 101f 28bf 083f 7b5f 0000 20ff 0000     .(...(?._{... ..
   14bb6:	085f 0000 94bf 295f 299f 087f 007f 0000     _....._).)......
   14bc6:	0000 0000 221f adff 00df 1a5f 0000 00fe     ....."...._.....
   14bd6:	0000 0000 0153 0b7f 0000 cf5f 0000 049f     ....S....._.....
   14be6:	0000 018b 0000 01a9 0000 063d 0000 dfff     ..........=.....
   14bf6:	01c7 0659 0000 01c6 0000 01c5 01c5 0632     ..Y...........2.
   14c06:	062f a7fd 0000 0000 01a3 0000 05e8 01a2     /...............
   14c16:	6ff7 05c6 01a1 0000 05c3 0000 4fef 0000     .o...........O..
   14c26:	05a1 0180 0580 0180 2fe8 0000 0540 0000     ........./..@...
   14c36:	0160 0000 1fe3 04e0 04a0 0140 0120 0000     `.........@. ...
   14c46:	0000 0000 02e0 0fa0 00a0 0260 0000 00a0     ..........`.....
   14c56:	0000 0000 0060 0960 0000 1b60 0000 0900     ....`.`...`.....
   14c66:	0000 0040 0000 0040 0000 08a0 0000 2160     ..@...@.......`!
   14c76:	0020 0880 0000 0020 0000 0020 0020 0840      ..... ... . .@.
   14c86:	0840 18c0 0000 0000 0020 0000 0840 0020     @....... ...@. .
   14c96:	2060 1020 0000 0000 1020 0000 3840 0000     `  ..... ...@8..
   14ca6:	1820 0800 2000 0800 6820 0000 2800 0000      .... .. h...(..
   14cb6:	1000 0000 0000                              ......

00014cbc <_ZN14Gamebuino_MetaL19lang_homeMenu_lightE>:
   14cbc:	0028 0000 4eb1 0001 0033 0000 4ebc 0001     (....N..3....N..
   14ccc:	002f 0000 4ec7 0001                         /....N..

00014cd4 <_ZN14Gamebuino_MetaL24lang_homeMenu_save_videoE>:
   14cd4:	0028 0000 4ed2 0001 0033 0000 4edd 0001     (....N..3....N..
   14ce4:	002f 0000 4ee8 0001                         /....N..

00014cec <_ZN14Gamebuino_MetaL20neoPixelsIntensitiesE>:
   14cec:	1000 8f40 00ff 0000                         ..@.....

00014cf4 <_ZN14Gamebuino_MetaL24lang_homeMenu_save_imageE>:
   14cf4:	0028 0000 4ef3 0001 0033 0000 4efe 0001     (....N..3....N..
   14d04:	002f 0000 4f09 0001 4552 0043 4552 2f43     /....O..REC.REC/
   14d14:	4552 2e43 4143 4843 0045 003e 002a 1413     REC.CACHE.>.*...
   14d24:	1300 0078 4552 2f43 3030 3030 2e30 4d47     ..x.REC/00000.GM
   14d34:	0056 6f53 696c 6174 7269 0065 672e 766d     V.Solitaire..gmv
   14d44:	5200 4345 002f 4453 4920 494e 2e54 2e2e     .REC/.SD INIT...
   14d54:	0020 4153 4556 532e 5641 2f00 4553 5454      .SAVE.SAV./SETT
   14d64:	4e49 5347 532e 5641 4700 4d42 0053 4146     INGS.SAV.GBMS.FA
   14d74:	4c49 4445 0021 4b4f 0021 6f59 2075 6e65     ILED!.OK!.You en
   14d84:	6574 6572 0a64 0a00 0a0a 3a15 6b6f 7961     tered......:okay
   14d94:	1620 653a 6964 0074 0015 0016 0017 6167      .:edit.......ga
   14da4:	656d 7562 6e69 6169 006e 2015 6f74 7320     mebuinian.. to s
   14db4:	6174 7472 1500 7a20 6d75 7320 6174 7472     tart.. zum start
   14dc4:	6e65 1500 7020 756f 2072 6f63 6d6d 6e65     en.. pour commen
   14dd4:	6563 0072 6173 6576 6600 7265 6974 0067     cer.save.fertig.
   14de4:	6e65 6572 2e67 6200 6361 006b 757a fc72     enreg..back.zur.
   14df4:	6b63 7200 7465 756f 0072 6974 7070 6e65     ck.retour.tippen
   14e04:	e900 7263 7269 0065 4f47 2021 2020 2020     ..crire.GO!     
   14e14:	2020 4c00 534f 2021 2020 2020 0020 4150       .LOS!      .PA
   14e24:	5452 5a45 2021 2020 5200 4145 5944 203f     RTEZ!   .READY? 
   14e34:	2020 0020 4542 4552 5449 203f 2020 5000        .BEREIT?   .P
   14e44:	ca52 3f54 2020 2020 0020 5245 4f52 2052     R.T?     .ERROR 
   14e54:	2020 2020 4600 4845 454c 2052 2020 0020         .FEHLER    .
   14e64:	5245 4552 5255 2020 2020 5300 5641 4445     ERREUR    .SAVED
   14e74:	2021 2020 0020 4547 4953 4843 5245 2154     !    .GESICHERT!
   14e84:	4500 524e 4745 5349 5254 00c9 4153 4956     .ENREGISTR..SAVI
   14e94:	474e 2e2e 202e 5300 4349 4548 4552 2e2e     NG... .SICHERE..
   14ea4:	002e 4e45 4552 4947 5453 4552 4c00 4749     ..ENREGISTRE.LIG
   14eb4:	5448 2020 2020 0020 494c 4843 2054 2020     HT     .LICHT   
   14ec4:	2020 4c00 4d55 4e49 534f 5449 00c9 4153       .LUMINOSIT..SA
   14ed4:	4556 5620 4449 4f45 5600 4449 5320 4350     VE VIDEO.VID SPC
   14ee4:	5248 004e 4e45 4752 5620 4449 4f45 5300     HRN.ENRG VIDEO.S
   14ef4:	5641 2045 4d49 4741 0045 4942 444c 5320     AVE IMAGE.BILD S
   14f04:	4350 5248 4500 524e 2047 4d49 4741 0045     PCHR.ENRG IMAGE.
   14f14:	4f56 554c 454d 2020 2020 4c00 5541 5354     VOLUME    .LAUTS
   14f24:	c454 4b52 0045 5845 5449 4720 4d41 2045     T.RKE.EXIT GAME 
   14f34:	5600 5245 414c 5353 4e45 0020 5551 5449     .VERLASSEN .QUIT
   14f44:	4554 2052 2020 0000                         TER   ..

00014f4c <_ZN14Gamebuino_MetaL16lang_homeMenu_GOE>:
   14f4c:	0028 0000 4e0c 0001 0033 0000 4e17 0001     (....N..3....N..
   14f5c:	002f 0000 4e22 0001                         /..."N..

00014f64 <_ZN14Gamebuino_MetaL13gamebuinoLogoE>:
   14f64:	0a50 3f3c f33f f3f3 3f33 1c3f 3f3c f33f     P.<??...3??.<??.
   14f74:	f3f3 3f33 263f 3330 3333 3303 3333 2633     ..3??&0333.3333&
   14f84:	3330 3333 3303 3333 2a33 3f33 3333 c3f3     0333.3333*3?33..
   14f94:	3333 1c33 3f33 3333 c3f3 3333 0033 3333     333.3?33..333.33
   14fa4:	3333 3303 3333 0033 3333 3333 3303 3333     33.3333.3333.333
   14fb4:	0033 333f 3333 f3f3 33f3 003f 333f 3333     3.?333...3?.?333
   14fc4:	f3f3 33f3 003f 0000                         ...3?...

00014fcc <_ZN14Gamebuino_MetaL19lang_homeMenu_SAVEDE>:
   14fcc:	0028 0000 4e6f 0001 0033 0000 4e7a 0001     (...oN..3...zN..
   14fdc:	002f 0000 4e85 0001                         /....N..

00014fe4 <_ZN14Gamebuino_MetaL20lang_homeMenu_volumeE>:
   14fe4:	0028 0000 4f14 0001 0033 0000 4f1f 0001     (....O..3....O..
   14ff4:	002f 0000 4f14 0001                         /....O..

00014ffc <_ZN14Gamebuino_MetaL18lang_homeMenu_exitE>:
   14ffc:	0028 0000 4f2a 0001 0033 0000 4f35 0001     (...*O..3...5O..
   1500c:	002f 0000 4f40 0001                         /...@O..

00015014 <_ZN14Gamebuino_MetaL19lang_homeMenu_ERRORE>:
   15014:	0028 0000 4e4e 0001 0033 0000 4e59 0001     (...NN..3...YN..
   15024:	002f 0000 4e64 0001                         /...dN..

0001502c <_ZN14Gamebuino_MetaL5Rcmd3E>:
   1502c:	e004 0210 071c 3712 2932 292d 2b25 0039     .......72)-)%+9.
   1503c:	0301 e110 0310 071d 2e06 292c 2e2d 372e     ..........,)-..7
   1504c:	003f 0200 1310 0a80 8029 0264                    ?.......).d

00015057 <_ZN14Gamebuino_MetaL10Rcmd2greenE>:
   15057:	2a02 0004 0002 2b81 0004 0001 02a0               .*.....+.....

00015064 <_ZN14Gamebuino_MetaL8Rcmd2redE>:
   15064:	2a02 0004 0000 2b7f 0004 0000 009f 0000     .*.....+........
   15074:	0000 0000                                   ....

00015078 <_ZTVN14Gamebuino_Meta14Display_ST7735E>:
	...
   15080:	8b29 0000 fb41 0000 5cc5 0000 5cd9 0000     )...A....\...\..
   15090:	822d 0000 8129 0000 9821 0000 829d 0000     -...)...!.......
   150a0:	8325 0000 8a59 0000 83ad 0000 8b11 0000     %...Y...........
   150b0:	7e55 0000 85a1 0000 8765 0000 98e1 0000     U~......e.......
   150c0:	9989 0000 9a89 0000                         ........

000150c8 <_ZN14Gamebuino_MetaL5Rcmd1E>:
   150c8:	010f 9680 8011 b1ff 0103 2d2c 03b2 2c01     ..........,-...,
   150d8:	b32d 0106 2d2c 2c01 b42d 0701 03c0 02a2     -...,-.,-.......
   150e8:	c184 c501 02c2 000a 02c3 2a8a 02c4 ee8a     ...........*....
   150f8:	01c5 200e 3600 c801 013a 0205                    ... .6..:..

00015103 <_ZN14Gamebuino_MetaL13Rcmd2green144E>:
   15103:	2a02 0004 0000 2b7f 0004 0000 037f               .*.....+.....

00015110 <font3x5>:
   15110:	0503 213f 123f 1208 100a 0e0a 0e1c 1e0c     ..?!?...........
   15120:	140c 141a 1f16 1e16 1e13 1b1e 1e1e 1e1f     ................
   15130:	213f 3a3f 3a2f 3d17 3f17 3f21 1f18 0402     ?!?:/:.=.?!?....
   15140:	040a 0e1f 0404 1f0e 1f0a 0e0a 1f0e 1104     ................
   15150:	2e0e 2e25 2a2f 262e 2929 1f02 0802 081f     ..%./*.&))......
   15160:	0e15 0404 150e 150e 1b15 1b15 0604 0404     ................
   15170:	040c 0000 0000 0017 0003 1f03 1f0a 3716     ...............7
   15180:	191a 1304 150a 003a 0003 0e00 1111 000e     ......:.........
   15190:	040a 040a 040e 3000 0400 0404 1000 1800     .......0........
   151a0:	0304 111f 121f 101f 151d 1117 1f15 0407     ................
   151b0:	171f 1d15 151f 011d 1f01 151f 171f 1f15     ................
   151c0:	0a00 0000 0032 0a04 0a11 0a0a 0a11 0104     ....2...........
   151d0:	0215 110e 1e17 1e05 151f 0e0a 0a11 111f     ................
   151e0:	1f0e 1115 051f 0e01 1d11 041f 111f 111f     ................
   151f0:	1008 1f0f 1b04 101f 1f10 1f06 041e 0e0f     ................
   15200:	0e11 091f 0e06 2e11 051f 121a 0915 1f01     ................
   15210:	1f01 1f10 180f 1f0f 1f0c 041b 031b 031c     ................
   15220:	1519 0013 111f 0403 1118 001f 0102 2002     ............... 
   15230:	2020 0100 0c02 1e12 121f 0c0c 1212 120c       ..............
   15240:	0c1f 141a 1e04 2405 1e2a 021f 141c 101d     .......$*.......
   15250:	2020 1f1d 1408 1f11 1e10 1e04 021e 0c1c       ..............
   15260:	0c12 0a3e 0c04 3e12 041e 1402 0a16 0f02     ..>....>........
   15270:	0e12 1e10 100e 1e0e 1e08 0c12 2612 1e28     .............&(.
   15280:	1a12 0416 110e 1f00 1100 040e 0201 3f01     ...............?
   15290:	3f21 0000 0000 001d 1f0e 140a 151e 040a     !?..............
   152a0:	0b0a 0b1c 1b00 1600 0d1b 0001 1301 0d0d     ................
   152b0:	0707 0406 000a 0404 000c 0000 1911 0117     ................
   152c0:	0101 0300 0a03 0a0f 0701 0504 0207 0200     ................
   152d0:	1e01 0608 0702 001f 0004 1810 0500 0407     ................
   152e0:	0704 0007 040a 1801 0118 1008 1b01 0818     ................
   152f0:	1015 0a1d 1c1c 1d0a 0b1d 1e1d 1d0b 0a1d     ................
   15300:	1c1d 1c0b 1f1e 2e15 1131 161f 1e12 1316     ........1.......
   15310:	171f 1f13 1316 1e13 1212 131e 1f13 1313     ................
   15320:	131e 151f 1d0e 1f09 120d 0c0c 0d12 130d     ................
   15330:	0e0d 0d13 120d 0a0d 0a04 150e 1d0e 1c10     ................
   15340:	101c 1d1d 1d11 101d 041d 0518 0e1f 1e0e     ................
   15350:	0a15 1409 081c 1d14 1509 0a1d 1d15 1409     ................
   15360:	081d 1c15 1c18 2c0c 1232 1a0d 0c14 151a     .......,2.......
   15370:	1b0d 0d15 151a 1c15 1410 111c 1d15 1511     ................
   15380:	111c 1b1d 1e0e 1905 1409 0808 0914 1509     ................
   15390:	0a09 0915 1409 0409 0415 4e14 0d05 1c10     ...........N....
   153a0:	100c 0d1d 1d11 100d 141d 0d18 0e1f 2504     ...............%
   153b0:	1d28 0a07 090b 0405 0008 0306 0201 0f0e     (...............
   153c0:	0d0c 0000 0000 0000                         ........

000153c8 <_ZTVN14Gamebuino_Meta8GraphicsE>:
	...
   153d0:	8b29 0000 fb41 0000 8a4d 0000 8cb1 0000     )...A...M.......
   153e0:	01ed 0001 01ed 0001 9821 0000 8ab3 0000     ........!.......
   153f0:	8acb 0000 8a59 0000 8add 0000 8b11 0000     ....Y...........
   15400:	8cad 0000 9069 0000 8cc9 0000 98e1 0000     ....i...........
   15410:	9989 0000 9a89 0000                         ........

00015418 <_ZTVN14Gamebuino_Meta17Frame_Handler_RAME>:
	...
   15420:	a099 0000 a20d 0000 ad91 0000 ad79 0000     ............y...
   15430:	a065 0000 ada3 0000                         e.......

00015438 <_ZTVN14Gamebuino_Meta17Frame_Handler_MemE>:
	...
   15440:	a071 0000 a1fb 0000 ad91 0000 ad79 0000     q...........y...
   15450:	a065 0000 ad6f 0000                         e...o...

00015458 <_ZTVN14Gamebuino_Meta13Frame_HandlerE>:
	...
   15460:	a049 0000 a1e9 0000 01ed 0001 01ed 0001     I...............
   15470:	a065 0000 ad6f 0000                         e...o...

00015478 <_ZTVN14Gamebuino_Meta5ImageE>:
	...
   15480:	8b29 0000 fb41 0000 a221 0000 a265 0000     )...A...!...e...
   15490:	a175 0000 a279 0000 9821 0000 8ab3 0000     u...y...!.......
   154a0:	a0c1 0000 8a59 0000 8add 0000 a9c5 0000     ....Y...........
   154b0:	8cad 0000 b109 0000 b259 0000 a7c1 0000     ........Y.......
   154c0:	a9b1 0000 aa35 0000 4d42 2000 4153 4556     ....5...BM. SAVE
   154d0:	5620 4449 4f45 2020 2020 4300 756f 646c      VIDEO    .Could
   154e0:	276e 2074 7263 6165 6574 4220 504d 0021     n't create BMP!.
   154f0:	4320 6572 7461 6e69 2067 6966 656c 0a3a      Creating file:.
   15500:	0020 2020 2020 2020 002f 424b 2000 6f43      .      /.KB. Co
   15510:	766e 7265 6974 676e 6620 6172 656d 3a73     nverting frames:
   15520:	200a 0000 0000 0000                         . ......

00015528 <_ZTVN14Gamebuino_Meta16Frame_Handler_SDE>:
	...
   15530:	c35d 0000 c389 0000 c42f 0000 c443 0000     ]......./...C...
   15540:	a065 0000 ad6f 0000 4153 4556 4520 5252     e...o...SAVE ERR
   15550:	524f 0020 6361 6563 7373 6e69 2067 6f6e     OR .accessing no
   15560:	2d6e 7865 7369 6974 676e 6220 6f6c 6b63     n-existing block
   15570:	6600 6c69 2065 2f49 004f 6e49 6176 696c     .file I/O.Invali
   15580:	2064 6173 6576 6620 6c69 0065 7274 6979     d save file.tryi
   15590:	676e 7420 206f 6567 2074 7266 6d6f 6120     ng to get from a
   155a0:	6e20 6e6f 692d 746e 7420 7079 0065 7274      non-int type.tr
   155b0:	6979 676e 7420 206f 6567 2074 7266 6d6f     ying to get from
   155c0:	6120 6e20 6e6f 622d 6f6c 2062 7974 6570      a non-blob type
   155d0:	7400 7972 6e69 2067 6573 2074 6f74 6120     .trying set to a
   155e0:	6e20 6e6f 692d 746e 7420 7079 0065 7274      non-int type.tr
   155f0:	6979 676e 7320 7465 7420 206f 2061 6f6e     ying set to a no
   15600:	2d6e 6c62 626f 7420 7079 0065               n-blob type.

0001560c <_ZN14Gamebuino_MetaL12_halfPeriodsE>:
   1560c:	595f 5054 474b 3f43 383c 3235 2d2f 282a     _YTPKGC?<852/-*(
   1561c:	2326 2021 1c1e 191b 1618 1415 1213 1011     &#! ............
   1562c:	0e0f 0d0d 0b0c 0a0b 0909 0808 0707 0607     ................
   1563c:	0606 0505 0405 0404 0404 0303 0303 0203     ................
   1564c:	0202 0000                                   ....

00015650 <_ZTVN14Gamebuino_Meta21Sound_Handler_PatternE>:
	...
   15658:	ebbd 0000 ebd5 0000 ebe9 0000 ebb1 0000     ................
   15668:	ebb9 0000 0000 0000                         ........

00015670 <_ZN14Gamebuino_MetaL9playTickPE>:
   15670:	0045 0168 0000                              E.h...

00015676 <_ZN14Gamebuino_MetaL17playCancelPatternE>:
   15676:	0005 0168 0138 0000 0000                    ..h.8.....

00015680 <_ZTVN14Gamebuino_Meta13Sound_HandlerE>:
	...
   15688:	ec89 0000 ec9d 0000 01ed 0001 01ed 0001     ................
   15698:	ec95 0000 0000 0000                         ........

000156a0 <_ZN14Gamebuino_MetaL13playOKPatternE>:
   156a0:	0005 0138 0168 0000                         ..8.h...

000156a8 <g_APinDescription>:
   156a8:	0000 0000 000b 0000 0002 0000 0004 0000     ................
   156b8:	00ff ffff ffff 000b 0000 0000 000a 0000     ................
   156c8:	0002 0000 0004 0000 00ff ffff ffff 000a     ................
   156d8:	0000 0000 000e 0000 0008 0000 0004 0000     ................
   156e8:	00ff ffff ffff 000e 0000 0000 0009 0000     ................
   156f8:	0004 0000 001c 0000 00ff 0001 0001 0009     ................
   15708:	0000 0000 0008 0000 0004 0000 001c 0000     ................
   15718:	00ff 0000 0000 0010 0000 0000 000f 0000     ................
   15728:	0004 0000 001c 0000 00ff 0301 0301 000f     ................
   15738:	0000 0000 0014 0000 0005 0000 002c 0000     ............,...
   15748:	00ff 0002 0002 0004 0000 0000 0015 0000     ................
   15758:	0008 0000 0004 0000 00ff ffff ffff 0005     ................
   15768:	0000 0000 0006 0000 0004 0000 001c 0000     ................
   15778:	00ff 0100 0100 0006 0000 0000 0007 0000     ................
   15788:	0004 0000 001c 0000 00ff 0101 0101 0007     ................
   15798:	0000 0000 0012 0000 0004 0000 001c 0000     ................
   157a8:	00ff 0300 0300 0002 0000 0000 0010 0000     ................
   157b8:	0004 0000 001c 0000 00ff 0200 0200 0000     ................
   157c8:	0000 0000 0013 0000 0005 0000 002c 0000     ............,...
   157d8:	00ff 0003 0003 0003 0000 0000 0011 0000     ................
   157e8:	0004 0000 001c 0000 00ff 0201 0201 0001     ................
   157f8:	0000 0000 0002 0000 0001 0000 0002 0000     ................
   15808:	0000 ffff ffff 0002 0001 0000 0008 0000     ................
   15818:	0001 0000 0018 0000 0002 0400 0400 0008     ................
   15828:	0001 0000 0009 0000 0001 0000 0018 0000     ................
   15838:	0003 0401 0401 0009 0000 0000 0004 0000     ................
   15848:	0001 0000 0000 0000 0004 ffff ffff 0004     ................
   15858:	0000 0000 0005 0000 0001 0000 0000 0000     ................
   15868:	0005 ffff ffff 0005 0001 0000 0002 0000     ................
   15878:	0001 0000 0000 0000 000a ffff ffff 0002     ................
   15888:	0000 0000 0016 0000 0002 0000 0004 0000     ................
   15898:	00ff ffff ffff 0006 0000 0000 0017 0000     ................
   158a8:	0002 0000 0004 0000 00ff ffff ffff 0007     ................
   158b8:	0000 0000 000c 0000 0003 0000 0004 0000     ................
   158c8:	00ff ffff ffff 000c 0001 0000 000a 0000     ................
   158d8:	0003 0000 0004 0000 00ff ffff ffff 000a     ................
   158e8:	0001 0000 000b 0000 0003 0000 0004 0000     ................
   158f8:	00ff ffff ffff 000b 0001 0000 0003 0000     ................
   15908:	000b 0000 0004 0000 00ff ffff ffff 00ff     ................
   15918:	0000 0000 001b 0000 000b 0000 0004 0000     ................
   15928:	00ff ffff ffff 00ff 0000 0000 001c 0000     ................
   15938:	0006 0000 0000 0000 00ff ffff ffff 00ff     ................
   15948:	0000 0000 0018 0000 0006 0000 0000 0000     ................
   15958:	00ff ffff ffff 00ff 0000 0000 0019 0000     ................
   15968:	0006 0000 0000 0000 00ff ffff ffff 00ff     ................
   15978:	0001 0000 0016 0000 0003 0000 0000 0000     ................
   15988:	00ff ffff ffff 00ff 0001 0000 0017 0000     ................
   15998:	0003 0000 0000 0000 00ff ffff ffff 00ff     ................
   159a8:	0000 0000 0016 0000 0002 0000 0000 0000     ................
   159b8:	00ff ffff ffff 00ff 0000 0000 0017 0000     ................
   159c8:	0002 0000 0000 0000 00ff ffff ffff 00ff     ................
   159d8:	0000 0000 0013 0000 0002 0000 0000 0000     ................
   159e8:	00ff ffff ffff 00ff 0000 0000 0010 0000     ................
   159f8:	0002 0000 0000 0000 00ff ffff ffff 00ff     ................
   15a08:	0000 0000 0012 0000 0002 0000 0000 0000     ................
   15a18:	00ff ffff ffff 00ff 0000 0000 0011 0000     ................
   15a28:	0002 0000 0000 0000 00ff ffff ffff 00ff     ................
   15a38:	0000 0000 000d 0000 0004 0000 000c 0000     ................
   15a48:	00ff 0001 ffff 000d 0000 0000 0015 0000     ................
   15a58:	0005 0000 000c 0000 00ff 0003 ffff 00ff     ................
   15a68:	0000 0000 0006 0000 0004 0000 000c 0000     ................
   15a78:	00ff 0100 ffff 00ff 0000 0000 0007 0000     ................
   15a88:	0004 0000 000c 0000 00ff 0101 ffff 00ff     ................
   15a98:	0000 0000 0003 0000 0001 0000 0002 0000     ................
   15aa8:	00ff ffff ffff 00ff 0000 0000 0002 0000     ................
   15ab8:	0001 0000 0002 0000 0014 ffff ffff 0002     ................
   15ac8:	001a 001a 001b 001b 001c 001c 001d 001d     ................
   15ad8:	0a0d 6e00 6e61 6900 666e 6f00 6676 0000     ...nan.inf.ovf..

00015ae8 <_ZTV4Uart>:
	...
   15af0:	0051 0001 fb41 0000 0033 0001 0047 0001     Q...A...3...G...
   15b00:	003d 0001 0029 0001 0005 0001 012d 0001     =...).......-...
   15b10:	0015 0001 0001 0001                         ........

00015b18 <_ZTV26DoubleBufferedEPOutHandler>:
	...
   15b20:	0545 0001 0429 0001 0371 0001 0000 0000     E...)...q.......

00015b30 <_ZL19STRING_MANUFACTURER>:
   15b30:	7241 7564 6e69 206f 4c4c 0043               Arduino LLC.

00015b3c <_ZL15STRING_LANGUAGE>:
   15b3c:	0304 0409                                   ....

00015b40 <_ZL21USB_DeviceDescriptorB>:
   15b40:	0112 0200 02ef 4001 2341 804d 0100 0201     .......@A#M.....
   15b50:	0103                                        ..

00015b52 <_ZL14STRING_PRODUCT>:
   15b52:	7241 7564 6e69 206f 655a 6f72 0000          Arduino Zero..

00015b60 <_ZTV7Serial_>:
	...
   15b68:	1173 0001 119f 0001 1187 0001 11d9 0001     s...............
   15b78:	11bd 0001 1193 0001 116f 0001 0000 0000     ........o.......

00015b88 <__sf_fake_stdin>:
	...

00015ba8 <__sf_fake_stdout>:
	...

00015bc8 <__sf_fake_stderr>:
	...

00015be8 <__EH_FRAME_BEGIN__>:
   15be8:	0000 0000                                   ....
